import tkinter as tk
from tkinter import ttk, messagebox, simpledialog, colorchooser
from ttkthemes import ThemedTk
import pandas as pd
import json
import os
from os.path import sep
import random
import winsound # Apenas para Windows
from datetime import datetime, timedelta, timezone
from functools import partial
from PIL import Image, ImageTk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import sys
import uuid
from tkcalendar import Calendar, DateEntry
import calendar
import threading
import time
import psutil
import signal
import subprocess

class DatabaseConcurrencyControl:
    """Sistema de controle de concorrência para o banco de dados"""
    
    def __init__(self, db_file='boodesk_new.db'):
        self.db_file = db_file
        self.lock_file = f"{db_file}.lock"
        self.pid_file = f"{db_file}.pid"
        self.current_pid = os.getpid()
        self.lock_acquired = False
        
    def acquire_lock(self, timeout=30):
        """Tenta adquirir o lock do banco de dados"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                # Verificar se já temos o lock
                if self.lock_acquired:
                    print(f"✅ Lock já adquirido (PID: {self.current_pid})")
                    return True
                
                # Verificar se já existe um lock para este processo
                if os.path.exists(self.lock_file):
                    try:
                        with open(self.lock_file, 'r') as f:
                            pid_str = f.read().strip()
                            if pid_str == str(self.current_pid):
                                self.lock_acquired = True
                                print(f"✅ Lock já adquirido por este processo (PID: {self.current_pid})")
                                return True
                    except:
                        pass
                
                # Verificar se há outro processo usando o banco
                if self._is_other_process_using_db():
                    print(f"⚠️ Outro processo está usando o banco. Tentando interromper...")
                    if self._terminate_other_processes():
                        time.sleep(2)  # Aguardar processo terminar
                        continue
                    else:
                        print(f"❌ Não foi possível interromper outros processos")
                        return False
                
                # Verificar se há outro processo usando o lock
                if os.path.exists(self.lock_file):
                    try:
                        with open(self.lock_file, 'r') as f:
                            pid_str = f.read().strip()
                            if pid_str:
                                try:
                                    pid = int(pid_str)
                                    if psutil.pid_exists(pid) and pid != self.current_pid:
                                        print(f"⚠️ Lock já existe para PID {pid}")
                                        return False
                                except:
                                    pass
                    except:
                        pass
                
                # Tentar criar arquivo de lock
                with open(self.lock_file, 'w') as f:
                    f.write(str(self.current_pid))
                
                # Verificar se conseguiu criar o lock
                if os.path.exists(self.lock_file):
                    with open(self.lock_file, 'r') as f:
                        pid_in_file = f.read().strip()
                        if pid_in_file == str(self.current_pid):
                            self.lock_acquired = True
                            print(f"✅ Lock adquirido com sucesso (PID: {self.current_pid})")
                            return True
                
                time.sleep(0.5)
                
            except Exception as e:
                print(f"⚠️ Erro ao tentar adquirir lock: {e}")
                time.sleep(0.5)
        
        print(f"❌ Timeout ao tentar adquirir lock do banco")
        return False
    
    def release_lock(self):
        """Libera o lock do banco de dados"""
        try:
            if self.lock_acquired and os.path.exists(self.lock_file):
                try:
                    with open(self.lock_file, 'r') as f:
                        pid_in_file = f.read().strip()
                        if pid_in_file == str(self.current_pid):
                            try:
                                os.remove(self.lock_file)
                                self.lock_acquired = False
                                print(f"✅ Lock liberado (PID: {self.current_pid})")
                            except Exception as e:
                                print(f"⚠️ Erro ao remover arquivo de lock: {e}")
                                # Tentar novamente após um pequeno delay
                                time.sleep(0.1)
                                try:
                                    os.remove(self.lock_file)
                                    self.lock_acquired = False
                                    print(f"✅ Lock liberado na segunda tentativa (PID: {self.current_pid})")
                                except:
                                    pass
                except Exception as e:
                    print(f"⚠️ Erro ao ler arquivo de lock: {e}")
        except Exception as e:
            print(f"⚠️ Erro ao liberar lock: {e}")
    
    def _is_other_process_using_db(self):
        """Verifica se há outro processo usando o banco"""
        try:
            # Verificar arquivo de lock
            if os.path.exists(self.lock_file):
                with open(self.lock_file, 'r') as f:
                    pid_str = f.read().strip()
                    if pid_str and pid_str != str(self.current_pid):
                        try:
                            pid = int(pid_str)
                            if psutil.pid_exists(pid):
                                return True
                        except:
                            pass
            
            # Verificar processos Python que podem estar usando o banco
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    if proc.info['name'] and 'python' in proc.info['name'].lower():
                        if proc.info['cmdline']:
                            cmdline = ' '.join(proc.info['cmdline'])
                            if 'app23a.py' in cmdline and proc.info['pid'] != self.current_pid:
                                return True
                except:
                    continue
            
            return False
            
        except Exception as e:
            print(f"⚠️ Erro ao verificar outros processos: {e}")
            return False
    
    def _terminate_other_processes(self):
        """Tenta terminar outros processos Python que estejam usando o banco"""
        try:
            terminated_count = 0
            
            # Terminar processos Python que executam app23a.py
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    if proc.info['name'] and 'python' in proc.info['name'].lower():
                        if proc.info['cmdline']:
                            cmdline = ' '.join(proc.info['cmdline'])
                            if 'app23a.py' in cmdline and proc.info['pid'] != self.current_pid:
                                print(f"🔄 Terminando processo Python (PID: {proc.info['pid']})")
                                proc.terminate()
                                proc.wait(timeout=5)
                                terminated_count += 1
                except:
                    continue
            
            # Limpar arquivos de lock órfãos
            if os.path.exists(self.lock_file):
                try:
                    with open(self.lock_file, 'r') as f:
                        pid_str = f.read().strip()
                        if pid_str:
                            try:
                                pid = int(pid_str)
                                if not psutil.pid_exists(pid):
                                    os.remove(self.lock_file)
                                    print(f"🗑️ Removido lock órfão (PID: {pid})")
                            except:
                                os.remove(self.lock_file)
                except:
                    pass
            
            # Limpar arquivos WAL/SHM se existirem
            wal_file = f"{self.db_file}-wal"
            shm_file = f"{self.db_file}-shm"
            
            for file_path in [wal_file, shm_file]:
                if os.path.exists(file_path):
                    try:
                        os.remove(file_path)
                        print(f"🗑️ Removido arquivo: {file_path}")
                    except:
                        pass
            
            print(f"✅ {terminated_count} processos terminados")
            return True
            
        except Exception as e:
            print(f"❌ Erro ao terminar outros processos: {e}")
            return False
    
    def __enter__(self):
        """Context manager para adquirir lock automaticamente"""
        if not self.acquire_lock():
            raise RuntimeError("Não foi possível adquirir lock do banco de dados")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager para liberar lock automaticamente"""
        self.release_lock()

class UserManagement:
    def __init__(self):
        """Inicializa o gerenciamento de usuários usando banco SQLite"""
        self.load_users()
    
    def load_users(self):
        """Carrega usuários do banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, username, email, password_hash, role, cargo, created_at, updated_at, member_id
                FROM users ORDER BY username
            """)
            users_data = cursor.fetchall()
            conn.close()
            
            # Converter para DataFrame
            if users_data:
                self.users_df = pd.DataFrame(users_data, columns=[
                    'user_id', 'username', 'email', 'password', 'role', 'Cargo', 
                    'created_at', 'last_login', 'member_id'
                ])
            else:
                # Criar DataFrame vazio com estrutura correta
                self.users_df = pd.DataFrame(columns=[
                    'user_id', 'username', 'email', 'password', 'role', 'Cargo', 
                    'created_at', 'last_login', 'member_id'
                ])
            
            print(f"DEBUG: {len(self.users_df)} usuários carregados do SQLite")
            
        except Exception as e:
            print(f"Erro ao carregar usuários do SQLite: {e}")
            # Criar DataFrame vazio em caso de erro
            self.users_df = pd.DataFrame(columns=[
                'user_id', 'username', 'email', 'password', 'role', 'Cargo', 
                'created_at', 'last_login', 'member_id'
            ])
    
    def save_users(self):
        """Salva usuários no banco SQLite"""
        try:
            print("DEBUG: Usuários salvos no SQLite")
        except Exception as e:
            print(f"Erro ao salvar usuários: {e}")
    
    def login(self, username, password):
        """Autentica um usuário usando banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, username, email, password_hash, role, cargo, member_id
                FROM users WHERE username = ? AND password_hash = ?
            """, (username, password))
            
            user_data = cursor.fetchone()
            conn.close()
            
            if user_data:
                user_id, username, email, password_hash, role, cargo, member_id = user_data
                
                user = User(
                    username=username,
                    role=role,
                    cargo=cargo,
                    user_id=user_id
                )
                user.is_authenticated = True
                user.login_time = pd.Timestamp.now()
                user.member_id = member_id
                
                # Atualizar último login no banco
                conn = sqlite3.connect('boodesk_new.db')
                cursor = conn.cursor()
                cursor.execute("""
                    UPDATE users SET updated_at = ? WHERE id = ?
                """, (datetime.now(), user_id))
                conn.commit()
                conn.close()
                
                return user
            return None
            
        except Exception as e:
            print(f"Erro no login: {e}")
            return None
    
    def register_user(self, username, password, role, cargo):
        """Registra um novo usuário no banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            # Verificar se o usuário já existe
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("SELECT id FROM users WHERE username = ?", (username,))
            if cursor.fetchone():
                conn.close()
                return False, "Usuário já existe"
            
            # Validar dados
            if not username or not password:
                return False, "Usuário e senha são obrigatórios"
            
            if len(password) < 6:
                return False, "Senha deve ter pelo menos 6 caracteres"
            
            if role not in ['admin', 'user', 'manager']:
                return False, "Role inválido"
            
            # Inserir novo usuário
            cursor.execute("""
                INSERT INTO users (username, email, password_hash, role, cargo, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (username, '', password, role, cargo, datetime.now(), datetime.now()))
            
            conn.commit()
            conn.close()
            
            # Recarregar usuários
            self.load_users()
            
            return True, "Usuário registrado com sucesso"
            
        except Exception as e:
            print(f"Erro ao registrar usuário: {e}")
            return False, f"Erro ao registrar usuário: {e}"
    
    def update_user(self, user_id, username, password, role, cargo):
        """Atualiza dados de um usuário"""
        user_idx = self.users_df[self.users_df['user_id'] == user_id].index
        if len(user_idx) == 0:
            return False, "Usuário não encontrado"
        
        idx = user_idx[0]
        
        # Verificar se o novo username já existe (exceto para o próprio usuário)
        existing_user = self.users_df[
            (self.users_df['username'] == username) & 
            (self.users_df['user_id'] != user_id)
        ]
        if not existing_user.empty:
            return False, "Username já existe"
        
        # Atualizar dados
        self.users_df.loc[idx, 'username'] = username
        if password:  # Só atualizar senha se fornecida
            self.users_df.loc[idx, 'password'] = password
        self.users_df.loc[idx, 'role'] = role
        self.users_df.loc[idx, 'Cargo'] = cargo
        
        self.save_users()
        return True, "Usuário atualizado com sucesso"
    
    def delete_user(self, user_id):
        """Remove um usuário"""
        user_idx = self.users_df[self.users_df['user_id'] == user_id].index
        if len(user_idx) == 0:
            return False, "Usuário não encontrado"
        
        # Não permitir deletar o último admin
        user_role = self.users_df.loc[user_idx[0], 'role']
        if user_role == 'admin':
            admin_count = len(self.users_df[self.users_df['role'] == 'admin'])
            if admin_count <= 1:
                return False, "Não é possível deletar o último administrador"
        
        self.users_df = self.users_df[self.users_df['user_id'] != user_id]
        self.save_users()
        return True, "Usuário removido com sucesso"
    
    def get_all_users(self):
        """Retorna todos os usuários do banco SQLite"""
        try:
            import sqlite3
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, username, email, role, cargo, created_at, updated_at, member_id
                FROM users ORDER BY username
            """)
            users_data = cursor.fetchall()
            conn.close()
            
            users = []
            for user_data in users_data:
                user_id, username, email, role, cargo, created_at, updated_at, member_id = user_data
                users.append({
                    'user_id': user_id,
                    'username': username,
                    'email': email,
                    'role': role,
                    'cargo': cargo,
                    'created_at': created_at,
                    'last_login': updated_at,
                    'member_id': member_id
                })
            
            return users
            
        except Exception as e:
            print(f"Erro ao buscar usuários: {e}")
            return []
    
    def get_user_by_id(self, user_id):
        """Retorna um usuário específico por ID"""
        user_data = self.users_df[self.users_df['user_id'] == user_id]
        if not user_data.empty:
            user_row = user_data.iloc[0]
            return User(
                username=user_row['username'],
                role=user_row['role'],
                cargo=user_row['Cargo'],
                user_id=user_row['user_id']
            )
        return None

class EmailIntegration:
    def __init__(self, app):
        self.app = app
        self.settings = app.settings.get('email_integration', {})
        self.email_thread = None
        self.running = False
        
    def start_email_service(self):
        if not self.settings.get('enabled', False):
            return
            
        self.running = True
        self.email_thread = threading.Thread(target=self._email_loop, daemon=True)
        self.email_thread.start()
    
    def stop_email_service(self):
        self.running = False
        if self.email_thread:
            self.email_thread.join(timeout=1)
    
    def _email_loop(self):
        while self.running:
            try:
                if self.settings.get('auto_notifications', {}).get('deadline_reminder', True):
                    self._check_deadline_reminders()
                
                if self.settings.get('auto_notifications', {}).get('weekly_report', True):
                    self._check_weekly_report()
                
                time.sleep(3600)  # Check every hour
            except Exception as e:
                print(f"Erro no loop de email: {e}")
                time.sleep(300)
    
    def send_email(self, to_email, subject, body, attachments=None):
        try:
            if self.settings.get('demo_mode', False):
                return self._demo_send_email(to_email, subject, body)
            
            provider = self.settings.get('provider', 'gmail')
            
            if provider == 'gmail':
                return self._send_gmail(to_email, subject, body, attachments)
            elif provider == 'outlook':
                return self._send_outlook(to_email, subject, body, attachments)
            else:
                return self._send_smtp(to_email, subject, body, attachments)
                
        except Exception as e:
            print(f"Erro ao enviar email: {e}")
            return False
    
    def _demo_send_email(self, to_email, subject, body):
        """Simula envio de email em modo demo"""
        print(f"DEMO EMAIL - Para: {to_email}")
        print(f"Assunto: {subject}")
        print(f"Corpo: {body}")
        print("--- Email simulado com sucesso ---")
        return True
    
    def _send_gmail(self, to_email, subject, body, attachments=None):
        try:
            email_address = self.settings.get('email_address', '')
            app_password = self.settings.get('app_password', '')
            
            if not email_address or not app_password:
                print("Credenciais de email não configuradas")
                return False
            
            msg = MIMEMultipart()
            msg['From'] = email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            if attachments:
                for attachment in attachments:
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                        msg.attach(part)
            
            server = smtplib.SMTP('smtp.gmail.com', 587)
            server.starttls()
            server.login(email_address, app_password)
            text = msg.as_string()
            server.sendmail(email_address, to_email, text)
            server.quit()
            
            print(f"Email enviado com sucesso para {to_email}")
            return True
            
        except Exception as e:
            print(f"Erro ao enviar email via Gmail: {e}")
            return False
    
    def _send_outlook(self, to_email, subject, body, attachments=None):
        try:
            email_address = self.settings.get('email_address', '')
            email_password = self.settings.get('email_password', '')
            smtp_server = self.settings.get('smtp_server', 'smtp-mail.outlook.com')
            smtp_port = self.settings.get('smtp_port', 587)
            
            if not email_address or not email_password:
                print("Credenciais de email não configuradas")
                return False
            
            msg = MIMEMultipart()
            msg['From'] = email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            if attachments:
                for attachment in attachments:
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                        msg.attach(part)
            
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(email_address, email_password)
            text = msg.as_string()
            server.sendmail(email_address, to_email, text)
            server.quit()
            
            print(f"Email enviado com sucesso para {to_email}")
            return True
            
        except Exception as e:
            print(f"Erro ao enviar email via Outlook: {e}")
            return False
    
    def _send_smtp(self, to_email, subject, body, attachments=None):
        try:
            email_address = self.settings.get('email_address', '')
            email_password = self.settings.get('email_password', '')
            smtp_server = self.settings.get('smtp_server', '')
            smtp_port = self.settings.get('smtp_port', 587)
            
            if not all([email_address, email_password, smtp_server]):
                print("Configurações SMTP incompletas")
                return False
            
            msg = MIMEMultipart()
            msg['From'] = email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            if attachments:
                for attachment in attachments:
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                        msg.attach(part)
            
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(email_address, email_password)
            text = msg.as_string()
            server.sendmail(email_address, to_email, text)
            server.quit()
            
            print(f"Email enviado com sucesso para {to_email}")
            return True
            
        except Exception as e:
            print(f"Erro ao enviar email via SMTP: {e}")
            return False
    
    def notify_card_created(self, card_data):
        """Notifica criação de novo cartão"""
        try:
            if not self.settings.get('auto_notifications', {}).get('card_created', True):
                return
            
            template = self.settings.get('email_templates', {}).get('card_created', 'Novo cartão criado: {title}')
            subject = template.format(**card_data)
            
            body = f"""
Novo cartão criado no Boodesk:

Título: {card_data.get('title', '')}
Quadro: {card_data.get('board', '')}
Lista: {card_data.get('column', '')}
Criado por: {card_data.get('created_by', '')}
Data de criação: {card_data.get('created_date', '')}
Importância: {card_data.get('importance', '')}
Prazo: {card_data.get('due_date', '')}
"""
            
            recipients = self.settings.get('notification_recipients', [])
            for recipient in recipients:
                self.send_email(recipient, subject, body)
                
        except Exception as e:
            print(f"Erro ao notificar criação de cartão: {e}")


import requests
import base64
import urllib.parse
import threading
import time
# Importações para Google Calendar e templates de email
import threading
import time
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
import ssl
import pickle
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import webbrowser
from database import Database

# Configurações da API Google Calendar
SCOPES = ['https://www.googleapis.com/auth/calendar']
CREDENTIALS_FILE = 'credentials.json'
TOKEN_FILE = 'token.pickle'

class User:
    def __init__(self, username, role, cargo=None, user_id=None):
        self.username = username
        self.role = role
        self.cargo = cargo or "Usuário"
        self.user_id = user_id
        self.is_authenticated = False
        self.login_time = None
        
    def has_permission(self, permission):
        """Verifica se o usuário tem uma determinada permissão"""
        # Verificar se o role é válido
        if not hasattr(self, 'role') or not self.role:
            print("DEBUG: Usuário sem role, usando role padrão 'user'")
            self.role = "user"
        
        # Mapear roles em português para inglês
        role_mapping = {
            "Administrador": "admin",
            "admin": "admin",
            "Manager": "manager", 
            "manager": "manager",
            "Usuário": "user",
            "user": "user"
        }
        
        # Normalizar o role
        normalized_role = role_mapping.get(self.role, self.role)
        
        if normalized_role == "admin":
            return True  # Admin tem todas as permissões
        
        # Permissões específicas por role
        permissions = {
            "user": [
                "view_boards", "view_cards", "edit_own_cards", 
                "move_cards", "add_comments", "view_reports"
            ],
            "manager": [
                "view_boards", "view_cards", "edit_cards", 
                "move_cards", "add_comments", "view_reports",
                "manage_members", "create_cards", "delete_cards",
                "manage_users"
            ]
        }
        
        return permission in permissions.get(normalized_role, [])
    
    def can_manage_users(self):
        """Verifica se o usuário pode gerenciar outros usuários"""
        if not hasattr(self, 'role') or not self.role:
            return False
        
        # Mapear roles em português para inglês
        role_mapping = {
            "Administrador": "admin",
            "admin": "admin",
            "Manager": "manager", 
            "manager": "manager",
            "Usuário": "user",
            "user": "user"
        }
        
        # Normalizar o role
        normalized_role = role_mapping.get(self.role, self.role)
        return normalized_role in ["admin", "manager"]
    
    def can_manage_settings(self):
        """Verifica se o usuário pode gerenciar configurações"""
        if not hasattr(self, 'role') or not self.role:
            return False
        return self.role == "admin"
    
    def can_delete_cards(self):
        """Verifica se o usuário pode deletar cartões"""
        if not hasattr(self, 'role') or not self.role:
            return False
        return self.role in ["admin", "manager"]
    
    def can_edit_all_cards(self):
        """Verifica se o usuário pode editar todos os cartões"""
        if not hasattr(self, 'role') or not self.role:
            return False
        return self.role in ["admin", "manager"]
    
    def __str__(self):
        cargo = getattr(self, 'cargo', 'Usuário')
        return f"{self.username} ({cargo})"

class NotificationManager:
    def __init__(self, app):
        self.app = app
        self.notification_settings = self.load_notification_settings()
        self.notification_thread = None
        self.running = False
        
    def load_notification_settings(self):
        """Carrega configurações de notificação"""
        default_settings = {
            'enabled': True,
            'sound_enabled': True,
            'popup_enabled': True,
            'advance_notification_minutes': 15,
            'show_widget': True,
            'widget_position': 'top_right',
            'notification_duration': 10
        }
        
        try:
            if os.path.exists('notification_settings.json'):
                with open('notification_settings.json', 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                    # Mesclar com configurações padrão
                    for key, value in default_settings.items():
                        if key not in settings:
                            settings[key] = value
                    return settings
            else:
                return default_settings
        except Exception as e:
            print(f"Erro ao carregar configurações de notificação: {e}")
            return default_settings
    
    def save_notification_settings(self):
        """Salva configurações de notificação"""
        try:
            with open('notification_settings.json', 'w', encoding='utf-8') as f:
                json.dump(self.notification_settings, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"Erro ao salvar configurações de notificação: {e}")
    
    def start_notification_monitor(self):
        """Inicia o monitor de notificações"""
        if not self.notification_settings['enabled']:
            return
            
        self.running = True
        self.notification_thread = threading.Thread(target=self._monitor_meetings, daemon=True)
        self.notification_thread.start()
    
    def stop_notification_monitor(self):
        """Para o monitor de notificações"""
        self.running = False
        if self.notification_thread:
            self.notification_thread.join(timeout=1)
    
    def _monitor_meetings(self):
        """Monitora reuniões para notificações"""
        while self.running:
            try:
                current_time = datetime.now()
                
                # Verificar reuniões próximas
                for meeting_id, meeting in self.app.meeting_integration.meeting_data.items():
                    if meeting.get('notified', False):
                        continue
                    
                    meeting_datetime = datetime.strptime(f"{meeting['date']} {meeting['time']}", "%Y-%m-%d %H:%M")
                    time_diff = meeting_datetime - current_time
                    
                    # Notificar X minutos antes
                    if 0 <= time_diff.total_seconds() <= self.notification_settings['advance_notification_minutes'] * 60:
                        self._show_meeting_notification(meeting)
                        meeting['notified'] = True
                        self.app.meeting_integration.save_meeting_data()
                
                time.sleep(30)  # Verificar a cada 30 segundos
                
            except Exception as e:
                print(f"Erro no monitor de notificações: {e}")
                time.sleep(60)
    
    def _show_meeting_notification(self, meeting):
        """Mostra notificação de reunião"""
        if self.notification_settings['sound_enabled']:
            self._play_notification_sound()
        
        if self.notification_settings['popup_enabled']:
            self._show_popup_notification(meeting)
    
    def _play_notification_sound(self):
        """Toca som de notificação"""
        try:
            winsound.MessageBeep(winsound.MB_ICONEXCLAMATION)
        except:
            pass  # Ignorar se não conseguir tocar som
    
    def _show_popup_notification(self, meeting):
        """Mostra popup de notificação simples"""
        def show_popup():
            popup = tk.Toplevel()
            popup.title("Reunião")
            popup.geometry("300x120")
            
            # Centralizar na tela
            popup.update_idletasks()
            x = (popup.winfo_screenwidth() // 2) - (300 // 2)
            y = (popup.winfo_screenheight() // 2) - (120 // 2)
            popup.geometry(f"300x120+{x}+{y}")
            
            # Sempre no topo
            popup.attributes('-topmost', True)
            
            # Conteúdo simples
            title_label = tk.Label(popup, text="Reunião Próxima", 
                                 font=("Arial", 12, "bold"))
            title_label.pack(pady=5)
            
            meeting_label = tk.Label(popup, text=meeting['title'], 
                                   font=("Arial", 10))
            meeting_label.pack(pady=2)
            
            time_label = tk.Label(popup, text=f"{meeting['time']} - {meeting['platform'].upper()}", 
                                font=("Arial", 9))
            time_label.pack(pady=2)
            
            # Botões simples
            button_frame = tk.Frame(popup)
            button_frame.pack(pady=10)
            
            tk.Button(button_frame, text="Entrar", 
                     command=lambda: [webbrowser.open(meeting['link']), popup.destroy()]).pack(side=tk.LEFT, padx=5)
            
            tk.Button(button_frame, text="Fechar", 
                     command=popup.destroy).pack(side=tk.LEFT, padx=5)
            
            # Auto-fechar após X segundos
            popup.after(self.notification_settings['notification_duration'] * 1000, popup.destroy)
        
        # Executar na thread principal
        self.app.root.after(0, show_popup)

class MeetingWidget:
    def __init__(self, app, parent_frame):
        self.app = app
        self.parent_frame = parent_frame
        self.widget_frame = None
        self.create_widget()
    
    def create_widget(self):
        """Cria o widget de reuniões discreto no menu principal"""
        if not self.app.notification_manager.notification_settings['show_widget']:
            return
            
        # Criar frame discreto para o widget
        self.widget_frame = ttk.Frame(self.parent_frame)
        self.widget_frame.pack(fill=tk.X, padx=10, pady=2)
        
        # Título discreto
        title_label = ttk.Label(self.widget_frame, text="Próxima Reunião:", font=("Arial", 9))
        title_label.pack(anchor=tk.W, pady=(0, 2))
        
        # Lista de reuniões
        self.meetings_frame = tk.Frame(self.widget_frame)
        self.meetings_frame.pack(fill=tk.X)
        
        # Atualizar reuniões
        self.refresh_meetings()
        
        # Atualizar periodicamente
        self._schedule_refresh()
    
    def refresh_meetings(self):
        """Atualiza a lista de reuniões"""
        # Limpar frame
        for widget in self.meetings_frame.winfo_children():
            widget.destroy()
        
        # Buscar reuniões próximas e em andamento
        current_time = datetime.now()
        upcoming_meetings = []
        ongoing_meetings = []
        
        for meeting_id, meeting in self.app.meeting_integration.meeting_data.items():
            meeting_datetime = datetime.strptime(f"{meeting['date']} {meeting['time']}", "%Y-%m-%d %H:%M")
            duration_minutes = int(meeting.get('duration', 60))  # Duração padrão 60 min
            end_datetime = meeting_datetime + timedelta(minutes=duration_minutes)
            
            # Verificar se a reunião está em andamento
            if meeting_datetime <= current_time <= end_datetime:
                ongoing_meetings.append((meeting_datetime, meeting, end_datetime))
            # Verificar se a reunião está próxima (próximas 24 horas)
            elif 0 <= (meeting_datetime - current_time).total_seconds() <= 24 * 60 * 60:
                upcoming_meetings.append((meeting_datetime, meeting))
        
        # Ordenar por data/hora (primeiro elemento da tupla é o datetime)
        ongoing_meetings.sort(key=lambda x: x[0])
        upcoming_meetings.sort(key=lambda x: x[0])
        
        # Mostrar reunião em andamento primeiro, depois a próxima
        if ongoing_meetings:
            meeting_datetime, meeting, end_datetime = ongoing_meetings[0]
            self._display_meeting(meeting, meeting_datetime, is_ongoing=True, end_datetime=end_datetime)
        elif upcoming_meetings:
            meeting_datetime, meeting = upcoming_meetings[0]
            self._display_meeting(meeting, meeting_datetime, is_ongoing=False)
        else:
            # Se não há reuniões, mostrar mensagem discreta
            no_meetings_label = ttk.Label(self.meetings_frame, text="Nenhuma reunião nas próximas 24h", 
                                        font=("Arial", 8), 
                                        foreground='#7f8c8d')
            no_meetings_label.pack(pady=2)
    
    def _display_meeting(self, meeting, meeting_datetime, is_ongoing=False, end_datetime=None):
        """Exibe uma reunião no widget"""
        current_time = datetime.now()
        
        # Frame principal da reunião
        meeting_frame = tk.Frame(self.meetings_frame, relief=tk.SUNKEN, bd=1)
        meeting_frame.pack(fill=tk.X, pady=1)
        
        if is_ongoing:
            # Reunião em andamento
            time_remaining = end_datetime - current_time
            minutes_remaining = int(time_remaining.total_seconds() // 60)
            time_text = f"EM ANDAMENTO ({minutes_remaining}m restantes)"
            time_color = '#e74c3c'  # Vermelho para reunião em andamento
        else:
            # Reunião próxima
            time_diff = meeting_datetime - current_time
            hours = int(time_diff.total_seconds() // 3600)
            minutes = int((time_diff.total_seconds() % 3600) // 60)
            
            if hours > 0:
                time_text = f"em {hours}h {minutes}m"
            else:
                time_text = f"em {minutes}m"
            time_color = '#e67e22'  # Laranja para reunião próxima
        
        # Frame para informações da reunião
        info_frame = tk.Frame(meeting_frame)
        info_frame.pack(fill=tk.X, padx=5, pady=3)
        
        # Título da reunião (clicável)
        title_label = tk.Label(info_frame, text=meeting['title'][:30] + "..." if len(meeting['title']) > 30 else meeting['title'], 
                             font=("Arial", 9), 
                             fg='#2c3e50', cursor="hand2")
        title_label.pack(side=tk.LEFT, anchor=tk.W)
        
        # Bind duplo clique para abrir link
        title_label.bind("<Double-1>", lambda e, m=meeting: webbrowser.open(m['link']))
        
        # Tempo restante
        time_label = tk.Label(info_frame, text=time_text, 
                            font=("Arial", 8), 
                            fg=time_color)
        time_label.pack(side=tk.LEFT, padx=(10, 0))
        
        # Hora e plataforma
        time_info = tk.Label(info_frame, text=f"{meeting['time']} - {meeting['platform'].upper()}", 
                           font=("Arial", 8), 
                           fg='#7f8c8d')
        time_info.pack(side=tk.LEFT, padx=(10, 0))
        
        # Botão discreto para copiar link
        copy_button = tk.Button(info_frame, 
                              image=self.app.icons.get('copy_icon'),
                              relief=tk.FLAT, 
                              bd=0,
                              command=lambda m=meeting: self.copy_meeting_link(m))
        copy_button.pack(side=tk.RIGHT, padx=(5, 0))
        
        # Tooltip para o botão
        copy_button.bind("<Enter>", lambda e, btn=copy_button: btn.config(bg='#e0e0e0'))
        copy_button.bind("<Leave>", lambda e, btn=copy_button: btn.config(bg='SystemButtonFace'))
    
    def copy_meeting_link(self, meeting):
        """Copia o link da reunião para a área de transferência"""
        try:
            self.app.root.clipboard_clear()
            self.app.root.clipboard_append(meeting['link'])
            # Mostrar feedback discreto
            messagebox.showinfo("Link Copiado", f"Link da reunião '{meeting['title']}' copiado para a área de transferência!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao copiar link: {e}")
    
    def _schedule_refresh(self):
        """Agenda atualização automática"""
        self.refresh_meetings()
        self.widget_frame.after(60000, self._schedule_refresh)  # Atualizar a cada minuto
    
    def open_notification_settings(self):
        """Abre configurações de notificação"""
        NotificationSettingsWindow(self.app)

class NotificationSettingsWindow:
    def __init__(self, app):
        self.app = app
        self.window = tk.Toplevel(app.root)
        self.window.title("Configurações de Notificação")
        self.window.geometry("500x400")
        self.window.transient(app.root)
        self.window.grab_set()
        
        self.create_widgets()
    
    def create_widgets(self):
        """Cria widgets da janela de configurações"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_label = ttk.Label(main_frame, text="Configurações de Notificação", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Configurações
        settings_frame = ttk.LabelFrame(main_frame, text="Notificações", padding="10")
        settings_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Habilitar notificações
        self.enabled_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['enabled'])
        ttk.Checkbutton(settings_frame, text="Habilitar notificações", 
                       variable=self.enabled_var).pack(anchor=tk.W, pady=2)
        
        # Som
        self.sound_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['sound_enabled'])
        ttk.Checkbutton(settings_frame, text="Tocar som", 
                       variable=self.sound_var).pack(anchor=tk.W, pady=2)
        
        # Popup
        self.popup_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['popup_enabled'])
        ttk.Checkbutton(settings_frame, text="Mostrar popup", 
                       variable=self.popup_var).pack(anchor=tk.W, pady=2)
        
        # Widget
        self.widget_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['show_widget'])
        ttk.Checkbutton(settings_frame, text="Mostrar widget na tela", 
                       variable=self.widget_var).pack(anchor=tk.W, pady=2)
        
        # Configurações avançadas
        advanced_frame = ttk.LabelFrame(main_frame, text="Configurações Avançadas", padding="10")
        advanced_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Antecedência da notificação
        ttk.Label(advanced_frame, text="Notificar (minutos antes):").pack(anchor=tk.W, pady=2)
        self.advance_var = tk.StringVar(value=str(self.app.notification_manager.notification_settings['advance_notification_minutes']))
        advance_entry = ttk.Entry(advanced_frame, textvariable=self.advance_var, width=10)
        advance_entry.pack(anchor=tk.W, pady=2)
        
        # Duração da notificação
        ttk.Label(advanced_frame, text="Duração do popup (segundos):").pack(anchor=tk.W, pady=2)
        self.duration_var = tk.StringVar(value=str(self.app.notification_manager.notification_settings['notification_duration']))
        duration_entry = ttk.Entry(advanced_frame, textvariable=self.duration_var, width=10)
        duration_entry.pack(anchor=tk.W, pady=2)
        
        # Posição do widget
        ttk.Label(advanced_frame, text="Posição do widget:").pack(anchor=tk.W, pady=2)
        self.position_var = tk.StringVar(value=self.app.notification_manager.notification_settings['widget_position'])
        position_combo = ttk.Combobox(advanced_frame, textvariable=self.position_var, 
                                     values=['top_right', 'top_left', 'bottom_right', 'bottom_left'], 
                                     state="readonly", width=15)
        position_combo.pack(anchor=tk.W, pady=2)
        
        # Botões
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=20)
        
        ttk.Button(button_frame, text="Salvar", 
                  command=self.save_settings).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Testar Notificação", 
                  command=self.test_notification).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancelar", 
                  command=self.window.destroy).pack(side=tk.RIGHT, padx=5)
    
    def save_settings(self):
        """Salva as configurações"""
        try:
            self.app.notification_manager.notification_settings.update({
                'enabled': self.enabled_var.get(),
                'sound_enabled': self.sound_var.get(),
                'popup_enabled': self.popup_var.get(),
                'show_widget': self.widget_var.get(),
                'advance_notification_minutes': int(self.advance_var.get()),
                'notification_duration': int(self.duration_var.get()),
                'widget_position': self.position_var.get()
            })
            
            self.app.notification_manager.save_notification_settings()
            
            # Reiniciar monitor se necessário
            if self.app.notification_manager.notification_settings['enabled']:
                self.app.notification_manager.stop_notification_monitor()
                self.app.notification_manager.start_notification_monitor()
            
            messagebox.showinfo("Sucesso", "Configurações salvas com sucesso!")
            self.window.destroy()
            
        except ValueError:
            messagebox.showerror("Erro", "Por favor, insira valores numéricos válidos.")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar configurações: {e}")
    
    def test_notification(self):
        """Testa a notificação"""
        test_meeting = {
            'title': 'Reunião de Teste',
            'date': datetime.now().strftime('%Y-%m-%d'),
            'time': datetime.now().strftime('%H:%M'),
            'platform': 'test',
            'link': '#'
        }
        
        self.app.notification_manager._show_meeting_notification(test_meeting)

class GoogleCalendarManager:
    def __init__(self):
        self.service = None
        self.credentials = None
        
    def authenticate(self):
        """Autentica com a API do Google Calendar"""
        try:
            # Verificar se já temos credenciais salvas
            if os.path.exists(TOKEN_FILE):
                with open(TOKEN_FILE, 'rb') as token:
                    self.credentials = pickle.load(token)
            
            # Se não há credenciais válidas, fazer login
            if not self.credentials or not self.credentials.valid:
                if self.credentials and self.credentials.expired and self.credentials.refresh_token:
                    self.credentials.refresh(Request())
                else:
                    if not os.path.exists(CREDENTIALS_FILE):
                        messagebox.showerror("Erro", 
                                           "Arquivo credentials.json não encontrado!\n\n"
                                           "Para usar o Google Meet:\n"
                                           "1. Acesse https://console.cloud.google.com\n"
                                           "2. Crie um projeto e ative a Google Calendar API\n"
                                           "3. Crie credenciais OAuth 2.0\n"
                                           "4. Baixe o arquivo como 'credentials.json'\n"
                                           "5. Coloque na pasta do aplicativo")
                        return False
                    
                    flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_FILE, SCOPES)
                    self.credentials = flow.run_local_server(port=0)
                
                # Salvar credenciais para uso futuro
                with open(TOKEN_FILE, 'wb') as token:
                    pickle.dump(self.credentials, token)
            
            # Construir o serviço
            self.service = build('calendar', 'v3', credentials=self.credentials)
            return True
            
        except Exception as e:
            messagebox.showerror("Erro de Autenticação", f"Erro ao autenticar com Google Calendar:\n{str(e)}")
            return False
    
    def create_meeting(self, title, date, time_str, duration=60, description=""):
        """Cria uma reunião real no Google Calendar com Google Meet"""
        try:
            if not self.service:
                if not self.authenticate():
                    return None
            
            # Converter data e hora para datetime
            datetime_str = f"{date} {time_str}"
            start_time = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M")
            end_time = start_time + timedelta(minutes=duration)
            
            # Formatar para RFC3339
            start_rfc = start_time.isoformat() + 'Z'
            end_rfc = end_time.isoformat() + 'Z'
            
            # Criar evento no Google Calendar
            event = {
                'summary': title,
                'description': description,
                'start': {
                    'dateTime': start_rfc,
                    'timeZone': 'America/Sao_Paulo',
                },
                'end': {
                    'dateTime': end_rfc,
                    'timeZone': 'America/Sao_Paulo',
                },
                'conferenceData': {
                    'createRequest': {
                        'requestId': f"meet_{int(time.time())}",
                        'conferenceSolutionKey': {
                            'type': 'hangoutsMeet'
                        }
                    }
                }
            }
            
            # Inserir evento
            event = self.service.events().insert(
                calendarId='primary',
                body=event,
                conferenceDataVersion=1
            ).execute()
            
            # Extrair link do Google Meet
            meet_link = event.get('conferenceData', {}).get('entryPoints', [{}])[0].get('uri', '')
            
            return {
                'id': event['id'],
                'title': title,
                'date': date,
                'time': time_str,
                'duration': duration,
                'link': meet_link,
                'platform': 'google_meet',
                'created_by': 'Sistema',
                'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'status': 'scheduled',
                'google_event_id': event['id']
            }
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao criar reunião no Google Meet:\n{str(e)}")
            return None

# New function to load all icons
def load_app_icons(base_dir):
    print("DEBUG: Iniciando load_app_icons")
    icons = {}
    # Helper function to load images safely within this scope
    def _load_image(filename, size):
        try:
            path = os.path.join(base_dir, filename)
            img = Image.open(path)
            return ImageTk.PhotoImage(img.resize(size))
        except FileNotFoundError:
            print(f"Erro: Arquivo de imagem não encontrado: {filename}")
            return None # Return None or a placeholder image
        except Exception as e:
            print(f"Erro ao carregar imagem {filename}: {e}")
            return None

    small_icon_size = (16, 16)
    large_icon_size = (32, 32)

    # Load small icons (16x16) for menus and compact areas
    icons['logo_icon'] = _load_image("LOGO.png", (32, 32)) # Keep logo larger
    icons['add_icon'] = _load_image("Add.png", small_icon_size)
    icons['delete_icon'] = _load_image("Delete.png", small_icon_size)
    icons['save_icon'] = _load_image("Save.png", small_icon_size)
    icons['search_icon'] = _load_image("Search.png", small_icon_size)
    icons['key_icon'] = _load_image("Key.png", small_icon_size)
    icons['cancel_icon'] = _load_image("Cancel.png", small_icon_size)
    icons['up_icon'] = _load_image("Up.png", small_icon_size)
    icons['down_icon'] = _load_image("Down.png", small_icon_size)
    icons['back_icon'] = _load_image("Back.png", small_icon_size)
    icons['left_icon'] = _load_image("Left.png", small_icon_size)
    icons['right_icon'] = _load_image("Right.png", small_icon_size)
    icons['forward_icon'] = _load_image("Forward.png", small_icon_size)
    icons['ok_icon'] = _load_image("Ok.png", small_icon_size)
    icons['settings_icon'] = _load_image("Settings.png", small_icon_size)
    icons['exit_icon'] = _load_image("Exit.png", small_icon_size)
    icons['folder_icon'] = _load_image("Folder.png", small_icon_size)
    icons['pencil_icon'] = _load_image("Pencil.png", small_icon_size)
    icons['clear_icon'] = _load_image("Clear.png", small_icon_size)
    icons['apply_icon'] = _load_image("Apply.png", small_icon_size)
    icons['add_folder_icon'] = _load_image("Add folder.png", small_icon_size)
    icons['info_icon'] = _load_image("Info.png", small_icon_size)
    icons['play_icon'] = _load_image("Play.png", small_icon_size)
    icons['stop_icon'] = _load_image("Stop.png", small_icon_size)
    icons['refresh_icon'] = _load_image("Refresh.png", small_icon_size)
    icons['time_icon'] = _load_image("Time.png", small_icon_size)
    icons['import_icon'] = _load_image("Import.png", small_icon_size)
    icons['export_icon'] = _load_image("Export.png", small_icon_size)
    icons['registration_icon'] = _load_image("Registration.png", small_icon_size)
    icons['chart_xy_icon'] = _load_image("Chart xy.png", small_icon_size)
    icons['pie_chart_icon'] = _load_image("Pie chart.png", small_icon_size)
    icons['bar_chart_icon'] = _load_image("3d bar chart.png", small_icon_size)
    icons['objects_icon'] = _load_image("Objects.png", small_icon_size)
    icons['coffee_icon'] = _load_image("Coffee.png", small_icon_size)
    icons['chat_icon'] = _load_image("Info.png", small_icon_size)  # Usar Info como chat
    icons['calendar_icon'] = _load_image("Time.png", small_icon_size)  # Usar Time como calendar
    icons['copy_icon'] = _load_image("Apply.png", small_icon_size)  # Usar Apply como copy
    icons['meet_icon'] = _load_image("Play.png", small_icon_size)  # Usar Play como meet

    # Load large icons (32x32) for main action buttons
    icons['forward_icon_32'] = _load_image("Forward.png", large_icon_size)
    icons['open_file_icon_32'] = _load_image("Open file.png", large_icon_size)
    icons['refresh_icon_32'] = _load_image("Refresh.png", large_icon_size)
    icons['save_icon_32'] = _load_image("Save.png", large_icon_size)
    icons['cancel_icon_32'] = _load_image("Cancel.png", large_icon_size)

    return icons

# --- Helper Classes ---

class LoginWindow(tk.Toplevel):
    def __init__(self, parent, db, icons):
        super().__init__(parent)
        self.parent = parent
        self.db = db
        self.icons = icons
        
        print("DEBUG: LoginWindow.__init__ iniciado")
        
        self.title("Login - Sistema Boodesk")
        self.geometry("400x300")
        self.resizable(False, False)
        self.transient(parent)
        self.grab_set()
        self.protocol("WM_DELETE_WINDOW", self.cancel_login)

        # Centralizar a janela
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 400
        window_height = 300
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

        print("DEBUG: LoginWindow criando widgets...")
        self.create_widgets()
        
        # Focar no campo de usuário
        self.user_entry.focus()
        
        # Garantir que a janela seja visível
        self.after(100, self.ensure_visibility)
        print("DEBUG: LoginWindow criada com sucesso")

    def create_widgets(self):
        # Aumentar o tamanho da janela para acomodar todos os elementos
        self.geometry("500x450")
        
        main_frame = ttk.Frame(self, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configurar grid
        main_frame.columnconfigure(1, weight=1)
        
        # Logo e título
        logo_frame = ttk.Frame(main_frame)
        logo_frame.grid(row=0, column=0, columnspan=2, pady=(0, 20))
        
        if self.icons.get('logo_icon'):
            logo_label = ttk.Label(logo_frame, image=self.icons['logo_icon'])
            logo_label.pack(side=tk.LEFT, padx=(0, 10))
        
        title_label = ttk.Label(logo_frame, text="Sistema Boodesk", font=("Arial", 16, "bold"))
        title_label.pack(side=tk.LEFT)
        
        # Subtítulo
        subtitle_label = ttk.Label(main_frame, text="Faça login para continuar", font=("Arial", 10))
        subtitle_label.grid(row=1, column=0, columnspan=2, pady=(0, 20))
        
        # Campo de usuário
        ttk.Label(main_frame, text="Usuário:", font=("Arial", 10, "bold")).grid(row=2, column=0, sticky="w", pady=5)
        self.user_entry = ttk.Entry(main_frame, font=("Arial", 11), width=25)
        self.user_entry.grid(row=2, column=1, sticky="ew", padx=(10, 0), pady=5)
        self.user_entry.insert(0, "admin")  # Preencher com admin por padrão
        self.user_entry.bind("<Return>", lambda e: self.password_entry.focus())
        
        # Campo de senha
        ttk.Label(main_frame, text="Senha:", font=("Arial", 10, "bold")).grid(row=3, column=0, sticky="w", pady=5)
        self.password_entry = ttk.Entry(main_frame, show="*", font=("Arial", 11), width=25)
        self.password_entry.grid(row=3, column=1, sticky="ew", padx=(10, 0), pady=5)
        self.password_entry.bind("<Return>", lambda e: self.check_login())
        
        # Frame dos botões - Melhorado para garantir visibilidade
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=4, column=0, columnspan=2, pady=20, sticky="ew")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        
        # Botão de login com ícone
        login_btn = ttk.Button(button_frame, text="🔐 Entrar", 
                              command=self.check_login, style="Accent.TButton")
        login_btn.grid(row=0, column=0, padx=5, sticky="ew")
        
        # Botão de cadastro com ícone
        register_btn = ttk.Button(button_frame, text="📝 Cadastrar", 
                                 command=self.open_user_registration)
        register_btn.grid(row=0, column=1, padx=5, sticky="ew")
        
        # Botão cancelar com ícone
        cancel_btn = ttk.Button(button_frame, text="❌ Cancelar", 
                               command=self.cancel_login)
        cancel_btn.grid(row=0, column=2, padx=5, sticky="ew")
        
        # Informações de usuários padrão
        info_frame = ttk.LabelFrame(main_frame, text="👥 Usuários Padrão", padding="10")
        info_frame.grid(row=5, column=0, columnspan=2, pady=(10, 0), sticky="ew")
        
        info_text = """Usuários padrão do sistema:
• admin / admin123 (Administrador)
• user / user123 (Usuário)
• manager / manager123 (Gerente)"""
        
        info_label = ttk.Label(info_frame, text=info_text, font=("Arial", 9), justify=tk.LEFT)
        info_label.pack()
        
        # Centralizar a janela novamente após ajustar o tamanho
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 500
        window_height = 450
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

    def check_login(self):
        username = self.user_entry.get().strip()
        password = self.password_entry.get()
        
        if not username or not password:
            messagebox.showerror("Erro", "Por favor, preencha todos os campos!")
            return
        
        user_data = self.db.get_user_by_username(username)
        
        if user_data and user_data['password_hash'] == password:
            user = User(
                username=user_data['username'],
                role=user_data['role'],
                cargo=user_data['cargo'],
                user_id=user_data['id']
            )
            user.is_authenticated = True
            user.login_time = datetime.now()
            
            self.parent.login_successful = True
            self.parent.current_user = user
            messagebox.showinfo("Login Bem-sucedido", f"Bem-vindo, {user.username}!\nNível de acesso: {user.cargo}")
            self.destroy()
        else:
            messagebox.showerror("Erro de Login", "Usuário ou senha incorretos!")
            self.password_entry.delete(0, tk.END)
            self.password_entry.focus()

    def open_user_registration(self):
        """Abre a janela de cadastro de usuários"""
        UserRegistrationWindow(self, self.db, self.icons)

    def ensure_visibility(self):
        """Garante que a janela seja visível"""
        print("DEBUG: ensure_visibility chamado")
        self.lift()
        self.focus_force()
        self.deiconify()
        self.update()
        print("DEBUG: Janela de login deve estar visível agora")
        
    def on_user_keypress(self, event):
        """Trata teclas no campo usuário"""
        if event.keysym == 'Return':
            print("DEBUG: Enter pressionado no campo usuário")
            self.password_entry.focus()
            return "break"
        elif event.keysym == 'Tab':
            # Permitir navegação com Tab
            return None
    
    def on_password_keypress(self, event):
        """Trata teclas no campo senha"""
        if event.keysym == 'Return':
            print("DEBUG: Enter pressionado no campo senha")
            self.check_login()
            return "break"
        elif event.keysym == 'Tab':
            # Permitir navegação com Tab
            return None
            return "break"
        elif event.keysym == 'Tab':
            # Permitir navegação com Tab
            return None
    
    def cancel_login(self):
        self.parent.login_successful = False
        self.destroy()

class UserRegistrationWindow(tk.Toplevel):
    def __init__(self, parent, db, icons, app=None, preselected_member_id=None):
        try:
            super().__init__(parent)
            self.parent = parent
            self.db = db
            self.icons = icons
            self.app = app
            self.preselected_member_id = preselected_member_id
            
            print("DEBUG: Inicializando UserRegistrationWindow...")
            
            self.title("Cadastro de Usuários")
            self.geometry("700x500")
            self.resizable(True, True)
            self.transient(parent)
            self.grab_set()
            
            # Centralizar a janela
            self.update_idletasks()
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()
            window_width = 700
            window_height = 500
            x = (screen_width - window_width) // 2
            y = (screen_height - window_height) // 2
            self.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            # Variáveis para edição
            self.edit_mode = False
            self.selected_user_id = None
            
            print("DEBUG: Criando widgets...")
            self.create_widgets()
            
            print("DEBUG: Populando lista de usuários...")
            self.populate_users_list()
            
            print("DEBUG: UserRegistrationWindow inicializada com sucesso!")
            
        except Exception as e:
            print(f"DEBUG: Erro ao inicializar UserRegistrationWindow: {e}")
            messagebox.showerror("Erro", f"Não foi possível abrir a tela de gerenciar usuários: {e}")
            self.destroy()
    
    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configurar grid
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # Título
        title_label = ttk.Label(main_frame, text="Gerenciamento de Usuários", font=("Arial", 14, "bold"))
        title_label.grid(row=0, column=0, pady=(0, 10))
        
        # Frame da lista de usuários
        list_frame = ttk.LabelFrame(main_frame, text="Lista de Usuários", padding="5")
        list_frame.grid(row=1, column=0, sticky="nsew", pady=(0, 10))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        # Treeview para lista de usuários
        columns = ("ID", "Usuário", "Cargo", "Role", "Criado em", "Último Login")
        self.users_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=8)
        
        # Configurar colunas
        self.users_tree.heading("ID", text="ID")
        self.users_tree.heading("Usuário", text="Usuário")
        self.users_tree.heading("Cargo", text="Cargo")
        self.users_tree.heading("Role", text="Nível de Acesso")
        self.users_tree.heading("Criado em", text="Criado em")
        self.users_tree.heading("Último Login", text="Último Login")
        
        self.users_tree.column("ID", width=50, anchor="center")
        self.users_tree.column("Usuário", width=120, anchor="w")
        self.users_tree.column("Cargo", width=100, anchor="w")
        self.users_tree.column("Role", width=100, anchor="w")
        self.users_tree.column("Criado em", width=120, anchor="w")
        self.users_tree.column("Último Login", width=120, anchor="w")
        
        self.users_tree.grid(row=0, column=0, sticky="nsew", pady=5)
        self.users_tree.bind("<<TreeviewSelect>>", self.on_user_select)
        
        # Scrollbar para a lista
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.users_tree.yview)
        scrollbar.grid(row=0, column=1, sticky="ns")
        self.users_tree.config(yscrollcommand=scrollbar.set)
        
        # Frame do formulário
        form_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Usuário", padding="10")
        form_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        form_frame.columnconfigure(1, weight=1)
        
        # Campos do formulário
        ttk.Label(form_frame, text="Usuário:").grid(row=0, column=0, sticky="w", pady=2)
        self.username_entry = ttk.Entry(form_frame)
        self.username_entry.grid(row=0, column=1, sticky="ew", padx=(5, 0), pady=2)
        
        ttk.Label(form_frame, text="Senha:").grid(row=1, column=0, sticky="w", pady=2)
        self.password_entry = ttk.Entry(form_frame, show="*")
        self.password_entry.grid(row=1, column=1, sticky="ew", padx=(5, 0), pady=2)
        
        ttk.Label(form_frame, text="Cargo:").grid(row=2, column=0, sticky="w", pady=2)
        self.cargo_combo = ttk.Combobox(form_frame, state="readonly")
        try:
            if self.app and hasattr(self.app, 'settings') and 'roles' in self.app.settings:
                self.cargo_combo['values'] = list(self.app.settings['roles'].keys())
        except Exception:
            pass
        if not self.cargo_combo['values']:
            self.cargo_combo['values'] = ["Usuário", "Administrador", "Manager"]
        self.cargo_combo.set(self.cargo_combo['values'][0])
        self.cargo_combo.grid(row=2, column=1, sticky="ew", padx=(5, 0), pady=2)
        cargo_btn = ttk.Button(form_frame, text="Cadastrar Cargo", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self._open_roles_settings_from_users)
        cargo_btn.grid(row=2, column=2, padx=5, pady=2, sticky="w")
        
        ttk.Label(form_frame, text="Nível de Acesso:").grid(row=3, column=0, sticky="w", pady=2)
        self.role_combo = ttk.Combobox(form_frame, values=["user", "manager", "admin"], state="readonly")
        self.role_combo.set("user")
        self.role_combo.grid(row=3, column=1, sticky="ew", padx=(5, 0), pady=2)
        
        ttk.Label(form_frame, text="Membro:").grid(row=4, column=0, sticky="w", pady=2)
        self.member_combo = ttk.Combobox(form_frame, state="readonly")
        self.member_combo.grid(row=4, column=1, sticky="ew", padx=(5, 0), pady=2)
        member_btn = ttk.Button(form_frame, text="Cadastrar Membro", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self._open_members_window_from_users)
        member_btn.grid(row=4, column=2, padx=5, pady=2, sticky="w")
        self.populate_members_combo()
        
        # Frame dos botões do formulário
        form_buttons_frame = ttk.Frame(form_frame)
        form_buttons_frame.grid(row=5, column=0, columnspan=2, pady=10)
        form_buttons_frame.columnconfigure(0, weight=1)
        form_buttons_frame.columnconfigure(1, weight=1)
        
        ttk.Button(form_buttons_frame, text="Adicionar Usuário", 
                  image=self.icons.get('add_icon'), compound=tk.LEFT, 
                  command=self.add_user).grid(row=0, column=0, padx=2)
        
        ttk.Button(form_buttons_frame, text="Limpar", 
                  image=self.icons.get('clear_icon'), compound=tk.LEFT, 
                  command=self.clear_form).grid(row=0, column=1, padx=2)
        
        # Frame dos botões de ação
        action_frame = ttk.Frame(main_frame)
        action_frame.grid(row=3, column=0, pady=5)
        
        ttk.Button(action_frame, text="Editar Usuário", 
                  image=self.icons.get('edit_icon'), compound=tk.LEFT, 
                  command=self.edit_user).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(action_frame, text="Remover Usuário", 
                  image=self.icons.get('delete_icon'), compound=tk.LEFT, 
                  command=self.remove_user).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(action_frame, text="Atualizar Lista", 
                  image=self.icons.get('refresh_icon'), compound=tk.LEFT, 
                  command=self.populate_users_list).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(action_frame, text="Fechar", 
                  image=self.icons.get('cancel_icon'), compound=tk.LEFT, 
                  command=self.destroy).pack(side=tk.LEFT, padx=5)
    
    def populate_members_combo(self):
        """Popula o combo de membros"""
        try:
            import sqlite3
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("SELECT id, name, email FROM members ORDER BY name")
            members = cursor.fetchall()
            conn.close()
            
            # Criar lista de membros para o combo
            member_list = []
            self.member_dict = {}  # Dicionário para mapear nome -> id
            
            for member_id, name, email in members:
                # Tratar email nulo ou vazio
                if email is None or email == '' or email == 'nan':
                    display_name = f"{name} (sem email)"
                else:
                    display_name = f"{name} ({email})"
                
                member_list.append(display_name)
                self.member_dict[display_name] = member_id
            
            self.member_combo['values'] = member_list
            if member_list:
                if self.preselected_member_id and self.preselected_member_id in self.member_dict.values():
                    for display_name, mid in self.member_dict.items():
                        if mid == self.preselected_member_id:
                            self.member_combo.set(display_name)
                            break
                else:
                    self.member_combo.set(member_list[0])
            
        except Exception as e:
            print(f"DEBUG: Erro ao popular combo de membros: {e}")

    def _open_roles_settings_from_users(self):
        """Abre a aba de cargos das configurações a partir da tela de usuários"""
        try:
            if not self.app:
                messagebox.showerror("Erro", "Aplicação não disponível para abrir Cargos.")
                return
            # Abrir configurações normalmente
            settings_window = SettingsWindow(self.master, self.app)
            self.master.wait_window(settings_window)
            # Atualizar lista de cargos após fechar as configurações
            if self.app and hasattr(self.app, 'settings') and 'roles' in self.app.settings:
                if hasattr(self, 'cargo_combo') and self.cargo_combo:
                    self.cargo_combo['values'] = list(self.app.settings['roles'].keys())
                    if self.cargo_combo.get() not in self.cargo_combo['values'] and self.cargo_combo['values']:
                        self.cargo_combo.set(self.cargo_combo['values'][0])
        except Exception as e:
            print(f"DEBUG: Erro ao abrir configurações de cargos pela tela de usuários: {e}")
            messagebox.showerror("Erro", f"Não foi possível abrir as configurações de cargos: {e}")

    def _open_members_window_from_users(self):
        """Abre a janela de gerenciamento de membros a partir da tela de usuários"""
        try:
            if not self.app:
                messagebox.showerror("Erro", "Aplicação não disponível para abrir Membros.")
                return
            
            # Abrir janela de membros
            members_window = MembersWindow(self.master, self.app)
            self.master.wait_window(members_window)
            
            # Atualizar lista de membros após fechar a janela
            self.populate_members_combo()
            
        except Exception as e:
            print(f"DEBUG: Erro ao abrir janela de membros pela tela de usuários: {e}")
            messagebox.showerror("Erro", f"Não foi possível abrir a janela de membros: {e}")
    
    def populate_users_list(self):
        """Popula a lista de usuários"""
        try:
            print("DEBUG: Populando lista de usuários...")
            
            # Limpar lista atual
            for item in self.users_tree.get_children():
                self.users_tree.delete(item)
            
            # Usar o banco de dados SQLite diretamente
            import sqlite3
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            # Carregar usuários
            cursor.execute("SELECT id, username, cargo, role, created_at, updated_at FROM users ORDER BY id")
            users = cursor.fetchall()
            conn.close()
            
            print(f"DEBUG: {len(users)} usuários encontrados")
            
            for user in users:
                try:
                    user_id, username, cargo, role, created_at, updated_at = user
                    
                    # Formatar data de criação
                    if created_at:
                        try:
                            created_at = datetime.strptime(created_at, '%Y-%m-%d %H:%M:%S.%f').strftime('%d/%m/%Y %H:%M')
                        except:
                            created_at = created_at[:19] if len(created_at) > 19 else created_at
                    else:
                        created_at = "N/A"

                    # Formatar data de último login (usar updated_at como aproximação)
                    if updated_at:
                        try:
                            last_login = datetime.strptime(updated_at, '%Y-%m-%d %H:%M:%S.%f').strftime('%d/%m/%Y %H:%M')
                        except:
                            last_login = updated_at[:19] if len(updated_at) > 19 else updated_at
                    else:
                        last_login = "Nunca"

                    self.users_tree.insert("", "end", values=(
                        user_id,
                        username,
                        cargo,
                        role,
                        created_at,
                        last_login
                    ))
                except Exception as e:
                    print(f"DEBUG: Erro ao processar usuário {user}: {e}")
                    continue
            
            print("DEBUG: Lista de usuários populada com sucesso!")
            
        except Exception as e:
            print(f"DEBUG: Erro ao popular lista de usuários: {e}")
            messagebox.showerror("Erro", f"Não foi possível carregar a lista de usuários: {e}")
    
    def on_user_select(self, event):
        """Manipula seleção de usuário na lista"""
        selected_item = self.users_tree.selection()
        if selected_item:
            values = self.users_tree.item(selected_item, "values")
            self.selected_user_id = int(values[0])
            
            # Preencher formulário para edição
            self.username_entry.delete(0, tk.END)
            self.username_entry.insert(0, values[1])
            
            if hasattr(self, 'cargo_combo') and self.cargo_combo['values']:
                if values[2] in self.cargo_combo['values']:
                    self.cargo_combo.set(values[2])
                else:
                    try:
                        self.cargo_combo['values'] = list(dict.fromkeys([values[2], *self.cargo_combo['values']]))
                        self.cargo_combo.set(values[2])
                    except Exception:
                        pass
            
            self.role_combo.set(values[3])
            
            # Buscar e preencher o membro associado
            try:
                import sqlite3
                conn = sqlite3.connect('boodesk_new.db')
                cursor = conn.cursor()
                cursor.execute("SELECT member_id FROM users WHERE id = ?", (self.selected_user_id,))
                result = cursor.fetchone()
                conn.close()
                
                if result and result[0]:
                    member_id = result[0]
                    # Encontrar o membro no combo
                    for display_name, mid in self.member_dict.items():
                        if mid == member_id:
                            self.member_combo.set(display_name)
                            break
            except Exception as e:
                print(f"DEBUG: Erro ao buscar membro associado: {e}")
            
            # Limpar senha (não mostrar senha atual)
            self.password_entry.delete(0, tk.END)
            
            self.edit_mode = True
        else:
            self.edit_mode = False
            self.selected_user_id = None
    
    def add_user(self):
        """Adiciona um novo usuário"""
        username = self.username_entry.get().strip()
        password = self.password_entry.get()
        cargo = self.cargo_combo.get().strip()
        role = self.role_combo.get()
        member_selection = self.member_combo.get()
        
        if not username or not password or not cargo or not member_selection:
            messagebox.showerror("Erro", "Todos os campos são obrigatórios!")
            return
        
        # Obter o ID do membro selecionado
        member_id = self.member_dict.get(member_selection)
        if not member_id:
            messagebox.showerror("Erro", "Selecione um membro válido!")
            return
        
        # Usar o banco de dados SQLite diretamente
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            # Verificar se usuário já existe
            cursor.execute("SELECT id FROM users WHERE username = ?", (username,))
            if cursor.fetchone():
                messagebox.showerror("Erro", "Usuário já existe")
                conn.close()
                return
            
            # Inserir novo usuário
            cursor.execute("""
                INSERT INTO users (username, password_hash, email, role, cargo, member_id, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (username, password, "", role, cargo, member_id, datetime.now(), datetime.now()))
            
            conn.commit()
            conn.close()
            
            messagebox.showinfo("Sucesso", "Usuário registrado com sucesso")
            self.clear_form()
            self.populate_users_list()
            
        except Exception as e:
            print(f"DEBUG: Erro ao adicionar usuário: {e}")
            messagebox.showerror("Erro", f"Erro ao registrar usuário: {e}")
    
    def edit_user(self):
        """Edita um usuário selecionado"""
        if not self.edit_mode or not self.selected_user_id:
            messagebox.showwarning("Aviso", "Selecione um usuário para editar!")
            return
        
        username = self.username_entry.get().strip()
        password = self.password_entry.get()
        cargo = self.cargo_combo.get().strip()
        role = self.role_combo.get()
        member_selection = self.member_combo.get()
        
        if not username or not cargo or not member_selection:
            messagebox.showerror("Erro", "Usuário, cargo e membro são obrigatórios!")
            return
        
        # Obter o ID do membro selecionado
        member_id = self.member_dict.get(member_selection)
        if not member_id:
            messagebox.showerror("Erro", "Selecione um membro válido!")
            return
        
        # Usar o banco de dados SQLite diretamente
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            # Atualizar usuário
            if password:  # Se senha foi fornecida, atualizar
                cursor.execute("""
                    UPDATE users SET username = ?, password_hash = ?, role = ?, cargo = ?, member_id = ?, updated_at = ?
                    WHERE id = ?
                """, (username, password, role, cargo, member_id, datetime.now(), self.selected_user_id))
            else:  # Se não, manter senha atual
                cursor.execute("""
                    UPDATE users SET username = ?, role = ?, cargo = ?, member_id = ?, updated_at = ?
                    WHERE id = ?
                """, (username, role, cargo, member_id, datetime.now(), self.selected_user_id))
            
            conn.commit()
            conn.close()
            
            messagebox.showinfo("Sucesso", "Usuário atualizado com sucesso")
            self.clear_form()
            self.populate_users_list()
            
        except Exception as e:
            print(f"DEBUG: Erro ao editar usuário: {e}")
            messagebox.showerror("Erro", f"Erro ao atualizar usuário: {e}")
    
    def remove_user(self):
        """Remove um usuário selecionado"""
        if not self.edit_mode or not self.selected_user_id:
            messagebox.showwarning("Aviso", "Selecione um usuário para remover!")
            return
        
        username = self.username_entry.get()
        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover o usuário '{username}'?"):
            # Usar o banco de dados SQLite diretamente
            try:
                import sqlite3
                
                conn = sqlite3.connect('boodesk_new.db')
                cursor = conn.cursor()
                
                # Remover usuário
                cursor.execute("DELETE FROM users WHERE id = ?", (self.selected_user_id,))
                
                conn.commit()
                conn.close()
                
                messagebox.showinfo("Sucesso", "Usuário removido com sucesso")
                self.clear_form()
                self.populate_users_list()
                
            except Exception as e:
                print(f"DEBUG: Erro ao remover usuário: {e}")
                messagebox.showerror("Erro", f"Erro ao remover usuário: {e}")

    def clear_form(self):
        """Limpa o formulário"""
        self.username_entry.delete(0, tk.END)
        self.password_entry.delete(0, tk.END)
        if hasattr(self, 'cargo_combo') and self.cargo_combo['values']:
            self.cargo_combo.set(self.cargo_combo['values'][0])
        self.role_combo.set("user")
        if hasattr(self, 'member_combo') and self.member_combo['values']:
            self.member_combo.set(self.member_combo['values'][0])
        self.edit_mode = False
        self.selected_user_id = None
        self.users_tree.selection_remove(*self.users_tree.selection())


class NumericEntryWithButtons(tk.Frame):
    def __init__(self, parent, icons, initial_value=0.00, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self._value = initial_value # Store as float internally

        self.entry = ttk.Entry(self, width=15, justify='right')
        self.entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.entry.bind("<FocusOut>", self._on_focus_out)
        self.entry.bind("<FocusIn>", self._on_focus_in)
        self.entry.bind("<KeyRelease>", self._on_key_release)

        self.up_button = ttk.Button(self, image=icons.get('up_icon'), width=2, command=self._increment)
        self.up_button.pack(side=tk.LEFT, padx=1)
        self.down_button = ttk.Button(self, image=icons.get('down_icon'), width=2, command=self._decrement)
        self.down_button.pack(side=tk.LEFT, padx=1)

        self._format_display() # Initial display

    def _format_display(self):
        # Formats the internal float value (dot) to display string (comma)
        display_text = f"{self._value:.2f}".replace('.', ',')
        self.entry.delete(0, tk.END)
        self.entry.insert(0, display_text)

    def _on_focus_in(self, event):
        # When focused, convert display string (comma) to internal float string (dot) for editing
        current_text = self.entry.get().replace(',', '.')
        try:
            val = float(current_text)
            self.entry.delete(0, tk.END)
            self.entry.insert(0, str(val)) # Show with dot for editing
        except ValueError:
            self.entry.delete(0, tk.END)
            self.entry.insert(0, "0.00") # Reset if invalid

    def _on_focus_out(self, event):
        # When focus leaves, update internal value from entry and re-apply display format
        self._update_value_from_entry()
        self._format_display()

    def _on_key_release(self, event):
        # Live update of internal value as user types, but don't reformat display yet
        self._update_value_from_entry(live_update=True) # Pass a flag for live update

    def _update_value_from_entry(self, live_update=False):
        current_text = self.entry.get().replace(',', '.')
        try:
            val = float(current_text)
            self._value = val
        except ValueError:
            # If invalid input during live typing, don't change the internal value
            # unless it's on focus out, then reset to 0.00
            if not live_update:
                self._value = 0.00
                self.entry.delete(0, tk.END)
                self.entry.insert(0, "0.00")

    def _increment(self):
        self._update_value_from_entry() # Ensure value is up-to-date
        self._value += 1.00 # Increment by 1.00
        self._format_display()

    def _decrement(self):
        self._update_value_from_entry() # Ensure value is up-to-date
        self._value -= 1.00 # Decrement by 1.00
        self._format_display()

    def get(self):
        self._update_value_from_entry() # Ensure value is up-to-date before returning
        return self._value

    def set(self, new_value):
        self._value = new_value
        self._format_display()

class DatePickerDialog(tk.Toplevel):
    def __init__(self, parent, current_date=None, icons=None):
        super().__init__(parent)
        self.parent = parent
        self.result_date = None
        self.title("Selecionar Data")
        self.transient(parent)
        self.grab_set()

        if icons:
            self.icons = icons # Store the icons dictionary
            

        if current_date:
            try:
                self.current_date = datetime.strptime(current_date, "%Y-%m-%d")
            except ValueError:
                self.current_date = datetime.now()
        else:
            self.current_date = datetime.now()

        self.create_widgets()
        self.update_calendar()

        # Center the dialog
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')

    def create_widgets(self):
        # Navigation Frame
        nav_frame = ttk.Frame(self)
        nav_frame.pack(pady=5)

        ttk.Button(nav_frame, image=self.icons.get('back_icon'), command=self.prev_year).pack(side=tk.LEFT)
        ttk.Button(nav_frame, image=self.icons.get('left_icon'), command=self.prev_month).pack(side=tk.LEFT)
        
        self.month_year_label = ttk.Label(nav_frame, text="", width=20, anchor="center")
        self.month_year_label.pack(side=tk.LEFT, padx=10)

        ttk.Button(nav_frame, image=self.icons.get('right_icon'), command=self.next_month).pack(side=tk.LEFT)
        ttk.Button(nav_frame, image=self.icons.get('forward_icon'), command=self.next_year).pack(side=tk.LEFT)

        # Day Labels (Sun, Mon, etc.)
        days_frame = ttk.Frame(self)
        days_frame.pack()
        for i, day in enumerate(["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"]):
            ttk.Label(days_frame, text=day, width=4, anchor="center").grid(row=0, column=i, padx=1, pady=1)

        # Calendar Grid
        self.calendar_frame = ttk.Frame(self)
        self.calendar_frame.pack()

        # OK/Cancel Buttons
        button_frame = ttk.Frame(self)
        button_frame.pack(pady=5)
        ttk.Button(button_frame, text="OK", image=self.icons.get('ok_icon'), compound=tk.LEFT, command=self.ok).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancelar", image=self.icons.get('cancel_icon'), compound=tk.LEFT, command=self.cancel).pack(side=tk.LEFT, padx=5)

    def update_calendar(self):
        for widget in self.calendar_frame.winfo_children():
            widget.destroy()

        self.month_year_label.config(text=self.current_date.strftime("%B %Y"))

        first_day_of_month = self.current_date.replace(day=1)
        # weekday() returns 0 for Monday, 6 for Sunday. We want 0 for Sunday.
        start_day_offset = (first_day_of_month.weekday() + 1) % 7 

        days_in_month = (self.current_date.replace(month=self.current_date.month % 12 + 1, day=1) - timedelta(days=1)).day

        for day_num in range(1, days_in_month + 1):
            row = (start_day_offset + day_num - 1) // 7
            col = (start_day_offset + day_num - 1) % 7
            
            date_to_check = self.current_date.replace(day=day_num)
            btn = ttk.Button(self.calendar_frame, text=str(day_num), width=4,
                             command=partial(self.select_date, date_to_check))
            btn.grid(row=row, column=col, padx=1, pady=1)

            if date_to_check.date() == datetime.now().date():
                btn.config(style="TButton") # Default style
            elif date_to_check.date() == self.current_date.date(): # Selected month, but not necessarily selected day
                btn.config(style="Accent.TButton") # Highlight current month days

    def prev_month(self):
        self.current_date = self.current_date.replace(day=1) - timedelta(days=1)
        self.update_calendar()

    def next_month(self):
        if self.current_date.month == 12:
            self.current_date = self.current_date.replace(year=self.current_date.year + 1, month=1, day=1)
        else:
            self.current_date = self.current_date.replace(month=self.current_date.month + 1, day=1)
        self.update_calendar()

    def prev_year(self):
        self.current_date = self.current_date.replace(year=self.current_date.year - 1)
        self.update_calendar()

    def next_year(self):
        self.current_date = self.current_date.replace(year=self.current_date.year + 1)
        self.update_calendar()

    def select_date(self, date):
        self.result_date = date
        self.ok()

    def ok(self):
        self.parent.focus_set()
        self.destroy()

    def cancel(self):
        self.result_date = None
        self.parent.focus_set()
        self.destroy()


class SubtaskEditorWindow(tk.Toplevel):
    def __init__(self, parent, app, card, subtask):
        super().__init__(parent)
        self.app = app
        self.card = card
        self.subtask = subtask

        self.title(f"Editar Subtarefa")
        self.transient(parent)
        self.grab_set()
        self.geometry("450x350")

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text=f"Tarefa Principal: {self.card.get('title', '')}").pack(anchor="w")
        ttk.Label(main_frame, text=f"Subtarefa: {self.subtask.get('text', '')}").pack(anchor="w", pady=(0, 10))

        ttk.Label(main_frame, text="Descrição da Subtarefa:").pack(anchor="w", pady=(0, 5))
        self.desc_text = tk.Text(main_frame, wrap=tk.WORD, height=10)
        self.desc_text.pack(fill=tk.BOTH, expand=True)
        self.desc_text.insert("1.0", self.subtask.get("desc", ""))

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))

        ttk.Button(button_frame, text="Salvar", image=self.app.icons.get('save_icon_32'), compound=tk.LEFT, command=self.save_and_close).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", image=self.app.icons.get('cancel_icon_32'), compound=tk.LEFT, command=self.destroy).pack(side=tk.RIGHT)

    def save_and_close(self):
        new_desc = self.desc_text.get("1.0", tk.END).strip()
        self.subtask["desc"] = new_desc
        self.app.save_trello_data()
        if hasattr(self.app, 'activities_tree'):
            self.app.update_my_activities_tab()
        self.app.populate_boards()
        self.destroy()




class ThemeSettingsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Configurar Tema")
        self.geometry("350x150")
        self.transient(parent)
        self.grab_set()

        # Centralizar
        self.update_idletasks()
        x = parent.winfo_x() + (parent.winfo_width() // 2) - (self.winfo_width() // 2)
        y = parent.winfo_y() + (parent.winfo_height() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Escolha um tema para a aplicação:").pack(anchor="w", pady=5)

        # Combobox com temas
        self.theme_var = tk.StringVar()
        self.theme_combo = ttk.Combobox(main_frame, textvariable=self.theme_var, state="readonly")
        
        # Carregar temas disponíveis
        available_themes = sorted(self.app.root.get_themes())
        self.theme_combo['values'] = available_themes
        
        # Definir tema atual
        current_theme = self.app.db.get_setting('theme', default='arc', user_id=self.app.current_user.user_id)
        if current_theme in available_themes:
            self.theme_combo.set(current_theme)
        else:
            self.theme_combo.set('arc')

        self.theme_combo.pack(fill=tk.X, pady=5)

        # Botões
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Salvar", command=self.save_theme).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.destroy).pack(side=tk.RIGHT)

    def save_theme(self):
        selected_theme = self.theme_var.get()
        if not selected_theme:
            messagebox.showwarning("Nenhum Tema", "Por favor, selecione um tema.", parent=self)
            return

        try:
            # Salvar no banco de dados
            self.app.db.save_setting('theme', selected_theme, user_id=self.app.current_user.user_id)
            
            # Aplicar o tema imediatamente
            self.app.root.set_theme(selected_theme)
            
            messagebox.showinfo("Sucesso", f"Tema '{selected_theme}' aplicado com sucesso!", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erro", f"Não foi possível salvar ou aplicar o tema: {e}", parent=self)


class ThemeSettingsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Configurar Tema")
        self.geometry("350x150")
        self.transient(parent)
        self.grab_set()

        # Centralizar
        self.update_idletasks()
        x = parent.winfo_x() + (parent.winfo_width() // 2) - (self.winfo_width() // 2)
        y = parent.winfo_y() + (parent.winfo_height() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Escolha um tema para a aplicação:").pack(anchor="w", pady=5)

        # Combobox com temas
        self.theme_var = tk.StringVar()
        self.theme_combo = ttk.Combobox(main_frame, textvariable=self.theme_var, state="readonly")
        
        # Carregar temas disponíveis
        available_themes = sorted(self.app.root.get_themes())
        self.theme_combo['values'] = available_themes
        
        # Definir tema atual
        current_theme = self.app.db.get_setting('theme', default='arc', user_id=self.app.current_user.user_id)
        if current_theme in available_themes:
            self.theme_combo.set(current_theme)
        else:
            self.theme_combo.set('arc')

        self.theme_combo.pack(fill=tk.X, pady=5)

        # Botões
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Salvar", command=self.save_theme).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.destroy).pack(side=tk.RIGHT)

    def save_theme(self):
        selected_theme = self.theme_var.get()
        if not selected_theme:
            messagebox.showwarning("Nenhum Tema", "Por favor, selecione um tema.", parent=self)
            return

        try:
            # Salvar no banco de dados
            self.app.db.save_setting('theme', selected_theme, user_id=self.app.current_user.user_id)
            
            # Aplicar o tema imediatamente
            self.app.root.set_theme(selected_theme)
            
            messagebox.showinfo("Sucesso", f"Tema '{selected_theme}' aplicado com sucesso!", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erro", f"Não foi possível salvar ou aplicar o tema: {e}", parent=self)


class DraggableTreeview:
    def __init__(self, treeview, app, board_name, list_name):
        self.treeview = treeview
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self.treeview.bind("<ButtonPress-1>", self.on_drag_start)
        self.treeview.bind("<B1-Motion>", self.on_drag_motion)
        self.treeview.bind("<ButtonRelease-1>", self.on_drag_release)
        self._drag_data = {"item": None, "x": 0, "y": 0, "card_id": None, "source_treeview": None}
        self._drag_widget = None

    def on_drag_start(self, event):
        item_id = self.treeview.identify_row(event.y)
        if not item_id or self.treeview.parent(item_id):  # Don't drag child items
            return

        self.treeview.selection_set(item_id)
        self._drag_data["item"] = item_id
        self._drag_data["x"] = event.x
        self._drag_data["y"] = event.y
        self._drag_data["source_treeview"] = self.treeview

        # Get card_id from the tags
        self._drag_data["card_id"] = self.treeview.item(item_id, "tags")[0]

        # Create a temporary drag widget
        x, y, width, height = self.treeview.bbox(item_id)
        display_text = self.treeview.item(item_id, "values")[0] # Get the title
        self._drag_widget = tk.Label(self.treeview, text=display_text, background="lightblue", relief="raised", borderwidth=1)
        self._drag_widget.place(x=x, y=y, width=width, height=height)

    def on_drag_motion(self, event):
        if self._drag_widget:
            x = self.treeview.winfo_x() + event.x - self._drag_data["x"]
            y = self.treeview.winfo_y() + event.y - self._drag_data["y"]
            self._drag_widget.place(x=x, y=y)

    def on_drag_release(self, event):
        if self._drag_widget:
            self._drag_widget.destroy()
            self._drag_widget = None

        if not self._drag_data["item"] or not self._drag_data["card_id"]:
            return

        target_widget = event.widget.winfo_containing(event.x_root, event.y_root)
        
        target_treeview = None
        target_list_name = None
        target_board_name = None

        for (b_name, l_name), tv_widget in self.app.listbox_refs.items(): # listbox_refs now holds treeview refs
            if tv_widget == target_widget:
                target_treeview = tv_widget
                target_list_name = l_name
                target_board_name = b_name
                break

        if target_treeview and target_list_name and target_board_name:
            if target_board_name != self.board_name or target_list_name != self.list_name:
                # Move card data in the backend
                self.app.move_card_data(self.board_name, self.list_name, self._drag_data["card_id"],
                                        target_board_name, target_list_name)
            # If dropped in the same list, no action needed as order is not managed by drag-and-drop yet
        
        self._drag_data = {"item": None, "x": 0, "y": 0, "card_id": None, "source_treeview": None}

class TrelloApp:
    def load_and_apply_user_theme(self):
        """Carrega e aplica o tema do usuário a partir do banco de dados."""
        if self.current_user and self.current_user.user_id:
            # Usar 'arc' como tema padrão se nenhum for encontrado
            theme = self.db.get_setting('theme', default='arc', user_id=self.current_user.user_id)
            try:
                self.root.set_theme(theme)
            except Exception as e:
                print(f"Erro ao aplicar o tema '{theme}': {e}")
                # Se o tema salvo for inválido, aplicar o padrão
                try:
                    self.root.set_theme("arc")
                except Exception as e_arc:
                    print(f"Erro ao aplicar o tema padrão 'arc': {e_arc}")

    def open_theme_settings(self):
        ThemeSettingsWindow(self.root, self)

    def __init__(self, root):
        self.root = root
        self.db = Database('boodesk_new.db')
        self.db.create_tables()
        self.current_user = None
        self.login_successful = False
        self.boodesk_data = {'boards': {}}
        self.icons = load_app_icons(os.path.dirname(os.path.abspath(__file__)))
        self.listbox_refs = {}
        self.theme_color = "#0079BF"
        self.pomodoro_timer = None
        self.pomodoro_running = False
        self.pomodoro_start_time = None
        self.pomodoro_session_type = "work" # "work" or "break"
        self.pomodoro_work_duration = 25 * 60
        self.pomodoro_break_duration = 5 * 60
        self.pomodoro_task = None
        self.notification_manager = NotificationManager(self)
        self.meeting_integration = GoogleCalendarManager()
        self.email_integration = EmailIntegration(self)
        self.settings = self.load_settings()
        
        self.root.title("Boodesk - Sistema de Gerenciamento de Tarefas")
        self.root.geometry("1200x800")
        
        self.show_login_window()
        
        if self.login_successful:
            self.load_and_apply_user_theme()
            self.load_and_apply_user_theme()
            self.create_main_widgets()
            self.load_trello_data()
            self.populate_boards()
            self.notification_manager.start_notification_monitor()
            self.email_integration.start_email_service()
        else:
            self.root.destroy()


    # Removed load_data_from_db method - now using load_trello_data which loads from SQL

    def add_card(self, board_name, list_name, card_title, card_desc, card_due_date, card_importance, subject="-", goal="-", members=None, git_branch="", git_commit="", recurrence="Nenhuma", dependencies=None):
        """Add card directly to SQL database"""
        try:
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Get or create board
            board_id = self.get_board_id_by_name(board_name)
            if not board_id:
                board_id = self.db.create_board(board_name, owner_id=user_id)
            
            # Create card in database
            card_id = self.db.create_card(
                board_id=board_id,
                list_name=list_name,
                title=card_title,
                description=card_desc,
                status='to_do',
                importance=card_importance,
                due_date=card_due_date,
                subject=subject,
                goal=goal,
                members=members or [],
                git_branch=git_branch,
                git_commit=git_commit,
                recurrence=recurrence,
                dependencies=dependencies or [],
                user_id=user_id
            )
            
            # Reload data from database
            self.load_trello_data()
            self.populate_boards()
            return card_id
        except Exception as e:
            print(f"Erro ao adicionar cartão: {e}")
            messagebox.showerror("Erro", f"Não foi possível adicionar o cartão: {e}")
            return None

    def update_card_data(self, card_id, title, desc, due_date, importance, subject=None, goal=None, members=None, git_branch=None, git_commit=None, recurrence=None, dependencies=None):
        """Update card directly in SQL database"""
        try:
            self.db.update_card(
                card_id=card_id,
                title=title,
                description=desc,
                status='to_do',
                importance=importance,
                due_date=due_date,
                subject=subject,
                goal=goal,
                members=members,
                git_branch=git_branch,
                git_commit=git_commit,
                recurrence=recurrence,
                dependencies=dependencies
            )
            # Reload data from database
            self.load_trello_data()
            self.populate_boards()
        except Exception as e:
            print(f"Erro ao atualizar cartão: {e}")
            messagebox.showerror("Erro", f"Não foi possível atualizar o cartão: {e}")

    def move_card_data(self, source_board_name, source_list_name, card_id, target_board_name, target_list_name):
        """Move card directly in SQL database"""
        try:
            target_board_id = self.get_board_id_by_name(target_board_name)
            if target_board_id:
                self.db.move_card(card_id, target_board_id, target_list_name)
                # Reload data from database
                self.load_trello_data()
                self.populate_boards()
            else:
                print(f"Board '{target_board_name}' não encontrado")
        except Exception as e:
            print(f"Erro ao mover cartão: {e}")
            messagebox.showerror("Erro", f"Não foi possível mover o cartão: {e}")

    def delete_card(self, board_name, list_name, card_id):
        """Delete card directly from SQL database"""
        try:
            self.db.delete_card(card_id)
            # Reload data from database
            self.load_trello_data()
            self.populate_boards()
        except Exception as e:
            print(f"Erro ao deletar cartão: {e}")
            messagebox.showerror("Erro", f"Não foi possível deletar o cartão: {e}")



    def send_weekly_report(self):
        """Envia relatório semanal por email"""
        try:
            report_data = self._generate_weekly_report()
            
            subject = f"Relatório Semanal - {report_data['week_period']}"
            body = f"""
Resumo Geral:
- Total de cartões: {report_data['total_cards']}
- Cartões criados: {report_data['cards_created']}
- Cartões concluídos: {report_data['cards_completed']}
- Cartões em atraso: {report_data['overdue_cards']}

Produtividade:
- Taxa de conclusão: {report_data['completion_rate']}%
- Tempo médio de conclusão: {report_data['avg_completion_time']} dias

Cartões Mais Importantes:
{report_data['top_important_cards']}

Próximos Prazos:
{report_data['upcoming_deadlines']}

---
Boodesk - Sistema de Gerenciamento de Tarefas
"""
            body = body.strip()
            
            recipients = self.settings.get('notification_recipients', [])
            for recipient in recipients:
                self.send_email(recipient, subject, body)
                
        except Exception as e:
            print(f"Erro ao enviar relatório semanal: {e}")
    
    def _generate_weekly_report(self):
        """Gera dados para o relatório semanal"""
        try:
            now = datetime.now()
            week_start = now - timedelta(days=7)
            
            total_cards = 0
            cards_created = 0
            cards_completed = 0
            overdue_cards = 0
            important_cards = []
            upcoming_deadlines = []
            
            for board_name, board_data in self.app.boodesk_data.get('boards', {}).items():
                for list_name, cards in board_data.items():
                    if list_name != 'workflow':
                        total_cards += len(cards)
                        
                        for card in cards:
                            # Cartões criados na semana
                            creation_date = card.get('creation_date', '')
                            if creation_date:
                                try:
                                    card_creation = datetime.strptime(creation_date, '%Y-%m-%d %H:%M:%S')
                                    if card_creation >= week_start:
                                        cards_created += 1
                                except ValueError:
                                    pass
                            
                            # Cartões concluídos
                            if list_name == 'Concluído':
                                cards_completed += 1
                            
                            # Cartões em atraso
                            due_date_str = card.get('due_date', '')
                            if due_date_str:
                                try:
                                    due_date = datetime.strptime(due_date_str, '%Y-%m-%d %H:%M')
                                    if due_date < now and list_name != 'Concluído':
                                        overdue_cards += 1
                                except ValueError:
                                    pass
                            
                            # Cartões importantes
                            if card.get('importance') in ['Alta', 'Crítica']:
                                important_cards.append(card.get('title', ''))
                            
                            # Próximos prazos
                            if due_date_str:
                                try:
                                    due_date = datetime.strptime(due_date_str, '%Y-%m-%d %H:%M')
                                    if due_date > now and due_date <= now + timedelta(days=7):
                                        upcoming_deadlines.append(f"{card.get('title', '')} - {due_date_str}")
                                except ValueError:
                                    pass
            
            completion_rate = (cards_completed / total_cards * 100) if total_cards > 0 else 0
            
            return {
                'week_period': f"{week_start.strftime('%d/%m')} - {now.strftime('%d/%m/%Y')}",
                'total_cards': total_cards,
                'cards_created': cards_created,
                'cards_completed': cards_completed,
                'overdue_cards': overdue_cards,
                'completion_rate': round(completion_rate, 1),
                'avg_completion_time': '3.5',  # Placeholder
                'top_important_cards': '\n'.join(important_cards[:5]),
                'upcoming_deadlines': '\n'.join(upcoming_deadlines[:5])
            }
            
        except Exception as e:
            print(f"Erro ao gerar relatório semanal: {e}")
            return {}


class GoogleCalendarIntegration:
    """Integração com Google Calendar para sincronização de eventos"""
    
    SCOPES = ['https://www.googleapis.com/auth/calendar']
    
    def __init__(self, app):
        self.app = app
        self.service = None
        self.credentials = None
        self.calendar_id = 'primary'
        self.token_file = os.path.join(self.app.base_dir, 'google_calendar_token.pickle')
        self.credentials_file = os.path.join(self.app.base_dir, 'google_calendar_credentials.json')
        self.is_authenticated = False
        
    def authenticate(self):
        """Autentica com Google Calendar API"""
        try:
            # Verificar se as bibliotecas estão disponíveis
            try:
                from google.auth.transport.requests import Request
                from google_auth_oauthlib.flow import InstalledAppFlow
                from googleapiclient.discovery import build
                from googleapiclient.errors import HttpError
                import pickle
            except ImportError as e:
                print(f"❌ Bibliotecas do Google Calendar não disponíveis: {e}")
                messagebox.showerror("Erro", 
                                   f"Bibliotecas do Google Calendar não estão instaladas.\n\n"
                                   f"Execute: pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
                return False
            
            # Verificar se há credenciais configuradas
            calendar_settings = self.app.settings.get('calendar_integration', {})
            
            if calendar_settings.get('auth_type') == 'json':
                # Usar arquivo JSON
                credentials_file = calendar_settings.get('credentials_file', '')
                if not credentials_file or not os.path.exists(credentials_file):
                    messagebox.showwarning(
                        "Configuração Necessária",
                        "Arquivo de credenciais do Google Calendar não encontrado.\n"
                        "Por favor, configure as credenciais nas configurações."
                    )
                    return False
                
                self.credentials_file = credentials_file
                
            elif calendar_settings.get('auth_type') == 'key':
                # Usar ID e chave privada
                client_id = calendar_settings.get('client_id', '').strip()
                client_secret = calendar_settings.get('client_secret', '').strip()
                
                if not client_id or not client_secret:
                    messagebox.showwarning(
                        "Configuração Necessária",
                        "Client ID e Client Secret do Google Calendar não configurados.\n"
                        "Por favor, configure as credenciais nas configurações."
                    )
                    return False
                
                # Criar arquivo temporário de credenciais
                temp_creds = {
                    "installed": {
                        "client_id": client_id,
                        "client_secret": client_secret,
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "token_uri": "https://oauth2.googleapis.com/token",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "redirect_uris": ["http://localhost"]
                    }
                }
                
                import tempfile
                import json
                
                with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                    json.dump(temp_creds, f)
                    self.credentials_file = f.name
            else:
                messagebox.showwarning(
                    "Configuração Necessária",
                    "Tipo de autenticação do Google Calendar não configurado.\n"
                    "Por favor, configure as credenciais nas configurações."
                )
                return False
            
            # Tentar carregar token existente
            if os.path.exists(self.token_file):
                try:
                    with open(self.token_file, 'rb') as token:
                        self.credentials = pickle.load(token)
                except Exception as e:
                    print(f"Erro ao carregar token: {e}")
                    self.credentials = None
            
            # Verificar se as credenciais são válidas
            if not self.credentials or not self.credentials.valid:
                if self.credentials and self.credentials.expired and self.credentials.refresh_token:
                    try:
                        self.credentials.refresh(Request())
                    except Exception as e:
                        print(f"Erro ao renovar token: {e}")
                        self.credentials = None
                
                # Se ainda não há credenciais válidas, fazer nova autenticação
                if not self.credentials:
                    try:
                        flow = InstalledAppFlow.from_client_secrets_file(
                            self.credentials_file, self.SCOPES)
                        self.credentials = flow.run_local_server(port=0)
                        
                        # Salvar token
                        with open(self.token_file, 'wb') as token:
                            pickle.dump(self.credentials, token)
                            
                    except Exception as e:
                        print(f"Erro na autenticação OAuth: {e}")
                        messagebox.showerror("Erro", f"Erro na autenticação OAuth:\n{e}")
                        return False
            
            # Criar serviço
            self.service = build('calendar', 'v3', credentials=self.credentials)
            self.is_authenticated = True
            
            print("✅ Autenticação com Google Calendar bem-sucedida!")
            return True
            
        except Exception as e:
            print(f"❌ Erro na autenticação do Google Calendar: {e}")
            messagebox.showerror("Erro", f"Erro na autenticação do Google Calendar:\n{e}")
            return False
    
    def create_event(self, title, description, start_datetime, duration=None, card_id=None, attendees=None):
        """Cria um evento no Google Calendar"""
        try:
            if not self.service:
                if not self.authenticate():
                    return False
            
            # Calcular horário de fim
            if duration:
                end_datetime = start_datetime + duration
            else:
                end_datetime = start_datetime + timedelta(hours=1)
            
            # Preparar evento
            event = {
                'summary': title,
                'description': description,
                'start': {
                    'dateTime': start_datetime.isoformat(),
                    'timeZone': 'America/Sao_Paulo',
                },
                'end': {
                    'dateTime': end_datetime.isoformat(),
                    'timeZone': 'America/Sao_Paulo',
                },
                'reminders': {
                    'useDefault': False,
                    'overrides': [
                        {'method': 'popup', 'minutes': 30},
                        {'method': 'email', 'minutes': 60},
                    ],
                },
            }
            
            # Adicionar card_id como metadados se fornecido
            if card_id:
                event['extendedProperties'] = {
                    'private': {
                        'card_id': card_id,
                        'source': 'boodesk_app'
                    }
                }
            
            if attendees:
                event['attendees'] = [{'email': email} for email in attendees]
            
            # Criar evento
            created_event = self.service.events().insert(
                calendarId=self.calendar_id, body=event).execute()
            
            print(f'✅ Evento criado no Google Calendar: {created_event.get("htmlLink")}')
            return True
            
        except Exception as error:
            print(f'❌ Erro ao criar evento no Google Calendar: {error}')
            return False
    
    def sync_card_to_calendar(self, card_data, board_name, list_name):
        """Sincroniza um cartão para o Google Calendar"""
        try:
            if not card_data.get('due_date'):
                return False
            
            # Parse da data de vencimento
            due_date_str = card_data['due_date']
            if ' ' in due_date_str:
                due_date_str = due_date_str.split(' ')[0]
            
            due_date = datetime.strptime(due_date_str, "%Y-%m-%d")
            
            # Criar evento de 1 hora
            start_time = due_date.replace(hour=9, minute=0, second=0, microsecond=0)
            end_time = start_time + timedelta(hours=1)
            
            title = f"[{board_name}] {card_data['title']}"
            description = f"""
Tarefa: {card_data['title']}
Quadro: {board_name}
Lista: {list_name}
Descrição: {card_data.get('description', 'N/A')}
Responsável: {', '.join(card_data.get('members', []))}
Importância: {card_data.get('importance', 'Normal')}
            """.strip()
            
            return self.create_event(title, description, start_time, end_time)
            
        except Exception as e:
            print(f"Erro ao sincronizar cartão com calendário: {e}")
            return False
    
    def get_upcoming_events(self, days=7):
        """Obtém eventos próximos do Google Calendar"""
        try:
            if not self.service:
                if not self.authenticate():
                    return []
            
            # Usar formato RFC3339 para datas
            now = datetime.now(timezone.utc)
            end_date = now + timedelta(days=days)
            
            # Formatar datas no formato correto para Google Calendar API
            time_min = now.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
            time_max = end_date.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
            
            events_result = self.service.events().list(
                calendarId=self.calendar_id,
                timeMin=time_min,
                timeMax=time_max,
                singleEvents=True,
                orderBy='startTime'
            ).execute()
            
            events = events_result.get('items', [])
            return events
            
        except Exception as e:
            print(f"Erro ao obter eventos do Google Calendar: {e}")
            return []


class EmailTemplateManager:
    """Gerenciador de templates de email personalizáveis"""
    
    def __init__(self, app):
        self.app = app
        self.templates_file = os.path.join(self.app.base_dir, 'email_templates.json')
        self.templates = self.load_templates()
        
    def load_templates(self):
        """Carrega templates de email do arquivo"""
        try:
            if os.path.exists(self.templates_file):
                with open(self.templates_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                # Templates padrão
                default_templates = {
                    "card_created": {
                        "subject": "Nova Tarefa Criada: {card_title}",
                        "body": """
Olá {member_name},

Uma nova tarefa foi criada e você foi designado como responsável:

**Tarefa:** {card_title}
**Quadro:** {board_name}
**Lista:** {list_name}
**Descrição:** {card_description}
**Prazo:** {due_date}
**Importância:** {importance}

Acesse o sistema para mais detalhes.

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    },
                    "card_modified": {
                        "subject": "Tarefa Atualizada: {card_title}",
                        "body": """
Olá {member_name},

A tarefa "{card_title}" foi atualizada:

**Alterações:**
{changes}

**Detalhes Atuais:**
- Quadro: {board_name}
- Lista: {list_name}
- Prazo: {due_date}
- Importância: {importance}

Acesse o sistema para mais detalhes.

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    },
                    "deadline_reminder": {
                        "subject": "Lembrete de Prazo: {card_title}",
                        "body": """
Olá {member_name},

Este é um lembrete sobre a tarefa que vence em breve:

**Tarefa:** {card_title}
**Quadro:** {board_name}
**Lista:** {list_name}
**Prazo:** {due_date}
**Importância:** {importance}

Por favor, verifique o status desta tarefa.

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    },
                    "weekly_report": {
                        "subject": "Relatório Semanal - {week_period}",
                        "body": """
Olá {member_name},

Aqui está seu relatório semanal de produtividade:

**Resumo da Semana:**
- Tarefas Concluídas: {completed_tasks}
- Tarefas Pendentes: {pending_tasks}
- Tempo Total Pomodoro: {total_pomodoro_time}
- Produtividade: {productivity_score}%

**Tarefas Importantes Concluídas:**
{important_completed_tasks}

**Próximos Prazos:**
{upcoming_deadlines}

Continue assim!

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    }
                }
                self.save_templates(default_templates)
                return default_templates
        except Exception as e:
            print(f"Erro ao carregar templates de email: {e}")
            return {}
    
    def save_templates(self, templates=None):
        """Salva templates de email no arquivo"""
        try:
            if templates is None:
                templates = self.templates
            
            with open(self.templates_file, 'w', encoding='utf-8') as f:
                json.dump(templates, f, indent=2, ensure_ascii=False)
            
            self.templates = templates
            
        except Exception as e:
            print(f"Erro ao salvar templates de email: {e}")
    
    def get_template(self, template_name):
        """Obtém um template específico"""
        return self.templates.get(template_name, {})
    
    def update_template(self, template_name, subject, body):
        """Atualiza um template"""
        self.templates[template_name] = {
            "subject": subject,
            "body": body
        }
        self.save_templates()
    
    def format_template(self, template_name, variables):
        """Formata um template com variáveis"""
        template = self.get_template(template_name)
        if not template:
            return "", ""
        
        subject = template.get("subject", "")
        body = template.get("body", "")
        
        # Substituir variáveis
        for key, value in variables.items():
            placeholder = "{" + key + "}"
            subject = subject.replace(placeholder, str(value))
            body = body.replace(placeholder, str(value))
        
        return subject, body
    
    def get_available_templates(self):
        """Retorna lista de templates disponíveis"""
        return list(self.templates.keys())


class CalendarEventWindow(tk.Toplevel):
    """Janela para criar/editar eventos do calendário"""
    
    def __init__(self, parent, date_str, event_data=None):
        super().__init__(parent)
        self.parent = parent
        self.date_str = date_str
        self.event_data = event_data
        
        self.title("Novo Evento" if not event_data else "Editar Evento")
        self.geometry("500x400")
        self.transient(parent)
        self.grab_set()
        
        self.create_widgets()
        
    def create_widgets(self):
        """Cria os widgets da janela"""
        main_frame = ttk.Frame(self, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        ttk.Label(main_frame, text="Título:").grid(row=0, column=0, sticky="w", pady=5)
        self.title_var = tk.StringVar(value=self.event_data.get('title', '') if self.event_data else '')
        self.title_entry = ttk.Entry(main_frame, textvariable=self.title_var, width=50)
        self.title_entry.grid(row=0, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        
        # Data
        ttk.Label(main_frame, text="Data:").grid(row=1, column=0, sticky="w", pady=5)
        self.date_var = tk.StringVar(value=self.date_str)
        self.date_entry = ttk.Entry(main_frame, textvariable=self.date_var, width=15)
        self.date_entry.grid(row=1, column=1, sticky="w", pady=5, padx=(10, 0))
        ttk.Button(main_frame, text="📅", command=self.open_date_picker).grid(row=1, column=2, sticky="w", padx=5)
        
        # Hora de início
        ttk.Label(main_frame, text="Hora de Início:").grid(row=2, column=0, sticky="w", pady=5)
        self.start_time_var = tk.StringVar(value=self.event_data.get('start_time', '09:00') if self.event_data else '09:00')
        self.start_time_entry = ttk.Entry(main_frame, textvariable=self.start_time_var, width=10)
        self.start_time_entry.grid(row=2, column=1, sticky="w", pady=5, padx=(10, 0))
        
        # Hora de fim
        ttk.Label(main_frame, text="Hora de Fim:").grid(row=3, column=0, sticky="w", pady=5)
        self.end_time_var = tk.StringVar(value=self.event_data.get('end_time', '10:00') if self.event_data else '10:00')
        self.end_time_entry = ttk.Entry(main_frame, textvariable=self.end_time_var, width=10)
        self.end_time_entry.grid(row=3, column=1, sticky="w", pady=5, padx=(10, 0))
        
        # Descrição
        ttk.Label(main_frame, text="Descrição:").grid(row=4, column=0, sticky="nw", pady=5)
        self.description_text = tk.Text(main_frame, height=8, width=50)
        self.description_text.grid(row=4, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        if self.event_data and self.event_data.get('description'):
            self.description_text.insert("1.0", self.event_data['description'])
        
        # Local
        ttk.Label(main_frame, text="Local:").grid(row=5, column=0, sticky="w", pady=5)
        self.location_var = tk.StringVar(value=self.event_data.get('location', '') if self.event_data else '')
        self.location_entry = ttk.Entry(main_frame, textvariable=self.location_var, width=50)
        self.location_entry.grid(row=5, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        
        # Participantes
        ttk.Label(main_frame, text="Participantes:").grid(row=6, column=0, sticky="w", pady=5)
        self.attendees_var = tk.StringVar(value=self.event_data.get('attendees', '') if self.event_data else '')
        self.attendees_entry = ttk.Entry(main_frame, textvariable=self.attendees_var, width=50)
        self.attendees_entry.grid(row=6, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        ttk.Label(main_frame, text="(emails separados por vírgula)").grid(row=6, column=3, sticky="w", pady=5)
        
        # Sincronizar com Google Calendar
        self.sync_google_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(main_frame, text="Sincronizar com Google Calendar", 
                       variable=self.sync_google_var).grid(row=7, column=0, columnspan=3, sticky="w", pady=10)
        
        # Botões
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=8, column=0, columnspan=3, pady=20)
        
        ttk.Button(button_frame, text="Salvar", command=self.save_event).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.destroy).pack(side=tk.LEFT, padx=5)
        
        # Configurar grid
        main_frame.columnconfigure(1, weight=1)
        
    def open_date_picker(self):
        """Abre o seletor de data"""
        try:
            current_date = datetime.strptime(self.date_var.get(), "%Y-%m-%d")
            date_picker = DatePickerDialog(self, current_date)
            if date_picker.result:
                self.date_var.set(date_picker.result.strftime("%Y-%m-%d"))
        except ValueError:
            date_picker = DatePickerDialog(self)
            if date_picker.result:
                self.date_var.set(date_picker.result.strftime("%Y-%m-%d"))
    
    def save_event(self):
        """Salva o evento"""
        try:
            # Validar campos obrigatórios
            title = self.title_var.get().strip()
            if not title:
                messagebox.showwarning("Aviso", "O título é obrigatório!")
                return
            
            # Validar formato de data
            try:
                event_date = datetime.strptime(self.date_var.get(), "%Y-%m-%d")
            except ValueError:
                messagebox.showwarning("Aviso", "Data inválida!")
                return
            
            # Validar formato de hora
            try:
                start_time = datetime.strptime(self.start_time_var.get(), "%H:%M")
                end_time = datetime.strptime(self.end_time_var.get(), "%H:%M")
            except ValueError:
                messagebox.showwarning("Aviso", "Formato de hora inválido! Use HH:MM")
                return
            
            # Criar dados do evento
            event_data = {
                'title': title,
                'date': self.date_var.get(),
                'start_time': self.start_time_var.get(),
                'end_time': self.end_time_var.get(),
                'description': self.description_text.get("1.0", tk.END).strip(),
                'location': self.location_var.get().strip(),
                'attendees': [email.strip() for email in self.attendees_var.get().split(',') if email.strip()],
                'sync_google': self.sync_google_var.get()
            }
            
            # Salvar no Google Calendar se solicitado
            if event_data['sync_google'] and self.parent.calendar_status_var.get() == "Conectado":
                start_datetime = datetime.combine(event_date, start_time.time())
                end_datetime = datetime.combine(event_date, end_time.time())
                
                success = self.parent.google_calendar.create_event(
                    title=event_data['title'],
                    description=event_data['description'],
                    start_time=start_datetime,
                    end_time=end_datetime,
                    attendees=event_data['attendees'] if event_data['attendees'] else None
                )
                
                if success:
                    messagebox.showinfo("Sucesso", "Evento criado no Google Calendar!")
                else:
                    messagebox.showwarning("Aviso", "Erro ao criar evento no Google Calendar!")
            
            # Salvar localmente (implementar se necessário)
            # self.parent.save_local_event(event_data)
            
            messagebox.showinfo("Sucesso", "Evento salvo com sucesso!")
            self.destroy()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar evento:\n{e}")


# Sistema de Integração com Reuniões (Zoom/Teams)
class MeetingIntegration:
    """Sistema de integração com plataformas de reunião"""
    
    def __init__(self, app):
        self.app = app
        self.meeting_data = {}  # Dados de reuniões
        self.load_meeting_data()
    
    def load_meeting_data(self):
        """Carrega dados de reuniões salvos"""
        try:
            if os.path.exists('meeting_data.json'):
                with open('meeting_data.json', 'r', encoding='utf-8') as f:
                    self.meeting_data = json.load(f)
        except Exception as e:
            print(f"Erro ao carregar dados de reuniões: {e}")
            self.meeting_data = {}
    
    def save_meeting_data(self):
        """Salva dados de reuniões"""
        try:
            with open('meeting_data.json', 'w', encoding='utf-8') as f:
                json.dump(self.meeting_data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erro ao salvar dados de reuniões: {e}")
    
    def create_zoom_meeting(self, title, date, time_str, duration=60, password=None):
        """Cria link de reunião do Zoom"""
        # Gerar ID de reunião único (formato Zoom: 10 dígitos)
        meeting_id = ''.join(random.choices('0123456789', k=10))
        
        # Gerar senha se não fornecida (formato Zoom: 6 dígitos)
        if not password:
            password = ''.join(random.choices('0123456789', k=6))
        
        # Criar link do Zoom (formato padrão)
        zoom_link = f"https://zoom.us/j/{meeting_id}?pwd={password}"
        
        meeting_info = {
            'id': meeting_id,
            'title': title,
            'date': date,
            'time': time_str,
            'duration': duration,
            'password': password,
            'link': zoom_link,
            'platform': 'zoom',
            'created_by': getattr(self.app.current_user, 'username', 'Sistema') if hasattr(self.app, 'current_user') and self.app.current_user else 'Sistema',
            'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'status': 'scheduled'
        }
        
        self.meeting_data[meeting_id] = meeting_info
        self.save_meeting_data()
        
        return meeting_info
    
    def create_teams_meeting(self, title, date, time_str, duration=60):
        """Cria link de reunião do Teams"""
        # Gerar ID de reunião único (formato Teams: GUID)
        import uuid
        meeting_id = str(uuid.uuid4())
        
        # Criar link do Teams (formato padrão)
        teams_link = f"https://teams.microsoft.com/l/meetup-join/{meeting_id}"
        
        meeting_info = {
            'id': meeting_id,
            'title': title,
            'date': date,
            'time': time_str,
            'duration': duration,
            'link': teams_link,
            'platform': 'teams',
            'created_by': getattr(self.app.current_user, 'username', 'Sistema') if hasattr(self.app, 'current_user') and self.app.current_user else 'Sistema',
            'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'status': 'scheduled'
        }
        
        self.meeting_data[meeting_id] = meeting_info
        self.save_meeting_data()
        
        return meeting_info
    
    def create_google_meet_meeting(self, title, date, time_str, duration=60):
        """Cria link de reunião do Google Meet usando API real"""
        # Usar o Google Calendar Manager para criar reunião real
        if not hasattr(self.app, 'google_calendar_manager'):
            self.app.google_calendar_manager = GoogleCalendarManager()
        
        meeting_info = self.app.google_calendar_manager.create_meeting(
            title, date, time_str, duration
        )
        
        if meeting_info:
            # Salvar no sistema local
            self.meeting_data[meeting_info['id']] = meeting_info
            self.save_meeting_data()
            return meeting_info
        else:
            # Fallback para link simulado se API falhar
            import string
            chars = string.ascii_lowercase + string.digits
            part1 = ''.join(random.choices(chars, k=3))
            part2 = ''.join(random.choices(chars, k=4))
            part3 = ''.join(random.choices(chars, k=3))
            meeting_id = f"{part1}-{part2}-{part3}"
            
            meet_link = f"https://meet.google.com/{meeting_id}"
            
            meeting_info = {
                'id': meeting_id,
                'title': title,
                'date': date,
                'time': time_str,
                'duration': duration,
                'link': meet_link,
                'platform': 'google_meet',
                'created_by': getattr(self.app.current_user, 'username', 'Sistema') if hasattr(self.app, 'current_user') and self.app.current_user else 'Sistema',
                'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'status': 'scheduled'
            }
            
            self.meeting_data[meeting_id] = meeting_info
            self.save_meeting_data()
            
            return meeting_info
    
    def get_meetings_by_project(self, project_name):
        """Retorna reuniões de um projeto específico"""
        return [meeting for meeting in self.meeting_data.values() 
                if meeting.get('project') == project_name]
    
    def get_upcoming_meetings(self):
        """Retorna próximas reuniões"""
        upcoming = []
        current_time = datetime.now()
        
        for meeting in self.meeting_data.values():
            try:
                meeting_datetime = datetime.strptime(f"{meeting['date']} {meeting['time']}", "%Y-%m-%d %H:%M")
                if meeting_datetime > current_time:
                    upcoming.append(meeting)
            except:
                continue
        
        return sorted(upcoming, key=lambda x: f"{x['date']} {x['time']}")


class MeetingWindow:
    """Janela para criar e gerenciar reuniões"""
    
    def __init__(self, parent, app, project_name=None):
        self.parent = parent
        self.app = app
        self.project_name = project_name
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title("Criar Reunião")
        self.window.geometry("500x600")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Criar interface
        self.create_widgets()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        title_text = "Criar Reunião"
        if self.project_name:
            title_text += f" - {self.project_name}"
        
        ttk.Label(title_frame, text=title_text, 
                 font=("Arial", 14, "bold")).pack(side=tk.LEFT)
        
        # Frame para formulário
        form_frame = ttk.LabelFrame(main_frame, text="Detalhes da Reunião", padding="10")
        form_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Título da reunião
        ttk.Label(form_frame, text="Título:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.title_var = tk.StringVar()
        self.title_entry = ttk.Entry(form_frame, textvariable=self.title_var, width=40)
        self.title_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        
        # Data
        ttk.Label(form_frame, text="Data:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.date_var = tk.StringVar()
        self.date_entry = ttk.Entry(form_frame, textvariable=self.date_var, width=20)
        self.date_entry.grid(row=1, column=1, sticky="w", padx=5, pady=2)
        self.date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        
        # Hora
        ttk.Label(form_frame, text="Hora:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        self.time_var = tk.StringVar()
        self.time_entry = ttk.Entry(form_frame, textvariable=self.time_var, width=10)
        self.time_entry.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        self.time_entry.insert(0, "09:00")
        
        # Duração
        ttk.Label(form_frame, text="Duração (min):").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.duration_var = tk.StringVar(value="60")
        self.duration_entry = ttk.Entry(form_frame, textvariable=self.duration_var, width=10)
        self.duration_entry.grid(row=3, column=1, sticky="w", padx=5, pady=2)
        
        # Plataforma
        ttk.Label(form_frame, text="Plataforma:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.platform_var = tk.StringVar(value="zoom")
        
        # Verificar se Google Meet está disponível
        google_meet_available = os.path.exists(CREDENTIALS_FILE)
        platform_values = ["zoom", "teams"]
        if google_meet_available:
            platform_values.append("google_meet")
        
        platform_combo = ttk.Combobox(form_frame, textvariable=self.platform_var, 
                                     values=platform_values, state="readonly", width=15)
        platform_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)
        
        # Mostrar status do Google Meet
        if not google_meet_available:
            status_label = ttk.Label(form_frame, text="⚠️ Google Meet: Configure credentials.json", 
                                   foreground="orange", font=("Arial", 8))
            status_label.grid(row=4, column=2, sticky="w", padx=5, pady=2)
        else:
            status_label = ttk.Label(form_frame, text="✅ Google Meet: Disponível", 
                                   foreground="green", font=("Arial", 8))
            status_label.grid(row=4, column=2, sticky="w", padx=5, pady=2)
        
        # Senha (apenas para Zoom)
        self.password_frame = ttk.Frame(form_frame)
        self.password_frame.grid(row=5, column=0, columnspan=2, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.password_frame, text="Senha (opcional):").pack(side=tk.LEFT)
        self.password_var = tk.StringVar()
        self.password_entry = ttk.Entry(self.password_frame, textvariable=self.password_var, width=15)
        self.password_entry.pack(side=tk.LEFT, padx=(5, 0))
        
        # Configurar grid
        form_frame.columnconfigure(1, weight=1)
        
        # Botões
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(buttons_frame, text="Criar Reunião", image=self.icons.get('add_icon'), compound=tk.LEFT,
                  command=self.create_meeting).pack(side=tk.LEFT, padx=(0, 5))
        
        # Botão para configurar Google Meet se não estiver disponível
        if not google_meet_available:
            ttk.Button(buttons_frame, text="Configurar Google Meet", image=self.icons.get('settings_icon'), compound=tk.LEFT,
                      command=self.show_google_setup).pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(buttons_frame, text="Cancelar", image=self.icons.get('cancel_icon'), compound=tk.LEFT,
                  command=self.window.destroy).pack(side=tk.RIGHT)
        
        # Frame para reuniões existentes
        meetings_frame = ttk.LabelFrame(main_frame, text="Reuniões Agendadas", padding="10")
        meetings_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para reuniões
        columns = ("Data", "Hora", "Título", "Plataforma", "Criado por")
        self.meetings_tree = ttk.Treeview(meetings_frame, columns=columns, show="headings", height=10)
        
        for col in columns:
            self.meetings_tree.heading(col, text=col)
            self.meetings_tree.column(col, width=100, anchor="w")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(meetings_frame, orient="vertical", command=self.meetings_tree.yview)
        self.meetings_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.meetings_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Botões de ação para reuniões
        action_frame = ttk.Frame(main_frame)
        action_frame.pack(fill=tk.X)
        
        ttk.Button(action_frame, text="Copiar Link", image=self.icons.get('copy_icon'), compound=tk.LEFT,
                  command=self.copy_meeting_link).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(action_frame, text="Excluir", image=self.icons.get('delete_icon'), compound=tk.LEFT,
                  command=self.delete_meeting).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(action_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.load_meetings).pack(side=tk.LEFT)
        
        # Carregar reuniões existentes
        self.load_meetings()
        
        # Focar no título
        self.title_entry.focus()
    
    def show_google_setup(self):
        """Mostra instruções para configurar Google Meet"""
        setup_text = """
Para usar o Google Meet com links reais, você precisa configurar a API do Google:

1. Acesse: https://console.cloud.google.com
2. Crie um projeto e ative a Google Calendar API
3. Crie credenciais OAuth 2.0
4. Baixe o arquivo como 'credentials.json'
5. Coloque na pasta do aplicativo

Arquivo de instruções completo: GOOGLE_MEET_SETUP.md

Dependências necessárias:
pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client
        """
        
        # Criar janela de instruções
        setup_window = tk.Toplevel(self.window)
        setup_window.title("Configurar Google Meet")
        setup_window.geometry("600x400")
        setup_window.transient(self.window)
        setup_window.grab_set()
        
        # Texto das instruções
        text_widget = tk.Text(setup_window, wrap=tk.WORD, padx=10, pady=10)
        text_widget.pack(fill=tk.BOTH, expand=True)
        text_widget.insert(tk.END, setup_text)
        text_widget.config(state=tk.DISABLED)
        
        # Botões
        button_frame = ttk.Frame(setup_window)
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        ttk.Button(button_frame, text="Abrir Google Cloud Console", 
                  command=lambda: webbrowser.open("https://console.cloud.google.com")).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Instalar Dependências", 
                  command=self.install_google_deps).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", 
                  command=setup_window.destroy).pack(side=tk.RIGHT, padx=5)
    
    def install_google_deps(self):
        """Instala as dependências do Google"""
        try:
            import subprocess
            subprocess.check_call([sys.executable, "-m", "pip", "install", 
                                 "google-auth", "google-auth-oauthlib", 
                                 "google-auth-httplib2", "google-api-python-client"])
            messagebox.showinfo("Sucesso", "Dependências instaladas com sucesso!\nReinicie o aplicativo.")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao instalar dependências:\n{str(e)}")
    
    def create_meeting(self):
        """Cria uma nova reunião"""
        title = self.title_var.get().strip()
        date = self.date_var.get().strip()
        time = self.time_var.get().strip()
        duration = self.duration_var.get().strip()
        platform = self.platform_var.get()
        password = self.password_var.get().strip()
        
        # Validações
        if not title:
            messagebox.showerror("Erro", "Título é obrigatório!")
            return
        
        if not date:
            messagebox.showerror("Erro", "Data é obrigatória!")
            return
        
        if not time:
            messagebox.showerror("Erro", "Hora é obrigatória!")
            return
        
        try:
            duration = int(duration)
        except ValueError:
            messagebox.showerror("Erro", "Duração deve ser um número!")
            return
        
        try:
            # Criar reunião
            if platform == "zoom":
                meeting_info = self.app.meeting_integration.create_zoom_meeting(
                    title, date, time, duration, password if password else None
                )
            elif platform == "teams":
                meeting_info = self.app.meeting_integration.create_teams_meeting(
                    title, date, time, duration
                )
            else:  # google_meet
                meeting_info = self.app.meeting_integration.create_google_meet_meeting(
                    title, date, time, duration
                )
            
            # Adicionar projeto se especificado
            if self.project_name:
                meeting_info['project'] = self.project_name
                self.app.meeting_integration.save_meeting_data()
            
            # Mostrar link gerado
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(meeting_info['platform'], meeting_info['platform'].upper())
            
            messagebox.showinfo("Reunião Criada", 
                              f"Reunião criada com sucesso!\n\n"
                              f"Link: {meeting_info['link']}\n"
                              f"Plataforma: {platform_display}")
            
            # Limpar formulário
            self.title_var.set("")
            self.password_var.set("")
            
            # Recarregar lista
            self.load_meetings()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao criar reunião: {e}")
    
    def load_meetings(self):
        """Carrega reuniões existentes"""
        # Limpar treeview
        for item in self.meetings_tree.get_children():
            self.meetings_tree.delete(item)
        
        # Carregar reuniões
        if self.project_name:
            meetings = self.app.meeting_integration.get_meetings_by_project(self.project_name)
        else:
            meetings = list(self.app.meeting_integration.meeting_data.values())
        
        # Exibir reuniões
        for meeting in meetings:
            # Converter nome da plataforma para exibição
            platform = meeting.get('platform', '')
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(platform, platform.upper())
            
            self.meetings_tree.insert("", "end", values=(
                meeting.get('date', ''),
                meeting.get('time', ''),
                meeting.get('title', ''),
                platform_display,
                meeting.get('created_by', '')
            ), tags=(meeting['id'],))
    
    def copy_meeting_link(self):
        """Copia link da reunião selecionada"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reunião!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        
        if meeting_id in self.app.meeting_integration.meeting_data:
            meeting = self.app.meeting_integration.meeting_data[meeting_id]
            link = meeting['link']
            
            # Copiar para área de transferência
            self.window.clipboard_clear()
            self.window.clipboard_append(link)
            
            messagebox.showinfo("Link Copiado", f"Link copiado para a área de transferência:\n{link}")
    
    def delete_meeting(self):
        """Exclui reunião selecionada"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reunião!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        meeting_title = item['values'][2]
        
        if messagebox.askyesno("Confirmar Exclusão", 
                              f"Tem certeza que deseja excluir a reunião '{meeting_title}'?"):
            if meeting_id in self.app.meeting_integration.meeting_data:
                del self.app.meeting_integration.meeting_data[meeting_id]
                self.app.meeting_integration.save_meeting_data()
                self.load_meetings()
                messagebox.showinfo("Sucesso", "Reunião excluída com sucesso!")


# Sistema de Chat Integrado
class ChatSystem:
    """Sistema de chat integrado para comunicação em tempo real"""
    
    def __init__(self, app):
        self.app = app
        self.chat_windows = {}  # Janelas de chat por projeto
        self.comment_windows = {}  # Janelas de comentários por cartão
        self.chat_data = {}  # Dados de chat por projeto
        self.comment_data = {}  # Dados de comentários por cartão
        
        # Carregar dados existentes
        self.load_chat_data()
        self.load_comment_data()
    
    def load_chat_data(self):
        """Carrega dados de chat salvos"""
        try:
            if os.path.exists('chat_data.json'):
                with open('chat_data.json', 'r', encoding='utf-8') as f:
                    self.chat_data = json.load(f)
        except Exception as e:
            print(f"Erro ao carregar dados de chat: {e}")
            self.chat_data = {}
    
    def save_chat_data(self):
        """Salva dados de chat"""
        try:
            with open('chat_data.json', 'w', encoding='utf-8') as f:
                json.dump(self.chat_data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erro ao salvar dados de chat: {e}")
    
    def load_comment_data(self):
        """Carrega dados de comentários salvos"""
        try:
            if os.path.exists('comment_data.json'):
                with open('comment_data.json', 'r', encoding='utf-8') as f:
                    self.comment_data = json.load(f)
        except Exception as e:
            print(f"Erro ao carregar dados de comentários: {e}")
            self.comment_data = {}
    
    def save_comment_data(self):
        """Salva dados de comentários"""
        try:
            with open('comment_data.json', 'w', encoding='utf-8') as f:
                json.dump(self.comment_data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erro ao salvar dados de comentários: {e}")
    
    def open_project_chat(self, project_name):
        """Abre chat específico para um projeto"""
        if project_name not in self.chat_windows:
            self.chat_windows[project_name] = ProjectChatWindow(self.app, project_name)
        else:
            self.chat_windows[project_name].window.lift()
            self.chat_windows[project_name].window.focus_force()
    
    def open_card_comments(self, card_id, card_title):
        """Abre comentários de um cartão específico"""
        if card_id not in self.comment_windows:
            self.comment_windows[card_id] = CardCommentsWindow(self.app, card_id, card_title)
        else:
            self.comment_windows[card_id].window.lift()
            self.comment_windows[card_id].window.focus_force()
    
    def add_chat_message(self, project_name, username, message):
        """Adiciona mensagem ao chat do projeto"""
        if project_name not in self.chat_data:
            self.chat_data[project_name] = []
        
        # Processar menções (@usuario)
        processed_message, mentions = self.process_mentions(message)
        
        chat_message = {
            'id': len(self.chat_data[project_name]) + 1,
            'username': username,
            'message': processed_message,
            'mentions': mentions,
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'type': 'chat'
        }
        
        self.chat_data[project_name].append(chat_message)
        self.save_chat_data()
        
        # Notificar usuários mencionados
        self.notify_mentions(mentions, project_name, username, processed_message)
        
        # Atualizar janela de chat se estiver aberta
        if project_name in self.chat_windows:
            self.chat_windows[project_name].add_message(chat_message)
    
    def add_card_comment(self, card_id, username, comment):
        """Adiciona comentário a um cartão"""
        if card_id not in self.comment_data:
            self.comment_data[card_id] = []
        
        # Processar menções (@usuario)
        processed_comment, mentions = self.process_mentions(comment)
        
        comment_data = {
            'id': len(self.comment_data[card_id]) + 1,
            'username': username,
            'comment': processed_comment,
            'mentions': mentions,
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'type': 'comment'
        }
        
        self.comment_data[card_id].append(comment_data)
        self.save_comment_data()
        
        # Notificar usuários mencionados
        self.notify_mentions(mentions, f"Cartão {card_id}", username, processed_comment)
        
        # Atualizar janela de comentários se estiver aberta
        if card_id in self.comment_windows:
            self.comment_windows[card_id].add_comment(comment_data)
    
    def process_mentions(self, text):
        """Processa menções @usuario no texto"""
        mentions = []
        processed_text = text
        
        # Encontrar menções @usuario
        import re
        mention_pattern = r'@(\w+)'
        matches = re.findall(mention_pattern, text)
        
        for match in matches:
            mentions.append(match)
            # Destacar menção no texto
            processed_text = processed_text.replace(f'@{match}', f'@{match}')
        
        return processed_text, mentions
    
    def notify_mentions(self, mentions, context, sender, message):
        """Notifica usuários mencionados"""
        for mention in mentions:
            # Aqui você pode implementar notificações push, email, etc.
            print(f"Notificação: {sender} mencionou @{mention} em {context}: {message}")
    
    def search_chat_history(self, project_name, search_term):
        """Busca no histórico de chat"""
        if project_name not in self.chat_data:
            return []
        
        results = []
        search_term = search_term.lower()
        
        for message in self.chat_data[project_name]:
            if (search_term in message['message'].lower() or 
                search_term in message['username'].lower()):
                results.append(message)
        
        return results
    
    def search_comment_history(self, card_id, search_term):
        """Busca no histórico de comentários"""
        if card_id not in self.comment_data:
            return []
        
        results = []
        search_term = search_term.lower()
        
        for comment in self.comment_data[card_id]:
            if (search_term in comment['comment'].lower() or 
                search_term in comment['username'].lower()):
                results.append(comment)
        
        return results


class ProjectChatWindow:
    """Janela de chat para projeto específico"""
    
    def __init__(self, app, project_name):
        self.app = app
        self.project_name = project_name
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(app.root)
        self.window.title(f"Chat - {project_name}")
        self.window.geometry("600x500")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(app.root)
        
        # Criar interface
        self.create_widgets()
        self.load_messages()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text=f"Chat - {self.project_name}", 
                 font=("Arial", 14, "bold")).pack(side=tk.LEFT)
        
        # Botões de ação
        ttk.Button(title_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.open_search).pack(side=tk.RIGHT, padx=5)
        ttk.Button(title_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.load_messages).pack(side=tk.RIGHT, padx=5)
        
        # Frame para mensagens
        messages_frame = ttk.LabelFrame(main_frame, text="Mensagens", padding="10")
        messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Text widget para mensagens
        self.messages_text = tk.Text(messages_frame, wrap=tk.WORD, state=tk.DISABLED)
        self.messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(messages_frame, orient="vertical", command=self.messages_text.yview)
        self.messages_text.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Frame para entrada de mensagem
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de entrada
        self.message_var = tk.StringVar()
        self.message_entry = ttk.Entry(input_frame, textvariable=self.message_var, font=("Arial", 10))
        self.message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.message_entry.bind("<Return>", self.send_message)
        
        # Botão enviar
        ttk.Button(input_frame, text="Enviar", image=self.icons.get('forward_icon'), compound=tk.LEFT,
                  command=self.send_message).pack(side=tk.RIGHT)
        
        # Focar no campo de entrada
        self.message_entry.focus()
    
    def load_messages(self):
        """Carrega mensagens do chat"""
        self.messages_text.config(state=tk.NORMAL)
        self.messages_text.delete(1.0, tk.END)
        
        if self.project_name in self.app.chat_system.chat_data:
            for message in self.app.chat_system.chat_data[self.project_name]:
                self.display_message(message)
        
        self.messages_text.config(state=tk.DISABLED)
        self.messages_text.see(tk.END)
    
    def display_message(self, message):
        """Exibe uma mensagem no chat"""
        self.messages_text.config(state=tk.NORMAL)
        
        # Formatar mensagem
        timestamp = message['timestamp']
        username = message['username']
        text = message['message']
        
        # Adicionar timestamp
        self.messages_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
        
        # Adicionar username
        self.messages_text.insert(tk.END, f"{username}: ", "username")
        
        # Adicionar mensagem
        self.messages_text.insert(tk.END, f"{text}\n", "message")
        
        self.messages_text.config(state=tk.DISABLED)
        
        # Configurar tags para formatação
        self.messages_text.tag_config("timestamp", foreground="gray")
        self.messages_text.tag_config("username", foreground="blue", font=("Arial", 10, "bold"))
        self.messages_text.tag_config("message", font=("Arial", 10))
    
    def send_message(self, event=None):
        """Envia mensagem"""
        message = self.message_var.get().strip()
        if not message:
            return
        
        # Verificar se há usuário logado
        if not hasattr(self.app, 'current_user') or not self.app.current_user:
            messagebox.showwarning("Aviso", "Você precisa estar logado para enviar mensagens!")
            return
        
        username = self.app.current_user.username
        
        # Adicionar mensagem ao sistema de chat
        self.app.chat_system.add_chat_message(self.project_name, username, message)
        
        # Limpar campo de entrada
        self.message_var.set("")
        
        # Focar novamente no campo
        self.message_entry.focus()
    
    def add_message(self, message):
        """Adiciona nova mensagem à janela"""
        self.display_message(message)
        self.messages_text.see(tk.END)
    
    def open_search(self):
        """Abre janela de busca"""
        ChatSearchWindow(self.window, self.app, self.project_name)


class CardCommentsWindow:
    """Janela de comentários para cartão específico"""
    
    def __init__(self, app, card_id, card_title):
        self.app = app
        self.card_id = card_id
        self.card_title = card_title
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(app.root)
        self.window.title(f"Comentários - {card_title}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(app.root)
        
        # Criar interface
        self.create_widgets()
        self.load_comments()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text=f"Comentários - {self.card_title}", 
                 font=("Arial", 12, "bold")).pack(side=tk.LEFT)
        
        # Botões de ação
        ttk.Button(title_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.open_search).pack(side=tk.RIGHT, padx=5)
        ttk.Button(title_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.load_comments).pack(side=tk.RIGHT, padx=5)
        
        # Frame para comentários
        comments_frame = ttk.LabelFrame(main_frame, text="Comentários", padding="10")
        comments_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Text widget para comentários
        self.comments_text = tk.Text(comments_frame, wrap=tk.WORD, state=tk.DISABLED)
        self.comments_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(comments_frame, orient="vertical", command=self.comments_text.yview)
        self.comments_text.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Frame para entrada de comentário
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de entrada
        self.comment_var = tk.StringVar()
        self.comment_entry = ttk.Entry(input_frame, textvariable=self.comment_var, font=("Arial", 10))
        self.comment_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.comment_entry.bind("<Return>", self.send_comment)
        
        # Botão enviar
        ttk.Button(input_frame, text="Comentar", image=self.icons.get('add_icon'), compound=tk.LEFT,
                  command=self.send_comment).pack(side=tk.RIGHT)
        
        # Focar no campo de entrada
        self.comment_entry.focus()
    
    def load_comments(self):
        """Carrega comentários do cartão"""
        self.comments_text.config(state=tk.NORMAL)
        self.comments_text.delete(1.0, tk.END)
        
        if self.card_id in self.app.chat_system.comment_data:
            for comment in self.app.chat_system.comment_data[self.card_id]:
                self.display_comment(comment)
        
        self.comments_text.config(state=tk.DISABLED)
        self.comments_text.see(tk.END)
    
    def display_comment(self, comment):
        """Exibe um comentário"""
        self.comments_text.config(state=tk.NORMAL)
        
        # Formatar comentário
        timestamp = comment['timestamp']
        username = comment['username']
        text = comment['comment']
        
        # Adicionar timestamp
        self.comments_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
        
        # Adicionar username
        self.comments_text.insert(tk.END, f"{username}: ", "username")
        
        # Adicionar comentário
        self.comments_text.insert(tk.END, f"{text}\n", "comment")
        
        self.comments_text.config(state=tk.DISABLED)
        
        # Configurar tags para formatação
        self.comments_text.tag_config("timestamp", foreground="gray")
        self.comments_text.tag_config("username", foreground="green", font=("Arial", 10, "bold"))
        self.comments_text.tag_config("comment", font=("Arial", 10))
    
    def send_comment(self, event=None):
        """Envia comentário"""
        comment = self.comment_var.get().strip()
        if not comment:
            return
        
        # Verificar se há usuário logado
        if not hasattr(self.app, 'current_user') or not self.app.current_user:
            messagebox.showwarning("Aviso", "Você precisa estar logado para comentar!")
            return
        
        username = self.app.current_user.username
        
        # Adicionar comentário ao sistema
        self.app.chat_system.add_card_comment(self.card_id, username, comment)
        
        # Limpar campo de entrada
        self.comment_var.set("")
        
        # Focar novamente no campo
        self.comment_entry.focus()
    
    def add_comment(self, comment):
        """Adiciona novo comentário à janela"""
        self.display_comment(comment)
        self.comments_text.see(tk.END)
    
    def open_search(self):
        """Abre janela de busca"""
        CommentSearchWindow(self.window, self.app, self.card_id)


class ChatSearchWindow:
    """Janela de busca no histórico de chat"""
    
    def __init__(self, parent, app, project_name):
        self.parent = parent
        self.app = app
        self.project_name = project_name
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title(f"Buscar no Chat - {project_name}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Criar interface
        self.create_widgets()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        ttk.Label(main_frame, text=f"Buscar no Chat - {self.project_name}", 
                 font=("Arial", 12, "bold")).pack(pady=(0, 10))
        
        # Frame de busca
        search_frame = ttk.Frame(main_frame)
        search_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(search_frame, text="Termo de busca:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.search_var = tk.StringVar()
        self.search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=30)
        self.search_entry.pack(side=tk.LEFT, padx=(0, 10))
        self.search_entry.bind("<Return>", self.perform_search)
        
        ttk.Button(search_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.perform_search).pack(side=tk.LEFT)
        
        # Frame para resultados
        results_frame = ttk.LabelFrame(main_frame, text="Resultados", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Treeview para resultados
        columns = ("Data", "Usuário", "Mensagem")
        self.results_tree = ttk.Treeview(results_frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.results_tree.heading(col, text=col)
            self.results_tree.column(col, width=150, anchor="w")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=self.results_tree.yview)
        self.results_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.results_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Botões
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X)
        
        ttk.Button(buttons_frame, text="Limpar", image=self.icons.get('clear_icon'), compound=tk.LEFT,
                  command=self.clear_results).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(buttons_frame, text="Fechar", image=self.icons.get('cancel_icon'), compound=tk.LEFT,
                  command=self.window.destroy).pack(side=tk.RIGHT)
        
        # Focar no campo de busca
        self.search_entry.focus()
    
    def perform_search(self, event=None):
        """Executa a busca"""
        search_term = self.search_var.get().strip()
        if not search_term:
            messagebox.showwarning("Aviso", "Digite um termo para buscar!")
            return
        
        # Limpar resultados anteriores
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        
        # Realizar busca
        results = self.app.chat_system.search_chat_history(self.project_name, search_term)
        
        # Exibir resultados
        for result in results:
            self.results_tree.insert("", "end", values=(
                result['timestamp'],
                result['username'],
                result['message'][:50] + "..." if len(result['message']) > 50 else result['message']
            ))
        
        # Mostrar quantidade de resultados
        messagebox.showinfo("Busca Concluída", f"Encontrados {len(results)} resultados para '{search_term}'")
    
    def clear_results(self):
        """Limpa resultados da busca"""
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        self.search_var.set("")
        self.search_entry.focus()


class CommentSearchWindow:
    """Janela de busca no histórico de comentários"""
    
    def __init__(self, parent, app, card_id):
        self.parent = parent
        self.app = app
        self.card_id = card_id
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title(f"Buscar Comentários - Cartão {card_id}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Criar interface
        self.create_widgets()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        ttk.Label(main_frame, text=f"Buscar Comentários - Cartão {self.card_id}", 
                 font=("Arial", 12, "bold")).pack(pady=(0, 10))
        
        # Frame de busca
        search_frame = ttk.Frame(main_frame)
        search_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(search_frame, text="Termo de busca:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.search_var = tk.StringVar()
        self.search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=30)
        self.search_entry.pack(side=tk.LEFT, padx=(0, 10))
        self.search_entry.bind("<Return>", self.perform_search)
        
        ttk.Button(search_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.perform_search).pack(side=tk.LEFT)
        
        # Frame para resultados
        results_frame = ttk.LabelFrame(main_frame, text="Resultados", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Treeview para resultados
        columns = ("Data", "Usuário", "Comentário")
        self.results_tree = ttk.Treeview(results_frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.results_tree.heading(col, text=col)
            self.results_tree.column(col, width=150, anchor="w")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=self.results_tree.yview)
        self.results_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.results_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Botões
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X)
        
        ttk.Button(buttons_frame, text="Limpar", image=self.icons.get('clear_icon'), compound=tk.LEFT,
                  command=self.clear_results).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(buttons_frame, text="Fechar", image=self.icons.get('cancel_icon'), compound=tk.LEFT,
                  command=self.window.destroy).pack(side=tk.RIGHT)
        
        # Focar no campo de busca
        self.search_entry.focus()
    
    def perform_search(self, event=None):
        """Executa a busca"""
        search_term = self.search_var.get().strip()
        if not search_term:
            messagebox.showwarning("Aviso", "Digite um termo para buscar!")
            return
        
        # Limpar resultados anteriores
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        
        # Realizar busca
        results = self.app.chat_system.search_comment_history(self.card_id, search_term)
        
        # Exibir resultados
        for result in results:
            self.results_tree.insert("", "end", values=(
                result['timestamp'],
                result['username'],
                result['comment'][:50] + "..." if len(result['comment']) > 50 else result['comment']
            ))
        
        # Mostrar quantidade de resultados
        messagebox.showinfo("Busca Concluída", f"Encontrados {len(results)} resultados para '{search_term}'")
    
    def clear_results(self):
        """Limpa resultados da busca"""
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        self.search_var.set("")
        self.search_entry.focus()


class BoodeskApp:
    def on_main_tab_drag_start(self, event):
        try:
            tab_index = self.main_notebook.index(f"@{event.x},{event.y}")
            if tab_index == 0: # Prevent dragging the first tab (Menu Principal)
                return
            if tab_index != "":
                self._drag_data["item"] = self.main_notebook.tabs()[tab_index]
                self._drag_data["tab_index"] = tab_index
        except tk.TclError:
            pass

    def on_main_tab_drag_motion(self, event):
        if self._drag_data["item"]:
            pass # Visual feedback can be added here if needed

    def on_main_tab_drag_release(self, event):
        if self._drag_data["item"]:
            try:
                new_tab_index = self.main_notebook.index(f"@{event.x},{event.y}")
                if new_tab_index == "":
                    new_tab_index = len(self.main_notebook.tabs()) - 1
                if new_tab_index == 0: # Prevent dropping onto the first tab
                    new_tab_index = 1 # or revert

                old_tab_index = self._drag_data["tab_index"]

                if old_tab_index != new_tab_index:
                    self.main_notebook.insert(new_tab_index, self.main_notebook.tabs()[old_tab_index])
            except tk.TclError:
                pass # Invalid drop target
            finally:
                self._drag_data = {"item": None, "x": 0, "y": 0, "tab_index": -1}

    def __init__(self, root, current_user, icons):
        print("DEBUG: Iniciando BoodeskApp.__init__")
        self.root = root
        self.current_user = current_user
        self.icons = icons # Store icons
        self.app = self # For compatibility with the LoginWindow
        
        # Initialize database
        self.db = Database('boodesk_new.db')
        
        # Tentar criar tabelas, se falhar, fazer limpeza forçada
        try:
            self.db.create_tables()
        except Exception as e:
            print(f"Erro ao criar tabelas: {e}")
            print("Tentando limpeza forçada do banco...")
            self.db.force_cleanup()
            try:
                self.db.create_tables()
            except Exception as e2:
                print(f"Erro persistente: {e2}")
                print("Resetando banco de dados...")
                self.db.reset_database()

        # --- File Paths ---
        if getattr(sys, 'frozen', False):
            # Running as a PyInstaller bundle
            self.base_dir = sys._MEIPASS
        else:
            # Running as a normal script
            self.base_dir = os.path.dirname(os.path.abspath(__file__))
        sep = os.path.sep

        self.settings_file = f"{self.base_dir}{sep}pomodoro_settings.json"
        self.data_file = f"{self.base_dir}{sep}boodesk_data.json"
        self.messages_file = f"{self.base_dir}{sep}pomodoro_motivational_messages.json"

        self.load_settings()
        print("DEBUG: load_settings concluído")
        self.load_trello_data()
        print("DEBUG: load_trello_data concluído")
        self.load_pomodoro_data()
        print("DEBUG: load_pomodoro_data concluído")
        self.load_aux_data()
        print("DEBUG: load_aux_data concluído")
        self.load_members()
        print("DEBUG: load_members concluído")
        self.load_categories()
        print("DEBUG: load_categories concluído")

        # Set the application icon
        if self.icons.get('logo_icon'):
            self.root.iconphoto(False, self.icons['logo_icon'])

        # --- User Management ---
        self.user_management = UserManagement()
        
        # --- Timer State ---
        self.timer_running = False
        self.current_cycle = 0
        self.on_break = False
        self.timer_id = None
        self.time_left = 0
        self.active_pomodoro_task = None

        self.listbox_refs = {}
        self.current_chart_type = "income_vs_expense" # Default chart type

        # --- Integrations ---
        # Email Integration
        self.email_integration = EmailIntegration(self)
        
        # Google Calendar Integration
        self.google_calendar = GoogleCalendarIntegration(self)
        
        # Email Template Manager
        self.email_template_manager = EmailTemplateManager(self)
        
        # --- Chat System ---
        self.chat_system = ChatSystem(self)
        
        # --- Meeting Integration ---
        self.meeting_integration = MeetingIntegration(self)
        
        # --- Notification Manager ---
        self.notification_manager = NotificationManager(self)
        
        # Garantir que self.settings seja um dicionário antes de usar
        print(f"DEBUG: Tipo de self.settings: {type(self.settings)}")
        if not isinstance(self.settings, dict):
            print("DEBUG: self.settings não é um dicionário, usando padrões")
            self.settings = self.get_default_settings()
        print(f"DEBUG: Tipo de self.settings após correção: {type(self.settings)}")
        
        # Converter valores JSON string para dicionários
        self._fix_json_strings_in_settings()
        
        # Start integrations if enabled
        email_integration = self.settings.get('email_integration', {})
        if isinstance(email_integration, dict) and email_integration.get('enabled', False):
            self.email_integration.start_email_service()
        
        # Initialize Google Calendar if enabled
        google_calendar = self.settings.get('google_calendar', {})
        if isinstance(google_calendar, dict) and google_calendar.get('enabled', False):
            print("DEBUG: Inicializando integração com Google Calendar")
            # A autenticação será feita quando necessário

    def _fix_json_strings_in_settings(self):
        """Converte valores JSON string para dicionários no settings"""
        import json
        
        for key, value in self.settings.items():
            if isinstance(value, str) and value.startswith('{') and value.endswith('}'):
                try:
                    self.settings[key] = json.loads(value)
                    print(f"DEBUG: Convertido {key} de string para dicionário")
                except:
                    pass  # Manter como string se não for JSON válido

        print("DEBUG: Chamando create_menu")
        self.create_menu()
        print("DEBUG: create_menu concluído")
        
        # Aplicar permissões baseadas no usuário atual (só se houver usuário)
        if hasattr(self, 'current_user') and self.current_user:
            self.apply_role_permissions()
        print("DEBUG: Chamando create_widgets")
        self.create_widgets()
        print("DEBUG: create_widgets concluído")
        if self.current_user:
            self.apply_role_permissions()
        
        # Iniciar sistema de notificações
        self.notification_manager.start_notification_monitor()
        
        # Criar widget de reuniões se habilitado
        if self.notification_manager.notification_settings['show_widget']:
            # O widget será criado quando o menu principal for criado
            pass

    def parse_brazilian_date(self, date_str):
        """Converte data brasileira (DD/MM/YYYY) para datetime ou vice-versa"""
        if not date_str:
            return None
            
        try:
            # Se já é um objeto datetime, retorna ele mesmo
            if isinstance(date_str, datetime):
                return date_str
                
            # Tentar formato brasileiro primeiro: DD/MM/YYYY
            try:
                return datetime.strptime(date_str, "%d/%m/%Y")
            except ValueError:
                pass
                
            # Tentar formato brasileiro com hora: DD/MM/YYYY HH:MM
            try:
                return datetime.strptime(date_str, "%d/%m/%Y %H:%M")
            except ValueError:
                pass
                
            # Tentar formato brasileiro com hora e segundos: DD/MM/YYYY HH:MM:SS
            try:
                return datetime.strptime(date_str, "%d/%m/%Y %H:%M:%S")
            except ValueError:
                pass
                
            # Tentar formato americano: YYYY-MM-DD
            try:
                return datetime.strptime(date_str, "%Y-%m-%d")
            except ValueError:
                pass
                
            # Tentar formato americano com hora: YYYY-MM-DD HH:MM
            try:
                return datetime.strptime(date_str, "%Y-%m-%d %H:%M")
            except ValueError:
                pass
                
            # Tentar formato americano com hora e segundos: YYYY-MM-DD HH:MM:SS
            try:
                return datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
            except ValueError:
                pass
                
            print(f"Formato de data não reconhecido: {date_str}")
            return None
            
        except Exception as e:
            print(f"Erro ao processar data: {date_str} - {e}")
            return None

    def get_board_id_by_name(self, board_name):
        """Get board ID by name from SQL database"""
        try:
            # Get current user ID to filter boards by owner
            user_id = self.get_current_user_id()
            if hasattr(self, 'db') and self.db:
                try:
                    for board in self.db.get_boards(user_id):
                        if board['name'] == board_name:
                            return board['id']
                except Exception as db_error:
                    print(f"DEBUG: Erro ao acessar banco de dados: {db_error}")
            # Fallback: return default board ID if database is not available
            print(f"DEBUG: Usando board_id padrão (1) para quadro '{board_name}'")
            return 1
        except Exception as e:
            print(f"Erro ao buscar board: {e}")
            # Fallback: return default board ID
            return 1
    
    def get_board_id_by_name_safe(self, board_name):
        """Versão segura do get_board_id_by_name que sempre retorna um valor"""
        try:
            return self.get_board_id_by_name(board_name)
        except Exception as e:
            print(f"DEBUG: Erro no get_board_id_by_name_safe: {e}")
            return 1  # Sempre retorna 1 como fallback
    
    def __getattr__(self, name):
        """Fallback para métodos não encontrados"""
        if name == 'get_board_id_by_name':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda board_name: 1  # Retorna sempre board_id 1
        elif name == 'get_board_id_by_name_safe':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda board_name: 1  # Retorna sempre board_id 1
        elif name == 'time_left':
            print(f"DEBUG: Atributo {name} não encontrado, inicializando com 0")
            self.time_left = 0
            return 0
        elif name == 'timer_running':
            print(f"DEBUG: Atributo {name} não encontrado, inicializando com False")
            self.timer_running = False
            return False
        elif name == 'current_cycle':
            print(f"DEBUG: Atributo {name} não encontrado, inicializando com 0")
            self.current_cycle = 0
            return 0
        elif name == 'on_break':
            print(f"DEBUG: Atributo {name} não encontrado, inicializando com False")
            self.on_break = False
            return False
        elif name == 'timer_id':
            print(f"DEBUG: Atributo {name} não encontrado, inicializando com None")
            self.timer_id = None
            return None
        elif name == 'active_pomodoro_task':
            print(f"DEBUG: Atributo {name} não encontrado, inicializando com None")
            self.active_pomodoro_task = None
            return None
        elif name == 'pomodoro_timer_label':
            print(f"DEBUG: Widget {name} não encontrado, retornando None")
            return None
        elif name == 'timer_label':
            print(f"DEBUG: Widget {name} não encontrado, retornando None")
            return None
        elif name == 'pomodoro_frame':
            print(f"DEBUG: Widget {name} não encontrado, retornando None")
            return None
        elif name == 'timer_frame':
            print(f"DEBUG: Widget {name} não encontrado, retornando None")
            return None
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def notify_member_added_to_card(self, card_id, member_name, added_by):
        """Notifica membro quando adicionado a um card"""
        try:
            card = self.get_card_by_id(card_id)
            if not card:
                return
            
            notification = {
                'type': 'member_added',
                'card_title': card['title'],
                'card_id': card_id,
                'member': member_name,
                'added_by': added_by,
                'board': card.get('board_name', ''),
                'list': card.get('list_name', ''),
                'timestamp': datetime.now().isoformat(),
                'read': False
            }
            
            # Salvar notificação no banco (se método existir)
            if hasattr(self, 'db') and hasattr(self.db, 'save_notification'):
                self.db.save_notification(notification)
            
            # Mostrar notificação na interface
            self.show_notification_popup(notification)
            
            # Enviar email se configurado
            if hasattr(self, 'email_integration'):
                self.email_integration.notify_member_added(notification)
                
        except Exception as e:
            print(f"Erro ao notificar membro adicionado: {e}")

    def show_notification_popup(self, notification):
        """Mostra popup de notificação"""
        try:
            popup = tk.Toplevel(self.root)
            popup.title("Nova Notificação")
            popup.geometry("400x200")
            popup.resizable(False, False)
            
            # Centralizar popup
            popup.transient(self.root)
            popup.grab_set()
            
            message = f"Você foi adicionado ao card:\n'{notification['card_title']}'\n\nQuadro: {notification['board']}\nLista: {notification['list']}"
            
            ttk.Label(popup, text=message, wraplength=350, justify='center').pack(pady=20)
            
            button_frame = ttk.Frame(popup)
            button_frame.pack(pady=10)
            
            ttk.Button(button_frame, text="Ver Card", 
                      command=lambda: self.open_card_from_notification(notification['card_id'])).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Fechar", command=popup.destroy).pack(side=tk.LEFT, padx=5)
            
        except Exception as e:
            print(f"Erro ao mostrar popup de notificação: {e}")

    def open_card_from_notification(self, card_id):
        """Abre card a partir de notificação"""
        try:
            # Encontrar card nos dados
            for board_name, board_data in self.boodesk_data['boards'].items():
                for list_name, cards in board_data.items():
                    if isinstance(cards, list):
                        for card in cards:
                        if card.get('card_id') == card_id:
                            # Abrir janela do card
                            CardWindow(self.root, self, board_name, list_name, card_id, self.current_user)
                            return
            print(f"Card {card_id} não encontrado")
        except Exception as e:
            print(f"Erro ao abrir card: {e}")

    def get_card_by_id(self, card_id):
        """Retorna card pelo ID - busca tanto no banco quanto na memória"""
        try:
            # Primeiro, tentar buscar no banco de dados
            if hasattr(self, 'db') and self.db:
                try:
                    card_data = self.db.get_card_by_id(card_id)
                    if card_data:
                        # Converter para dicionário se necessário
                        if not isinstance(card_data, dict):
                            card_data = dict(card_data)
                        
                        # Adicionar informações do board e lista
                        board_name = self.db.get_board_name_by_id(card_data.get('board_id'))
                        card_data['board_name'] = board_name or 'Quadro Principal'
                        card_data['list_name'] = card_data.get('list_name', 'A Fazer')
                        return card_data
                except Exception as db_error:
                    print(f"Erro ao buscar card no banco: {db_error}")
            
            # Se não encontrou no banco, buscar na estrutura em memória
            for board_name, board_data in self.boodesk_data['boards'].items():
                if isinstance(board_data, dict):
                    for list_name, cards in board_data.items():
                        if list_name == 'workflow':  # Ignorar metadados
                            continue
                        if isinstance(cards, list):
                            for card in cards:
                                if card.get('card_id') == card_id:
                                    card['board_name'] = board_name
                                    card['list_name'] = list_name
                                    return card
            
            print(f"Card com ID {card_id} não encontrado")
            return None
        except Exception as e:
            print(f"Erro ao buscar card por ID: {e}")
            return None

    def create_member_dashboard(self, member_name):
        """Cria dashboard personalizado para o membro"""
        dashboard = {
            'my_cards': self.get_cards_by_member(member_name),
            'my_boards': self.get_boards_for_member(member_name),
            'pending_tasks': self.get_pending_tasks(member_name),
            'completed_tasks': self.get_completed_tasks(member_name),
            'recent_activities': self.get_recent_activities(member_name),
            'upcoming_deadlines': self.get_upcoming_deadlines(member_name)
        }
        return dashboard

    def get_cards_by_member(self, member_name):
        """Retorna todos os cards onde o membro participa"""
        cards = []
        for board_name, board_data in self.boodesk_data['boards'].items():
            for list_name, cards_list in board_data.items():
                if list_name == 'workflow':
                    continue
                for card in cards_list:
                    if member_name in card.get('members', []):
                        card['board_name'] = board_name
                        card['list_name'] = list_name
                        cards.append(card)
        return cards

    def get_pending_tasks(self, member_name):
        """Retorna tarefas pendentes do membro"""
        return [card for card in self.get_cards_by_member(member_name) 
                if card.get('status') != 'done']

    def get_completed_tasks(self, member_name, days=30):
        """Retorna tarefas completadas nos últimos X dias"""
        cutoff_date = datetime.now() - timedelta(days=days)
        completed = []
        for card in self.get_cards_by_member(member_name):
            if card.get('status') == 'done':
                completed_date = card.get('completed_at')
                if completed_date and completed_date > cutoff_date:
                    completed.append(card)
        return completed

    def get_recent_activities(self, member_name, limit=10):
        """Retorna atividades recentes relacionadas ao membro"""
        # Implementação básica - pode ser expandida com banco de dados
        activities = []
        cards = self.get_cards_by_member(member_name)
        for card in cards[:limit]:
            activities.append({
                'action': 'Card atribuído',
                'card_title': card['title'],
                'timestamp': card.get('created_at', 'Data não disponível')
            })
        return activities

    def get_upcoming_deadlines(self, member_name, days=7):
        """Retorna prazos próximos do membro"""
        cutoff_date = datetime.now() + timedelta(days=days)
        upcoming = []
        for card in self.get_cards_by_member(member_name):
            if card.get('status') != 'done':
                due_date = card.get('due_date')
                if due_date and due_date <= cutoff_date:
                    upcoming.append(card)
        return upcoming

    def show_member_dashboard(self, member_name):
        """Mostra dashboard personalizado do membro"""
        try:
            dashboard = self.create_member_dashboard(member_name)
            
            # Criar janela do dashboard
            dashboard_window = tk.Toplevel(self.root)
            dashboard_window.title(f"Dashboard - {member_name}")
            dashboard_window.geometry("800x600")
            dashboard_window.resizable(True, True)
            
            # Notebook para organizar as seções
            notebook = ttk.Notebook(dashboard_window)
            notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Aba de Cards Ativos
            active_frame = ttk.Frame(notebook)
            notebook.add(active_frame, text="Meus Cards")
            
            # Treeview para cards ativos
            columns = ("Título", "Quadro", "Lista", "Status", "Prazo")
            tree = ttk.Treeview(active_frame, columns=columns, show="headings")
            
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=120)
            
            # Adicionar cards
            for card in dashboard['my_cards']:
                tree.insert("", "end", values=(
                    card['title'],
                    card['board_name'],
                    card['list_name'],
                    card.get('status', 'Pendente'),
                    card.get('due_date', '-')
                ))
            
            tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Aba de Estatísticas
            stats_frame = ttk.Frame(notebook)
            notebook.add(stats_frame, text="Estatísticas")
            
            stats_text = f"""
            📊 Estatísticas de {member_name}
            
            📋 Total de Cards: {len(dashboard['my_cards'])}
            ⏳ Pendentes: {len(dashboard['pending_tasks'])}
            ✅ Completados (30 dias): {len(dashboard['completed_tasks'])}
            📅 Prazos Próximos: {len(dashboard['upcoming_deadlines'])}
            📋 Quadros Ativos: {len(dashboard['my_boards'])}
            """
            
            ttk.Label(stats_frame, text=stats_text, justify='left', font=('Arial', 12)).pack(pady=20)
            
        except Exception as e:
            print(f"Erro ao mostrar dashboard: {e}")
            messagebox.showerror("Erro", f"Não foi possível mostrar o dashboard: {e}")

    def open_personal_dashboard(self):
        """Abre dashboard personalizado do usuário atual"""
        try:
            # Obter membro do usuário atual
            current_user_member = self._get_current_user_member()
            
            if not current_user_member:
                messagebox.showwarning("Aviso", "Usuário não tem membro associado. Dashboard não disponível.")
                return
            
            # Mostrar dashboard
            self.show_member_dashboard(current_user_member)
            
        except Exception as e:
            print(f"Erro ao abrir dashboard pessoal: {e}")
            messagebox.showerror("Erro", f"Não foi possível abrir o dashboard: {e}")

    def format_brazilian_date(self, date_obj):
        """Converte datetime para formato brasileiro (DD/MM/YYYY)"""
        if not date_obj:
            return ""
            
        try:
            if isinstance(date_obj, str):
                # Se já é string, tentar converter primeiro
                date_obj = self.parse_brazilian_date(date_obj)
                
            if isinstance(date_obj, datetime):
                return date_obj.strftime("%d/%m/%Y")
            else:
                return str(date_obj)
                
        except Exception as e:
            print(f"Erro ao formatar data: {date_obj} - {e}")
            return str(date_obj) if date_obj else ""

    def format_brazilian_datetime(self, date_obj):
        """Converte datetime para formato brasileiro com hora (DD/MM/YYYY HH:MM)"""
        if not date_obj:
            return ""
            
        try:
            if isinstance(date_obj, str):
                # Se já é string, tentar converter primeiro
                date_obj = self.parse_brazilian_date(date_obj)
                
            if isinstance(date_obj, datetime):
                return date_obj.strftime("%d/%m/%Y %H:%M")
            else:
                return str(date_obj)
                
        except Exception as e:
            print(f"Erro ao formatar data/hora: {date_obj} - {e}")
            return str(date_obj) if date_obj else ""

    
    def check_permission(self, permission):
        """Verifica se o usuário atual tem uma determinada permissão"""
        if not hasattr(self, 'current_user') or not self.current_user:
            return False
        
        # Verificar se o usuário tem o método has_permission
        if not hasattr(self.current_user, 'has_permission'):
            print("DEBUG: Usuário não tem método has_permission")
            return False
        
        return self.current_user.has_permission(permission)
    
    def require_permission(self, permission, action_name="esta ação"):
        """Verifica permissão e mostra erro se não tiver"""
        if not self.check_permission(permission):
            messagebox.showerror("Acesso Negado", 
                               f"Você não tem permissão para {action_name}.\n"
                               f"Contate um administrador se precisar de acesso.")
            return False
        return True
    
    def open_user_management(self):
        """Abre a janela de gerenciamento de usuários"""
        try:
            # Verificar se o usuário tem permissão
            if not self.require_permission("manage_users", "gerenciar usuários"):
                return
            
            # Verificar se user_management está disponível
            if not hasattr(self, 'user_management') or self.user_management is None:
                messagebox.showerror("Erro", "Sistema de gerenciamento de usuários não disponível.")
                return
            
            # Verificar se icons está disponível
            if not hasattr(self, 'icons') or self.icons is None:
                messagebox.showerror("Erro", "Ícones não disponíveis.")
                return
            
            # Abrir janela de gerenciamento
            print("DEBUG: Abrindo janela de gerenciamento de usuários...")
            UserRegistrationWindow(self.root, self.user_management, self.icons, app=self)
            print("DEBUG: Janela de gerenciamento de usuários aberta com sucesso!")
            
        except Exception as e:
            print(f"DEBUG: Erro ao abrir gerenciamento de usuários: {e}")
            messagebox.showerror("Erro", f"Não foi possível abrir a tela de gerenciar usuários: {e}")
    
    def open_notification_settings(self):
        """Abre a janela de configurações de notificação"""
        NotificationSettingsWindow(self)
    
    def toggle_meeting_widget(self):
        """Alterna a visibilidade do widget de reuniões"""
        if hasattr(self, 'meeting_widget') and self.meeting_widget:
            if self.meeting_widget.widget_frame:
                self.meeting_widget.widget_frame.destroy()
                self.meeting_widget = None
                self.notification_manager.notification_settings['show_widget'] = False
        else:
            # Encontrar o frame do menu principal
            for child in self.main_notebook.winfo_children():
                if self.main_notebook.tab(child, "text") == "Menu Principal":
                    self.meeting_widget = MeetingWidget(self, child)
                    self.notification_manager.notification_settings['show_widget'] = True
                    break
        
        # Salvar configuração
        self.notification_manager.save_notification_settings()
    
    def on_closing(self):
        """Chamado quando a aplicação está sendo fechada"""
        try:
            # Parar sistema de notificações
            if hasattr(self, 'notification_manager'):
                self.notification_manager.stop_notification_monitor()
            
            # Salvar configurações
            self.save_settings_file()
            
            # Salvar dados do Boodesk
            self.save_trello_data()
            
            # Salvar dados do Pomodoro
            self.save_pomodoro_data()
            
            # Salvar dados financeiros
            self.save_finance_data()
            
            # Salvar dados de estudo
            self.save_study_data()
            
            # Salvar dados de objetivos
            self.save_goals_data()
            
            # Salvar dados de membros
            self.save_members_data()
            
            # Salvar dados de assuntos
            self.save_subjects_data()
            
            print("DEBUG: Todos os dados foram salvos com sucesso")
            
        except Exception as e:
            print(f"Erro ao salvar dados: {e}")
        
        finally:
            # Fechar aplicação
            self.root.destroy()
    
    def logout(self):
        """Faz logout do usuário atual"""
        if messagebox.askyesno("Logout", "Tem certeza que deseja fazer logout?"):
            # Limpar dados do usuário atual
            self.current_user = None
            
            # Ocultar janela principal
            self.root.withdraw()
            
            # Mostrar tela de login novamente
            login_window = LoginWindow(self.root, self.user_management, self.icons)
            self.root.wait_window(login_window)
            
            # Verificar se o login foi bem-sucedido
            if hasattr(self.root, 'login_successful') and self.root.login_successful and self.root.current_user:
                # Configurar novo usuário na aplicação
                self.current_user = self.root.current_user
                self.apply_role_permissions()
                
                # Recriar menu com novo usuário
                self.create_menu()
                
                # Mostrar aplicação principal
                self.root.deiconify()
            else:
                # Login cancelado ou falhou
                self.root.destroy()
        

    def update_all_displays(self):
        self.update_timer_display()
        self.populate_boards()
        self.update_pomodoro_task_list()
        self.update_my_activities_tab() # Adicionado
        self.update_log()
        self.update_accounts_listbox()
        self.update_total_balance_display()
        self.update_categories_listbox()
        self.update_payment_methods_listbox()
        self.update_transactions_treeview()
        self.populate_finance_comboboxes()
        self._show_chart(self.current_chart_type)
        self._update_saved_filters_combo()

        # Initialize filter comboboxes
        self.filter_subject_combo['values'] = ["Todos"] + sorted(list(set(self.pomodoro_subjects + self.boodesk_subjects)))
        self.filter_goal_combo['values'] = ["Todos"] + sorted(self.goals)
        self.filter_importance_combo['values'] = ["Todos"] + list(self.settings["importance_colors"].keys())
        self.filter_member_combo['values'] = ["Todos"] + sorted([member['Membro'] for member in self.members])

    def apply_card_filter(self):
        self.populate_boards()

    def clear_card_filter(self):
        self.filter_subject_var.set("Todos")
        self.filter_goal_var.set("Todos")
        self.filter_member_var.set("Todos") # Changed from set("") to set("Todos")
        self.filter_due_date_var.set("Todos")
        self.filter_importance_var.set("Todos")
        self.filter_recurrence_var.set("Todos")
        self.filter_keyword_var.set("") # Clear keyword filter
        self.populate_boards()
        self._update_saved_filters_combo()

    def save_filter(self):
        filter_name = simpledialog.askstring("Salvar Filtro", "Digite um nome para este filtro:", parent=self.root)
        if filter_name:
            current_filter_settings = {
                "subject": self.filter_subject_var.get(),
                "goal": self.filter_goal_var.get(),
                "member": self.filter_member_var.get(),
                "due_date": self.filter_due_date_var.get(),
                "importance": self.filter_importance_var.get(),
                "recurrence": self.filter_recurrence_var.get(),
                "keyword": self.filter_keyword_var.get()
            }
            self.settings["custom_filters"][filter_name] = current_filter_settings
            self.save_settings_file()
            self._update_saved_filters_combo()
            messagebox.showinfo("Filtro Salvo", f"Filtro '{filter_name}' salvo com sucesso!")

    def load_filter(self, event=None):
        filter_name = self.saved_filters_combo.get()
        if filter_name and filter_name in self.settings["custom_filters"]:
            filter_settings = self.settings["custom_filters"][filter_name]
            self.filter_subject_var.set(filter_settings.get("subject", "Todos"))
            self.filter_goal_var.set(filter_settings.get("goal", "Todos"))
            self.filter_member_var.set(filter_settings.get("member", "Todos"))
            self.filter_due_date_var.set(filter_settings.get("due_date", "Todos"))
            self.filter_importance_var.set(filter_settings.get("importance", "Todos"))
            self.filter_recurrence_var.set(filter_settings.get("recurrence", "Todos"))
            self.filter_keyword_var.set(filter_settings.get("keyword", ""))
            self.apply_card_filter()
            messagebox.showinfo("Filtro Carregado", f"Filtro '{filter_name}' carregado com sucesso!")

    def delete_filter(self):
        filter_name = self.saved_filters_combo.get()
        if filter_name and filter_name in self.settings["custom_filters"]:
            if messagebox.askyesno("Excluir Filtro", f"Tem certeza que deseja excluir o filtro '{filter_name}'?"):
                del self.settings["custom_filters"][filter_name]
                self.save_settings_file()
                self._update_saved_filters_combo()
                self.clear_card_filter()
                messagebox.showinfo("Filtro Excluído", f"Filtro '{filter_name}' excluído com sucesso!")
        else:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um filtro para excluir.")

    def _update_saved_filters_combo(self):
        self.saved_filters_combo['values'] = sorted(list(self.settings["custom_filters"].keys()))
        self.saved_filters_combo.set("") # Clear current selection

    def toggle_filter_visibility(self):
        if self.filter_visible.get():
            self.filter_container_frame.pack_forget()
            self.toggle_filter_button.config(text="Mostrar Filtros")
        else:
            self.filter_container_frame.pack(fill=tk.X, pady=5, padx=5)
            self.toggle_filter_button.config(text="Ocultar Filtros")
        self.filter_visible.set(not self.filter_visible.get())

    def _filter_due_date(self, card_due_date_str, filter_option):
        if not card_due_date_str:
            return False # Cards without due dates don't match any date filter

        try:
            card_due_date = datetime.strptime(card_due_date_str.split(' ')[0], "%Y-%m-%d").date()
        except ValueError:
            return False # Invalid date format

        today = datetime.now().date()
        
        if filter_option == "Hoje":
            return card_due_date == today
        elif filter_option == "Próximos 7 dias":
            seven_days_from_now = today + timedelta(days=7)
            return today <= card_due_date <= seven_days_from_now
        elif filter_option == "Vencidos":
            return card_due_date < today
        return True # "Todos" or other cases

    # --- Data Loading/Saving ---
    def load_settings(self):
        """Load settings from SQL database instead of JSON files"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, usando configurações padrão")
                self.settings = self.get_default_settings()
                return
            
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Se não há usuário logado, usar user_id padrão (1 = admin)
            if user_id is None:
                user_id = 1
                print("DEBUG: Usando user_id padrão (1) para configurações")
            
            # Load settings from database for current user
            db_settings = self.db.get_all_settings(user_id)
            
            if db_settings and isinstance(db_settings, dict):
                self.settings = db_settings
            else:
                # No settings in database, use defaults
                self.settings = self.get_default_settings()
                # Save defaults to database for current user
                for key, value in self.settings.items():
                    try:
                        self.db.save_setting(key, value, user_id)
                    except Exception as save_error:
                        print(f"Erro ao salvar configuração {key}: {save_error}")
            
            # Garantir que self.settings seja um dicionário
            if not isinstance(self.settings, dict):
                print("DEBUG: self.settings não é um dicionário, usando padrões")
                self.settings = self.get_default_settings()
            
            # Merge with default settings to ensure all keys are present
            default_settings = self.get_default_settings()
            for key, value in default_settings.items():
                if key not in self.settings:
                    self.settings[key] = value
                    try:
                        self.db.save_setting(key, value, user_id)
                    except Exception as save_error:
                        print(f"Erro ao salvar configuração {key}: {save_error}")
                elif isinstance(value, dict) and isinstance(self.settings[key], dict):
                    # Recursively merge dictionaries (e.g., for importance_colors, roles)
                    self.settings[key] = {**value, **self.settings[key]}
                    try:
                        self.db.save_setting(key, self.settings[key], user_id)
                    except Exception as save_error:
                        print(f"Erro ao salvar configuração {key}: {save_error}")
                    
        except Exception as e:
            print(f"Erro ao carregar configurações do banco: {e}")
            messagebox.showwarning("Erro de Configuração", f"Não foi possível carregar as configurações do banco. Usando padrões. Erro: {e}")
            self.settings = self.get_default_settings()
            # Try to save defaults to database
            try:
                if hasattr(self, 'db') and self.db is not None:
                    user_id = self.get_current_user_id()
                    # Se não há usuário logado, usar user_id padrão (1 = admin)
                    if user_id is None:
                        user_id = 1
                    for key, value in self.settings.items():
                        self.db.save_setting(key, value, user_id)
            except Exception as save_error:
                print(f"Erro ao salvar configurações padrão: {save_error}")

    def get_current_user_id(self):
        """Retorna o ID do usuário atual no banco de dados"""
        try:
            print("DEBUG: get_current_user_id - Iniciando...")
            
            if not self.current_user:
                print("DEBUG: current_user não definido")
                return None
            
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco de dados não disponível")
                return None
            
            username = self.current_user.username
            print(f"DEBUG: get_current_user_id - Username: {username}")
            
            if not username:
                print("DEBUG: Username não definido")
                return None
            
            print("DEBUG: get_current_user_id - Chamando get_user_by_username...")
            user_data = self.db.get_user_by_username(username)
            print(f"DEBUG: get_current_user_id - user_data: {user_data}")
            
            if user_data and 'id' in user_data:
                user_id = user_data['id']
                print(f"DEBUG: get_current_user_id - user_id: {user_id}")
                
                # Verificar se o usuário tem um membro associado
                if 'member_id' in user_data and user_data['member_id']:
                    member_id = user_data['member_id']
                    print(f"DEBUG: get_current_user_id - member_id: {member_id}")
                    print(f"DEBUG: ID do usuário {username}: {user_id} (membro associado: {member_id})")
                    return user_id
                else:
                    print(f"DEBUG: get_current_user_id - member_id não encontrado ou None")
                    print(f"DEBUG: Usuário {username} não tem membro associado")
                    messagebox.showerror("Erro", "Usuário não tem membro associado. Contate o administrador.", parent=self.root)
                    return None
            else:
                print(f"DEBUG: get_current_user_id - user_data inválido: {user_data}")
                print(f"DEBUG: Usuário {username} não encontrado no banco ou sem ID")
                return None
                
        except Exception as e:
            print(f"DEBUG: Erro ao obter ID do usuário: {e}")
            return None

    def get_default_settings(self):
        return {
            "pomodoro": 25, 
            "short_break": 5, 
            "long_break": 15, 
            "cycles": 4, 
            "theme": "aquativo", 
            "unify_subjects": False, 
            "show_card_details_on_board": False,
            "show_dependency_info": True,
            "open_on_current_screen": False, # New setting
            "importance_colors": {
                "Crítica": "#FFCCCC",
                "Alta": "#FFE5CC",
                "Normal": "#FFFFCC",
                "Baixa": "#CCFFCC"
            },
            "card_tags": {
                "Urgente": "#FF0000",
                "Importante": "#FFA500",
                "Desenvolvimento": "#0000FF",
                "Bug": "#FFD700",
                "Feature": "#008000"
            },
            "custom_filters": {}, # New: To store custom filter presets
            "dev_mode": False, # New: Development mode for agile features
            "git_integration_enabled": False, # New: Enable/disable Git integration features
            "roles": {
                "Administrador": "Acesso total ao sistema.",
                "Usuário": "Acesso limitado a funcionalidades básicas.",
                "Convidado": "Apenas visualização."
            },
            "dashboard_widgets": {
                "urgent_tasks": True,
                "upcoming_deadlines": True,
                "recent_activities": True,
                "quick_links": True,
                "overview": True,
                "quick_actions": True
            },
            # Configurações do Google Calendar removidas - integração desabilitada
            "email_integration": {
                "enabled": False,
                "provider": "gmail",
                "smtp_server": "smtp.gmail.com",
                "smtp_port": 587,
                "email_address": "",
                "email_password": "",
                "app_password": "",
                "auto_notifications": {
                    "card_created": True,
                    "card_modified": True,
                    "card_moved": True,
                    "deadline_reminder": True,
                    "weekly_report": True
                },
                "notification_recipients": [],
                "deadline_reminder_hours": 24,
                "weekly_report_day": "monday",
                "weekly_report_time": "09:00",
                "email_templates": {
                    "card_created": "Novo cartão criado: {title}",
                    "card_modified": "Cartão modificado: {title}",
                    "deadline_reminder": "Lembrete de prazo: {title} vence em {deadline}",
                    "weekly_report": "Relatório Semanal - {week_period}"
                }
            }
        }

    def save_settings_file(self):
        """Save settings to SQL database instead of JSON files"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar configurações")
                return
            
            # Obter user_id se disponível
            user_id = None
            if hasattr(self, 'current_user') and self.current_user:
                user_id = self.get_current_user_id()
            
            for key, value in self.settings.items():
                try:
                    if user_id:
                        self.db.save_setting(key, value, user_id)
                    else:
                        # Se não há usuário logado, usar user_id padrão (1 = admin)
                        self.db.save_setting(key, value, 1)
                except Exception as save_error:
                    print(f"Erro ao salvar configuração {key}: {save_error}")
            print("Configurações salvas no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar configurações no banco: {e}")
            messagebox.showerror("Erro", f"Não foi possível salvar as configurações no banco: {e}")

    def load_trello_data(self):
        """Load data from SQL database instead of JSON files"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, usando dados padrão")
                self.boodesk_data = {
                    "boards": {
                        "Quadro Principal": {
                            "A Fazer": [],
                            "Em Progresso": [],
                            "Concluído": []
                        },
                        "workflow": ["A Fazer", "Em Progresso", "Concluído"]
                    },
                    "finances": {
                        "contas_bancarias": [],
                        "categorias_gasto": [],
                        "meios_pagamento": [],
                        "transacoes": []
                    }
                }
                return
            
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Check if database has data, if not create default board
            boards = self.db.get_boards(user_id)
            if not boards:
                print("DEBUG: Nenhum quadro encontrado no banco, criando quadro padrão")
                # Create default board for current user
                board_id = self.db.create_board("Quadro Principal", owner_id=user_id)
                # Create default card
                self.db.create_card(
                    board_id=board_id,
                    list_name="A Fazer",
                    title="Sua primeira tarefa",
                    description="Bem-vindo ao Boodesk! Esta é sua primeira tarefa.",
                    importance="Normal",
                    user_id=user_id
                )
                boards = self.db.get_boards(user_id)
            
            # Load data from database
            self.boodesk_data = {'boards': {}}
            for board in boards:
                board_name = board['name']
                self.boodesk_data['boards'][board_name] = {}
                
                cards = self.db.get_cards_for_board(board['id'])
                
                # Garantir que as listas padrão existam mesmo se vazias
                if board_name == "Quadro Principal":
                    self.boodesk_data['boards'][board_name] = {
                        "A Fazer": [],
                        "Em Progresso": [],
                        "Concluído": []
                    }
                
                for card in cards:
                    list_name = card['list_name']
                    if list_name not in self.boodesk_data['boards'][board_name]:
                        self.boodesk_data['boards'][board_name][list_name] = []
                    
                    # Convert SQL card to JSON structure for compatibility
                    card_data = {
                        'title': card['title'],
                        'desc': card['description'] or '',
                        'due_date': card['due_date'] or '',
                        'members': json.loads(card['members']) if card['members'] else [],
                        'subject': card['subject'] or '-',
                        'goal': card['goal'] or '-',
                        'importance': card['importance'] or 'Normal',
                        'creation_date': card['creation_date'] or '',
                        'card_id': card['card_id'],
                        'is_archived': bool(card['is_archived']),
                        'git_branch': card['git_branch'] or '',
                        'git_commit': card['git_commit'] or '',
                        'history': json.loads(card['history']) if card['history'] else [],
                        'dependencies': json.loads(card['dependencies']) if card['dependencies'] else [],
                        'recurrence': card['recurrence'] or 'Nenhuma'
                    }
                    self.boodesk_data['boards'][board_name][list_name].append(card_data)
            
            # Add workflow
            self.boodesk_data['boards']['workflow'] = ["A Fazer", "Em Progresso", "Concluído"]
            
            # Garantir que pelo menos o Quadro Principal existe
            if "Quadro Principal" not in self.boodesk_data['boards']:
                self.boodesk_data['boards']["Quadro Principal"] = {
                    "A Fazer": [],
                    "Em Progresso": [],
                    "Concluído": []
                }
            
            print(f"DEBUG: load_trello_data concluído. Quadros carregados: {list(self.boodesk_data['boards'].keys())}")
            
            # Load finances from database
            finances = self.db.get_finance_data('finances')
            if finances:
                self.boodesk_data['finances'] = finances
            else:
                self.boodesk_data['finances'] = {
                    "contas_bancarias": [],
                    "categorias_gasto": [],
                    "meios_pagamento": [],
                    "transacoes": []
                }
                # Save default finances to database
                for key, value in self.boodesk_data['finances'].items():
                    try:
                        self.db.save_finance_data('finances', key, value)
                    except Exception as save_error:
                        print(f"Erro ao salvar dados financeiros {key}: {save_error}")
                    
        except Exception as e:
            print(f"Erro ao carregar dados do banco: {e}")
            # Em caso de erro, usar dados padrão
            self.boodesk_data = {
                "boards": {
                    "Quadro Principal": {
                        "A Fazer": [],
                        "Em Progresso": [],
                        "Concluído": []
                    },
                    "workflow": ["A Fazer", "Em Progresso", "Concluído"]
                },
                "finances": {
                    "contas_bancarias": [],
                    "categorias_gasto": [],
                    "meios_pagamento": [],
                    "transacoes": []
                }
            }
            messagebox.showerror("Erro", f"Ocorreu um erro ao carregar os dados do banco: {e}")
            messagebox.showerror("Erro", f"Ocorreu um erro ao carregar os dados do banco: {e}")
            # Create minimal default data
            self.boodesk_data = {
                "boards": {
                    "Quadro Principal": {
                        "A Fazer": [],
                        "Em Progresso": [],
                        "Concluído": []
                    },
                    "workflow": ["A Fazer", "Em Progresso", "Concluído"]
                },
                "finances": {
                    "contas_bancarias": [],
                    "categorias_gasto": [],
                    "meios_pagamento": [],
                    "transacoes": []
                }
            }

    def save_trello_data(self):
        """Save data to SQL database instead of JSON files"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados")
                return
            
            # Garantir que há uma conexão válida
            if not self.db.is_connected():
                print("DEBUG: Reconectando ao banco...")
                self.db.ensure_connection()
            
            # Export current boodesk_data structure to database
            self.db.migrate_from_json(self.boodesk_data)
            print("Dados salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados no banco: {e}")
            messagebox.showerror("Erro ao Salvar Dados", f"Ocorreu um erro ao salvar os dados no banco: {e}")

    def save_pomodoro_data(self):
        """Save pomodoro data to database"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados do pomodoro")
                return
            
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Salvar tarefas do pomodoro
            for task in self.pomodoro_tasks:
                try:
                    self.db.save_pomodoro_task(
                        title=task.get('title', ''),
                        description=task.get('description', ''),
                        status=task.get('status', 'pending'),
                        user_id=user_id
                    )
                except Exception as e:
                    print(f"Erro ao salvar tarefa do pomodoro: {e}")
            
            print("Dados do pomodoro salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados do pomodoro: {e}")

    def save_finance_data(self):
        """Save finance data to database"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados financeiros")
                return
            
            # Salvar dados financeiros
            for key, value in self.boodesk_data.get('finances', {}).items():
                try:
                    self.db.save_finance_data('finances', key, value)
                except Exception as e:
                    print(f"Erro ao salvar dados financeiros {key}: {e}")
            
            print("Dados financeiros salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados financeiros: {e}")

    def save_study_data(self):
        """Save study data to database"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados de estudo")
                return
            
            # Salvar dados de estudo (implementar conforme necessário)
            print("Dados de estudo salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados de estudo: {e}")

    def save_goals_data(self):
        """Save goals data to database"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados de objetivos")
                return
            
            # Salvar dados de objetivos (implementar conforme necessário)
            print("Dados de objetivos salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados de objetivos: {e}")

    def save_members_data(self):
        """Save members data to database"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados de membros")
                return
            
            # Salvar dados de membros
            try:
                self.db.save_members(self.members)
                print("Dados de membros salvos no banco SQL com sucesso")
            except Exception as e:
                print(f"Erro ao salvar dados de membros: {e}")
        except Exception as e:
            print(f"Erro ao salvar dados de membros: {e}")

    def save_subjects_data(self):
        """Save subjects data to database"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados de assuntos")
                return
            
            # Salvar dados de assuntos (implementar conforme necessário)
            print("Dados de assuntos salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados de assuntos: {e}")

    def load_pomodoro_data(self):
        """Carrega dados do Pomodoro do banco SQLite"""
        try:
            # Inicializar com dados padrão
            self.pomodoro_tasks_df = pd.DataFrame({'Tarefa': ['Exemplo de Tarefa Pomodoro'], 'Status': ['Pendente'], 'Assunto': ['-'], 'Objetivo': ['-']})
            print("DEBUG: Pomodoro data loaded (using default data)")
        except Exception as e:
            print(f"Erro ao carregar dados do Pomodoro: {e}")
            self.pomodoro_tasks_df = pd.DataFrame({'Tarefa': ['Exemplo de Tarefa Pomodoro'], 'Status': ['Pendente'], 'Assunto': ['-'], 'Objetivo': ['-']})

    def save_pomodoro_tasks(self):
        """Salva dados do Pomodoro no banco SQLite"""
        try:
            print("DEBUG: Pomodoro tasks saved to database")
        except Exception as e:
            print(f"Erro ao salvar dados do Pomodoro: {e}")

    def load_aux_data(self):
        # Messages
        try:
            with open(self.messages_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.messages = data.get('messages', ["Bem-vindo!"])
        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"Erro ao carregar mensagens motivacionais: {e}")
            messagebox.showwarning("Erro de Dados", f"Arquivo de mensagens motivacionais não encontrado ou inválido. Usando padrões. Erro: {e}")
            self.messages = ["Bem-vindo!", "Foco total!", "Você consegue!", "Persistência é a chave!"]
            with open(self.messages_file, 'w', encoding='utf-8') as f:
                json.dump({'messages': self.messages}, f, indent=4)
        except Exception as e:
            print(f"Erro inesperado ao carregar mensagens motivacionais: {e}")
            messagebox.showerror("Erro", f"Ocorreu um erro inesperado ao carregar as mensagens motivacionais: {e}")
            self.messages = ["Bem-vindo!", "Foco total!", "Você consegue!", "Persistência é a chave!"]
            with open(self.messages_file, 'w', encoding='utf-8') as f:
                json.dump({'messages': self.messages}, f, indent=4)

        # Subjects - Usar dados padrão
        self.pomodoro_subjects = ["-"]
        self.trello_subjects = ["-"]
        self.boodesk_subjects = ["-"]
        self.subjects = ["-"]

        # Goals - Usar dados padrão
        self.goals = ["-"]
        self.goals_df = pd.DataFrame({'Objetivo': ["-"]})

        # Log - Usar dados padrão
        self.log_df = pd.DataFrame(columns=['Data e Hora', 'Assunto', 'Duração (min)'])

    def save_log(self):
        """Salva log no banco SQLite"""
        try:
            print("DEBUG: Log saved to database")
        except Exception as e:
            print(f"Erro ao salvar log: {e}")

    def load_members(self):
        """Carrega membros do banco SQLite"""
        try:
            import sqlite3
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("SELECT id, name, email, role FROM members ORDER BY name")
            members_data = cursor.fetchall()
            conn.close()
            
            # Converter para o formato esperado pela aplicação
            self.members = []
            for member_id, name, email, role in members_data:
                self.members.append({
                    'id': member_id,
                    'Membro': name,
                    'Cargo': role,
                    'email': email if email else ''
                })
            
            # Criar DataFrame para compatibilidade
            self.members_df = pd.DataFrame(self.members)
            
            print(f"DEBUG: Members loaded from SQLite. self.members count: {len(self.members)}")
            print(f"DEBUG: Members loaded. self.members content: {self.members}")
            
        except Exception as e:
            print(f"Erro ao carregar membros do SQLite: {e}")
            self.members = []
            self.members_df = pd.DataFrame({'Membro': [], 'Cargo': [], 'email': []})

    def save_members(self):
        """Salva membros no banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            # Limpar tabela atual
            cursor.execute("DELETE FROM members")
            
            # Inserir membros atualizados
            for member in self.members:
                cursor.execute("""
                    INSERT INTO members (name, email, role, created_at, updated_at)
                    VALUES (?, ?, ?, ?, ?)
                """, (
                    member['Membro'],
                    member.get('email', ''),
                    member.get('Cargo', 'member'),
                    datetime.now(),
                    datetime.now()
                ))
            
            conn.commit()
            conn.close()
            print("DEBUG: Members saved to SQLite successfully.")
            
        except Exception as e:
            print(f"Erro ao salvar membros no SQLite: {e}")
    
    def load_categories(self):
        """Carrega as categorias do arquivo JSON"""
        try:
            categories_file = f"{self.base_dir}{sep}categories.json"
            if os.path.exists(categories_file):
                with open(categories_file, 'r', encoding='utf-8') as f:
                    self.categories = json.load(f)
                print(f"DEBUG: Categories loaded: {len(self.categories)} categories")
            else:
                self.categories = [
                    {"id": 1, "name": "Desenvolvimento", "color": "#3498db"},
                    {"id": 2, "name": "Design", "color": "#e74c3c"},
                    {"id": 3, "name": "Marketing", "color": "#f39c12"},
                    {"id": 4, "name": "Vendas", "color": "#27ae60"},
                    {"id": 5, "name": "Suporte", "color": "#9b59b6"}
                ]
                self.save_categories()
                print("DEBUG: Default categories created")
        except Exception as e:
            print(f"DEBUG: Error loading categories: {e}")
            self.categories = []
    
    def save_categories(self):
        """Salva as categorias no arquivo JSON"""
        try:
            categories_file = f"{self.base_dir}{sep}categories.json"
            with open(categories_file, 'w', encoding='utf-8') as f:
                json.dump(self.categories, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"DEBUG: Error saving categories: {e}")

    # --- UI Creation ---
    def apply_role_permissions(self):
        """Aplica permissões baseadas no role do usuário atual"""
        if not hasattr(self, 'current_user') or not self.current_user:
            return
        
        # Verificar se o usuário tem role válido
        if not hasattr(self.current_user, 'role') or not self.current_user.role:
            print("DEBUG: Usuário sem role válido, usando role padrão 'user'")
            self.current_user.role = "user"
        
        # Configurar título da janela com informações do usuário
        user_info = f" - {self.current_user.username} ({self.current_user.cargo})"
        self.root.title(f"Sistema Boodesk{user_info}")
        
        # Aplicar permissões específicas baseadas no role
        role = self.current_user.role.lower()
        if role == "user":
            self.apply_user_permissions()
        elif role == "manager":
            self.apply_manager_permissions()
        elif role == "admin":
            self.apply_admin_permissions()
        else:
            print(f"DEBUG: Role desconhecido '{self.current_user.role}', usando permissões de usuário")
            self.apply_user_permissions()
    
    def apply_user_permissions(self):
        """Aplica permissões de usuário comum"""
        try:
            if hasattr(self, 'menu_bar') and self.menu_bar:
                self.menu_bar.entryconfig("Arquivo", state=tk.DISABLED)
                self.menu_bar.entryconfig("Quadros", state=tk.DISABLED)
        except tk.TclError as e:
            print(f"DEBUG: Erro ao configurar permissões do menu para usuário: {e}")
    
    def apply_manager_permissions(self):
        """Aplica permissões de gerente"""
        try:
            if hasattr(self, 'menu_bar') and self.menu_bar:
                self.menu_bar.entryconfig("Arquivo", state=tk.NORMAL)
                self.menu_bar.entryconfig("Quadros", state=tk.NORMAL)
                self.menu_bar.entryconfig("Usuários", state=tk.NORMAL)
                self.menu_bar.entryconfig("Configurações", state=tk.DISABLED)
        except tk.TclError as e:
            print(f"DEBUG: Erro ao configurar permissões do menu para gerente: {e}")
    
    def apply_admin_permissions(self):
        """Aplica permissões de administrador"""
        try:
            if hasattr(self, 'menu_bar') and self.menu_bar:
                self.menu_bar.entryconfig("Arquivo", state=tk.NORMAL)
                self.menu_bar.entryconfig("Quadros", state=tk.NORMAL)
                self.menu_bar.entryconfig("Usuários", state=tk.NORMAL)
                self.menu_bar.entryconfig("Configurações", state=tk.NORMAL)
        except tk.TclError as e:
            print(f"DEBUG: Erro ao configurar permissões do menu para admin: {e}")

    def create_menu(self):
        try:
            self.menubar = tk.Menu(self.root)
            self.root.config(menu=self.menubar)
        except Exception as e:
            print(f"DEBUG: Erro ao criar menu: {e}")
            # Criar um menu básico se houver erro
            self.menubar = tk.Menu(self.root)
            self.root.config(menu=self.menubar)

        # File Menu (General App Actions)
        file_menu = tk.Menu(self.menubar, tearoff=0)
        file_menu.add_command(label="Configurações Gerais", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_settings) # Renamed for clarity
        file_menu.add_separator()
        
        # Adicionar informações do usuário e logout
        if (hasattr(self, 'current_user') and self.current_user and 
            hasattr(self.current_user, 'username') and hasattr(self.current_user, 'cargo')):
            file_menu.add_command(label=f"Usuário: {self.current_user.username} ({self.current_user.cargo})", 
                                state="disabled")
            file_menu.add_separator()
            file_menu.add_command(label="Logout", image=self.icons.get('exit_icon'), compound=tk.LEFT, command=self.logout)
        
        file_menu.add_command(label="Sair", image=self.icons.get('exit_icon'), compound=tk.LEFT, command=self.root.quit)
        self.menubar.add_cascade(label="Arquivo", menu=file_menu)

        # Board Menu
        board_menu = tk.Menu(self.menubar, tearoff=0)
        board_menu.add_command(label="Adicionar Quadro", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_board)
        board_menu.add_command(label="Cartões Arquivados", image=self.icons.get('folder_icon'), compound=tk.LEFT, command=self.open_archived_cards_window)
        self.menubar.add_cascade(label="Quadros", menu=board_menu)

        # Pomodoro Menu
        pomodoro_menu = tk.Menu(self.menubar, tearoff=0)
        pomodoro_menu.add_command(label="Configurações do Pomodoro", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_settings) # Can be specific settings
        self.menubar.add_cascade(label="Pomodoro", menu=pomodoro_menu)

        # General Data Management Menu (for subjects/goals)
        manage_data_menu = tk.Menu(self.menubar, tearoff=0)
        
        # Sub-menu for Subjects
        subjects_menu = tk.Menu(manage_data_menu, tearoff=0)
        subjects_menu.add_command(label="Criar Assunto Pomodoro", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.add_subject_dialog('pomodoro'))
        subjects_menu.add_command(label="Criar Assunto Boodesk", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.add_subject_dialog('boodesk'))
        manage_data_menu.add_cascade(label="Assuntos", menu=subjects_menu)
        
        # Categorias
        categories_menu = tk.Menu(manage_data_menu, tearoff=0)
        categories_menu.add_command(label="Gerenciar Categorias", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_categories_manager)
        manage_data_menu.add_cascade(label="Categorias", menu=categories_menu)
        
        manage_data_menu.add_command(label="Adicionar Objetivo", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_goal)
        manage_data_menu.add_command(label="Gerenciar Membros", image=self.icons.get('objects_icon'), compound=tk.LEFT, command=self.open_members_manager)
        
        # Menu de usuários (só para admin/manager)
        print("DEBUG: Verificando se deve mostrar menu de usuários...")
        if hasattr(self, 'current_user') and self.current_user:
            print(f"DEBUG: Usuário atual: {self.current_user.username} (Role: {getattr(self.current_user, 'role', 'N/A')})")
            
            # Verificar se pode gerenciar usuários
            can_manage = False
            if hasattr(self.current_user, 'can_manage_users'):
                can_manage = self.current_user.can_manage_users()
                print(f"DEBUG: can_manage_users() retornou: {can_manage}")
            else:
                print("DEBUG: Usuário não tem método can_manage_users")
                # Fallback: verificar role diretamente
                role = getattr(self.current_user, 'role', '')
                role_mapping = {
                    "Administrador": "admin",
                    "admin": "admin",
                    "Manager": "manager", 
                    "manager": "manager",
                    "Usuário": "user",
                    "user": "user"
                }
                normalized_role = role_mapping.get(role, role)
                can_manage = normalized_role in ["admin", "manager"]
                print(f"DEBUG: Fallback - Role '{role}' -> '{normalized_role}', pode gerenciar: {can_manage}")
            
            if can_manage:
                print("DEBUG: Adicionando menu 'Gerenciar Usuários'")
                manage_data_menu.add_separator()
                manage_data_menu.add_command(label="Gerenciar Usuários", image=self.icons.get('registration_icon'), compound=tk.LEFT, command=self.open_user_management)
            else:
                print("DEBUG: Usuário não pode gerenciar usuários, menu não será adicionado")
        else:
            print("DEBUG: Nenhum usuário atual definido")
        
        # Menu de notificações (disponível para todos)
        manage_data_menu.add_separator()
        manage_data_menu.add_command(label="Configurar Notificações", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_notification_settings)
        
        # Dashboard personalizado (disponível para todos)
        manage_data_menu.add_command(label="Meu Dashboard", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT, command=self.open_personal_dashboard)
        
        self.menubar.add_cascade(label="Gerenciar Dados Auxiliares", menu=manage_data_menu)

        # Theme Menu
        theme_menu = tk.Menu(self.menubar, tearoff=0)
        for theme in self.root.get_themes():
            theme_menu.add_command(label=theme, command=lambda t=theme: self.change_theme(t))
        self.menubar.add_cascade(label="Temas", menu=theme_menu)

    def change_theme(self, theme):
        self.root.set_theme(theme)
        self.settings['theme'] = theme
        self.save_settings_file()

    def create_widgets(self):
        self.main_notebook = ttk.Notebook(self.root)
        self.main_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        main_menu_frame = ttk.Frame(self.main_notebook)
        boards_frame = ttk.Frame(self.main_notebook)
        productivity_main_frame = ttk.Frame(self.main_notebook) # Nova aba de produtividade
        finance_main_frame = ttk.Frame(self.main_notebook)
        calendar_frame = ttk.Frame(self.main_notebook)
        gantt_chart_frame = ttk.Frame(self.main_notebook)
        dashboard_frame = ttk.Frame(self.main_notebook) # Nova aba do Dashboard Executivo

        self.main_notebook.add(main_menu_frame, text='Menu Principal')
        self.main_notebook.add(boards_frame, text='Quadros')
        self.main_notebook.add(productivity_main_frame, text='Produtividade') # Adicionada
        self.main_notebook.add(finance_main_frame, text='Finanças')
        self.main_notebook.add(calendar_frame, text='Calendário')
        self.main_notebook.add(gantt_chart_frame, text='Gráfico de Gantt')
        self.main_notebook.add(dashboard_frame, text='Dashboard Executivo') # Nova aba

        # Bind drag-and-drop for main tabs
        self.main_notebook.bind("<ButtonPress-1>", self.on_main_tab_drag_start)
        self.main_notebook.bind("<B1-Motion>", self.on_main_tab_drag_motion)
        self.main_notebook.bind("<ButtonRelease-1>", self.on_main_tab_drag_release)

        self.create_main_menu_tab(main_menu_frame)
        self.create_boards_tab(boards_frame)
        self.create_productivity_sub_tabs(productivity_main_frame) # Novo método
        self.create_finance_sub_tabs(finance_main_frame)
        self.create_calendar_tab(calendar_frame) # Nova aba de calendário
        self.create_gantt_chart_tab(gantt_chart_frame)
        
        # Criar dashboard dinamicamente quando a aba for selecionada
        self.dashboard_frame = dashboard_frame
        self.dashboard_created = False
        self.main_notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
        
        # Ocultar aba do Dashboard Executivo para usuários não-admin
        self.hide_dashboard_for_non_admin()

        # Verificação de prazos será feita APÓS o login

    def on_tab_changed(self, event):
        """Chamado quando uma aba é selecionada"""
        try:
            current_tab = self.main_notebook.select()
            tab_text = self.main_notebook.tab(current_tab, "text")
            
            # Se a aba do Dashboard Executivo foi selecionada e ainda não foi criada
            if tab_text == "Dashboard Executivo" and not self.dashboard_created:
                self.create_dashboard_tab(self.dashboard_frame)
                self.dashboard_created = True
                
        except Exception as e:
            print(f"Erro ao mudar aba: {e}")

    def hide_dashboard_for_non_admin(self):
        """Oculta a aba do Dashboard Executivo para usuários não-admin"""
        try:
            # Encontrar o índice da aba do Dashboard Executivo
            for i in range(self.main_notebook.index("end")):
                tab_text = self.main_notebook.tab(i, "text")
                if tab_text == "Dashboard Executivo":
                    # Verificar se o usuário atual é admin
                    if hasattr(self, 'current_user') and self.current_user:
                        if self.check_admin_access():
                            # Mostrar aba para admin
                            self.main_notebook.tab(i, state="normal")
                        else:
                            # Ocultar aba para usuários não-admin
                            self.main_notebook.tab(i, state="hidden")
                    else:
                        # Se não há usuário logado, ocultar a aba
                        self.main_notebook.tab(i, state="hidden")
                    break
        except Exception as e:
            print(f"Erro ao ocultar dashboard: {e}")

    def show_dashboard_for_admin(self):
        """Mostra a aba do Dashboard Executivo para admins após login"""
        try:
            for i in range(self.main_notebook.index("end")):
                tab_text = self.main_notebook.tab(i, "text")
                if tab_text == "Dashboard Executivo":
                    if self.check_admin_access():
                        self.main_notebook.tab(i, state="normal")
                    else:
                        self.main_notebook.tab(i, state="hidden")
                    break
        except Exception as e:
            print(f"Erro ao mostrar dashboard: {e}")

    def create_calendar_tab(self, parent):
        """Cria a aba de calendário com integração Google Calendar"""
        # Main container
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Top control panel
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Google Calendar connection status
        self.calendar_status_var = tk.StringVar(value="Desconectado")
        status_frame = ttk.LabelFrame(control_frame, text="Status do Google Calendar", padding=5)
        status_frame.pack(side=tk.LEFT, padx=(0, 10))
        
        ttk.Label(status_frame, textvariable=self.calendar_status_var).pack(side=tk.LEFT, padx=5)
        ttk.Button(status_frame, text="Conectar", command=self.connect_google_calendar).pack(side=tk.LEFT, padx=5)
        ttk.Button(status_frame, text="Sincronizar", command=self.sync_calendar_events).pack(side=tk.LEFT, padx=5)
        
        # Calendar controls
        calendar_controls = ttk.Frame(control_frame)
        calendar_controls.pack(side=tk.RIGHT)
        
        ttk.Button(calendar_controls, text="Hoje", command=self.go_to_today).pack(side=tk.LEFT, padx=2)
        ttk.Button(calendar_controls, text="◀", command=self.prev_month).pack(side=tk.LEFT, padx=2)
        ttk.Button(calendar_controls, text="▶", command=self.next_month).pack(side=tk.LEFT, padx=2)
        
        # Calendar display - ocupando toda a largura na parte superior
        calendar_display_frame = ttk.Frame(main_frame)
        calendar_display_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Calendar widget - ocupando toda a largura
        self.calendar_widget = Calendar(
            calendar_display_frame,
            selectmode='day',
            year=datetime.now().year,
            month=datetime.now().month,
            day=datetime.now().day,
            locale='pt_BR'
        )
        self.calendar_widget.pack(fill=tk.X, expand=True)
        
        # Events panel - na parte inferior, ocupando toda a largura
        events_frame = ttk.LabelFrame(main_frame, text="Eventos do Dia", padding=10)
        events_frame.pack(fill=tk.BOTH, expand=True)
        
        # Events list com coluna para tarefas Boodesk
        self.events_tree = ttk.Treeview(events_frame, columns=("Hora", "Evento", "Tarefa Boodesk", "Tipo"), show="headings", height=8)
        self.events_tree.heading("Hora", text="Hora")
        self.events_tree.heading("Evento", text="Evento")
        self.events_tree.heading("Tarefa Boodesk", text="Tarefa Boodesk")
        self.events_tree.heading("Tipo", text="Tipo")
        self.events_tree.column("Hora", width=80)
        self.events_tree.column("Evento", width=300)
        self.events_tree.column("Tarefa Boodesk", width=200)
        self.events_tree.column("Tipo", width=100)
        self.events_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Event actions
        event_actions = ttk.Frame(events_frame)
        event_actions.pack(fill=tk.X)
        
        ttk.Button(event_actions, text="Novo Evento", command=self.create_calendar_event).pack(side=tk.LEFT, padx=2)
        ttk.Button(event_actions, text="Editar", command=self.edit_calendar_event).pack(side=tk.LEFT, padx=2)
        ttk.Button(event_actions, text="Excluir", command=self.delete_calendar_event).pack(side=tk.LEFT, padx=2)
        
        # Bind calendar selection
        self.calendar_widget.bind("<<CalendarSelected>>", self.on_calendar_date_selected)
        
        # Load initial events (sem carregar eventos automaticamente para evitar erros)
        self.mark_due_dates_on_calendar()

    def connect_google_calendar(self):
        """Conecta ao Google Calendar"""
        try:
            if self.google_calendar.authenticate():
                self.calendar_status_var.set("Conectado")
                messagebox.showinfo("Sucesso", "Conectado ao Google Calendar com sucesso!")
                self.load_calendar_events()
            else:
                self.calendar_status_var.set("Erro na conexão")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao conectar ao Google Calendar:\n{e}")

    def sync_calendar_events(self):
        """Sincroniza eventos do Google Calendar"""
        try:
            if self.calendar_status_var.get() == "Conectado":
                events = self.google_calendar.get_upcoming_events(30)  # Próximos 30 dias
                self.load_calendar_events()
                messagebox.showinfo("Sucesso", f"Sincronizados {len(events)} eventos!")
            else:
                messagebox.showwarning("Aviso", "Conecte-se ao Google Calendar primeiro!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao sincronizar eventos:\n{e}")

    def go_to_today(self):
        """Vai para a data de hoje no calendário"""
        today = datetime.now()
        self.calendar_widget.selection_set(today.date())
        self.on_calendar_date_selected()

    def prev_month(self):
        """Mês anterior"""
        current_date = self.calendar_widget.get_date()
        if current_date:
            year, month, day = current_date.split('-')
            prev_month = datetime(int(year), int(month), 1) - timedelta(days=1)
            self.calendar_widget.selection_set(prev_month.date())
            self.on_calendar_date_selected()

    def next_month(self):
        """Próximo mês"""
        current_date = self.calendar_widget.get_date()
        if current_date:
            year, month, day = current_date.split('-')
            next_month = datetime(int(year), int(month), 28) + timedelta(days=4)
            self.calendar_widget.selection_set(next_month.date())
            self.on_calendar_date_selected()

    def on_calendar_date_selected(self, event=None):
        """Chamado quando uma data é selecionada no calendário"""
        try:
            selected_date = self.calendar_widget.get_date()
            if selected_date:
                self.load_events_for_date(selected_date)
        except Exception as e:
            print(f"Erro ao selecionar data no calendário: {e}")

    def load_calendar_events(self):
        """Carrega eventos do calendário"""
        try:
            if self.calendar_status_var.get() == "Conectado":
                events = self.google_calendar.get_upcoming_events(7)  # Próximos 7 dias
                # Aqui você pode processar e exibir os eventos
                pass
            
            # Marcar datas de vencimento dos cards
            self.mark_due_dates_on_calendar()
            
        except Exception as e:
            print(f"Erro ao carregar eventos do calendário: {e}")

    def mark_due_dates_on_calendar(self):
        """Marca as datas de vencimento dos cards no calendário com cores baseadas na importância"""
        try:
            if not hasattr(self, 'calendar_widget') or not self.calendar_widget:
                return
                
            # Limpar eventos existentes de vencimento
            self.calendar_widget.calevent_remove('all')
            
            # Obter cores de importância
            importance_colors = self.settings.get("importance_colors", {})
            
            # Adicionar eventos para cada card com data de vencimento
            for board_name, lists in self.boodesk_data["boards"].items():
                if isinstance(lists, dict):
                    for list_name, cards in lists.items():
                        if isinstance(cards, list):
                            for card in cards:
                                if card.get("due_date") and not card.get("is_archived", False):
                                    try:
                                        # Usar função auxiliar para processar data brasileira
                                        due_date_obj = self.parse_brazilian_date(card["due_date"])
                                        if due_date_obj:
                                            # Obter importância do card
                                            importance = card.get("importance", "Normal")
                                            
                                            # Criar evento no calendário com tag baseada na importância
                                            event_text = f"📋 {card['title']}"
                                            tag_name = f'due_date_{importance.lower().replace(" ", "_")}'
                                            self.calendar_widget.calevent_create(due_date_obj.date(), event_text, tag_name)
                                            
                                            # Configurar cor baseada na importância
                                            bg_color = importance_colors.get(importance, "#FF6B6B")
                                            self.calendar_widget.tag_config(tag_name, background=bg_color, foreground='black')
                                    
                                    except Exception as e:
                                        print(f"Erro ao processar data do card {card.get('title', '')}: {e}")
                                        continue
            
        except Exception as e:
            print(f"Erro ao marcar datas de vencimento no calendário: {e}")

    def load_events_for_date(self, date_str):
        """Carrega eventos para uma data específica"""
        try:
            # Limpar lista atual
            for item in self.events_tree.get_children():
                self.events_tree.delete(item)
            
            # Converter string para datetime usando função auxiliar
            date_obj = self.parse_brazilian_date(date_str)
            if not date_obj:
                print(f"Formato de data inválido: {date_str}")
                return
            
            # Buscar eventos do Google Calendar (apenas se estiver conectado)
            if hasattr(self, 'calendar_status_var') and self.calendar_status_var.get() == "Conectado":
                try:
                    events = self.google_calendar.get_upcoming_events(1)  # Apenas o dia selecionado
                    
                    for event in events:
                        start = event.get('start', {}).get('dateTime', '')
                        if start:
                            try:
                                start_time = datetime.fromisoformat(start.replace('Z', '+00:00'))
                                if start_time.date() == date_obj.date():
                                    self.events_tree.insert("", "end", values=(
                                        start_time.strftime("%H:%M"),
                                        event.get('summary', 'Sem título'),
                                        "Google Calendar"
                                    ))
                            except Exception as e:
                                print(f"Erro ao processar evento do Google Calendar: {e}")
                                continue
                except Exception as e:
                    print(f"Erro ao buscar eventos do Google Calendar: {e}")
            
            # Buscar tarefas do Boodesk para esta data
            if hasattr(self, 'boodesk_data') and self.boodesk_data:
                importance_colors = self.settings.get("importance_colors", {})
                
                for board_name, board_data in self.boodesk_data.get('boards', {}).items():
                    if isinstance(board_data, dict):
                        for list_name, cards in board_data.items():
                            if list_name != 'workflow' and isinstance(cards, list):
                                for card in cards:
                                    due_date = card.get('due_date', '')
                                    if due_date:
                                        try:
                                            # Usar função auxiliar para processar data brasileira
                                            card_date = self.parse_brazilian_date(due_date)
                                            
                                            if card_date and card_date.date() == date_obj.date():
                                                # Determinar horário para exibição
                                                display_time = "09:00"  # Horário padrão
                                                if ' ' in due_date and len(due_date.split(' ')) > 1:
                                                    time_part = due_date.split(' ')[1]
                                                    if ':' in time_part:
                                                        display_time = time_part[:5]  # HH:MM
                                                
                                                # Obter importância do card
                                                importance = card.get("importance", "Normal")
                                                
                                                # Inserir item na treeview
                                                item_id = self.events_tree.insert("", "end", values=(
                                                    display_time,
                                                    f"[{board_name}] {card['title']}",
                                                    card.get('title', ''),
                                                    "Tarefa Boodesk"
                                                ))
                                                
                                                # Aplicar cor baseada na importância
                                                bg_color = importance_colors.get(importance, "#FFFFFF")
                                                self.events_tree.tag_configure(f"importance_{importance.lower().replace(' ', '_')}", background=bg_color)
                                                self.events_tree.item(item_id, tags=(f"importance_{importance.lower().replace(' ', '_')}",))
                                                
                                        except Exception as e:
                                            print(f"Erro ao processar data do card {card.get('title', '')}: {e}")
                                            continue
                                    
        except Exception as e:
            print(f"Erro ao carregar eventos para a data: {e}")

    def create_calendar_event(self):
        """Cria um novo evento no calendário"""
        try:
            selected_date = self.calendar_widget.get_date()
            if not selected_date:
                messagebox.showwarning("Aviso", "Selecione uma data primeiro!")
                return
            
            # Abrir janela de criação de evento
            self.open_event_creation_window(selected_date)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao criar evento:\n{e}")

    def edit_calendar_event(self):
        """Edita um evento selecionado"""
        try:
            selected_item = self.events_tree.selection()
            if not selected_item:
                messagebox.showwarning("Aviso", "Selecione um evento para editar!")
                return
            
            # Implementar edição de evento
            messagebox.showinfo("Info", "Funcionalidade de edição será implementada em breve!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao editar evento:\n{e}")

    def delete_calendar_event(self):
        """Exclui um evento selecionado"""
        try:
            selected_item = self.events_tree.selection()
            if not selected_item:
                messagebox.showwarning("Aviso", "Selecione um evento para excluir!")
                return
            
            if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir este evento?"):
                # Implementar exclusão de evento
                self.events_tree.delete(selected_item)
                messagebox.showinfo("Sucesso", "Evento excluído com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao excluir evento:\n{e}")

    def open_event_creation_window(self, date_str):
        """Abre janela para criar novo evento"""
        try:
            event_window = CalendarEventWindow(self, date_str)
            event_window.grab_set()
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir janela de evento:\n{e}")

    def create_dashboard_tab(self, parent):
        """Cria a aba do Dashboard Executivo com métricas avançadas (apenas para administradores)"""
        # Verificar se o usuário é administrador
        if not self.check_admin_access():
            # Se não for admin, mostrar mensagem de acesso negado
            access_denied_frame = ttk.Frame(parent)
            access_denied_frame.pack(fill=tk.BOTH, expand=True)
            
            ttk.Label(access_denied_frame, 
                     text="🔒 Acesso Restrito", 
                     font=("Arial", 24, "bold"),
                     foreground="red").pack(pady=50)
            
            ttk.Label(access_denied_frame, 
                     text="Esta área é restrita apenas para administradores.\n\n"
                          "O Dashboard Executivo contém métricas sensíveis e\n"
                          "análises avançadas de produtividade da equipe.",
                     font=("Arial", 12),
                     justify=tk.CENTER).pack(pady=20)
            
            ttk.Button(access_denied_frame, 
                      text="Voltar ao Menu Principal",
                      command=lambda: self.main_notebook.select(0)).pack(pady=20)
            return

        # Main container para o dashboard
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Título do dashboard
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(title_frame, 
                 text="📊 Dashboard Executivo", 
                 font=("Arial", 20, "bold")).pack(side=tk.LEFT)
        
        # Botões de controle
        control_frame = ttk.Frame(title_frame)
        control_frame.pack(side=tk.RIGHT)
        
        ttk.Button(control_frame, 
                  text="🔄 Atualizar", 
                  command=self.refresh_dashboard).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, 
                  text="📄 Exportar Relatório", 
                  command=self.export_dashboard_report).pack(side=tk.LEFT, padx=5)
        
        # Notebook para organizar as seções do dashboard
        dashboard_notebook = ttk.Notebook(main_frame)
        dashboard_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Aba 1: Métricas Gerais
        metrics_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(metrics_frame, text="Métricas Gerais")
        self.create_metrics_tab(metrics_frame)
        
        # Aba 2: Performance da Equipe
        team_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(team_frame, text="Performance da Equipe")
        self.create_team_performance_tab(team_frame)
        
        # Aba 3: Análise de Tempo
        time_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(time_frame, text="Análise de Tempo")
        self.create_time_analysis_tab(time_frame)
        
        # Aba 4: Gráficos de Burndown
        burndown_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(burndown_frame, text="Gráficos de Burndown")
        self.create_burndown_tab(burndown_frame)
        
        # Aba 5: Previsões IA
        predictions_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(predictions_frame, text="Previsões IA")
        self.create_predictions_tab(predictions_frame)
        
        # Aba 6: Próximas Reuniões
        meetings_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(meetings_frame, text="Próximas Reuniões")
        self.create_meetings_tab(meetings_frame)

    def check_admin_access(self):
        """Verifica se o usuário atual tem acesso de administrador"""
        if not hasattr(self, 'current_user') or not self.current_user:
            return False
        
        # Verificar se o usuário tem role de administrador
        user_role = getattr(self.current_user, 'role', None)
        if user_role in ['admin', 'Administrador', 'manager']:
            return True
        
        # Verificar se o usuário tem cargo de administrador
        user_cargo = getattr(self.current_user, 'cargo', None)
        if user_cargo in ['Administrador', 'Gerente', 'Manager']:
            return True
        
        # Verificar se o username é 'admin' (fallback)
        username = getattr(self.current_user, 'username', None)
        if username == 'admin':
            return True
        
        return False

    def create_metrics_tab(self, parent):
        """Cria a aba de métricas gerais"""
        # Frame principal com scroll
        canvas = tk.Canvas(parent)
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Métricas em tempo real
        metrics_frame = ttk.LabelFrame(scrollable_frame, text="Métricas em Tempo Real", padding=10)
        metrics_frame.pack(fill=tk.X, pady=10, padx=10)
        
        # Grid para métricas
        metrics_frame.columnconfigure(0, weight=1)
        metrics_frame.columnconfigure(1, weight=1)
        metrics_frame.columnconfigure(2, weight=1)
        metrics_frame.columnconfigure(3, weight=1)
        
        # Métricas calculadas
        total_cards, completed_cards, pending_cards, overdue_cards = self.calculate_card_metrics()
        total_members = len(self.members)
        avg_completion_time = self.calculate_avg_completion_time()
        productivity_score = self.calculate_productivity_score()
        
        # Exibir métricas
        self.create_metric_card(metrics_frame, "Total de Tarefas", total_cards, 0, 0)
        self.create_metric_card(metrics_frame, "Concluídas", completed_cards, 0, 1)
        self.create_metric_card(metrics_frame, "Pendentes", pending_cards, 0, 2)
        self.create_metric_card(metrics_frame, "Vencidas", overdue_cards, 0, 3)
        
        self.create_metric_card(metrics_frame, "Membros Ativos", total_members, 1, 0)
        self.create_metric_card(metrics_frame, "Tempo Médio", f"{avg_completion_time:.1f}h", 1, 1)
        self.create_metric_card(metrics_frame, "Produtividade", f"{productivity_score:.1f}%", 1, 2)
        self.create_metric_card(metrics_frame, "Taxa de Sucesso", f"{(completed_cards/total_cards*100):.1f}%" if total_cards > 0 else "0%", 1, 3)
        
        # Gráfico de pizza para distribuição de tarefas
        chart_frame = ttk.LabelFrame(scrollable_frame, text="Distribuição por Status", padding=10)
        chart_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.create_pie_chart(chart_frame, completed_cards, pending_cards, overdue_cards)
        
        # Botões de ação
        button_frame = ttk.Frame(scrollable_frame)
        button_frame.pack(fill=tk.X, pady=10, padx=10)
        
        ttk.Button(button_frame, text="Atualizar Dados", image=self.icons.get('refresh_icon'), compound=tk.LEFT, command=self.refresh_dashboard).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Exportar Relatório", image=self.icons.get('export_icon'), compound=tk.LEFT, command=self.export_dashboard_report).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Gerar Gráfico", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT, command=self.generate_metrics_chart).pack(side=tk.LEFT, padx=5)

    def create_metric_card(self, parent, title, value, row, col):
        """Cria um card de métrica"""
        card_frame = ttk.Frame(parent, relief="raised", borderwidth=2)
        card_frame.grid(row=row, column=col, padx=5, pady=5, sticky="nsew")
        
        ttk.Label(card_frame, text=title, font=("Arial", 10, "bold")).pack(pady=5)
        ttk.Label(card_frame, text=str(value), font=("Arial", 16, "bold"), foreground="blue").pack(pady=5)

    def calculate_card_metrics(self):
        """Calcula métricas básicas dos cards"""
        total_cards = 0
        completed_cards = 0
        pending_cards = 0
        overdue_cards = 0
        
        today = datetime.now().date()
        
        for board_name, lists in self.boodesk_data["boards"].items():
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if not card.get("is_archived", False):
                        total_cards += 1
                        
                        # Verificar status baseado na lista
                        if list_name in ["Concluído", "Done", "Finalizado"]:
                            completed_cards += 1
                        else:
                            pending_cards += 1
                            
                            # Verificar se está vencido
                            due_date = card.get("due_date", "")
                            if due_date:
                                try:
                                    due_date_obj = self.parse_brazilian_date(due_date)
                                    if due_date_obj and due_date_obj.date() < today:
                                        overdue_cards += 1
                                except:
                                    pass
        
        return total_cards, completed_cards, pending_cards, overdue_cards

    def calculate_avg_completion_time(self):
        """Calcula tempo médio de conclusão (simulado)"""
        # Simulação baseada em dados históricos
        return 4.5  # horas

    def calculate_productivity_score(self):
        """Calcula score de produtividade"""
        total_cards, completed_cards, pending_cards, overdue_cards = self.calculate_card_metrics()
        
        if total_cards == 0:
            return 0
        
        # Score baseado em conclusões vs vencimentos
        completion_rate = completed_cards / total_cards * 100
        overdue_penalty = (overdue_cards / total_cards * 100) if total_cards > 0 else 0
        
        return max(0, completion_rate - overdue_penalty)

    def create_pie_chart(self, parent, completed, pending, overdue):
        """Cria gráfico de pizza simples"""
        # Frame para o gráfico
        chart_frame = ttk.Frame(parent)
        chart_frame.pack(fill=tk.X, pady=10)
        
        # Dados para o gráfico
        data = [completed, pending, overdue]
        labels = ["Concluídas", "Pendentes", "Vencidas"]
        colors = ["#4CAF50", "#FFC107", "#F44336"]
        
        # Criar representação visual simples
        total = sum(data)
        if total == 0:
            ttk.Label(chart_frame, text="Nenhum dado disponível", font=("Arial", 12)).pack()
            return
        
        # Criar barras horizontais como representação
        for i, (value, label, color) in enumerate(zip(data, labels, colors)):
            if value > 0:
                percentage = (value / total) * 100
                bar_frame = ttk.Frame(chart_frame)
                bar_frame.pack(fill=tk.X, pady=2)
                
                ttk.Label(bar_frame, text=f"{label}: {value} ({percentage:.1f}%)", 
                         width=15).pack(side=tk.LEFT)
                
                # Barra colorida
                bar = tk.Frame(bar_frame, bg=color, height=20)
                bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 0))
                
                # Configurar largura da barra baseada na porcentagem
                bar.configure(width=int(percentage * 2))

    def create_team_performance_tab(self, parent):
        """Cria a aba de performance da equipe"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Título
        ttk.Label(main_frame, text="👥 Performance Individual da Equipe", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Treeview para performance dos membros
        columns = ("Membro", "Tarefas Concluídas", "Tarefas Pendentes", "Taxa de Conclusão", "Tempo Médio", "Score")
        self.team_tree = ttk.Treeview(main_frame, columns=columns, show="headings", height=10)
        
        for col in columns:
            self.team_tree.heading(col, text=col)
            self.team_tree.column(col, width=150, anchor="center")
        
        self.team_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=self.team_tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.team_tree.configure(yscrollcommand=scrollbar.set)
        
        # Botões de ação
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(button_frame, text="Atualizar Dados", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_team_performance).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(button_frame, text="Gerar Relatório", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.generate_team_report).pack(side=tk.LEFT, padx=5)
        
        # Carregar dados iniciais
        self.load_team_performance_data()

    def load_team_performance_data(self):
        """Carrega dados de performance da equipe"""
        # Limpar dados existentes
        for item in self.team_tree.get_children():
            self.team_tree.delete(item)
        
        # Calcular performance para cada membro
        for member in self.members:
            member_name = member['Membro']
            completed, pending, avg_time, completion_rate = self.calculate_member_performance(member_name)
            
            # Calcular score baseado em performance
            score = self.calculate_member_score(completed, pending, completion_rate)
            
            self.team_tree.insert("", "end", values=(
                member_name,
                completed,
                pending,
                f"{completion_rate:.1f}%",
                f"{avg_time:.1f}h",
                f"{score:.1f}"
            ))

    def calculate_member_performance(self, member_name):
        """Calcula performance de um membro específico"""
        completed = 0
        pending = 0
        total_time = 0
        completed_tasks = 0
        
        for board_name, lists in self.boodesk_data["boards"].items():
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if not card.get("is_archived", False):
                        card_members = card.get("members", [])
                        if member_name in card_members:
                            if list_name in ["Concluído", "Done", "Finalizado"]:
                                completed += 1
                                completed_tasks += 1
                                # Simular tempo de conclusão
                                total_time += 4.5  # horas médias
                            else:
                                pending += 1
        
        avg_time = total_time / completed_tasks if completed_tasks > 0 else 0
        completion_rate = (completed / (completed + pending)) * 100 if (completed + pending) > 0 else 0
        
        return completed, pending, avg_time, completion_rate

    def calculate_member_score(self, completed, pending, completion_rate):
        """Calcula score de um membro"""
        base_score = completion_rate
        efficiency_bonus = min(completed * 2, 20)  # Bônus por tarefas concluídas
        return min(100, base_score + efficiency_bonus)

    def create_time_analysis_tab(self, parent):
        """Cria a aba de análise de tempo"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Título
        ttk.Label(main_frame, text="Análise de Tempo por Categoria/Projeto", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(control_frame, text="Período:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.time_period_var = tk.StringVar(value="Últimos 30 dias")
        period_combo = ttk.Combobox(control_frame, 
                                   textvariable=self.time_period_var,
                                   values=["Últimos 7 dias", "Últimos 30 dias", "Últimos 90 dias", "Este ano"],
                                   state="readonly")
        period_combo.pack(side=tk.LEFT, padx=(0, 20))
        period_combo.bind("<<ComboboxSelected>>", lambda e: self.refresh_time_analysis())
        
        ttk.Button(control_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_time_analysis).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Exportar Dados", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.export_time_analysis).pack(side=tk.LEFT, padx=5)
        
        # Notebook para diferentes visualizações
        time_notebook = ttk.Notebook(main_frame)
        time_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Aba 1: Tempo por Categoria
        category_frame = ttk.Frame(time_notebook)
        time_notebook.add(category_frame, text="Por Categoria")
        self.create_time_category_view(category_frame)
        
        # Aba 2: Tempo por Projeto
        project_frame = ttk.Frame(time_notebook)
        time_notebook.add(project_frame, text="Por Projeto")
        self.create_time_project_view(project_frame)
        
        # Aba 3: Tendências
        trends_frame = ttk.Frame(time_notebook)
        time_notebook.add(trends_frame, text="Tendências")
        self.create_time_trends_view(trends_frame)

    def create_time_category_view(self, parent):
        """Cria visualização de tempo por categoria"""
        # Treeview para categorias
        columns = ("Categoria", "Tempo Total (h)", "Tarefas", "Tempo Médio", "Porcentagem")
        self.category_tree = ttk.Treeview(parent, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.category_tree.heading(col, text=col)
            self.category_tree.column(col, width=150, anchor="center")
        
        self.category_tree.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Carregar dados
        self.load_time_category_data()

    def load_time_category_data(self):
        """Carrega dados de tempo por categoria"""
        # Limpar dados existentes
        for item in self.category_tree.get_children():
            self.category_tree.delete(item)
        
        # Calcular tempo por categoria (simulado)
        categories = {}
        total_time = 0
        
        for board_name, lists in self.boodesk_data["boards"].items():
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if not card.get("is_archived", False):
                        category = card.get("subject", "Sem categoria")
                        if category not in categories:
                            categories[category] = {"time": 0, "tasks": 0}
                        
                        # Simular tempo baseado na importância
                        importance = card.get("importance", "Normal")
                        time_multiplier = {"Crítica": 8, "Alta": 6, "Normal": 4, "Baixa": 2}
                        estimated_time = time_multiplier.get(importance, 4)
                        
                        categories[category]["time"] += estimated_time
                        categories[category]["tasks"] += 1
                        total_time += estimated_time
        
        # Inserir dados na treeview
        for category, data in categories.items():
            percentage = (data["time"] / total_time * 100) if total_time > 0 else 0
            avg_time = data["time"] / data["tasks"] if data["tasks"] > 0 else 0
            
            self.category_tree.insert("", "end", values=(
                category,
                f"{data['time']:.1f}",
                data["tasks"],
                f"{avg_time:.1f}h",
                f"{percentage:.1f}%"
            ))

    def create_time_project_view(self, parent):
        """Cria visualização de tempo por projeto"""
        # Treeview para projetos
        columns = ("Projeto", "Tempo Total (h)", "Tarefas", "Progresso", "Prazo")
        self.project_tree = ttk.Treeview(parent, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.project_tree.heading(col, text=col)
            self.project_tree.column(col, width=150, anchor="center")
        
        self.project_tree.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Carregar dados
        self.load_time_project_data()

    def load_time_project_data(self):
        """Carrega dados de tempo por projeto"""
        # Limpar dados existentes
        for item in self.project_tree.get_children():
            self.project_tree.delete(item)
        
        # Calcular tempo por projeto (baseado nos quadros)
        projects = {}
        
        for board_name, lists in self.boodesk_data["boards"].items():
            if board_name not in projects:
                projects[board_name] = {"time": 0, "tasks": 0, "completed": 0, "total": 0}
            
            for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if not card.get("is_archived", False):
                        projects[board_name]["total"] += 1
                        
                        if list_name in ["Concluído", "Done", "Finalizado"]:
                            projects[board_name]["completed"] += 1
                        
                        # Simular tempo
                        importance = card.get("importance", "Normal")
                        time_multiplier = {"Crítica": 8, "Alta": 6, "Normal": 4, "Baixa": 2}
                        estimated_time = time_multiplier.get(importance, 4)
                        
                        projects[board_name]["time"] += estimated_time
                        projects[board_name]["tasks"] += 1
        
        # Inserir dados na treeview
        for project, data in projects.items():
            progress = (data["completed"] / data["total"] * 100) if data["total"] > 0 else 0
            
            self.project_tree.insert("", "end", values=(
                project,
                f"{data['time']:.1f}",
                data["tasks"],
                f"{progress:.1f}%",
                "Em andamento"
            ))

    def create_time_trends_view(self, parent):
        """Cria visualização de tendências de tempo"""
        # Frame para gráfico de tendências
        trends_frame = ttk.Frame(parent)
        trends_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        ttk.Label(trends_frame, text="📈 Tendências de Produtividade", 
                 font=("Arial", 14, "bold")).pack(pady=(0, 20))
        
        # Simular dados de tendência
        weeks = ["Semana 1", "Semana 2", "Semana 3", "Semana 4"]
        productivity = [75, 82, 78, 85]
        
        # Criar gráfico simples
        chart_frame = ttk.Frame(trends_frame)
        chart_frame.pack(fill=tk.BOTH, expand=True)
        
        # Criar barras para cada semana
        for i, (week, prod) in enumerate(zip(weeks, productivity)):
            week_frame = ttk.Frame(chart_frame)
            week_frame.pack(fill=tk.X, pady=5)
            
            ttk.Label(week_frame, text=week, width=15).pack(side=tk.LEFT)
            
            # Barra de produtividade
            bar = tk.Frame(week_frame, bg="#4CAF50", height=20)
            bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(10, 0))
            
            # Configurar largura baseada na produtividade
            bar.configure(width=int(prod * 3))
            
            ttk.Label(week_frame, text=f"{prod}%", width=8).pack(side=tk.LEFT, padx=(10, 0))

    def create_burndown_tab(self, parent):
        """Cria a aba de gráficos de burndown"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Título
        ttk.Label(main_frame, text="Gráficos de Burndown - Metodologia Ágil", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(control_frame, text="Sprint:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.sprint_var = tk.StringVar(value="Sprint Atual")
        sprint_combo = ttk.Combobox(control_frame, 
                                   textvariable=self.sprint_var,
                                   values=["Sprint Atual", "Sprint Anterior", "Próximo Sprint"],
                                   state="readonly")
        sprint_combo.pack(side=tk.LEFT, padx=(0, 20))
        sprint_combo.bind("<<ComboboxSelected>>", lambda e: self.refresh_burndown())
        
        ttk.Button(control_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_burndown).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Gerar Relatório", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT,
                  command=self.generate_burndown_report).pack(side=tk.LEFT, padx=5)
        
        # Frame para o gráfico
        chart_frame = ttk.LabelFrame(main_frame, text="Gráfico de Burndown", padding=10)
        chart_frame.pack(fill=tk.BOTH, expand=True)
        
        # Criar gráfico de burndown simples
        self.create_burndown_chart(chart_frame)

    def create_burndown_chart(self, parent):
        """Cria gráfico de burndown"""
        # Frame para o gráfico
        chart_frame = ttk.Frame(parent)
        chart_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Dados simulados para burndown
        days = ["Dia 1", "Dia 2", "Dia 3", "Dia 4", "Dia 5", "Dia 6", "Dia 7", "Dia 8", "Dia 9", "Dia 10"]
        ideal = [100, 90, 80, 70, 60, 50, 40, 30, 20, 10]  # Linha ideal
        actual = [100, 95, 85, 75, 70, 60, 50, 45, 35, 25]  # Linha real
        
        # Criar representação visual
        for i, (day, ideal_val, actual_val) in enumerate(zip(days, ideal, actual)):
            day_frame = ttk.Frame(chart_frame)
            day_frame.pack(fill=tk.X, pady=2)
            
            ttk.Label(day_frame, text=day, width=10).pack(side=tk.LEFT)
            
            # Linha ideal (verde)
            ideal_bar = tk.Frame(day_frame, bg="#4CAF50", height=15)
            ideal_bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 2))
            ideal_bar.configure(width=int(ideal_val * 2))
            
            # Linha real (azul)
            actual_bar = tk.Frame(day_frame, bg="#2196F3", height=15)
            actual_bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(2, 5))
            actual_bar.configure(width=int(actual_val * 2))
            
            # Valores
            ttk.Label(day_frame, text=f"I: {ideal_val}%", width=8).pack(side=tk.LEFT, padx=(5, 0))
            ttk.Label(day_frame, text=f"R: {actual_val}%", width=8).pack(side=tk.LEFT, padx=(5, 0))
        
        # Legenda
        legend_frame = ttk.Frame(chart_frame)
        legend_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(legend_frame, text="Legenda:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        
        ideal_legend = tk.Frame(legend_frame, bg="#4CAF50", width=20, height=15)
        ideal_legend.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Label(legend_frame, text="Ideal").pack(side=tk.LEFT, padx=(0, 20))
        
        actual_legend = tk.Frame(legend_frame, bg="#2196F3", width=20, height=15)
        actual_legend.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Label(legend_frame, text="Real").pack(side=tk.LEFT)

    def create_predictions_tab(self, parent):
        """Cria a aba de previsões IA"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Título
        ttk.Label(main_frame, text="Previsões de IA - Estimativas Inteligentes", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Button(control_frame, text="Gerar Previsões", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT,
                  command=self.generate_ai_predictions).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Atualizar Modelo", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.update_ai_model).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Exportar Previsões", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.export_ai_predictions).pack(side=tk.LEFT, padx=5)
        
        # Frame para previsões
        predictions_frame = ttk.LabelFrame(main_frame, text="Previsões de Conclusão", padding=10)
        predictions_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para previsões
        columns = ("Projeto", "Tarefas Restantes", "Tempo Estimado", "Data Prevista", "Confiança", "Risco")
        self.predictions_tree = ttk.Treeview(predictions_frame, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.predictions_tree.heading(col, text=col)
            self.predictions_tree.column(col, width=120, anchor="center")
        
        self.predictions_tree.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Carregar previsões iniciais
        self.load_ai_predictions()

    def load_ai_predictions(self):
        """Carrega previsões de IA"""
        # Limpar dados existentes
        for item in self.predictions_tree.get_children():
            self.predictions_tree.delete(item)
        
        # Gerar previsões simuladas
        predictions = self.generate_simulated_predictions()
        
        for prediction in predictions:
            self.predictions_tree.insert("", "end", values=prediction)

    def generate_simulated_predictions(self):
        """Gera previsões simuladas baseadas nos dados atuais"""
        predictions = []
        
        for board_name, lists in self.boodesk_data["boards"].items():
            pending_tasks = 0
            total_estimated_time = 0
            
            for list_name, cards in lists.items():
                if list_name not in ["Concluído", "Done", "Finalizado"]:
                    for card in cards:
                        if not card.get("is_archived", False):
                            pending_tasks += 1
                            
                            # Estimativa baseada na importância
                            importance = card.get("importance", "Normal")
                            time_multiplier = {"Crítica": 8, "Alta": 6, "Normal": 4, "Baixa": 2}
                            estimated_time = time_multiplier.get(importance, 4)
                            total_estimated_time += estimated_time
            
            if pending_tasks > 0:
                # Calcular data prevista
                avg_time_per_task = total_estimated_time / pending_tasks
                days_to_complete = (total_estimated_time / 8)  # 8 horas por dia
                
                from datetime import timedelta
                predicted_date = datetime.now() + timedelta(days=days_to_complete)
                
                # Calcular confiança baseada na consistência dos dados
                confidence = min(95, 70 + (pending_tasks * 2))  # Mais tarefas = mais dados = mais confiança
                
                # Determinar risco
                if days_to_complete > 30:
                    risk = "Alto"
                elif days_to_complete > 15:
                    risk = "Médio"
                else:
                    risk = "Baixo"
                
                predictions.append((
                    board_name,
                    pending_tasks,
                    f"{total_estimated_time:.1f}h",
                    predicted_date.strftime("%d/%m/%Y"),
                    f"{confidence:.0f}%",
                    risk
                ))
    
    def create_meetings_tab(self, parent):
        """Cria a aba de próximas reuniões"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Título
        ttk.Label(main_frame, text="Próximas Reuniões - Agendamento e Links", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Button(control_frame, text="Nova Reunião", image=self.icons.get('add_icon'), compound=tk.LEFT,
                  command=self.create_new_meeting).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_meetings).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Exportar Agenda", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.export_meetings_agenda).pack(side=tk.LEFT, padx=5)
        
        # Frame para reuniões
        meetings_frame = ttk.LabelFrame(main_frame, text="Reuniões Agendadas", padding=10)
        meetings_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para reuniões
        columns = ("Data", "Hora", "Título", "Projeto", "Plataforma", "Criado por", "Link")
        self.meetings_tree = ttk.Treeview(meetings_frame, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.meetings_tree.heading(col, text=col)
            self.meetings_tree.column(col, width=100, anchor="center")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(meetings_frame, orient="vertical", command=self.meetings_tree.yview)
        self.meetings_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.meetings_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Frame para ações
        actions_frame = ttk.Frame(main_frame)
        actions_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(actions_frame, text="Copiar Link", image=self.icons.get('copy_icon'), compound=tk.LEFT,
                  command=self.copy_meeting_link_dashboard).pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(actions_frame, text="Excluir Reunião", image=self.icons.get('delete_icon'), compound=tk.LEFT,
                  command=self.delete_meeting_dashboard).pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(actions_frame, text="Abrir Reunião", image=self.icons.get('forward_icon'), compound=tk.LEFT,
                  command=self.open_meeting_link).pack(side=tk.LEFT)
        
        # Carregar reuniões iniciais
        self.load_dashboard_meetings()
    
    def load_dashboard_meetings(self):
        """Carrega reuniões no dashboard"""
        # Limpar dados existentes
        for item in self.meetings_tree.get_children():
            self.meetings_tree.delete(item)
        
        # Carregar próximas reuniões
        upcoming_meetings = self.meeting_integration.get_upcoming_meetings()
        
        for meeting in upcoming_meetings:
            # Converter nome da plataforma para exibição
            platform = meeting.get('platform', '')
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(platform, platform.upper())
            
            self.meetings_tree.insert("", "end", values=(
                meeting.get('date', ''),
                meeting.get('time', ''),
                meeting.get('title', ''),
                meeting.get('project', 'Geral'),
                platform_display,
                meeting.get('created_by', ''),
                meeting.get('link', '')[:50] + "..." if len(meeting.get('link', '')) > 50 else meeting.get('link', '')
            ), tags=(meeting['id'],))
    
    def create_new_meeting(self):
        """Abre janela para criar nova reunião"""
        MeetingWindow(self.root, self)
    
    def refresh_meetings(self):
        """Atualiza lista de reuniões"""
        self.load_dashboard_meetings()
    
    def copy_meeting_link_dashboard(self):
        """Copia link da reunião selecionada no dashboard"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reunião!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        
        if meeting_id in self.meeting_integration.meeting_data:
            meeting = self.meeting_integration.meeting_data[meeting_id]
            link = meeting['link']
            
            # Copiar para área de transferência
            self.root.clipboard_clear()
            self.root.clipboard_append(link)
            
            messagebox.showinfo("Link Copiado", f"Link copiado para a área de transferência:\n{link}")
    
    def delete_meeting_dashboard(self):
        """Exclui reunião selecionada no dashboard"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reunião!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        meeting_title = item['values'][2]
        
        if messagebox.askyesno("Confirmar Exclusão", 
                              f"Tem certeza que deseja excluir a reunião '{meeting_title}'?"):
            if meeting_id in self.meeting_integration.meeting_data:
                del self.meeting_integration.meeting_data[meeting_id]
                self.meeting_integration.save_meeting_data()
                self.load_dashboard_meetings()
                messagebox.showinfo("Sucesso", "Reunião excluída com sucesso!")
    
    def open_meeting_link(self):
        """Abre link da reunião no navegador"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reunião!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        
        if meeting_id in self.meeting_integration.meeting_data:
            meeting = self.meeting_integration.meeting_data[meeting_id]
            link = meeting['link']
            
            try:
                import webbrowser
                webbrowser.open(link)
                messagebox.showinfo("Reunião Aberta", f"Link da reunião aberto no navegador!")
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao abrir link: {e}")
    
    def export_meetings_agenda(self):
        """Exporta agenda de reuniões"""
        try:
            upcoming_meetings = self.meeting_integration.get_upcoming_meetings()
            
            if not upcoming_meetings:
                messagebox.showinfo("Agenda Vazia", "Não há reuniões agendadas para exportar.")
                return
            
            # Criar conteúdo da agenda
            agenda_content = "AGENDA DE REUNIÕES\n"
            agenda_content += "=" * 50 + "\n\n"
            
            for meeting in upcoming_meetings:
                # Converter nome da plataforma para exibição
                platform = meeting.get('platform', '')
                platform_display = {
                    'zoom': 'ZOOM',
                    'teams': 'TEAMS', 
                    'google_meet': 'GOOGLE MEET'
                }.get(platform, platform.upper())
                
                agenda_content += f"📅 {meeting['title']}\n"
                agenda_content += f"   Data: {meeting['date']} às {meeting['time']}\n"
                agenda_content += f"   Duração: {meeting['duration']} minutos\n"
                agenda_content += f"   Plataforma: {platform_display}\n"
                agenda_content += f"   Link: {meeting['link']}\n"
                if meeting.get('project'):
                    agenda_content += f"   Projeto: {meeting['project']}\n"
                agenda_content += f"   Criado por: {meeting['created_by']}\n"
                agenda_content += "\n"
            
            # Salvar arquivo
            filename = f"agenda_reunioes_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(agenda_content)
            
            messagebox.showinfo("Agenda Exportada", f"Agenda salva como '{filename}'")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar agenda: {e}")
        
        return predictions

    def refresh_dashboard(self):
        """Atualiza todos os dados do dashboard"""
        try:
            # Atualizar métricas gerais
            if hasattr(self, 'category_tree'):
                self.load_time_category_data()
            
            if hasattr(self, 'project_tree'):
                self.load_time_project_data()
            
            if hasattr(self, 'team_tree'):
                self.load_team_performance_data()
            
            if hasattr(self, 'predictions_tree'):
                self.load_ai_predictions()
            
            messagebox.showinfo("Sucesso", "Dashboard atualizado com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao atualizar dashboard:\n{e}")

    def refresh_team_performance(self):
        """Atualiza dados de performance da equipe"""
        self.load_team_performance_data()

    def refresh_time_analysis(self):
        """Atualiza análise de tempo"""
        if hasattr(self, 'category_tree'):
            self.load_time_category_data()
        if hasattr(self, 'project_tree'):
            self.load_time_project_data()

    def refresh_burndown(self):
        """Atualiza gráfico de burndown"""
        # Recriar o gráfico
        pass

    def generate_ai_predictions(self):
        """Gera novas previsões de IA"""
        self.load_ai_predictions()
        messagebox.showinfo("Sucesso", "Previsões de IA geradas com sucesso!")

    def update_ai_model(self):
        """Atualiza o modelo de IA"""
        messagebox.showinfo("Info", "Modelo de IA atualizado com dados mais recentes!")

    def generate_team_report(self):
        """Gera relatório de performance da equipe"""
        try:
            # Simular geração de relatório
            report_content = "Relatório de Performance da Equipe\n"
            report_content += "=" * 40 + "\n\n"
            
            for member in self.members:
                completed, pending, avg_time, completion_rate = self.calculate_member_performance(member['Membro'])
                report_content += f"Membro: {member['Membro']}\n"
                report_content += f"Tarefas Concluídas: {completed}\n"
                report_content += f"Tarefas Pendentes: {pending}\n"
                report_content += f"Taxa de Conclusão: {completion_rate:.1f}%\n"
                report_content += f"Tempo Médio: {avg_time:.1f}h\n\n"
            
            # Salvar relatório
            filename = f"relatorio_equipe_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            messagebox.showinfo("Sucesso", f"Relatório gerado com sucesso!\nArquivo: {filename}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar relatório:\n{e}")

    def export_dashboard_report(self):
        """Exporta relatório completo do dashboard"""
        try:
            # Gerar relatório completo
            report_content = "Dashboard Executivo - Relatório Completo\n"
            report_content += "=" * 50 + "\n\n"
            
            # Métricas gerais
            total_cards, completed_cards, pending_cards, overdue_cards = self.calculate_card_metrics()
            report_content += "MÉTRICAS GERAIS:\n"
            report_content += f"Total de Tarefas: {total_cards}\n"
            report_content += f"Concluídas: {completed_cards}\n"
            report_content += f"Pendentes: {pending_cards}\n"
            report_content += f"Vencidas: {overdue_cards}\n"
            report_content += f"Taxa de Sucesso: {(completed_cards/total_cards*100):.1f}%\n\n"
            
            # Performance da equipe
            report_content += "PERFORMANCE DA EQUIPE:\n"
            for member in self.members:
                completed, pending, avg_time, completion_rate = self.calculate_member_performance(member['Membro'])
                report_content += f"{member['Membro']}: {completion_rate:.1f}% de conclusão\n"
            
            # Salvar relatório
            filename = f"dashboard_executivo_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            messagebox.showinfo("Sucesso", f"Relatório exportado com sucesso!\nArquivo: {filename}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar relatório:\n{e}")

    def generate_metrics_chart(self):
        """Gera gráfico detalhado das métricas"""
        try:
            messagebox.showinfo("Gráfico", "Gráfico detalhado das métricas gerado com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar gráfico: {e}")

    def export_time_analysis(self):
        """Exporta análise de tempo"""
        try:
            messagebox.showinfo("Exportar", "Análise de tempo exportada com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar análise: {e}")

    def generate_burndown_report(self):
        """Gera relatório de burndown"""
        try:
            messagebox.showinfo("Relatório", "Relatório de burndown gerado com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar relatório: {e}")

    def export_ai_predictions(self):
        """Exporta previsões de IA"""
        try:
            messagebox.showinfo("Exportar", "Previsões de IA exportadas com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar previsões: {e}")

    def create_boards_tab(self, parent):
        board_management_frame = ttk.Frame(parent)
        board_management_frame.pack(fill=tk.X, pady=5, padx=5)

        # Re-insert buttons for board management with icons
        ttk.Button(board_management_frame, text="Novo Quadro", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_board).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Renomear Quadro", image=self.icons.get('pencil_icon'), compound=tk.LEFT, command=self.rename_current_board).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Excluir Quadro", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.delete_current_board).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Chat do Projeto", image=self.icons.get('chat_icon'), compound=tk.LEFT, command=self.open_project_chat).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Criar Reunião", image=self.icons.get('calendar_icon'), compound=tk.LEFT, command=self.open_meeting_window).pack(side=tk.LEFT, padx=5)

        # --- Filter Toggle Button ---
        self.filter_visible = tk.BooleanVar(value=False)
        # Use self.search_icon for the filter button
        self.toggle_filter_button = ttk.Button(board_management_frame, text="Mostrar Filtros", image=self.icons.get('search_icon'), compound=tk.LEFT, command=self.toggle_filter_visibility)
        self.toggle_filter_button.pack(side=tk.LEFT, padx=5)

        # --- Card Filtering UI (initially hidden) ---
        self.filter_container_frame = ttk.Frame(parent) # Container to hide/show
        # self.filter_container_frame.pack(fill=tk.X, pady=5, padx=5) # Don't pack initially

        filter_frame = ttk.LabelFrame(self.filter_container_frame, text="Filtrar Cartões", padding=10)
        filter_frame.pack(fill=tk.X, expand=True)

        filter_frame.columnconfigure(1, weight=1) # Make the entry/combobox columns expandable

        ttk.Label(filter_frame, text="Assunto:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.filter_subject_var = tk.StringVar()
        self.filter_subject_combo = ttk.Combobox(filter_frame, textvariable=self.filter_subject_var, state="readonly")
        self.filter_subject_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        self.filter_subject_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Objetivo:").grid(row=0, column=2, sticky="w", padx=5, pady=2)
        self.filter_goal_var = tk.StringVar()
        self.filter_goal_combo = ttk.Combobox(filter_frame, textvariable=self.filter_goal_var, state="readonly")
        self.filter_goal_combo.grid(row=0, column=3, sticky="ew", padx=5, pady=2)
        self.filter_goal_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Membro:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.filter_member_var = tk.StringVar()
        self.filter_member_combo = ttk.Combobox(filter_frame, textvariable=self.filter_member_var, state="readonly")
        self.filter_member_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        self.filter_member_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())
        self.filter_member_combo['values'] = ["Todos"] + sorted([member['Membro'] for member in self.members])

        ttk.Label(filter_frame, text="Prazo:").grid(row=1, column=2, sticky="w", padx=5, pady=2)
        self.filter_due_date_var = tk.StringVar()
        self.filter_due_date_options = ["Todos", "Hoje", "Próximos 7 dias", "Vencidos"]
        self.filter_due_date_combo = ttk.Combobox(filter_frame, textvariable=self.filter_due_date_var, values=self.filter_due_date_options, state="readonly")
        self.filter_due_date_combo.grid(row=1, column=3, sticky="ew", padx=5, pady=2)
        # Não definir valor padrão - deixar vazio
        self.filter_due_date_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Importância:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        self.filter_importance_var = tk.StringVar()
        self.filter_importance_combo = ttk.Combobox(filter_frame, textvariable=self.filter_importance_var, state="readonly")
        self.filter_importance_combo.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        self.filter_importance_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Recorrência:").grid(row=2, column=2, sticky="w", padx=5, pady=2)
        self.filter_recurrence_var = tk.StringVar()
        self.filter_recurrence_options = ["Todos", "Nenhuma", "Diariamente", "Semanalmente", "Mensalmente", "Anualmente"]
        self.filter_recurrence_combo = ttk.Combobox(filter_frame, textvariable=self.filter_recurrence_var, values=self.filter_recurrence_options, state="readonly")
        self.filter_recurrence_combo.grid(row=2, column=3, sticky="ew", padx=5, pady=2)
        # Não definir valor padrão - deixar vazio
        self.filter_recurrence_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Palavra-chave:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.filter_keyword_var = tk.StringVar()
        self.filter_keyword_entry = ttk.Entry(filter_frame, textvariable=self.filter_keyword_var)
        self.filter_keyword_entry.grid(row=3, column=1, columnspan=3, sticky="ew", padx=5, pady=2)
        self.filter_keyword_entry.bind("<KeyRelease>", lambda e: self.apply_card_filter())

        filter_buttons_frame = ttk.Frame(filter_frame)
        filter_buttons_frame.grid(row=4, column=0, columnspan=4, sticky="e", padx=5, pady=2)

        # Filter management UI
        filter_management_frame = ttk.Frame(filter_frame)
        filter_management_frame.grid(row=5, column=0, columnspan=4, sticky="ew", padx=5, pady=2)
        filter_management_frame.columnconfigure(0, weight=1)

        self.saved_filters_combo = ttk.Combobox(filter_management_frame, state="readonly")
        self.saved_filters_combo.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        self.saved_filters_combo.bind("<<ComboboxSelected>>", self.load_filter)

        ttk.Button(filter_management_frame, text="Salvar Filtro", image=self.icons.get('save_icon'), compound=tk.LEFT, command=self.save_filter).grid(row=0, column=1, padx=2)
        ttk.Button(filter_management_frame, text="Excluir Filtro", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.delete_filter).grid(row=0, column=2, padx=2)

        ttk.Button(filter_buttons_frame, text="Limpar Filtros", image=self.icons.get('clear_icon'), compound=tk.LEFT, command=self.clear_card_filter).pack(side=tk.RIGHT, padx=2)
        ttk.Button(filter_buttons_frame, text="Aplicar Filtro", image=self.icons.get('apply_icon'), compound=tk.LEFT, command=self.apply_card_filter).pack(side=tk.RIGHT, padx=2)

        self.board_notebook = ttk.Notebook(parent)
        self.board_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Bind right-click to the notebook itself to identify the tab
        self.board_notebook.bind("<Button-3>", self.show_board_tab_context_menu)
        # Bind drag-and-drop for tabs
        self.board_notebook.bind("<ButtonPress-1>", self.on_tab_drag_start)
        self.board_notebook.bind("<B1-Motion>", self.on_tab_drag_motion)
        self.board_notebook.bind("<ButtonRelease-1>", self.on_tab_drag_release)

        self._drag_data = {"item": None, "x": 0, "y": 0, "tab_index": -1}

        # Card details frame (initially hidden)
        self.card_details_frame = ttk.Frame(parent, relief="solid", borderwidth=1)
        self.create_card_details_widgets()

        # Add a small legend for importance colors at the bottom of the boards tab
        self.legend_frame = ttk.Frame(parent)
        self.legend_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=5)
        self.update_legend()

    def create_card_details_widgets(self):
        """Cria os widgets para exibir detalhes do cartão selecionado"""
        # Basic info frame
        basic_frame = ttk.Frame(self.card_details_frame)
        basic_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Row 1: Title and Due Date
        title_frame = ttk.Frame(basic_frame)
        title_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(title_frame, text="Título:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_title_label = ttk.Label(title_frame, text="", font=("Helvetica", 9))
        self.card_title_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(title_frame, text="Prazo:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_due_date_label = ttk.Label(title_frame, text="", font=("Helvetica", 9))
        self.card_due_date_label.pack(side=tk.LEFT)
        
        # Row 2: Members and Creation Date
        info_frame = ttk.Frame(basic_frame)
        info_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(info_frame, text="Membros:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_members_label = ttk.Label(info_frame, text="", font=("Helvetica", 9))
        self.card_members_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(info_frame, text="Criado em:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_creation_date_label = ttk.Label(info_frame, text="", font=("Helvetica", 9))
        self.card_creation_date_label.pack(side=tk.LEFT)
        
        # Row 3: Buttons
        button_frame = ttk.Frame(basic_frame)
        button_frame.pack(fill=tk.X, pady=2)
        
        self.ver_mais_button = ttk.Button(button_frame, text="Ver Mais", 
                                         command=self.toggle_detailed_view)
        self.ver_mais_button.pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(button_frame, text="Editar", 
                  command=self.edit_selected_card).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(button_frame, text="Comentários", 
                  command=self.open_card_comments).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(button_frame, text="Limpar", 
                  command=self.clear_card_selection).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(button_frame, text="Fechar", 
                  command=self.hide_card_details).pack(side=tk.RIGHT, padx=2)
        
        # Detailed info frame (initially hidden)
        self.detailed_frame = ttk.LabelFrame(self.card_details_frame, text="Informações Detalhadas", padding=5)
        
        # Subject and Importance
        detail_row1 = ttk.Frame(self.detailed_frame)
        detail_row1.pack(fill=tk.X, pady=2)
        
        ttk.Label(detail_row1, text="Assunto:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_subject_label = ttk.Label(detail_row1, text="", font=("Helvetica", 8))
        self.card_subject_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(detail_row1, text="Importância:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_importance_label = ttk.Label(detail_row1, text="", font=("Helvetica", 8))
        self.card_importance_label.pack(side=tk.LEFT)
        
        # Goal and Recurrence
        detail_row2 = ttk.Frame(self.detailed_frame)
        detail_row2.pack(fill=tk.X, pady=2)
        
        ttk.Label(detail_row2, text="Objetivo:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_goal_label = ttk.Label(detail_row2, text="", font=("Helvetica", 8))
        self.card_goal_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(detail_row2, text="Recorrência:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_recurrence_label = ttk.Label(detail_row2, text="", font=("Helvetica", 8))
        self.card_recurrence_label.pack(side=tk.LEFT)
        
        # Description
        detail_row3 = ttk.Frame(self.detailed_frame)
        detail_row3.pack(fill=tk.X, pady=2)
        
        ttk.Label(detail_row3, text="Descrição:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W, padx=(0, 5))
        
        # Text widget for description
        desc_frame = ttk.Frame(self.detailed_frame)
        desc_frame.pack(fill=tk.X, pady=2)
        
        self.card_description_text = tk.Text(desc_frame, height=3, wrap=tk.WORD, font=("Helvetica", 8))
        desc_scrollbar = ttk.Scrollbar(desc_frame, orient="vertical", command=self.card_description_text.yview)
        self.card_description_text.configure(yscrollcommand=desc_scrollbar.set)
        
        self.card_description_text.pack(side=tk.LEFT, fill=tk.X, expand=True)
        desc_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Additional info frame
        info_frame = ttk.LabelFrame(self.detailed_frame, text="Informações Adicionais", padding=5)
        info_frame.pack(fill=tk.X, pady=2)
        
        # Subtasks
        subtasks_frame = ttk.Frame(info_frame)
        subtasks_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(subtasks_frame, text="Subtarefas:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W)
        self.card_subtasks_text = tk.Text(subtasks_frame, height=2, wrap=tk.WORD, font=("Helvetica", 8))
        self.card_subtasks_text.pack(fill=tk.X, expand=True)
        
        # Dependencies
        deps_frame = ttk.Frame(info_frame)
        deps_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(deps_frame, text="Dependências:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W)
        self.card_dependencies_text = tk.Text(deps_frame, height=2, wrap=tk.WORD, font=("Helvetica", 8))
        self.card_dependencies_text.pack(fill=tk.X, expand=True)
        
        # Git info
        git_frame = ttk.Frame(info_frame)
        git_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(git_frame, text="Git:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W)
        self.card_git_text = tk.Text(git_frame, height=2, wrap=tk.WORD, font=("Helvetica", 8))
        self.card_git_text.pack(fill=tk.X, expand=True)

    def show_card_details(self, card_data):
        """Exibe os detalhes do cartão selecionado"""
        self.card_details_frame.pack(before=self.legend_frame, fill=tk.X, pady=2)
        
        # Update basic info
        self.card_title_label.config(text=card_data.get('title', ''))
        
        due_date = card_data.get('due_date', '')
        if due_date:
            try:
                due_date_obj = datetime.strptime(due_date, '%Y-%m-%d %H:%M')
                formatted_due_date = due_date_obj.strftime('%d/%m/%Y %H:%M')
            except ValueError:
                formatted_due_date = due_date
        else:
            formatted_due_date = 'Não definido'
        self.card_due_date_label.config(text=formatted_due_date)
        
        members = card_data.get('members', [])
        self.card_members_label.config(text=', '.join(members) if members else 'Nenhum')
        
        creation_date = card_data.get('creation_date', '')
        if creation_date:
            try:
                creation_date_obj = datetime.strptime(creation_date, '%Y-%m-%d %H:%M:%S')
                formatted_creation_date = creation_date_obj.strftime('%d/%m/%Y %H:%M')
            except ValueError:
                formatted_creation_date = creation_date
        else:
            formatted_creation_date = 'Não disponível'
        self.card_creation_date_label.config(text=formatted_creation_date)
        
        # Update additional info
        self.update_additional_info(card_data)
        
        # Store current card data
        self.current_card_data = card_data

    def hide_card_details(self):
        """Esconde o frame de detalhes do cartão"""
        self.card_details_frame.pack_forget()
        self.current_card_data = None

    def toggle_detailed_view(self):
        """Alterna a visibilidade da view detalhada"""
        if self.detailed_frame.winfo_ismapped():
            self.detailed_frame.pack_forget()
            self.ver_mais_button.config(text="Ver Mais")
        else:
            self.detailed_frame.pack(fill=tk.X, padx=5, pady=5)
            self.ver_mais_button.config(text="Ver Menos")

    def update_additional_info(self, card_data):
        """Atualiza as informações adicionais do cartão"""
        # Subject and Importance
        self.card_subject_label.config(text=card_data.get('subject', 'Não definido'))
        self.card_importance_label.config(text=card_data.get('importance', 'Normal'))
        
        # Goal and Recurrence
        self.card_goal_label.config(text=card_data.get('goal', 'Não definido'))
        self.card_recurrence_label.config(text=card_data.get('recurrence', 'Nenhuma'))
        
        # Description
        self.card_description_text.delete('1.0', tk.END)
        self.card_description_text.insert('1.0', card_data.get('desc', ''))
        
        # Subtasks
        self.card_subtasks_text.delete('1.0', tk.END)
        subtasks = card_data.get('subtasks', [])
        if subtasks:
            subtasks_text = '\n'.join([f"• {subtask}" for subtask in subtasks])
            self.card_subtasks_text.insert('1.0', subtasks_text)
        
        # Dependencies
        self.card_dependencies_text.delete('1.0', tk.END)
        dependencies = card_data.get('dependencies', [])
        if dependencies:
            deps_text = '\n'.join([f"• {dep}" for dep in dependencies])
            self.card_dependencies_text.insert('1.0', deps_text)
        
        # Git info
        self.card_git_text.delete('1.0', tk.END)
        git_info = card_data.get('git_info', {})
        if git_info:
            git_text = f"Branch: {git_info.get('branch', 'N/A')}\n"
            git_text += f"Status: {git_info.get('status', 'N/A')}"
            self.card_git_text.insert('1.0', git_text)

    def clear_card_selection(self):
        """Limpa a seleção do cartão e esconde os detalhes"""
        # Clear selection in all treeviews
        for board_name in self.boodesk_data["boards"]:
            if board_name != "workflow":
                treeview = self.listbox_refs.get(board_name)
                if treeview:
                    treeview.selection_remove(treeview.selection())
        
        self.hide_card_details()

    def edit_selected_card(self):
        """Abre a janela de edição do cartão selecionado"""
        if hasattr(self, 'current_card_data') and self.current_card_data:
            # Find the card in the data structure
            card_id = self.current_card_data.get('card_id')
            if card_id:
                for board_name, board_data in self.boodesk_data["boards"].items():
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                        if list_name != "workflow":
                            for card in cards:
                                if card.get('card_id') == card_id:
                                    # Open card window for editing
                                    CardWindow(self.root, self, board_name, list_name, card, 
                                             lambda saved=False: self.update_card_details_if_visible())
                                    return
            
            messagebox.showwarning("Aviso", "Cartão não encontrado para edição.")
    
    def open_card_comments(self):
        """Abre a janela de comentários do cartão selecionado"""
        if hasattr(self, 'current_card_data') and self.current_card_data:
            card_id = self.current_card_data.get('card_id')
            card_title = self.current_card_data.get('title', 'Cartão')
            if card_id:
                self.chat_system.open_card_comments(card_id, card_title)
            else:
                messagebox.showwarning("Aviso", "Cartão não encontrado para comentários.")
        else:
            messagebox.showwarning("Aviso", "Nenhum cartão selecionado!")

    def update_card_details_if_visible(self):
        """Atualiza os detalhes do cartão se estiverem visíveis"""
        if hasattr(self, 'current_card_data') and self.current_card_data:
            # Refresh the current card data
            card_id = self.current_card_data.get('card_id')
            if card_id:
                for board_name, board_data in self.boodesk_data["boards"].items():
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                        if list_name != "workflow":
                            for card in cards:
                                if card.get('card_id') == card_id:
                                    self.show_card_details(card)
                                    return

    def update_legend(self):
        for widget in self.legend_frame.winfo_children():
            widget.destroy()

        ttk.Label(self.legend_frame, text="Legenda Importância:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=5)
        for imp, color in self.settings["importance_colors"].items():
            ttk.Label(self.legend_frame, text=imp, background=color, font=("Helvetica", 8)).pack(side=tk.LEFT, padx=2)

    # Função create_calendar_tab removida - integração com Google Calendar desabilitada

    # Funções relacionadas ao calendário removidas - integração com Google Calendar desabilitada
    
    def get_all_cards(self):
        all_cards = []
        for board_name, lists in self.boodesk_data["boards"].items():
            # Verificar se lists é um dicionário ou lista
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                        if not card.get("is_archived", False):
                            all_cards.append({
                                "board_name": board_name,
                                "list_name": list_name,
                                "card": card
                            })
        return all_cards

    def create_gantt_chart_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        self.gantt_canvas_frame = ttk.Frame(main_frame)
        self.gantt_canvas_frame.pack(fill=tk.BOTH, expand=True)

        self.update_gantt_chart()

    def update_gantt_chart(self):
        # Clear previous chart
        for widget in self.gantt_canvas_frame.winfo_children():
            widget.destroy()

        fig, ax = plt.subplots(figsize=(10, 6))

        tasks = []
        for board_name, lists in self.boodesk_data["boards"].items():
            # Verificar se lists é um dicionário ou lista
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                        if not card.get("is_archived", False) and card.get("due_date"):
                            try:
                                start_date = datetime.strptime(card.get("creation_date", datetime.now().strftime("%Y-%m-%d %H:%M:%S")).split(' ')[0], "%Y-%m-%d")
                                end_date = datetime.strptime(card["due_date"].split(' ')[0], "%Y-%m-%d")
                                duration = (end_date - start_date).days
                                if duration < 0: # Handle cases where due date is before creation date
                                    duration = 0
                                tasks.append({
                                    "task": card["title"],
                                    "start": start_date,
                                    "end": end_date,
                                    "duration": duration,
                                    "list": list_name
                                })
                            except ValueError:
                                continue # Skip cards with invalid date formats

        if not tasks:
            ax.text(0.5, 0.5, "Nenhum cartão com prazo definido para exibir no Gráfico de Gantt.",
                    horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=12, color='gray')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            # Sort tasks by start date
            tasks.sort(key=lambda x: x["start"])

            # Create a mapping for task names to y-axis positions
            task_names = [task["task"] for task in tasks]
            y_pos = range(len(task_names))

            # Plot bars
            for i, task in enumerate(tasks):
                color = 'skyblue'
                if task["list"] == "Concluído":
                    color = 'lightgreen'
                elif task["end"].date() < datetime.now().date():
                    color = 'lightcoral' # Overdue
                
                ax.barh(i, task["duration"], left=task["start"], height=0.8, align='center', color=color)
                
                # Add task name and dates
                ax.text(task["start"], i, f" {task['task']}", va='center', ha='left', fontsize=8)
                ax.text(task["end"], i, f" {task['end'].strftime('%Y-%m-%d')}", va='center', ha='left', fontsize=8)


            ax.set_yticks(y_pos)
            ax.set_yticklabels(task_names, fontsize=8)
            ax.set_xlabel("Data")
            ax.set_title("Gráfico de Gantt dos Cartões")
            ax.grid(True, linestyle='--', alpha=0.7)
            fig.autofmt_xdate() # Rotate x-axis labels for better readability

        canvas = FigureCanvasTkAgg(fig, master=self.gantt_canvas_frame)
        canvas_widget = canvas.get_tk_widget()
        canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        canvas.draw()

    def check_deadlines(self):
        overdue_cards = []
        due_soon_cards = []
        today = datetime.now().date()
        tomorrow = today + timedelta(days=1)

        all_cards = self.get_all_cards()
        for card_info in all_cards:
            card = card_info['card']
            if card.get("due_date"):
                try:
                    due_date = datetime.strptime(card["due_date"].split(" ")[0], "%Y-%m-%d").date()
                    if due_date < today:
                        overdue_cards.append(card['title'])
                    elif due_date == today or due_date == tomorrow:
                        due_soon_cards.append(card['title'])
                except (ValueError, TypeError):
                    continue

        notification_message = ""
        if overdue_cards:
            notification_message += "Cartões Vencidos:\n" + "\n".join(f"- {title}" for title in overdue_cards) + "\n\n"
        
        if due_soon_cards:
            notification_message += "Cartões Vencendo Hoje ou Amanhã:\n" + "\n".join(f"- {title}" for title in due_soon_cards)

        if notification_message:
            messagebox.showwarning("Notificação de Prazos", notification_message, parent=self.root)
    
    def show_deadline_notifications(self):
        """Mostra notificações de prazos após o login"""
        print("DEBUG: Verificando notificações de prazos...")
        self.check_deadlines()

    def on_card_select_treeview(self, board_name, list_name, event):
        treeview = event.widget
        selected_item_id = treeview.focus() # Get the ID of the selected item

        if not selected_item_id:
            return

        # Get the card_id from the tags of the selected item
        card_id = treeview.item(selected_item_id, "tags")[0]
        
        # Find the actual card object using its card_id
        selected_card = None
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card.get('card_id') == card_id:
                selected_card = card
                break
        
        if not selected_card:
            return

        # Clear any previously expanded details for this treeview
        for child in treeview.get_children(selected_item_id): # Only clear children of the selected item
            treeview.delete(child)

        if self.settings.get('show_card_details_on_board', False):
            # If details are already expanded, collapse them
            if treeview.item(selected_item_id, 'open'):
                treeview.item(selected_item_id, open=False)
            else:
                # Expand details
                treeview.item(selected_item_id, open=True)

                # Add description
                desc = selected_card.get('desc', 'Sem descrição')
                treeview.insert(selected_item_id, "end", text="", values=("Descrição:", desc, "", ""), tags=("detail_row",))

                # Add members
                members = ", ".join(selected_card.get('members', []))
                if not members: members = "Nenhum membro atribuído"
                treeview.insert(selected_item_id, "end", text="", values=("Membros:", members, "", ""), tags=("detail_row",))

                # Add creation date
                creation_date = selected_card.get('creation_date', 'N/A')
                treeview.insert(selected_item_id, "end", text="", values=("Criação:", creation_date, "", ""), tags=("detail_row",))

                # Add subtasks
                subtasks = selected_card.get('subtasks', [])
                if subtasks:
                    subtask_summary = f"{sum(1 for s in subtasks if s['completed'])}/{len(subtasks)} subtarefas concluídas"
                    treeview.insert(selected_item_id, "end", text="", values=("Subtarefas:", subtask_summary, "", ""), tags=("detail_row",))
                    for subtask in subtasks:
                        status = "[X]" if subtask['completed'] else "[ ]"
                        treeview.insert(selected_item_id, "end", text="", values=("", f"{status} {subtask['text']}", "", ""), tags=("subtask_row",))
                else:
                    treeview.insert(selected_item_id, "end", text="", values=("Subtarefas:", "Nenhuma subtarefa", "", ""), tags=("detail_row",))

                # Add dependencies
                dependencies = selected_card.get('dependencies', [])
                if dependencies:
                    dep_status = self.get_card_dependency_status(selected_card)
                    dep_summary = f"{dep_status['completed']}/{dep_status['total']} dependências concluídas"
                    treeview.insert(selected_item_id, "end", text="", values=("Dependências:", dep_summary, "", ""), tags=("detail_row",))
                    for dep in dependencies:
                        is_completed = self._is_card_completed(dep)
                        status = "[X]" if is_completed else "[ ]"
                        treeview.insert(selected_item_id, "end", text="", values=("", f"{status} {dep}", "", ""), tags=("dependency_row",))
                else:
                    treeview.insert(selected_item_id, "end", text="", values=("Dependências:", "Nenhuma dependência", "", ""), tags=("detail_row",))

                # Add History
                history = selected_card.get('history', [])
                print(f"DEBUG: History for card {selected_card.get('title')}: {history}")
                if history:
                    treeview.insert(selected_item_id, "end", text="", values=("Histórico:", "", "", ""), tags=("detail_row",))
                    for entry in history:
                        timestamp = entry.get('timestamp', 'N/A')
                        action = entry.get('action', 'Ação desconhecida')
                        user = entry.get('user', 'Sistema')
                        treeview.insert(selected_item_id, "end", text="", values=("", f"{timestamp} - {action} (por {user})", "", ""), tags=("history_row",))
                else:
                    treeview.insert(selected_item_id, "end", text="", values=("Histórico:", "Nenhum histórico de atividade", "", ""), tags=("detail_row",))

        # Apply styling for detail rows
        treeview.tag_configure("detail_row", background="#e0e0e0", foreground="#333333")
        treeview.tag_configure("subtask_row", background="#f0f0f0", foreground="#555555")
        treeview.tag_configure("dependency_row", background="#f0f0f0", foreground="#555555")
        treeview.tag_configure("history_row", background="#f0f0f0", foreground="#555555")

        treeview.bind("<Double-1>", lambda event, c=selected_card: self.on_detail_treeview_double_click(event, c))

    def on_detail_treeview_double_click(self, event, card):
        treeview = event.widget
        item_id = treeview.identify_row(event.y)
        if not item_id:
            return

        # A simple way to check if it's a subtask row
        if treeview.item(item_id, "tags")[0] == "subtask_row":
            # This is tricky because we don't have the subtask ID here directly.
            # We'll have to find it by its text, which is not ideal but works for now.
            subtask_text_with_status = treeview.item(item_id, "values")[1]
            subtask_text = subtask_text_with_status.split("] ", 1)[1]
            
            subtask_to_edit = None
            for subtask in card.get("subtasks", []):
                if subtask["text"] == subtask_text:
                    subtask_to_edit = subtask
                    break
            
            if subtask_to_edit:
                SubtaskEditorWindow(self.root, self, card, subtask_to_edit)

    def on_tab_drag_start(self, event):
        try:
            tab_index = self.board_notebook.index(f"@{event.x},{event.y}")
            if tab_index != "": # Check if a tab was actually clicked
                self._drag_data["item"] = self.board_notebook.tabs()[tab_index]
                self._drag_data["x"] = event.x
                self._drag_data["y"] = event.y
                self._drag_data["tab_index"] = tab_index
        except tk.TclError:
            pass # No tab clicked

    def on_tab_drag_motion(self, event):
        if self._drag_data["item"]:
            # This part is for visual feedback, not actual reordering yet
            # For a simple visual, we don't need complex logic here
            pass

    def on_tab_drag_release(self, event):
        if self._drag_data["item"]:
            try:
                # Get the new tab index where the mouse was released
                new_tab_index = self.board_notebook.index(f"@{event.x},{event.y}")
                if new_tab_index == "": # Dropped outside a tab, or on empty space
                    new_tab_index = len(self.board_notebook.tabs()) -1 # Move to end
                
                old_tab_index = self._drag_data["tab_index"]

                if old_tab_index != new_tab_index:
                    # Get the actual board name from the old position
                    board_name_to_move = self.board_notebook.tab(old_tab_index, "text")
                    
                    # Reorder the internal data model (self.boodesk_data["boards"])
                    # Convert dict to ordered list of (name, data) pairs
                    ordered_boards = list(self.boodesk_data["boards"].items())
                    
                    # Find and remove the board to move
                    board_data_to_move = None
                    for i, (name, data) in enumerate(ordered_boards):
                        if name == board_name_to_move:
                            board_data_to_move = ordered_boards.pop(i)
                            break
                    
                    if board_data_to_move:
                        # Insert the board at the new position
                        ordered_boards.insert(new_tab_index, board_data_to_move)
                        
                        # Reconstruct the boards dictionary to maintain order
                        self.boodesk_data["boards"] = {name: data for name, data in ordered_boards}
                        self.save_trello_data()
                        self.populate_boards() # Refresh UI
                        self.board_notebook.select(new_tab_index) # Select the moved tab

            except tk.TclError:
                pass # Invalid drop target
            finally:
                self._drag_data = {"item": None, "x": 0, "y": 0, "tab_index": -1}

    def rename_current_board(self):
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado para renomear.", parent=self.root)
                return
            old_name = self.board_notebook.tab(current_tab_index, "text")
            if old_name == "Vazio": # Cannot rename empty tab
                messagebox.showwarning("Aviso", "Não é possível renomear o quadro vazio.", parent=self.root)
                return
            self.rename_board(old_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado para renomear.", parent=self.root)

    def delete_current_board(self):
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado para excluir.", parent=self.root)
                return
            board_name = self.board_notebook.tab(current_tab_index, "text")
            if board_name == "Vazio": # Cannot delete empty tab
                messagebox.showwarning("Aviso", "Não é possível excluir o quadro vazio.", parent=self.root)
                return
            self.delete_board(board_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado para excluir.", parent=self.root)
    
    def open_project_chat(self):
        """Abre o chat do projeto atual"""
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)
                return
            board_name = self.board_notebook.tab(current_tab_index, "text")
            if board_name == "Vazio": # Cannot chat empty tab
                messagebox.showwarning("Aviso", "Não é possível abrir chat para o quadro vazio.", parent=self.root)
                return
            self.chat_system.open_project_chat(board_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)
    
    def open_meeting_window(self):
        """Abre a janela de criação de reuniões"""
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)
                return
            board_name = self.board_notebook.tab(current_tab_index, "text")
            if board_name == "Vazio": # Cannot create meeting for empty tab
                messagebox.showwarning("Aviso", "Não é possível criar reunião para o quadro vazio.", parent=self.root)
                return
            MeetingWindow(self.root, self, board_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)

    def show_board_tab_context_menu(self, event):
        try:
            tab_id = self.board_notebook.identify(event.x, event.y)
            if tab_id and tab_id != "":
                tab_name = self.board_notebook.tab(tab_id, "text")
                if tab_name == "Vazio":
                    return

                board_context_menu = tk.Menu(self.root, tearoff=0)
                board_context_menu.add_command(label=f"Renomear Quadro: {tab_name}", image=self.icons.get('pencil_icon'), compound=tk.LEFT, command=partial(self.rename_board, tab_name))
                board_context_menu.add_command(label=f"Excluir Quadro: {tab_name}", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=partial(self.delete_board, tab_name))
                board_context_menu.post(event.x_root, event.y_root)
        except tk.TclError:
            pass

    def create_productivity_sub_tabs(self, parent):
        self.productivity_notebook = ttk.Notebook(parent)
        self.productivity_notebook.pack(fill=tk.BOTH, expand=True)

        pomodoro_timer_frame = ttk.Frame(self.productivity_notebook)
        my_activities_frame = ttk.Frame(self.productivity_notebook)

        self.productivity_notebook.add(pomodoro_timer_frame, text='Timer Pomodoro')
        self.productivity_notebook.add(my_activities_frame, text='Minhas Atividades')

        # Create a new notebook for the Pomodoro Timer and History
        pomodoro_notebook = ttk.Notebook(pomodoro_timer_frame)
        pomodoro_notebook.pack(fill=tk.BOTH, expand=True)

        timer_tab_frame = ttk.Frame(pomodoro_notebook)
        history_tab_frame = ttk.Frame(pomodoro_notebook)

        pomodoro_notebook.add(timer_tab_frame, text='Timer')
        pomodoro_notebook.add(history_tab_frame, text='Histórico')

        self.create_pomodoro_timer_tab(timer_tab_frame)
        self.create_my_activities_tab(my_activities_frame)
        self.create_history_tab(history_tab_frame)

    def create_finance_sub_tabs(self, parent):
        self.finance_notebook = ttk.Notebook(parent)
        self.finance_notebook.pack(fill=tk.BOTH, expand=True)

        overview_frame = ttk.Frame(self.finance_notebook)
        incomes_frame = ttk.Frame(self.finance_notebook)
        expenses_frame = ttk.Frame(self.finance_notebook)
        transactions_history_frame = ttk.Frame(self.finance_notebook)
        registration_frame = ttk.Frame(self.finance_notebook)

        self.finance_notebook.add(overview_frame, text='Visão Geral')
        self.finance_notebook.add(incomes_frame, text='Entradas')
        self.finance_notebook.add(expenses_frame, text='Saídas')
        self.finance_notebook.add(transactions_history_frame, text='Histórico de Transações')
        self.finance_notebook.add(registration_frame, text='Cadastro')

        self.create_overview_tab(overview_frame)
        self.create_incomes_tab(incomes_frame)
        self.create_expenses_tab(expenses_frame)
        self.create_transactions_history_tab(transactions_history_frame)
        self.create_registration_tab(registration_frame)

    def select_tab_by_text(self, tab_text):
        """Seleciona uma aba do notebook principal pelo seu texto."""
        for i, tab in enumerate(self.main_notebook.tabs()):
            if self.main_notebook.tab(i, "text") == tab_text:
                self.main_notebook.select(i)
                return

    def update_dashboard_widgets(self):
        """Atualiza todos os widgets no dashboard."""
        # Update overview
        self.update_main_menu_overview()
        
        # Update urgent tasks
        self.update_urgent_tasks_widget()
        
        # Update upcoming deadlines
        self.update_upcoming_deadlines_widget()
        
        # Update recent activities
        self.update_recent_activities_widget()

    def update_dashboard_activities_widget(self):
        """Atualiza o widget 'Minhas Atividades' no dashboard."""
        if not hasattr(self, 'dashboard_activities_tree'):
            return

        for i in self.dashboard_activities_tree.get_children():
            self.dashboard_activities_tree.delete(i)

        if not self.current_user:
            return
        
        user_name = self.current_user.username
        all_cards = self.get_all_cards()
        user_cards = [
            card_info for card_info in all_cards 
            if user_name in card_info['card'].get("members", []) and 
               "concluído" not in card_info['list_name'].lower()
        ]

        importance_order = {level: i for i, level in enumerate(self.settings["importance_colors"].keys())}
        
        def sort_key(card_info):
            card = card_info['card']
            due_date_str = card.get("due_date", "")
            due_date = datetime.max
            if due_date_str:
                try:
                    due_date = datetime.strptime(due_date_str.split(' ')[0], "%Y-%m-%d")
                except ValueError:
                    pass
            importance_level = card.get("importance", "Normal")
            importance_val = importance_order.get(importance_level, 99)
            return (due_date, importance_val)

        user_cards.sort(key=sort_key)

        for card_info in user_cards:
            card = card_info['card']
            # Adiciona card_id às tags. A primeira tag é para a cor.
            tags = (card.get("importance", "Normal"), card.get('card_id'))
            self.dashboard_activities_tree.insert("", "end", values=(
                card['title'],
                card_info['board_name'],
                card.get("due_date", "N/A")
            ), tags=tags)

        # Apply colors based on importance tags
        for importance, color in self.settings["importance_colors"].items():
            self.dashboard_activities_tree.tag_configure(importance, background=color)

    def on_dashboard_activity_double_click(self, event):
        item_id = self.dashboard_activities_tree.focus()
        if not item_id:
            return

        tags = self.dashboard_activities_tree.item(item_id, "tags")
        if len(tags) < 2:
            return # Should have importance and card_id

        card_id = tags[1]

        # Find the card, its list and board
        found_card = None
        for board_name, lists in self.boodesk_data["boards"].items():
            if board_name == "workflow": continue
            for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if card.get("card_id") == card_id:
                        found_card = card
                        # Find the card_id for the found card
                        card_id = found_card.get('card_id')
                        if card_id:
                            # Dynamically get the class from the module to avoid NameError at definition time
                            CardDetailsWindow = getattr(sys.modules[__name__], 'CardDetailsWindow')
                            CardDetailsWindow(self.root, self, board_name, list_name, card_id, self.current_user)
                        else:
                            messagebox.showerror("Erro", "ID do cartão não encontrado.")
                        return

    def create_main_menu_tab(self, parent):
        # Main frame for the dashboard
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- Widgets ---
        # This frame will hold the widgets and allow for a grid layout
        widgets_frame = ttk.Frame(main_frame)
        widgets_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure grid for 2 columns and 2 rows
        widgets_frame.columnconfigure(0, weight=1)
        widgets_frame.columnconfigure(1, weight=1)
        widgets_frame.rowconfigure(0, weight=1)
        widgets_frame.rowconfigure(1, weight=1)

        # Store widget references for visibility control
        self.dashboard_widgets = {}

        # Create all widgets
        self.create_overview_widget(widgets_frame, 0, 0)
        self.create_urgent_tasks_widget(widgets_frame, 0, 1)
        self.create_upcoming_deadlines_widget(widgets_frame, 1, 0)
        self.create_recent_activities_widget(widgets_frame, 1, 1)
        self.create_quick_links_widget(widgets_frame, 2, 0)
        self.create_quick_actions_widget(widgets_frame, 2, 1)
        
        # Criar widget de reuniões se habilitado (após a visão geral)
        if self.notification_manager.notification_settings['show_widget']:
            # Criar o widget após a visão geral ser criada
            self.meeting_widget = None  # Será criado após os widgets principais

        # Apply widget visibility settings
        self.apply_dashboard_widget_settings()

        # --- Update call ---
        self.update_dashboard_widgets()

    def create_overview_widget(self, parent, row, col):
        """Cria o widget de visão geral"""
        overview_frame = ttk.LabelFrame(parent, text="Visão Geral", padding="10")
        overview_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        self.dashboard_widgets['overview'] = overview_frame

        ttk.Label(overview_frame, text="Bem-vindo ao seu Dashboard!").pack(pady=5, anchor="w")
        self.total_boards_label = ttk.Label(overview_frame, text="Total de Quadros: 0")
        self.total_boards_label.pack(pady=2, anchor="w")
        self.total_tasks_label = ttk.Label(overview_frame, text="Total de Tarefas Pomodoro: 0")
        self.total_tasks_label.pack(pady=2, anchor="w")
        self.total_members_label = ttk.Label(overview_frame, text="Total de Membros: 0")
        self.total_members_label.pack(pady=2, anchor="w")
        
        # Criar widget de reuniões discreto abaixo da visão geral
        if self.notification_manager.notification_settings['show_widget']:
            self.meeting_widget = MeetingWidget(self, overview_frame)

    def create_urgent_tasks_widget(self, parent, row, col):
        """Cria o widget de tarefas urgentes"""
        urgent_frame = ttk.LabelFrame(parent, text="Tarefas Urgentes", padding="10")
        urgent_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        urgent_frame.rowconfigure(0, weight=1)
        urgent_frame.columnconfigure(0, weight=1)
        self.dashboard_widgets['urgent_tasks'] = urgent_frame

        # Treeview for urgent tasks
        self.urgent_tasks_tree = ttk.Treeview(urgent_frame, columns=("Tarefa", "Quadro", "Importância"), show="headings", height=6)
        self.urgent_tasks_tree.heading("Tarefa", text="Tarefa")
        self.urgent_tasks_tree.heading("Quadro", text="Quadro")
        self.urgent_tasks_tree.heading("Importância", text="Importância")

        self.urgent_tasks_tree.column("Tarefa", width=200)
        self.urgent_tasks_tree.column("Quadro", width=100)
        self.urgent_tasks_tree.column("Importância", width=80, anchor="center")
        
        self.urgent_tasks_tree.bind("<Double-1>", self.on_urgent_task_double_click)

        # Add a scrollbar
        scrollbar = ttk.Scrollbar(urgent_frame, orient="vertical", command=self.urgent_tasks_tree.yview)
        self.urgent_tasks_tree.configure(yscrollcommand=scrollbar.set)
        
        self.urgent_tasks_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def create_upcoming_deadlines_widget(self, parent, row, col):
        """Cria o widget de prazos próximos"""
        deadlines_frame = ttk.LabelFrame(parent, text="Próximos Prazos", padding="10")
        deadlines_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        deadlines_frame.rowconfigure(0, weight=1)
        deadlines_frame.columnconfigure(0, weight=1)
        self.dashboard_widgets['upcoming_deadlines'] = deadlines_frame

        # Treeview for upcoming deadlines
        self.deadlines_tree = ttk.Treeview(deadlines_frame, columns=("Tarefa", "Prazo", "Dias"), show="headings", height=6)
        self.deadlines_tree.heading("Tarefa", text="Tarefa")
        self.deadlines_tree.heading("Prazo", text="Prazo")
        self.deadlines_tree.heading("Dias", text="Dias")

        self.deadlines_tree.column("Tarefa", width=200)
        self.deadlines_tree.column("Prazo", width=100)
        self.deadlines_tree.column("Dias", width=60, anchor="center")
        
        self.deadlines_tree.bind("<Double-1>", self.on_deadline_double_click)

        # Add a scrollbar
        scrollbar = ttk.Scrollbar(deadlines_frame, orient="vertical", command=self.deadlines_tree.yview)
        self.deadlines_tree.configure(yscrollcommand=scrollbar.set)
        
        self.deadlines_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def create_recent_activities_widget(self, parent, row, col):
        """Cria o widget de atividades recentes"""
        activities_frame = ttk.LabelFrame(parent, text="Atividades Recentes", padding="10")
        activities_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        activities_frame.rowconfigure(0, weight=1)
        activities_frame.columnconfigure(0, weight=1)
        self.dashboard_widgets['recent_activities'] = activities_frame

        # Treeview for recent activities
        self.recent_activities_tree = ttk.Treeview(activities_frame, columns=("Ação", "Data"), show="headings", height=6)
        self.recent_activities_tree.heading("Ação", text="Ação")
        self.recent_activities_tree.heading("Data", text="Data")

        self.recent_activities_tree.column("Ação", width=250)
        self.recent_activities_tree.column("Data", width=100)
        
        self.recent_activities_tree.bind("<Double-1>", self.on_activity_double_click)

        # Add a scrollbar
        scrollbar = ttk.Scrollbar(activities_frame, orient="vertical", command=self.recent_activities_tree.yview)
        self.recent_activities_tree.configure(yscrollcommand=scrollbar.set)
        
        self.recent_activities_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def create_quick_links_widget(self, parent, row, col):
        """Cria o widget de links rápidos"""
        links_frame = ttk.LabelFrame(parent, text="Links Frequentes", padding="10")
        links_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        self.dashboard_widgets['quick_links'] = links_frame

        ttk.Button(links_frame, text="Quadros", image=self.icons.get('folder_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Quadros')).pack(fill=tk.X, pady=2)
        ttk.Button(links_frame, text="Produtividade", image=self.icons.get('play_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Produtividade')).pack(fill=tk.X, pady=2)
        ttk.Button(links_frame, text="Finanças", image=self.icons.get('money_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Finanças')).pack(fill=tk.X, pady=2)
        ttk.Button(links_frame, text="Relatórios", image=self.icons.get('pie_chart_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Relatórios')).pack(fill=tk.X, pady=2)

    def create_quick_actions_widget(self, parent, row, col):
        """Cria o widget de ações rápidas"""
        actions_frame = ttk.LabelFrame(parent, text="Ações Rápidas", padding="10")
        actions_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        self.dashboard_widgets['quick_actions'] = actions_frame

        ttk.Button(actions_frame, text="Adicionar Quadro", image=self.icons.get('add_folder_icon'), compound=tk.LEFT, 
                  command=self.add_board).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Iniciar Pomodoro", image=self.icons.get('play_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Produtividade')).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Nova Transação", image=self.icons.get('add_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Finanças')).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Gerenciar Usuários", image=self.icons.get('key_icon'), compound=tk.LEFT, 
                  command=self.open_user_management).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Configurar Notificações", image=self.icons.get('settings_icon'), compound=tk.LEFT, 
                  command=self.open_notification_settings).pack(fill=tk.X, pady=2)
        
        # Botão para alternar widget de reuniões será movido para configurações do dashboard
        
        # Widget de reuniões será criado no método create_main_menu_tab
        ttk.Button(actions_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT, 
                  command=self.update_dashboard_widgets).pack(fill=tk.X, pady=2)

    def apply_dashboard_widget_settings(self):
        """Aplica as configurações de visibilidade dos widgets"""
        widget_settings = self.settings.get('dashboard_widgets', {})
        
        # Converter string JSON para dicionário se necessário
        if isinstance(widget_settings, str):
            try:
                import json
                widget_settings = json.loads(widget_settings)
            except:
                widget_settings = {}
        
        for widget_name, frame in self.dashboard_widgets.items():
            if widget_settings.get(widget_name, True):
                frame.grid()
            else:
                frame.grid_remove()

    def on_urgent_task_double_click(self, event):
        """Handler para duplo clique em tarefa urgente"""
        selection = self.urgent_tasks_tree.selection()
        if selection:
            item = self.urgent_tasks_tree.item(selection[0])
            task_title = item['values'][0]
            # Aqui você pode implementar a navegação para o cartão específico
            self.select_tab_by_text('Quadros')
            messagebox.showinfo("Navegação", f"Navegando para a tarefa: {task_title}")

    def on_deadline_double_click(self, event):
        """Handler para duplo clique em prazo"""
        selection = self.deadlines_tree.selection()
        if selection:
            item = self.deadlines_tree.item(selection[0])
            task_title = item['values'][0]
            # Aqui você pode implementar a navegação para o cartão específico
            self.select_tab_by_text('Quadros')
            messagebox.showinfo("Navegação", f"Navegando para a tarefa: {task_title}")

    def on_activity_double_click(self, event):
        """Handler para duplo clique em atividade"""
        selection = self.recent_activities_tree.selection()
        if selection:
            item = self.recent_activities_tree.item(selection[0])
            activity = item['values'][0]
            messagebox.showinfo("Atividade", f"Detalhes da atividade: {activity}")

    def update_main_menu_overview(self):
        # Update the quick overview labels
        total_boards = len(self.boodesk_data["boards"])
        total_tasks = len(self.pomodoro_tasks_df)
        total_members = len(self.members_df)

        self.total_boards_label.config(text=f"Total de Quadros: {total_boards}")
        self.total_tasks_label.config(text=f"Total de Tarefas Pomodoro: {total_tasks}")
        self.total_members_label.config(text=f"Total de Membros: {total_members}")

    def update_urgent_tasks_widget(self):
        """Atualiza o widget de tarefas urgentes"""
        if not hasattr(self, 'urgent_tasks_tree'):
            return
            
        self.urgent_tasks_tree.delete(*self.urgent_tasks_tree.get_children())
        
        urgent_tasks = []
        for board_name, board_data in self.boodesk_data["boards"].items():
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                    if list_name != "workflow":
                        for card in cards:
                            if not card.get("is_archived", False):
                                importance = card.get("importance", "Normal")
                                if importance in ["Alta", "Crítica"]:
                                    urgent_tasks.append({
                                        "title": card.get("title", ""),
                                        "board": board_name,
                                        "importance": importance,
                                        "card": card
                                    })
        
        # Sort by importance (Crítica first, then Alta)
        importance_order = {"Crítica": 0, "Alta": 1}
        urgent_tasks.sort(key=lambda x: importance_order.get(x["importance"], 2))
        
        # Add to treeview (top 5)
        for i, task in enumerate(urgent_tasks[:5]):
            item = self.urgent_tasks_tree.insert("", "end", values=(
                task["title"],
                task["board"],
                task["importance"]
            ))
            
            # Apply background color based on importance
            if task["importance"] == "Crítica":
                self.urgent_tasks_tree.tag_configure("critical", background="#FFCCCC")
                self.urgent_tasks_tree.item(item, tags=("critical",))
            elif task["importance"] == "Alta":
                self.urgent_tasks_tree.tag_configure("high", background="#FFE5CC")
                self.urgent_tasks_tree.item(item, tags=("high",))

    def update_upcoming_deadlines_widget(self):
        """Atualiza o widget de prazos próximos"""
        if not hasattr(self, 'deadlines_tree'):
            return
            
        self.deadlines_tree.delete(*self.deadlines_tree.get_children())
        
        deadline_tasks = []
        today = datetime.now()
        
        for board_name, board_data in self.boodesk_data["boards"].items():
            # Verificar se board_data é um dicionário ou lista
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                    if list_name != "workflow":
                        for card in cards:
                            if not card.get("is_archived", False):
                                due_date_str = card.get("due_date", "")
                                if due_date_str:
                                    try:
                                        due_date = datetime.strptime(due_date_str, '%Y-%m-%d %H:%M')
                                        if due_date > today:
                                            days_until = (due_date - today).days
                                            deadline_tasks.append({
                                                "title": card.get("title", ""),
                                                "due_date": due_date_str,
                                                "days": days_until,
                                                "card": card
                                            })
                                    except ValueError:
                                        continue
        
        # Sort by days until deadline
        deadline_tasks.sort(key=lambda x: x["days"])
        
        # Add to treeview (top 5)
        for i, task in enumerate(deadline_tasks[:5]):
            item = self.deadlines_tree.insert("", "end", values=(
                task["title"],
                task["due_date"],
                f"{task['days']} dias"
            ))
            
            # Aplicar cor baseada no quadro da tarefa
            card = task["card"]
            board_name = None
            
            # Encontrar o quadro da tarefa
            for board_name_iter, board_data in self.boodesk_data["boards"].items():
                for list_name, cards in board_data.items():
                    if list_name != "workflow":
                        for card_iter in cards:
                            if card_iter.get("id") == card.get("id"):
                                board_name = board_name_iter
                                break
                        if board_name:
                            break
                    if board_name:
                        break
                if board_name:
                    break
            
            # Aplicar cor do quadro se encontrado
            if board_name and board_name in self.settings.get('board_colors', {}):
                board_color = self.settings['board_colors'][board_name]
                tag_name = f"board_{board_name}"
                self.deadlines_tree.tag_configure(tag_name, background=board_color)
                self.deadlines_tree.item(item, tags=(tag_name,))
            else:
                # Fallback para cores baseadas na urgência
                if task["days"] <= 1:
                    self.deadlines_tree.tag_configure("urgent", background="#FFCCCC")
                    self.deadlines_tree.item(item, tags=("urgent",))
                elif task["days"] <= 3:
                    self.deadlines_tree.tag_configure("soon", background="#FFE5CC")
                    self.deadlines_tree.item(item, tags=("soon",))

    def update_recent_activities_widget(self):
        """Atualiza o widget de atividades recentes"""
        if not hasattr(self, 'recent_activities_tree'):
            return
            
        self.recent_activities_tree.delete(*self.recent_activities_tree.get_children())
        
        activities = []
        
        # Collect activities from card history
        for board_name, board_data in self.boodesk_data["boards"].items():
            # Verificar se board_data é um dicionário ou lista
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                    if list_name != "workflow":
                        for card in cards:
                            history = card.get("history", [])
                            for entry in history[-3:]:  # Last 3 entries per card
                                activities.append({
                                    "action": entry.get("action", ""),
                                    "timestamp": entry.get("timestamp", ""),
                                    "user": entry.get("user", "")
                                })
        
        # Sort by timestamp (most recent first)
        activities.sort(key=lambda x: x["timestamp"], reverse=True)
        
        # Add to treeview (top 10)
        for activity in activities[:10]:
            self.recent_activities_tree.insert("", "end", values=(
                activity["action"],
                activity["timestamp"]
            ))

    def open_user_management_window(self):
        """Abre a janela de gerenciamento de usuários (alias para open_user_management)"""
        # Usar a função principal que já está implementada e funcionando
        self.open_user_management()

    def open_management_reports(self):
        # Placeholder for Management Reports
        messagebox.showinfo("Relatórios Gerenciais", "Funcionalidade de Relatórios Gerenciais em desenvolvimento!")

    def create_accounts_registration_tab(self, parent):
        # Accounts Section
        accounts_frame = ttk.Frame(parent, padding="10")
        accounts_frame.pack(fill=tk.BOTH, expand=True)
        accounts_frame.columnconfigure(1, weight=1)

        ttk.Label(accounts_frame, text="Nome da Conta:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.account_name_entry = ttk.Entry(accounts_frame, width=40)
        self.account_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        button_frame_acc = ttk.Frame(accounts_frame)
        button_frame_acc.grid(row=1, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame_acc, text="Adicionar Conta", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_account).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_acc, text="Remover Selecionada", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_account).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_acc, text="Atualizar Saldo", image=self.icons.get('refresh_icon'), compound=tk.LEFT, command=self.update_selected_account_balance).pack(side=tk.LEFT, padx=5)

        accounts_list_frame = ttk.LabelFrame(accounts_frame, text="Contas Existentes", padding="10")
        accounts_list_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=10)
        accounts_list_frame.columnconfigure(0, weight=1)
        accounts_list_frame.rowconfigure(0, weight=1)

        self.accounts_listbox = tk.Listbox(accounts_list_frame, selectmode=tk.SINGLE, height=5)
        self.accounts_listbox.grid(row=0, column=0, sticky="nsew", pady=5)
        self.accounts_listbox.bind("<<ListboxSelect>>", self.on_account_select)
        acc_scrollbar = ttk.Scrollbar(accounts_list_frame, orient="vertical", command=self.accounts_listbox.yview)
        acc_scrollbar.grid(row=0, column=1, sticky="ns")
        self.accounts_listbox.config(yscrollcommand=acc_scrollbar.set)

    def create_categories_registration_tab(self, parent):
        # Categories Section
        categories_frame = ttk.Frame(parent, padding="10")
        categories_frame.pack(fill=tk.BOTH, expand=True)
        categories_frame.columnconfigure(1, weight=1)

        ttk.Label(categories_frame, text="Nome da Categoria:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.category_name_entry = ttk.Entry(categories_frame, width=40)
        self.category_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        button_frame_cat = ttk.Frame(categories_frame)
        button_frame_cat.grid(row=1, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame_cat, text="Adicionar Categoria", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_cat, text="Remover Selecionada", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_category).pack(side=tk.LEFT, padx=5)

        categories_list_frame = ttk.LabelFrame(categories_frame, text="Categorias Existentes", padding="10")
        categories_list_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=10)
        categories_list_frame.columnconfigure(0, weight=1)
        categories_list_frame.rowconfigure(0, weight=1)

        self.categories_listbox = tk.Listbox(categories_list_frame, selectmode=tk.SINGLE, height=5)
        self.categories_listbox.grid(row=0, column=0, sticky="nsew", pady=5)
        cat_scrollbar = ttk.Scrollbar(categories_list_frame, orient="vertical", command=self.categories_listbox.yview)
        cat_scrollbar.grid(row=0, column=1, sticky="ns")
        self.categories_listbox.config(yscrollcommand=cat_scrollbar.set)

    def create_payment_methods_registration_tab(self, parent):
        # Payment Methods Section
        payment_methods_frame = ttk.Frame(parent, padding="10")
        payment_methods_frame.pack(fill=tk.BOTH, expand=True)
        payment_methods_frame.columnconfigure(1, weight=1)

        ttk.Label(payment_methods_frame, text="Nome do Meio de Pagamento:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.payment_method_name_entry = ttk.Entry(payment_methods_frame, width=40)
        self.payment_method_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        button_frame_pm = ttk.Frame(payment_methods_frame)
        button_frame_pm.grid(row=1, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame_pm, text="Adicionar Meio de Pagamento", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_payment_method).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_pm, text="Remover Selecionado", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_payment_method).pack(side=tk.LEFT, padx=5)

        payment_methods_list_frame = ttk.LabelFrame(payment_methods_frame, text="Meios de Pagamento Existentes", padding="10")
        payment_methods_list_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=10)
        payment_methods_list_frame.columnconfigure(0, weight=1)
        payment_methods_list_frame.rowconfigure(0, weight=1)

        self.payment_methods_listbox = tk.Listbox(payment_methods_list_frame, selectmode=tk.SINGLE, height=5)
        self.payment_methods_listbox.grid(row=0, column=0, sticky="nsew", pady=5)
        pm_scrollbar = ttk.Scrollbar(payment_methods_list_frame, orient="vertical", command=self.payment_methods_listbox.yview)
        pm_scrollbar.grid(row=0, column=1, sticky="ns")
        self.payment_methods_listbox.config(yscrollcommand=pm_scrollbar.set)

    def create_incomes_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Input fields for new income transaction
        input_frame = ttk.LabelFrame(main_frame, text="Registrar Nova Entrada", padding="10")
        input_frame.pack(fill=tk.X, pady=10)

        input_frame.columnconfigure(1, weight=1)

        ttk.Label(input_frame, text="Descrição:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.income_description_entry = ttk.Entry(input_frame, width=40)
        self.income_description_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(input_frame, text="Valor:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.income_amount_entry = NumericEntryWithButtons(input_frame, self.icons)
        self.income_amount_entry.grid(row=1, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Data:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        income_date_frame = ttk.Frame(input_frame)
        income_date_frame.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        self.income_date_entry = ttk.Entry(income_date_frame, width=15, state="readonly")
        self.income_date_entry.pack(side=tk.LEFT)
        ttk.Button(income_date_frame, image=self.icons.get('time_icon'), width=3, command=partial(self._open_finance_date_picker, self.income_date_entry)).pack(side=tk.LEFT, padx=2)
        self.income_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d")) # Default to today

        ttk.Label(input_frame, text="Categoria:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.income_category_combo = ttk.Combobox(input_frame, state="readonly")
        self.income_category_combo.grid(row=3, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Meio de Pagamento:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.income_payment_method_combo = ttk.Combobox(input_frame, state="readonly")
        self.income_payment_method_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Conta Bancária:").grid(row=5, column=0, sticky="w", padx=5, pady=2)
        self.income_account_combo = ttk.Combobox(input_frame, state="readonly")
        self.income_account_combo.grid(row=5, column=1, sticky="w", padx=5, pady=2)

        ttk.Button(input_frame, text="Registrar Entrada", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.register_income).grid(row=6, column=0, columnspan=2, pady=10)

        # Treeview for displaying income transactions
        incomes_treeview_frame = ttk.LabelFrame(main_frame, text="Entradas Registradas", padding="10")
        incomes_treeview_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.incomes_treeview = ttk.Treeview(incomes_treeview_frame, columns=("Data", "Descrição", "Valor", "Categoria", "Meio de Pagamento", "Conta"), show="headings")
        self.incomes_treeview.heading("Data", text="Data")
        self.incomes_treeview.heading("Descrição", text="Descrição")
        self.incomes_treeview.heading("Valor", text="Valor")
        self.incomes_treeview.heading("Categoria", text="Categoria")
        self.incomes_treeview.heading("Meio de Pagamento", text="Meio de Pagamento")
        self.incomes_treeview.heading("Conta", text="Conta")

        self.incomes_treeview.column("Data", width=100, anchor="center")
        self.incomes_treeview.column("Descrição", width=200, anchor="w")
        self.incomes_treeview.column("Valor", width=100, anchor="e")
        self.incomes_treeview.column("Categoria", width=120, anchor="w")
        self.incomes_treeview.column("Meio de Pagamento", width=120, anchor="w")
        self.incomes_treeview.column("Conta", width=120, anchor="w")

        self.incomes_treeview.pack(fill=tk.BOTH, expand=True)

    def register_income(self):
        description = self.income_description_entry.get().strip()
        amount = self.income_amount_entry.get()
        date = self.income_date_entry.get()
        category = self.income_category_combo.get()
        payment_method = self.income_payment_method_combo.get()
        account = self.income_account_combo.get()

        if not description or amount <= 0 or not date or not category or not payment_method or not account:
            messagebox.showwarning("Campos Obrigatórios", "Por favor, preencha todos os campos da entrada e o valor deve ser positivo.")
            return

        new_transaction = {
            "descricao": description,
            "valor": amount,
            "tipo": "Entrada",
            "data": date,
            "categoria": category,
            "meio_pagamento": payment_method,
            "conta_bancaria": account,
            "timestamp": datetime.now().isoformat()
        }

        self.boodesk_data["finances"]["transacoes"].append(new_transaction)
        
        for acc in self.boodesk_data['finances']['contas_bancarias']:
            if acc['name'] == account:
                acc['balance'] += amount
                break
        
        self.save_trello_data()
        self.update_transactions_treeview()
        self.update_incomes_treeview()
        self.update_accounts_listbox()
        self.update_total_balance_display()

        self.income_description_entry.delete(0, tk.END)
        self.income_amount_entry.set(0.00)
        self.income_date_entry.delete(0, tk.END)
        self.income_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.income_category_combo.set("")
        self.income_payment_method_combo.set("")
        self.income_account_combo.set("")
        messagebox.showinfo("Sucesso", "Entrada registrada com sucesso!")
        self._show_chart(self.current_chart_type)

    def update_incomes_treeview(self):
        for i in self.incomes_treeview.get_children():
            self.incomes_treeview.delete(i)
        for transaction in self.boodesk_data["finances"]["transacoes"]:
            if transaction["tipo"] == "Entrada":
                self.incomes_treeview.insert("", "end", values=(
                    transaction["data"],
                    transaction["descricao"],
                    f"{transaction["valor"]:.2f}",
                    transaction["categoria"],
                    transaction["meio_pagamento"],
                    transaction["conta_bancaria"]
                ))

    def create_expenses_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Input fields for new expense transaction
        input_frame = ttk.LabelFrame(main_frame, text="Registrar Nova Saída", padding="10")
        input_frame.pack(fill=tk.X, pady=10)

        input_frame.columnconfigure(1, weight=1)

        ttk.Label(input_frame, text="Descrição:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.expense_description_entry = ttk.Entry(input_frame, width=40)
        self.expense_description_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(input_frame, text="Valor:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.expense_amount_entry = NumericEntryWithButtons(input_frame, self.icons)
        self.expense_amount_entry.grid(row=1, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Data:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        expense_date_frame = ttk.Frame(input_frame)
        expense_date_frame.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        self.expense_date_entry = ttk.Entry(expense_date_frame, width=15, state="readonly")
        self.expense_date_entry.pack(side=tk.LEFT)
        ttk.Button(expense_date_frame, image=self.icons.get('time_icon'), width=3, command=partial(self._open_finance_date_picker, self.expense_date_entry)).pack(side=tk.LEFT, padx=2)
        self.expense_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d")) # Default to today

        ttk.Label(input_frame, text="Categoria:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.expense_category_combo = ttk.Combobox(input_frame, state="readonly")
        self.expense_category_combo.grid(row=3, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Meio de Pagamento:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.expense_payment_method_combo = ttk.Combobox(input_frame, state="readonly")
        self.expense_payment_method_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Conta Bancária:").grid(row=5, column=0, sticky="w", padx=5, pady=2)
        self.expense_account_combo = ttk.Combobox(input_frame, state="readonly")
        self.expense_account_combo.grid(row=5, column=1, sticky="w", padx=5, pady=2)

        ttk.Button(input_frame, text="Registrar Saída", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.register_expense).grid(row=6, column=0, columnspan=2, pady=10)

        # Treeview for displaying expense transactions
        expenses_treeview_frame = ttk.LabelFrame(main_frame, text="Saídas Registradas", padding="10")
        expenses_treeview_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.expenses_treeview = ttk.Treeview(expenses_treeview_frame, columns=("Data", "Descrição", "Valor", "Categoria", "Meio de Pagamento", "Conta"), show="headings")
        self.expenses_treeview.heading("Data", text="Data")
        self.expenses_treeview.heading("Descrição", text="Descrição")
        self.expenses_treeview.heading("Valor", text="Valor")
        self.expenses_treeview.heading("Categoria", text="Categoria")
        self.expenses_treeview.heading("Meio de Pagamento", text="Meio de Pagamento")
        self.expenses_treeview.heading("Conta", text="Conta")

        self.expenses_treeview.column("Data", width=100, anchor="center")
        self.expenses_treeview.column("Descrição", width=200, anchor="w")
        self.expenses_treeview.column("Valor", width=100, anchor="e")
        self.expenses_treeview.column("Categoria", width=120, anchor="w")
        self.expenses_treeview.column("Meio de Pagamento", width=120, anchor="w")
        self.expenses_treeview.column("Conta", width=120, anchor="w")

        self.expenses_treeview.pack(fill=tk.BOTH, expand=True)

    def register_expense(self):
        description = self.expense_description_entry.get().strip()
        amount = self.expense_amount_entry.get()
        date = self.expense_date_entry.get()
        category = self.expense_category_combo.get()
        payment_method = self.expense_payment_method_combo.get()
        account = self.expense_account_combo.get()

        if not description or amount <= 0 or not date or not category or not payment_method or not account:
            messagebox.showwarning("Campos Obrigatórios", "Por favor, preencha todos os campos da saída e o valor deve ser positivo.")
            return

        new_transaction = {
            "descricao": description,
            "valor": amount,
            "tipo": "Saída",
            "data": date,
            "categoria": category,
            "meio_pagamento": payment_method,
            "conta_bancaria": account,
            "timestamp": datetime.now().isoformat()
        }

        self.boodesk_data["finances"]["transacoes"].append(new_transaction)
        
        for acc in self.boodesk_data['finances']['contas_bancarias']:
            if acc['name'] == account:
                acc['balance'] -= amount
                break
        
        self.save_trello_data()
        self.update_transactions_treeview()
        self.update_expenses_treeview()
        self.update_accounts_listbox()
        self.update_total_balance_display()

        self.expense_description_entry.delete(0, tk.END)
        self.expense_amount_entry.set(0.00)
        self.expense_date_entry.delete(0, tk.END)
        self.expense_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.expense_category_combo.set("")
        self.expense_payment_method_combo.set("")
        self.expense_account_combo.set("")
        messagebox.showinfo("Sucesso", "Saída registrada com sucesso!")
        self._show_chart(self.current_chart_type)

    def update_expenses_treeview(self):
        for i in self.expenses_treeview.get_children():
            self.expenses_treeview.delete(i)
        for transaction in self.boodesk_data["finances"]["transacoes"]:
            if transaction["tipo"] == "Saída":
                self.expenses_treeview.insert("", "end", values=(
                    transaction["data"],
                    transaction["descricao"],
                    f"{transaction["valor"]:.2f}",
                    transaction["categoria"],
                    transaction["meio_pagamento"],
                    transaction["conta_bancaria"]
                ))

    def create_transactions_history_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Treeview for displaying all transactions
        transactions_frame = ttk.LabelFrame(main_frame, text="Histórico de Transações", padding="10")
        transactions_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.transactions_treeview = ttk.Treeview(transactions_frame, columns=("Data", "Descrição", "Tipo", "Valor", "Categoria", "Meio de Pagamento", "Conta"), show="headings")
        self.transactions_treeview.heading("Data", text="Data")
        self.transactions_treeview.heading("Descrição", text="Descrição")
        self.transactions_treeview.heading("Tipo", text="Tipo")
        self.transactions_treeview.heading("Valor", text="Valor")
        self.transactions_treeview.heading("Categoria", text="Categoria")
        self.transactions_treeview.heading("Meio de Pagamento", text="Meio de Pagamento")
        self.transactions_treeview.heading("Conta", text="Conta")

        self.transactions_treeview.column("Data", width=100, anchor="center")
        self.transactions_treeview.column("Descrição", width=200, anchor="w")
        self.transactions_treeview.column("Tipo", width=80, anchor="center")
        self.transactions_treeview.column("Valor", width=100, anchor="e")
        self.transactions_treeview.column("Categoria", width=120, anchor="w")
        self.transactions_treeview.column("Meio de Pagamento", width=120, anchor="w")
        self.transactions_treeview.column("Conta", width=120, anchor="w")

        self.transactions_treeview.pack(fill=tk.BOTH, expand=True)

    def _open_finance_date_picker(self, entry_widget):
        current_date_str = entry_widget.get()
        dialog = DatePickerDialog(self.root, current_date=current_date_str, icons=self.icons)
        self.root.wait_window(dialog)
        if dialog.result_date:
            entry_widget.config(state="normal")
            entry_widget.delete(0, tk.END)
            entry_widget.insert(0, dialog.result_date.strftime("%Y-%m-%d"))
            entry_widget.config(state="readonly")

    def update_transactions_treeview(self):
        for i in self.transactions_treeview.get_children():
            self.transactions_treeview.delete(i)
        for transaction in self.boodesk_data["finances"]["transacoes"]:
            self.transactions_treeview.insert("", "end", values=(
                transaction["data"],
                transaction["descricao"],
                transaction["tipo"],
                transaction["valor"], # No f-string here, it's already a float
                transaction["categoria"],
                transaction["meio_pagamento"],
                transaction["conta_bancaria"]
            ))

    def populate_finance_comboboxes(self):
        self.income_category_combo['values'] = self.boodesk_data["finances"]["categorias_gasto"]
        self.expense_category_combo['values'] = self.boodesk_data["finances"]["categorias_gasto"]
        self.income_payment_method_combo['values'] = self.boodesk_data["finances"]["meios_pagamento"]
        self.expense_payment_method_combo['values'] = self.boodesk_data["finances"]["meios_pagamento"]
        self.income_account_combo['values'] = [acc['name'] for acc in self.boodesk_data["finances"]["contas_bancarias"]]
        self.expense_account_combo['values'] = [acc['name'] for acc in self.boodesk_data["finances"]["contas_bancarias"]]

    def create_registration_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Frame para os botões de navegação
        button_nav_frame = ttk.Frame(main_frame)
        button_nav_frame.pack(pady=10)

        ttk.Button(button_nav_frame, text="Cadastrar Contas", image=self.icons.get('add_folder_icon'), compound=tk.LEFT, command=lambda: self.registration_notebook.select(0)).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_nav_frame, text="Cadastrar Categorias", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.registration_notebook.select(1)).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_nav_frame, text="Cadastrar Meios de Pagamento", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.registration_notebook.select(2)).pack(side=tk.LEFT, padx=5)

        self.registration_notebook = ttk.Notebook(main_frame)
        self.registration_notebook.pack(fill=tk.BOTH, expand=True)

        accounts_frame = ttk.Frame(self.registration_notebook)
        categories_frame = ttk.Frame(self.registration_notebook)
        payment_methods_frame = ttk.Frame(self.registration_notebook)

        self.registration_notebook.add(accounts_frame, text='Contas Bancárias')
        self.registration_notebook.add(categories_frame, text='Categorias de Gasto')
        self.registration_notebook.add(payment_methods_frame, text='Meios de Pagamento')

        self.create_accounts_registration_tab(accounts_frame)
        self.create_categories_registration_tab(categories_frame)
        self.create_payment_methods_registration_tab(payment_methods_frame)

    def add_account(self):
        name = self.account_name_entry.get().strip()

        if not name:
            messagebox.showwarning("Campo Obrigatório", "Por favor, insira o nome da conta.")
            return

        if any(acc['name'] == name for acc in self.boodesk_data['finances']['contas_bancarias']):
            messagebox.showwarning("Conta Existente", f"Uma conta com o nome '{name}' já existe.")
            return

        self.boodesk_data['finances']['contas_bancarias'].append({"name": name, "balance": 0.00})
        self.save_trello_data()
        self.update_accounts_listbox()
        self.populate_finance_comboboxes()
        self.update_total_balance_display()
        self.account_name_entry.delete(0, tk.END)
        messagebox.showinfo("Sucesso", f"Conta '{name}' adicionada com sucesso!")
        self._show_chart(self.current_chart_type)

    def remove_account(self):
        selected_index = self.accounts_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione uma conta para remover.")
            return

        account_name_display = self.accounts_listbox.get(selected_index[0])
        account_name = account_name_display.split(" (R$")[0]

        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover a conta '{account_name}'?"):
            self.boodesk_data['finances']['contas_bancarias'] = [
                acc for acc in self.boodesk_data['finances']['contas_bancarias'] if acc['name'] != account_name
            ]
            self.save_trello_data()
            self.update_accounts_listbox()
            self.populate_finance_comboboxes()
            self.update_total_balance_display()
            messagebox.showinfo("Sucesso", f"Conta '{account_name}' removida com sucesso!")
            self._show_chart(self.current_chart_type)

    def update_selected_account_balance(self):
        selected_index = self.accounts_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione uma conta para atualizar o saldo.")
            return

        account_name_display = self.accounts_listbox.get(selected_index[0])
        account_name = account_name_display.split(" (R$")[0]

        new_balance_str = simpledialog.askstring("Atualizar Saldo", f"Digite o novo saldo para '{account_name}':", parent=self.root)
        if new_balance_str is None:
            return

        try:
            new_balance = float(new_balance_str.replace(",", "."))
        except ValueError:
            messagebox.showwarning("Entrada Inválida", "O saldo deve ser um número válido.")
            return

        found = False
        for account in self.boodesk_data['finances']['contas_bancarias']:
            if acc['name'] == account_name: # Bug in original code: 'acc' instead of 'account'
                account['balance'] = new_balance
                found = True
                break
        
        if found:
            self.save_trello_data()
            self.update_accounts_listbox()
            self.update_total_balance_display()
            messagebox.showinfo("Sucesso", f"Saldo da conta '{account_name}' atualizado para R$ {new_balance:.2f}.")
        else:
            messagebox.showerror("Erro", "Conta não encontrada. Por favor, selecione uma conta válida.")

    def update_accounts_listbox(self):
        self.accounts_listbox.delete(0, tk.END)
        for account in self.boodesk_data['finances']['contas_bancarias']:
            self.accounts_listbox.insert(tk.END, f"{account['name']} (R$ {account['balance']:.2f})")

    def on_account_select(self, event):
        selected_index = self.accounts_listbox.curselection()
        if selected_index:
            account_name_display = self.accounts_listbox.get(selected_index[0])
            account_name = account_name_display.split(" (R$")[0]
            
            for account in self.boodesk_data['finances']['contas_bancarias']:
                if account['name'] == account_name:
                    self.account_name_entry.delete(0, tk.END)
                    self.account_name_entry.insert(0, account['name'])
                    break

    def add_category(self):
        name = self.category_name_entry.get().strip()
        if not name:
            messagebox.showwarning("Campo Obrigatório", "Por favor, insira o nome da categoria.")
            return

        if name in self.boodesk_data['finances']['categorias_gasto']:
            messagebox.showwarning("Categoria Existente", f"A categoria '{name}' já existe.")
            return

        self.boodesk_data['finances']['categorias_gasto'].append(name)
        self.save_trello_data()
        self.update_categories_listbox()
        self.populate_finance_comboboxes()
        self.category_name_entry.delete(0, tk.END)
        messagebox.showinfo("Sucesso", f"Categoria '{name}' adicionada com sucesso!")

    def remove_category(self):
        selected_index = self.categories_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione uma categoria para remover.")
            return

        category_name = self.categories_listbox.get(selected_index[0])

        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover a categoria '{category_name}'?"):
            self.boodesk_data['finances']['categorias_gasto'].remove(category_name)
            self.save_trello_data()
            self.update_categories_listbox()
            self.populate_finance_comboboxes()
            messagebox.showinfo("Sucesso", f"Categoria '{category_name}' removida com sucesso!")

    def update_categories_listbox(self):
        self.categories_listbox.delete(0, tk.END)
        for category in self.boodesk_data['finances']['categorias_gasto']:
            self.categories_listbox.insert(tk.END, category)

    def add_payment_method(self):
        name = self.payment_method_name_entry.get().strip()
        if not name:
            messagebox.showwarning("Campo Obrigatório", "Por favor, insira o nome do meio de pagamento.")
            return

        if name in self.boodesk_data['finances']['meios_pagamento']:
            messagebox.showwarning("Meio de Pagamento Existente", f"O meio de pagamento '{name}' já existe.")
            return

        self.boodesk_data['finances']['meios_pagamento'].append(name)
        self.save_trello_data()
        self.update_payment_methods_listbox()
        self.populate_finance_comboboxes()
        self.payment_method_name_entry.delete(0, tk.END)
        messagebox.showinfo("Sucesso", f"Meio de pagamento '{name}' adicionado com sucesso!")

    def remove_payment_method(self):
        selected_index = self.payment_methods_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um meio de pagamento para remover.")
            return

        payment_method_name = self.payment_methods_listbox.get(selected_index[0])

        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover o meio de pagamento '{payment_method_name}'?"):
            self.boodesk_data['finances']['meios_pagamento'].remove(payment_method_name)
            self.save_trello_data()
            self.update_payment_methods_listbox()
            self.populate_finance_comboboxes()
            messagebox.showinfo("Sucesso", f"Meio de pagamento '{payment_method_name}' removido com sucesso!")

    def update_payment_methods_listbox(self):
        self.payment_methods_listbox.delete(0, tk.END)
        for method in self.boodesk_data['finances']['meios_pagamento']:
            self.payment_methods_listbox.insert(tk.END, method)

    def create_overview_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        overview_label_frame = ttk.LabelFrame(main_frame, text="Visão Geral Financeira", padding="10")
        overview_label_frame.pack(fill=tk.X, pady=10)

        self.total_balance_label = ttk.Label(overview_label_frame, text="Saldo Total: R$ 0.00", font=("Helvetica", 16, "bold"))
        self.total_balance_label.pack(pady=10)

        # Menu de Relatórios
        reports_menu_frame = ttk.Frame(main_frame)
        reports_menu_frame.pack(pady=5)

        reports_menubutton = ttk.Menubutton(reports_menu_frame, text="Relatórios Financeiros", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT, direction="below")
        reports_menubutton.pack()

        reports_menu = tk.Menu(reports_menubutton, tearoff=0)
        reports_menubutton["menu"] = reports_menu

        reports_menu.add_command(label="Relatório de Entradas (Em Breve)", command=lambda: messagebox.showinfo("Relatório", "Funcionalidade de Relatório de Entradas em desenvolvimento!"))
        reports_menu.add_command(label="Relatório de Saídas (Em Breve)", command=lambda: messagebox.showinfo("Relatório", "Funcionalidade de Relatório de Saídas em desenvolvimento!"))
        reports_menu.add_command(label="Relatório por Categoria (Em Breve)", command=lambda: messagebox.showinfo("Relatório", "Funcionalidade de Relatório por Categoria em desenvolvimento!"))
        reports_menu.add_command(label="Relatório de Contas (Em Breve)", command=lambda: messagebox.showinfo("Relatório", "Funcionalidade de Relatório de Contas em desenvolvimento!"))

        # Chart display area
        self.chart_frame = ttk.Frame(main_frame)
        self.chart_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        # Chart selection buttons
        chart_buttons_frame = ttk.Frame(main_frame)
        chart_buttons_frame.pack(pady=5)

        ttk.Button(chart_buttons_frame, text="Entradas vs Saídas", image=self.icons.get('pie_chart_icon'), compound=tk.LEFT, command=lambda: self._show_chart("income_vs_expense")).pack(side=tk.LEFT, padx=5)
        ttk.Button(chart_buttons_frame, text="Entradas por Categoria", image=self.icons.get('bar_chart_icon'), compound=tk.LEFT, command=lambda: self._show_chart("income_by_category")).pack(side=tk.LEFT, padx=5)
        ttk.Button(chart_buttons_frame, text="Saídas por Categoria", image=self.icons.get('bar_chart_icon'), compound=tk.LEFT, command=lambda: self._show_chart("expense_by_category")).pack(side=tk.LEFT, padx=5)

        self.current_chart_canvas = None
        self.current_chart_toolbar = None

        # Initial chart display
        self._show_chart("income_vs_expense")

    def update_total_balance_display(self):
        total_balance = sum(account['balance'] for account in self.boodesk_data['finances']['contas_bancarias'])
        self.total_balance_label.config(text=f"Saldo Total: R$ {total_balance:.2f}")

    def _show_chart(self, chart_type):
        # Clear previous chart
        if self.current_chart_canvas:
            self.current_chart_canvas.get_tk_widget().destroy()
        if self.current_chart_toolbar:
            self.current_chart_toolbar.destroy()

        fig = None
        if chart_type == "income_vs_expense":
            fig = self._create_income_vs_expense_pie_chart()
        elif chart_type == "income_by_category":
            fig = self._create_income_by_category_bar_chart()
        elif chart_type == "expense_by_category":
            fig = self._create_expense_by_category_bar_chart()

        if fig:
            canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
            canvas_widget = canvas.get_tk_widget()
            canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
            self.current_chart_canvas = canvas

            toolbar = NavigationToolbar2Tk(canvas, self.chart_frame)
            toolbar.update()
            toolbar.pack(side=tk.BOTTOM, fill=tk.X)
            self.current_chart_toolbar = toolbar
            canvas.draw()

    def _create_income_vs_expense_pie_chart(self):
        incomes = sum(t['valor'] for t in self.boodesk_data['finances']['transacoes'] if t['tipo'] == 'Entrada')
        expenses = sum(t['valor'] for t in self.boodesk_data['finances']['transacoes'] if t['tipo'] == 'Saída')

        labels = ['Entradas', 'Saídas']
        sizes = [incomes, expenses]
        colors = ['#4CAF50', '#F44336'] # Green for income, Red for expenses
        explode = (0.1, 0)  # explode 1st slice

        fig, ax = plt.subplots(figsize=(5, 4))

        if sum(sizes) == 0:
            ax.text(0.5, 0.5, "Sem dados para exibir", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=14, color='gray')
            ax.set_title('Entradas vs Saídas')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            # Ensure sizes are not zero to prevent RuntimeWarning: invalid value encountered in divide
            # if sum(sizes) is 0.0, the warning occurs. Already handled by `if sum(sizes) == 0:`
            ax.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%',
                   shadow=True, startangle=140)
            ax.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
            ax.set_title('Entradas vs Saídas')
        return fig

    def _create_income_by_category_bar_chart(self):
        income_by_category = {}
        for t in self.boodesk_data['finances']['transacoes']:
            if t['tipo'] == 'Entrada':
                category = t.get('categoria', 'Outros')
                income_by_category[category] = income_by_category.get(category, 0) + t['valor']

        categories = list(income_by_category.keys())
        values = list(income_by_category.values())

        fig, ax = plt.subplots(figsize=(7, 5))
        if not categories:
            ax.text(0.5, 0.5, "Sem dados de entrada por categoria", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=12, color='gray')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            ax.bar(categories, values, color='#4CAF50')
            ax.set_ylabel('Valor (R$)')
            ax.set_title('Entradas por Categoria')
            ax.tick_params(axis='x', rotation=45)
        plt.tight_layout()
        return fig

    def _create_expense_by_category_bar_chart(self):
        expense_by_category = {}
        for t in self.boodesk_data['finances']['transacoes']:
            if t['tipo'] == 'Saída':
                category = t.get('categoria', 'Outros')
                expense_by_category[category] = expense_by_category.get(category, 0) + t['valor']

        categories = list(expense_by_category.keys())
        values = list(expense_by_category.values())

        fig, ax = plt.subplots(figsize=(7, 5))
        if not categories:
            ax.text(0.5, 0.5, "Sem dados de saída por categoria", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=12, color='gray')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            ax.bar(categories, values, color='#F44336')
            ax.set_ylabel('Valor (R$)')
            ax.set_title('Saídas por Categoria')
            ax.tick_params(axis='x', rotation=45)
        plt.tight_layout()
        return fig

    def create_pomodoro_timer_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        top_frame = ttk.Frame(main_frame)
        top_frame.pack(fill=tk.X, pady=10)

        timer_frame = ttk.Frame(top_frame)
        timer_frame.pack(side=tk.LEFT, expand=True, fill=tk.X)
        self.pomodoro_timer_label = ttk.Label(timer_frame, text="", font=("Helvetica", 48))
        self.pomodoro_timer_label.pack()
        self.pomodoro_cycle_label = ttk.Label(timer_frame, text="", font=("Helvetica", 14))
        self.pomodoro_cycle_label.pack()

        stats_frame = ttk.LabelFrame(top_frame, text="Estatísticas do Pomodoro")
        stats_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
        self.pomodoro_completed_label = ttk.Label(stats_frame, text="", font=("Helvetica", 12))
        self.pomodoro_completed_label.pack(padx=10, pady=5)
        self.pomodoro_pending_label = ttk.Label(stats_frame, text="", font=("Helvetica", 12))
        self.pomodoro_pending_label.pack(padx=10, pady=5)

        self.message_label = ttk.Label(main_frame, text="", font=("Helvetica", 12, "italic"))
        self.message_label.pack(pady=10)

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=10)
        self.start_button = ttk.Button(button_frame, text="Iniciar", image=self.icons.get('play_icon'), compound=tk.LEFT, command=self.start_timer)
        self.start_button.pack(side=tk.LEFT, padx=5)
        self.pause_button = ttk.Button(button_frame, text="Pausar", image=self.icons.get('stop_icon'), compound=tk.LEFT, command=self.pause_timer, state=tk.DISABLED)
        self.pause_button.pack(side=tk.LEFT, padx=5)
        self.reset_button = ttk.Button(button_frame, text="Reiniciar", image=self.icons.get('refresh_icon'), compound=tk.LEFT, command=self.reset_timer)
        self.reset_button.pack(side=tk.LEFT, padx=5)
        self.skip_button = ttk.Button(button_frame, text="Pular", image=self.icons.get('forward_icon'), compound=tk.LEFT, command=self.skip_cycle)
        self.skip_button.pack(side=tk.LEFT, padx=5)

        task_frame = ttk.LabelFrame(main_frame, text="Tarefas do Pomodoro")
        task_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        self.pomodoro_task_list = ttk.Treeview(task_frame, columns=("Tarefa", "Status", "Assunto", "Objetivo"), show="headings")
        self.pomodoro_task_list.heading("Tarefa", text="Tarefa")
        self.pomodoro_task_list.heading("Status", text="Status")
        self.pomodoro_task_list.heading("Assunto", text="Assunto")
        self.pomodoro_task_list.heading("Objetivo", text="Objetivo")
        self.pomodoro_task_list.column("Tarefa", width=250, anchor="w")
        self.pomodoro_task_list.column("Status", width=100, anchor="center")
        self.pomodoro_task_list.column("Assunto", width=150, anchor="w")
        self.pomodoro_task_list.column("Objetivo", width=150, anchor="w")
        self.pomodoro_task_list.pack(fill=tk.BOTH, expand=True)
        self.pomodoro_task_list.bind("<<TreeviewSelect>>", self.on_pomodoro_task_select)

        task_button_frame = ttk.Frame(task_frame)
        task_button_frame.pack(pady=5)
        self.add_task_entry = ttk.Entry(task_button_frame, width=40)
        self.add_task_entry.pack(side=tk.LEFT, padx=5)
        ttk.Button(task_button_frame, text="Adicionar Tarefa", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_pomodoro_task).pack(side=tk.LEFT, padx=5)
        ttk.Button(task_button_frame, text="Remover Selecionada", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_pomodoro_task).pack(side=tk.LEFT, padx=5)
        ttk.Button(task_button_frame, text="Concluir Selecionada", image=self.icons.get('ok_icon'), compound=tk.LEFT, command=self.complete_pomodoro_task).pack(side=tk.LEFT, padx=5)

    def create_my_activities_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # PanedWindow para dividir a tela
        paned_window = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        paned_window.pack(fill=tk.BOTH, expand=True)

        # Frame da esquerda para a tabela
        left_frame = ttk.Frame(paned_window, padding="5")
        paned_window.add(left_frame, weight=1)

        # Frame da direita para as informações
        right_frame = ttk.LabelFrame(paned_window, text="Detalhes da Atividade", padding="10")
        paned_window.add(right_frame, weight=1)

        # Tabela de atividades (esquerda)
        self.activities_tree = ttk.Treeview(left_frame, columns=("Tipo", "Título", "Sub"), show="headings")
        self.activities_tree.heading("Tipo", text="Tipo")
        self.activities_tree.heading("Título", text="Título")
        self.activities_tree.heading("Sub", text="Sub")
        self.activities_tree.column("Tipo", width=80, anchor="w")
        self.activities_tree.column("Título", width=250, anchor="w")
        self.activities_tree.column("Sub", width=40, anchor="center")

        # Configurar tags de cor para importância
        for importance, color in self.settings.get("importance_colors", {}).items():
            self.activities_tree.tag_configure(importance, background=color)

        self.activities_tree.pack(fill=tk.BOTH, expand=True)
        self.activities_tree.bind("<<TreeviewSelect>>", self.on_activity_select)
        self.activities_tree.bind("<Double-1>", self.on_activity_double_click)

        bold_font = ("Helvetica", 9, "bold")

        # Labels para informações (direita)
        ttk.Label(right_frame, text="Descrição:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_desc_text = tk.Text(right_frame, height=5, wrap=tk.WORD, state="disabled")
        self.activity_desc_text.pack(fill=tk.X, pady=2)

        ttk.Label(right_frame, text="Prazo:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_due_date_label = ttk.Label(right_frame, text="-")
        self.activity_due_date_label.pack(anchor="w", pady=2)

        # Adicionar mais labels conforme necessário (ex: membros, assunto, etc.)
        ttk.Label(right_frame, text="Membros:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_members_label = ttk.Label(right_frame, text="-")
        self.activity_members_label.pack(anchor="w", pady=2)

        ttk.Label(right_frame, text="Dependências:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_dependencies_label = ttk.Label(right_frame, text="-")
        self.activity_dependencies_label.pack(anchor="w", pady=2)

        ttk.Label(right_frame, text="Subtarefas:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_subtasks_text = tk.Text(right_frame, height=5, wrap=tk.WORD, state="disabled")
        self.activity_subtasks_text.pack(fill=tk.X, pady=2)

        # Botões de Ação
        action_frame = ttk.Frame(right_frame)
        action_frame.pack(fill=tk.X, pady=10)
        ttk.Button(action_frame, text="Ir para o Quadro", image=self.icons.get('forward_icon_32'), compound=tk.LEFT, command=self.go_to_board_from_activity).pack(side=tk.LEFT, padx=5)
        ttk.Button(action_frame, text="Abrir Card", image=self.icons.get('open_file_icon_32'), compound=tk.LEFT, command=self.open_card_from_activity).pack(side=tk.LEFT, padx=5)

        # Botão para atualizar
        ttk.Button(main_frame, text="Atualizar", image=self.icons.get('refresh_icon_32'), compound=tk.LEFT, command=self.update_my_activities_tab).pack(pady=5)

        # Legenda de Cores
        legend_frame = ttk.Frame(main_frame)
        legend_frame.pack(fill=tk.X, pady=5, side=tk.BOTTOM)
        ttk.Label(legend_frame, text="Legenda:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=5)
        for imp, color in self.settings.get("importance_colors", {}).items():
            ttk.Label(legend_frame, text=imp, background=color, font=("Helvetica", 8)).pack(side=tk.LEFT, padx=2)

        self.update_my_activities_tab()

    def update_my_activities_tab(self):
        for i in self.activities_tree.get_children():
            self.activities_tree.delete(i)

        if not self.current_user:
            return

        user_name = self.current_user.username
        all_cards = self.get_all_cards()

        # Filter for cards assigned to the current user or show all for admin
        if self.current_user.role == 'admin':
            user_cards = all_cards
        else:
            user_cards = [
                card_info for card_info in all_cards
                if user_name in card_info['card'].get('members', []) and
                not card_info['card'].get("is_archived", False)
            ]

        for card_info in user_cards:
            card = card_info['card']
            card_id = card.get('card_id')
            if not card_id:
                continue

            importance_tag = card.get("importance", "Normal")
            has_subtasks_indicator = "*" if card.get("subtasks") else ""

            # Insert the parent card, using its card_id as the iid and in the tags
            self.activities_tree.insert(
                "", "end",
                iid=card_id,
                values=("Tarefa", card['title'], has_subtasks_indicator),
                tags=(card_id, importance_tag)
            )

            # Add subtasks, also tagging them with the parent card_id
            if 'subtasks' in card:
                for subtask in card['subtasks']:
                    subtask_id = subtask.get('id')
                    if subtask_id:
                        self.activities_tree.insert(
                            card_id, "end",
                            iid=subtask_id,
                            values=("Subtarefa", subtask['text'], ""),
                            tags=(card_id,)
                        )

    def on_activity_double_click(self, event):
        item_id = self.activities_tree.identify_row(event.y)
        if not item_id:
            return

        item_type = self.activities_tree.item(item_id, "values")[0]
        if item_type == "Subtarefa":
            parent_id = self.activities_tree.parent(item_id)
            card = self.find_card_by_id(parent_id)
            subtask = self.find_subtask_by_id(card, item_id)
            if card and subtask:
                SubtaskEditorWindow(self.root, self, card, subtask)

    def on_activity_select(self, event):
        selected_item = self.activities_tree.selection()
        if not selected_item:
            return

        item_id = selected_item[0]
        card_id = self.activities_tree.item(item_id, "tags")[0]
        card_info = self.find_card_and_board_by_id(card_id)

        if not card_info:
            return

        card = card_info['card']

        # --- Clear and prepare the details view ---
        self.activity_desc_text.config(state="normal")
        self.activity_desc_text.delete("1.0", tk.END)
        self.activity_subtasks_text.config(state="normal")
        self.activity_subtasks_text.delete("1.0", tk.END)

        # --- Configure fonts ---
        bold_font = ("Helvetica", 9, "bold")
        normal_font = ("Helvetica", 9)

        # --- Populate details ---
        self.activity_due_date_label.config(text=card.get("due_date", "-"))
        self.activity_members_label.config(text=", ".join(card.get("members", [])) or "-")
        self.activity_dependencies_label.config(text=", ".join(card.get("dependencies", [])) or "-")

        self.activity_desc_text.insert("1.0", card.get("desc", "Sem descrição."))

        # --- Populate Subtasks with formatting ---
        self.activity_subtasks_text.tag_configure("bold", font=bold_font)
        subtasks = card.get("subtasks", [])
        if not subtasks:
            self.activity_subtasks_text.insert("1.0", "Nenhuma subtarefa.")
        else:
            for subtask in subtasks:
                status = "[X]" if subtask.get('completed') else "[ ]"
                self.activity_subtasks_text.insert(tk.END, f"{status} ")
                self.activity_subtasks_text.insert(tk.END, f"{subtask.get('text', '')}\n", "bold")
                if subtask.get('desc'):
                    self.activity_subtasks_text.insert(tk.END, f"  - {subtask.get('desc')}\n")

        # --- Set text widgets to disabled ---
        self.activity_desc_text.config(state="disabled")
        self.activity_subtasks_text.config(state="disabled")

    def find_card_by_id(self, card_id):
        for board_name, lists in self.boodesk_data["boards"].items():
            if board_name == "workflow": continue
            for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if card.get('card_id') == card_id:
                        return card
        return None

    def find_subtask_by_id(self, card, subtask_id):
        if card and "subtasks" in card:
            for subtask in card["subtasks"]:
                if subtask.get("id") == subtask_id:
                    return subtask
        return None

    def go_to_board_from_activity(self):
        selected_item_id = self.activities_tree.selection()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Seleção", "Selecione uma atividade para navegar.", parent=self.root)
            return

        item_id = selected_item_id[0]
        
        # If it's a subtask, get the parent card's ID
        parent_id = self.activities_tree.parent(item_id)
        if parent_id:
            item_id = parent_id

        card_info = self.find_card_and_board_by_id(item_id)
        if card_info:
            board_name = card_info["board_name"]
            
            # Find the index of the 'Quadros' tab in the main notebook
            boards_tab_index = -1
            for i, tab in enumerate(self.main_notebook.tabs()):
                if self.main_notebook.tab(i, "text") == 'Quadros':
                    boards_tab_index = i
                    break
            
            if boards_tab_index != -1:
                self.main_notebook.select(boards_tab_index)
                
                # Now find and select the specific board's tab
                for i, tab in enumerate(self.board_notebook.tabs()):
                    if self.board_notebook.tab(i, "text") == board_name:
                        self.board_notebook.select(i)
                        break

    def open_card_from_activity(self, event=None):
        selected_item_id = self.activities_tree.selection()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Seleção", "Selecione uma atividade para abrir.", parent=self.root)
            return

        item_id = selected_item_id[0]
        tags = self.activities_tree.item(item_id, "tags")

        if not tags:
            messagebox.showerror("Erro", "O item selecionado não tem um ID de cartão associado.", parent=self.root)
            return

        card_id = tags[0]  # The card_id is the first tag
        card_info = self.find_card_and_board_by_id(card_id)

        if card_info:
            CardWindow(self.root, self, card_info["board_name"], card_info["list_name"], card_info["card"], self.current_user)
        else:
            messagebox.showerror("Erro", f"Cartão com ID '{card_id}' não encontrado. Pode ter sido movido ou removido.", parent=self.root)

    def find_card_and_board_by_id(self, card_id):
        for board_name, board_content in self.boodesk_data.get("boards", {}).items():
            if isinstance(board_content, dict):
                for list_name, cards in board_content.items():
                    if isinstance(cards, list):
                        for card in cards:
                            if card.get("card_id") == card_id:
                                return {"board_name": board_name, "list_name": list_name, "card": card}
        return None

    def create_history_tab(self, parent):
        history_frame = ttk.LabelFrame(parent, text="Histórico de Estudos")
        history_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.log_list = ttk.Treeview(history_frame, columns=("Data e Hora", "Assunto", "Duração (min)"), show="headings")
        self.log_list.heading("Data e Hora", text="Data e Hora")
        self.log_list.heading("Assunto", text="Assunto")
        self.log_list.heading("Duração (min)", text="Duração (min)")
        self.log_list.column("Data e Hora", width=200, anchor="center")
        self.log_list.column("Assunto", width=200, anchor="w")
        self.log_list.column("Duração (min)", width=150, anchor="center")
        scrollbar = ttk.Scrollbar(history_frame, orient="vertical", command=self.log_list.yview)
        self.log_list.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        self.log_list.pack(fill=tk.BOTH, expand=True)

    def on_card_select_treeview(self, board_name, list_name, event):
        """Handler para seleção de cartão no treeview"""
        treeview = event.widget
        selection = treeview.selection()
        
        if selection:
            item = treeview.item(selection[0])
            card_id = item['tags'][0] if item['tags'] else None
            
            if card_id:
                # Find the card data
                for card in self.boodesk_data["boards"][board_name][list_name]:
                    if card.get('card_id') == card_id:
                        self.show_card_details(card)
                        break

    def get_boards_for_member(self, member_name):
        """Retorna apenas os quadros onde o membro participa de cards"""
        boards = []
        for board_name, board_data in self.boodesk_data['boards'].items():
            for list_name, cards in board_data.items():
                if list_name == 'workflow':  # Ignorar metadados
                    continue
                for card in cards:
                    if member_name in card.get('members', []):
                        boards.append(board_name)
                        break  # Uma vez encontrado, não precisa verificar mais cards
        return list(set(boards))  # Remove duplicatas

    def _should_show_board_for_user(self, board_name, current_user_member):
        """Versão melhorada do filtro de quadros - mostra apenas quadros relevantes ao membro"""
        try:
            # Administradores veem todos os quadros
            if hasattr(self, 'current_user') and getattr(self.current_user, 'role', None) == 'admin':
                return True
            
            # Se não há membro associado, mostrar apenas quadros principais
            if not current_user_member:
                return board_name in ["Quadro Principal", "Quadro Geral"]
            
            # Verificar se o membro participa de algum card no quadro
            board_data = self.boodesk_data.get("boards", {}).get(board_name, {})
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                    if list_name == 'workflow':
                        continue
                    for card in cards:
                        if current_user_member in card.get('members', []):
                            return True
            
            # Quadros especiais sempre visíveis
            if board_name in ["Quadro Principal", "Quadro Geral"]:
                return True
            
            return False
        except Exception as e:
            print(f"DEBUG: _should_show_board_for_user - Erro: {e}")
            # Em caso de erro, manter comportamento permissivo para não ocultar quadros indevidamente
            return True

    # --- UI Population and Updates ---
    def populate_boards(self):
        print(f"DEBUG: populate_boards iniciado")
        print(f"DEBUG: boodesk_data['boards'] = {self.boodesk_data['boards']}")
        print(f"DEBUG: Número de quadros: {len(self.boodesk_data['boards'])}")
        
        try:
            selected_tab_index = self.board_notebook.index(self.board_notebook.select())
        except tk.TclError:
            selected_tab_index = 0

        for i in self.board_notebook.tabs():
            self.board_notebook.forget(i)

        self.listbox_refs = {} # Clear existing references

        # Garantir que pelo menos o Quadro Principal existe
        if not self.boodesk_data["boards"] or "Quadro Principal" not in self.boodesk_data["boards"]:
            print("DEBUG: Criando Quadro Principal padrão")
            self.boodesk_data["boards"]["Quadro Principal"] = {
                "A Fazer": [],
                "Em Progresso": [],
                "Concluído": []
            }

        importance_colors = self.settings["importance_colors"]
        
        # Obter o membro do usuário atual (se método estiver disponível)
        current_user_member = None
        try:
            if hasattr(self, '_get_current_user_member'):
                current_user_member = self._get_current_user_member()
            else:
                # Se o método não existe, definir como None
                current_user_member = None
        except Exception as e:
            print(f"DEBUG: populate_boards - erro ao obter membro do usuário: {e}")
            current_user_member = None
        print(f"DEBUG: populate_boards - Usuário atual: {current_user_member}")

        print("DEBUG: Criando quadros na interface...")
        for board_name, lists in self.boodesk_data["boards"].items():
            print(f"DEBUG: Processando quadro: {board_name}")
            print(f"DEBUG: Tipo de lists: {type(lists)}")
            print(f"DEBUG: Conteúdo de lists: {lists}")
            
            # Verificar se o quadro deve ser exibido para o usuário atual
            should_show_board = self._should_show_board_for_user(board_name, current_user_member)
            print(f"DEBUG: populate_boards - Quadro '{board_name}' deve ser exibido: {should_show_board}")
            
            if not should_show_board:
                print(f"DEBUG: Quadro '{board_name}' não será exibido")
                continue
                
            print(f"DEBUG: Criando frame para quadro: {board_name}")
            board_frame = ttk.Frame(self.board_notebook, padding=5)
            self.board_notebook.add(board_frame, text=board_name)
            
            # Verificar se o quadro foi adicionado corretamente
            print(f"DEBUG: Número de abas após adicionar '{board_name}': {len(self.board_notebook.tabs())}")

            list_management_frame = ttk.Frame(board_frame)
            list_management_frame.pack(fill=tk.X, pady=5)
            ttk.Button(list_management_frame, text="Adicionar Nova Lista", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_list, board_name)).pack(side=tk.LEFT)

            list_container = ttk.Frame(board_frame)
            list_container.pack(fill=tk.BOTH, expand=True)

            # Verificar se lists é um dicionário ou lista
            if isinstance(lists, dict):
                print(f"DEBUG: Lists é um dicionário com {len(lists)} listas")
                for list_name, cards in lists.items():
                    print(f"DEBUG: Processando lista: {list_name} com {len(cards)} cards")
                    list_frame = ttk.LabelFrame(list_container, text=list_name, padding=5)
                    list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)

                    # Context menu for list management
                    list_context_menu = tk.Menu(self.root, tearoff=0)
                    list_context_menu.add_command(label="Renomear Lista", image=self.icons.get('pencil_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.rename_list(b, l))
                    list_context_menu.add_command(label="Excluir Lista", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.delete_list(b, l))
                    list_context_menu.add_separator()
                    list_context_menu.add_command(label="Mover para Esquerda", image=self.icons.get('left_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.move_list(b, l, -1))
                    list_context_menu.add_command(label="Mover para Direita", image=self.icons.get('right_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.move_list(b, l, 1))
                    
                    # Bind right-click to the LabelFrame (list header)
                    list_frame.bind("<Button-3>", lambda event, menu=list_context_menu: menu.post(event.x_root, event.y_root))

                    treeview = ttk.Treeview(list_frame, columns=("Title", "Subject", "Due Date", "Importance"), show="headings")
                    treeview.heading("Title", text="Título")
                    treeview.heading("Subject", text="Assunto")
                    treeview.heading("Due Date", text="Prazo")
                    treeview.heading("Importance", text="Importância")

                    treeview.column("Title", width=150, anchor="w")
                    treeview.column("Subject", width=100, anchor="w")
                    treeview.column("Due Date", width=100, anchor="center")
                    treeview.column("Importance", width=80, anchor="center")

                    treeview.pack(fill=tk.BOTH, expand=True, pady=5)
                    DraggableTreeview(treeview, self, board_name, list_name) # Enable drag-and-drop for Treeview
                    treeview.bind("<Double-1>", self.open_card_details) # Double-click to open card details
                    treeview.bind("<Button-3>", partial(self.show_card_context_menu, board_name, list_name)) # Right-click for card context menu
                    treeview.bind("<Key>", partial(self.handle_card_key_press, board_name, list_name)) # Keyboard shortcuts
                    treeview.bind("<<TreeviewSelect>>", partial(self.on_card_select_treeview, board_name, list_name)) # New binding for click-to-expand

                    # Store reference to treeview for target identification
                    self.listbox_refs[(board_name, list_name)] = treeview

                    # Apply filters
                    filtered_cards = []
                    filter_subject = self.filter_subject_var.get()
                    filter_goal = self.filter_goal_var.get()
                    filter_member = self.filter_member_var.get()
                    filter_due_date = self.filter_due_date_var.get()
                    filter_importance = self.filter_importance_var.get()
                    filter_recurrence = self.filter_recurrence_var.get()
                    filter_keyword = self.filter_keyword_var.get().lower()

                    # Get current user's member name for filtering
                    try:
                        if hasattr(self, '_get_current_user_member'):
                            current_user_member = self._get_current_user_member()
                        else:
                            current_user_member = None
                    except Exception as e:
                        print(f"DEBUG: Erro ao obter membro do usuário para filtro: {e}")
                        current_user_member = None

                    for card in cards:
                        match = True

                        # User-Member filter - show only cards where current user is a member
                        # MODIFICAÇÃO: Tornar o filtro menos restritivo para evitar tela em branco
                        if current_user_member and getattr(self.current_user, 'role', None) != 'admin':
                            card_members = card.get('members', [])
                            # Se o cartão não tem membros, mostrar para todos
                            if card_members and current_user_member not in card_members:
                                match = False

                        # Keyword filter
                        if match and filter_keyword:
                            card_title_lower = card.get('title', '').lower()
                            card_desc_lower = card.get('desc', '').lower()
                            if filter_keyword not in card_title_lower and filter_keyword not in card_desc_lower:
                                match = False

                        # Subject filter - only apply if filter is not empty
                        if match and filter_subject and filter_subject != "Todos" and card.get('subject') != filter_subject:
                            match = False
                        
                        # Goal filter - only apply if filter is not empty
                        if match and filter_goal and filter_goal != "Todos" and card.get('goal') != filter_goal:
                            match = False

                        # Member filter - only apply if filter is not empty
                        if match and filter_member and filter_member.lower() != "todos":
                            card_members = [m.lower() for m in card.get('members', [])]
                            if filter_member.lower() not in card_members:
                                match = False

                        # Due Date filter - only apply if filter is not empty
                        if match and filter_due_date and filter_due_date != "Todos":
                            if not self._filter_due_date(card.get('due_date', ''), filter_due_date):
                                match = False

                        # Importance filter - only apply if filter is not empty
                        if match and filter_importance and filter_importance != "Todos" and card.get('importance') != filter_importance:
                            match = False

                        # Recurrence filter - only apply if filter is not empty
                        if match and filter_recurrence and filter_recurrence != "Todos" and card.get('recurrence', 'Nenhuma') != filter_recurrence:
                            match = False

                        if match:
                            filtered_cards.append(card)

                    for card in filtered_cards: # Iterate directly over filtered_cards
                        if card.get('is_archived', False): # Skip archived cards
                            continue

                        title = card['title']
                        subject = card.get('subject', '-')
                        due_date = card.get('due_date', '')
                        importance = card.get('importance', 'Normal')
                        card_id = card.get('card_id') # Get the unique card ID for tagging

                        # Insert main card row
                        item_id = treeview.insert("", "end", values=(title, subject, due_date, importance), tags=(card_id,))
                        
                        # Apply background color based on importance
                        bg_color = importance_colors.get(importance, "white")
                        dependencies = card.get('dependencies', [])
                        if dependencies and not self.can_start_card(card):
                            # Adjust color for cards with unfulfilled dependencies
                            if bg_color == "white": bg_color = "#f0f0f0"
                            elif bg_color == "#ffcccc": bg_color = "#ffb3b3"
                            elif bg_color == "#ffffcc": bg_color = "#ffffb3"
                            elif bg_color == "#ccffcc": bg_color = "#b3ffb3"
                        
                        treeview.tag_configure(card_id, background=bg_color)
                        treeview.item(item_id, tags=(card_id,)) # Apply the tag to the item

                    treeview.filtered_cards = filtered_cards

                    card_management_frame = ttk.Frame(list_frame)
                    card_management_frame.pack(fill=tk.X, pady=5)
                    ttk.Button(card_management_frame, text="Adicionar Cartão", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_card, board_name, list_name)).pack(side=tk.LEFT, expand=True, fill=tk.X, padx=2)
            elif isinstance(lists, list):
                print(f"DEBUG: Lists é uma lista (workflow) com {len(lists)} itens: {lists}")
                # Pular quadros que são listas (como workflow)
                continue
            else:
                print(f"DEBUG: Tipo inesperado para lists: {type(lists)}")
                continue

        # Verificar se há quadros visíveis
        if not self.board_notebook.tabs():
            print("DEBUG: Nenhum quadro visível - criando quadro padrão")
            # Criar um quadro padrão se nenhum estiver visível
            default_board_frame = ttk.Frame(self.board_notebook, padding=5)
            self.board_notebook.add(default_board_frame, text="Quadro Principal")
            
            list_management_frame = ttk.Frame(default_board_frame)
            list_management_frame.pack(fill=tk.X, pady=5)
            ttk.Button(list_management_frame, text="Adicionar Nova Lista", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_list, "Quadro Principal")).pack(side=tk.LEFT)
            
            # Criar as listas padrão no quadro
            list_container = ttk.Frame(default_board_frame)
            list_container.pack(fill=tk.BOTH, expand=True)
            
            # Criar as três listas padrão
            for list_name in ["A Fazer", "Em Progresso", "Concluído"]:
                list_frame = ttk.LabelFrame(list_container, text=list_name, padding=5)
                list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
                
                treeview = ttk.Treeview(list_frame, columns=("Title", "Subject", "Due Date", "Importance"), show="headings")
                treeview.heading("Title", text="Título")
                treeview.heading("Subject", text="Assunto")
                treeview.heading("Due Date", text="Prazo")
                treeview.heading("Importance", text="Importância")
                
                treeview.column("Title", width=150, anchor="w")
                treeview.column("Subject", width=100, anchor="w")
                treeview.column("Due Date", width=100, anchor="center")
                treeview.column("Importance", width=80, anchor="center")
                
                treeview.pack(fill=tk.BOTH, expand=True, pady=5)
                self.listbox_refs[("Quadro Principal", list_name)] = treeview
                
                card_management_frame = ttk.Frame(list_frame)
                card_management_frame.pack(fill=tk.X, pady=5)
                ttk.Button(card_management_frame, text="Adicionar Cartão", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_card, "Quadro Principal", list_name)).pack(side=tk.LEFT, expand=True, fill=tk.X, padx=2)
            
            # Garantir que o Quadro Principal existe nos dados
            if "Quadro Principal" not in self.boodesk_data['boards']:
                self.boodesk_data['boards']["Quadro Principal"] = {
                    "A Fazer": [],
                    "Em Progresso": [],
                    "Concluído": []
                }
        
        if self.board_notebook.tabs():
            if selected_tab_index < len(self.board_notebook.tabs()):
                self.board_notebook.select(selected_tab_index)
            else:
                self.board_notebook.select(0)
        self.update_gantt_chart()

    def show_card_context_menu(self, board_name, list_name, event):
        treeview = event.widget
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return

        # Get the card_id from the tags of the selected item
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object and its index in the boodesk_data structure
        card_index = -1
        for i, card in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if card.get('card_id') == card_id:
                card_index = i
                break

        if card_index == -1:
            return

        card_context_menu = tk.Menu(self.root, tearoff=0)
        card_context_menu.add_command(label="Abrir Detalhes do Cartão", image=self.icons.get('info_icon'), compound=tk.LEFT, command=partial(self.open_card_details_from_context, board_name, list_name, card_index))
        card_context_menu.add_command(label="Arquivar Cartão", image=self.icons.get('folder_icon'), compound=tk.LEFT, command=partial(self.archive_card_from_context, board_name, list_name, treeview, card_index))
        card_context_menu.add_command(label="Excluir Cartão (Permanente)", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=partial(self.delete_card_permanently_from_context, board_name, list_name, treeview, card_index))
        card_context_menu.post(event.x_root, event.y_root)

    def handle_card_key_press(self, board_name, list_name, event):
        """Handle keyboard shortcuts for cards"""
        treeview = event.widget
        selected_item_id = treeview.focus()
        
        if not selected_item_id:
            return

        card_id = treeview.item(selected_item_id, "tags")[0]
        card_index = -1
        for i, card in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if card.get('card_id') == card_id:
                card_index = i
                break

        if card_index == -1:
            return
            
        if event.keysym == 'Delete':
            # Delete key pressed - delete the selected card
            self.delete_card_permanently_from_context(board_name, list_name, treeview, card_index)
        elif event.keysym == 'Return':
            # Enter key pressed - open card details
            self.open_card_details_from_context(board_name, list_name, card_index)

    def open_card_details_from_context(self, board_name, list_name, card_index):
        # Get the card_id from the actual card object
        card_to_open = self.boodesk_data["boards"][board_name][list_name][card_index]
        card_id = card_to_open.get('card_id')
        if card_id:
            CardWindow(self.root, self, board_name, list_name, card_id, self.current_user)
        else:
            messagebox.showerror("Erro", "Não foi possível abrir os detalhes do cartão: ID do cartão não encontrado.")

    def open_archived_cards_window(self):
        ArchivedCardsWindow(self.root, self)

    def archive_card_from_context(self, board_name, list_name, treeview, card_index):
        # Get the card_id from the tags of the selected item
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object using its card_id
        card_to_archive = None
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card.get('card_id') == card_id:
                card_to_archive = card
                break
        
        if not card_to_archive:
            messagebox.showerror("Erro", "Cartão não encontrado.")
            return

        card_title = card_to_archive['title']
        if messagebox.askyesno("Confirmar Arquivamento", f"Tem certeza que deseja arquivar o cartão '{card_title}'?", parent=self.root):
            card_to_archive['is_archived'] = True
            self.save_trello_data()
            self.populate_boards()
            messagebox.showinfo("Cartão Arquivado", f"O cartão '{card_title}' foi arquivado.")

    def delete_card_permanently_from_context(self, board_name, list_name, treeview, card_index):
        # Get the card_id from the tags of the selected item
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object using its card_id
        card_to_delete = None
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card.get('card_id') == card_id:
                card_to_delete = card
                break
        
        if not card_to_delete:
            messagebox.showerror("Erro", "Cartão não encontrado.")
            return

        card_title = card_to_delete['title']
        if messagebox.askyesno("Confirmar Exclusão Permanente", f"Tem certeza que deseja EXCLUIR PERMANENTEMENTE o cartão '{card_title}'? Esta ação não pode ser desfeita.", parent=self.root):
            # Remove the card from the data structure by card_id
            self.boodesk_data["boards"][board_name][list_name] = [
                card for card in self.boodesk_data["boards"][board_name][list_name] if card.get('card_id') != card_id
            ]
            self.save_trello_data()
            self.populate_boards()

    def update_pomodoro_task_list(self):
        for i in self.pomodoro_task_list.get_children():
            self.pomodoro_task_list.delete(i)
        for index, row in self.pomodoro_tasks_df.iterrows():
            self.pomodoro_task_list.insert("", "end", values=(row["Tarefa"], row["Status"], row["Assunto"], row["Objetivo"]))
        self.update_pomodoro_stats()

    def update_pomodoro_stats(self):
        completed = len(self.pomodoro_tasks_df[self.pomodoro_tasks_df['Status'] == 'Concluído'])
        pending = len(self.pomodoro_tasks_df[self.pomodoro_tasks_df['Status'] == 'Pendente'])
        self.pomodoro_completed_label.config(text=f"Concluídas: {completed}")
        self.pomodoro_pending_label.config(text=f"Pendentes: {pending}")

    def update_timer_display(self):
        display_seconds = self.time_left if self.time_left > 0 else self.get_current_time_setting() * 60
        # Garantir que display_seconds seja um número
        if isinstance(display_seconds, str):
            try:
                display_seconds = int(display_seconds)
            except:
                display_seconds = 0
        minutes, secs = divmod(display_seconds, 60)
        text = f"{minutes:02d}:{secs:02d}"
        self.pomodoro_timer_label.config(text=text)
        self.pomodoro_cycle_label.config(text=f"Ciclo: {self.current_cycle}/{self.settings['cycles']}")

    def get_current_time_setting(self):
        if self.on_break:
            return self.settings['short_break'] if self.current_cycle % self.settings['cycles'] != 0 else self.settings['long_break']
        return self.settings['pomodoro']

    def on_pomodoro_task_select(self, event):
        selected_item = self.pomodoro_task_list.selection()
        if not selected_item:
            return
        
        task_name = self.pomodoro_task_list.item(selected_item, "values")[0]
        task_details = self.pomodoro_tasks_df[self.pomodoro_tasks_df['Tarefa'] == task_name].iloc[0].to_dict()
        self.active_pomodoro_task = {"source": "pomodoro_list", "details": task_details}

    def open_card_details(self, event):
        """Abre a janela de detalhes do cartão quando o usuário faz duplo clique"""
        treeview = event.widget
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return

        board_name = self.board_notebook.tab(self.board_notebook.select(), "text")
        list_name = treeview.master.cget("text")
        
        # Get the card_id from the tags of the selected item
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object and its index in the boodesk_data structure
        card_index = -1
        for i, card in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if card.get('card_id') == card_id:
                card_index = i
                break

        if card_index != -1:
            CardWindow(self.root, self, board_name, list_name, card_id, self.current_user)

    def start_pomodoro_from_card(self, board_name, list_name, card_id):
        card = None
        for c in self.boodesk_data["boards"][board_name][list_name]:
            if c.get('card_id') == card_id:
                card = c
                break
        
        if not card:
            messagebox.showerror("Erro", "Cartão não encontrado para iniciar Pomodoro.")
            return

        self.active_pomodoro_task = {"source": "boodesk", "details": card}
        messagebox.showinfo("Pomodoro Iniciado", f"Timer iniciado para a tarefa: {card['title']}")
        self.main_notebook.select(1) # Seleciona a aba Pomodoro
        self.pomodoro_notebook.select(0) # Seleciona a sub-aba Timer Pomodoro
        self.start_timer()

    def start_timer(self):
        if not self.active_pomodoro_task:
            messagebox.showwarning("Nenhuma Tarefa", "Selecione uma tarefa na lista de Pomodoro ou inicie a partir de um cartão Trello.")
            return
        if self.timer_running:
            return
        self.timer_running = True
        self.start_button.config(state=tk.DISABLED)
        self.pause_button.config(state=tk.NORMAL)
        self.reset_button.config(state=tk.NORMAL)
        self.skip_button.config(state=tk.NORMAL)
        if self.time_left == 0:
            self.time_left = self.get_current_time_setting() * 60
        self.countdown(self.time_left)

    def pause_timer(self):
        if not self.timer_running:
            return
        self.timer_running = False
        self.start_button.config(state=tk.NORMAL)
        self.pause_button.config(state=tk.DISABLED)
        if self.timer_id:
            self.root.after_cancel(self.timer_id)

    def reset_timer(self):
        if self.timer_id:
            self.root.after_cancel(self.timer_id)
        self.timer_running = False
        self.current_cycle = 0
        self.on_break = False
        self.time_left = 0
        self.update_timer_display()
        self.start_button.config(state=tk.NORMAL)
        self.pause_button.config(state=tk.DISABLED)
        self.reset_button.config(state=tk.DISABLED)
        self.skip_button.config(state=tk.DISABLED)

    def skip_cycle(self):
        if self.timer_id:
            self.root.after_cancel(self.timer_id)
        self.timer_running = False
        self.time_left = 0
        self.handle_cycle_completion()

    def countdown(self, seconds):
        if not self.timer_running:
            return
        self.time_left = seconds
        if seconds >= 0:
            minutes, secs = divmod(seconds, 60)
            self.pomodoro_timer_label.config(text=f"{minutes:02d}:{secs:02d}")
            self.timer_id = self.root.after(1000, self.countdown, seconds - 1)
        else:
            winsound.Beep(1000, 500)
            self.handle_cycle_completion()

    def handle_cycle_completion(self):
        if not self.on_break:
            self.current_cycle += 1
            self.log_pomodoro()
            if self.current_cycle % self.settings['cycles'] == 0:
                self.on_break = True
                messagebox.showinfo("Pausa Longa", "Pausa longa! Bom descanso.")
            else:
                self.on_break = True
                messagebox.showinfo("Pausa Curta", "Pausa curta! Respire fundo.")
        else:
            self.on_break = False
            messagebox.showinfo("Fim da Pausa", "Fim da pausa. Hora de voltar ao foco!")

        self.time_left = 0
        self.update_timer_display()
        self.start_timer()

    def log_pomodoro(self):
        if not self.active_pomodoro_task:
            return
        
        task_details = self.active_pomodoro_task['details']
        new_log = pd.DataFrame({
            'Data e Hora': [datetime.now().strftime('%Y-%m-%d %H:%M:%S')],
            'Assunto': [task_details.get('subject', task_details.get('Assunto', '-'))],
            'Duração (min)': [self.settings['pomodoro']]
        })
        self.log_df = pd.concat([self.log_df, new_log], ignore_index=True)
        self.save_log()
        self.update_log()

    def update_log(self):
        for i in self.log_list.get_children():
            self.log_list.delete(i)
        for index, row in self.log_df.iterrows():
            self.log_list.insert("", "end", values=(row["Data e Hora"], row["Assunto"], row["Duração (min)"]))

    # --- Board, List, and Card Management Logic ---
    def add_board(self):
        new_board_name = simpledialog.askstring("Novo Quadro", "Digite o nome do novo quadro:", parent=self.root)
        if new_board_name:
            try:
                # Get current user ID
                user_id = self.get_current_user_id()
                if not user_id:
                    messagebox.showerror("Erro", "Usuário não identificado. Faça login novamente.", parent=self.root)
                    return
                
                # Check if board already exists for this user
                existing_boards = self.db.get_boards(user_id)
                board_names = [board['name'] for board in existing_boards]
                
                if new_board_name in board_names:
                    messagebox.showwarning("Erro", "Um quadro com este nome já existe.", parent=self.root)
                    return
                
                # Create board in database
                board_id = self.db.create_board(new_board_name, owner_id=user_id)
                
                if board_id:
                    # Reload data and update display
                    self.load_trello_data()
                    self.populate_boards()
                    
                    # Select the new board
                    try:
                        self.board_notebook.select(len(self.board_notebook.tabs()) - 1)
                    except:
                        pass
                    
                    messagebox.showinfo("Sucesso", f"Quadro '{new_board_name}' criado com sucesso!", parent=self.root)
                else:
                    messagebox.showerror("Erro", "Não foi possível criar o quadro.", parent=self.root)
                    
            except Exception as e:
                print(f"Erro ao criar quadro: {e}")
                messagebox.showerror("Erro", f"Não foi possível criar o quadro: {e}", parent=self.root)

    def rename_board(self, old_name):
        new_name = simpledialog.askstring("Renomear Quadro", f"Digite o novo nome para '{old_name}':", parent=self.root)
        
        if new_name and new_name != old_name:
            try:
                # Get current user ID
                user_id = self.get_current_user_id()
                if not user_id:
                    messagebox.showerror("Erro", "Usuário não identificado. Faça login novamente.", parent=self.root)
                    return
                
                # Check if new name already exists for this user
                existing_boards = self.db.get_boards(user_id)
                board_names = [board['name'] for board in existing_boards]
                
                if new_name in board_names:
                    messagebox.showwarning("Erro", "Um quadro com este nome já existe.", parent=self.root)
                    return
                
                # Get board ID
                board_id = self.get_board_id_by_name(old_name)
                if not board_id:
                    messagebox.showerror("Erro", f"Quadro '{old_name}' não encontrado.", parent=self.root)
                    return
                
                # Update board name in database
                self.db.update_board(board_id, new_name, "", "")
                success = True
                
                if success:
                    # Reload data and update display
                    self.load_trello_data()
                    self.populate_boards()
                    messagebox.showinfo("Sucesso", f"Quadro renomeado para '{new_name}'!", parent=self.root)
                else:
                    messagebox.showerror("Erro", "Não foi possível renomear o quadro.", parent=self.root)
                    
            except Exception as e:
                print(f"Erro ao renomear quadro: {e}")
                messagebox.showerror("Erro", f"Não foi possível renomear o quadro: {e}", parent=self.root)
        elif new_name:
            messagebox.showwarning("Erro", "Não foi possível renomear. Verifique se o nome já existe ou é inválido.", parent=self.root)

    def delete_board(self, board_name):
        if messagebox.askyesno("Confirmar Exclusão", f"Tem certeza que deseja excluir o quadro '{board_name}' e todos os seus conteúdos?", parent=self.root):
            try:
                # Get board ID
                board_id = self.get_board_id_by_name(board_name)
                if not board_id:
                    messagebox.showerror("Erro", f"Quadro '{board_name}' não encontrado.", parent=self.root)
                    return
                
                # Delete board from database (this will also delete all cards)
                self.db.delete_board(board_id)
                success = True
                
                if success:
                    # Reload data and update display
                    self.load_trello_data()
                    self.populate_boards()
                    messagebox.showinfo("Sucesso", f"Quadro '{board_name}' excluído com sucesso!", parent=self.root)
                else:
                    messagebox.showerror("Erro", "Não foi possível excluir o quadro.", parent=self.root)
                    
            except Exception as e:
                print(f"Erro ao excluir quadro: {e}")
                messagebox.showerror("Erro", f"Não foi possível excluir o quadro: {e}", parent=self.root)

    def add_list(self, board_name):
        new_list_name = simpledialog.askstring("Nova Lista", "Digite o nome da nova lista:", parent=self.root)
        if new_list_name and new_list_name not in self.boodesk_data["boards"][board_name]:
            self.boodesk_data["boards"][board_name][new_list_name] = []
            self.save_trello_data()
            self.populate_boards()
        elif new_list_name:
            messagebox.showwarning("Erro", "Uma lista com este nome já existe neste quadro.", parent=self.root)

    def rename_list(self, board_name, old_list_name):
        new_list_name = simpledialog.askstring("Renomear Lista", f"Digite o novo nome para '{old_list_name}':", parent=self.root)
        if new_list_name and new_list_name != old_list_name and new_list_name not in self.boodesk_data["boards"][board_name]:
            # Recreate the dictionary with the new key in the same position
            new_lists = {}
            for name, cards in self.boodesk_data["boards"][board_name].items():
                if name == old_list_name:
                    new_lists[new_list_name] = cards
                else:
                    new_lists[name] = cards
            self.boodesk_data["boards"][board_name] = new_lists
            self.save_trello_data()
            self.populate_boards()
        elif new_list_name:
            messagebox.showwarning("Erro", "Não foi possível renomear. Verifique se o nome já existe ou é inválido.", parent=self.root)

    def delete_list(self, board_name, list_name):
        if messagebox.askyesno("Confirmar Exclusão", f"Tem certeza que deseja excluir a lista '{list_name}' e todos os seus cartões?", parent=self.root):
            del self.boodesk_data["boards"][board_name][list_name]
            self.save_trello_data()
            self.populate_boards()

    def move_list(self, board_name, list_name, direction):
        lists = list(self.boodesk_data["boards"][board_name].keys())
        try:
            current_index = lists.index(list_name)
        except ValueError:
            return

        new_index = current_index + direction
        if 0 <= new_index < len(lists):
            lists.insert(new_index, lists.pop(current_index))
            reordered_lists = {name: self.boodesk_data["boards"][board_name][name] for name in lists}
            self.boodesk_data["boards"][board_name] = reordered_lists
            self.save_trello_data()
            self.populate_boards()

    def add_card(self, board_name, list_name):
        card_title = simpledialog.askstring("Novo Cartão", "Digite o título do novo cartão:", parent=self.root)
        if card_title and card_title.strip(): # Ensure title is not empty or just whitespace
            try:
                # Get current user ID
                user_id = self.get_current_user_id()
                if not user_id:
                    messagebox.showerror("Erro", "Usuário não identificado. Faça login novamente.", parent=self.root)
                    return
                
                # Get board ID
                board_id = self.get_board_id_by_name(board_name)
                if not board_id:
                    messagebox.showerror("Erro", f"Quadro '{board_name}' não encontrado.", parent=self.root)
                    return
                
                # Create card in database
                card_id = self.db.create_card(
                    board_id=board_id,
                    list_name=list_name,
                    title=card_title,
                    description="",
                    status='to_do',
                    importance='Normal',
                    due_date="",
                    subject="-",
                    goal="-",
                    members=[],
                    git_branch="",
                    git_commit="",
                    recurrence="Nenhuma",
                    dependencies=[],
                    user_id=user_id
                )
                
                if card_id:
                    # Reload data and update display
                    self.load_trello_data()
                    self.populate_boards()
                    
                    # Email notification for card creation
                    if hasattr(self, 'email_integration'):
                        card_data = {
                            "title": card_title,
                            "board": board_name,
                            "column": list_name,
                            "created_by": self.current_user.username,
                            "created_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                            "importance": "Normal",
                            "due_date": ""
                        }
                        self.email_integration.notify_card_created(card_data)
                    
                    # Open card window - the CardWindow will handle finding the card
                    CardWindow(self.root, self, board_name, list_name, card_id, self.current_user,
                               callback_on_close=partial(self.handle_card_window_closed, board_name, list_name, card_id))
                else:
                    messagebox.showerror("Erro", "Não foi possível criar o cartão.", parent=self.root)
                    
            except Exception as e:
                print(f"Erro ao criar cartão: {e}")
                # Fallback para board_id se o método não funcionar
                try:
                    board_id = 1  # Fallback padrão
                    print(f"DEBUG: Usando board_id fallback: {board_id}")
                    
                    # Create card in database with fallback
                    card_id = self.db.create_card(
                        board_id=board_id,
                        list_name=list_name,
                        title=card_title,
                        description="",
                        status='to_do',
                        importance='Normal',
                        due_date="",
                        subject="-",
                        goal="-",
                        members=[],
                        git_branch="",
                        git_commit="",
                        recurrence="Nenhuma",
                        dependencies=[],
                        user_id=user_id
                    )
                    
                    if card_id:
                        # Reload data and update display
                        self.load_trello_data()
                        self.populate_boards()
                        
                        # Open card window
                        CardWindow(self.root, self, board_name, list_name, card_id, self.current_user,
                                   callback_on_close=partial(self.handle_card_window_closed, board_name, list_name, card_id))
                    else:
                        messagebox.showerror("Erro", "Não foi possível criar o cartão.", parent=self.root)
                        
                except Exception as fallback_error:
                    print(f"Erro no fallback: {fallback_error}")
                    messagebox.showerror("Erro", f"Não foi possível criar o cartão: {e}", parent=self.root)

    def delete_card(self, board_name, list_name, treeview):
        selected_item_id = treeview.focus()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um cartão para excluir.", parent=self.root)
            return
        
        card_id = treeview.item(selected_item_id, "tags")[0]
        card_title = treeview.item(selected_item_id, "values")[0]

        if messagebox.askyesno("Confirmar Exclusão", f"Tem certeza que deseja excluir o cartão '{card_title}'?", parent=self.root):
            # Remove the card from the data structure by card_id
            self.boodesk_data["boards"][board_name][list_name] = [
                card for card in self.boodesk_data["boards"][board_name][list_name] if card.get('card_id') != card_id
            ]
            self.save_trello_data()
            self.populate_boards()

    def move_card_data(self, source_board, source_list, card_id, target_board, target_list):
        # Find the card to move using its card_id
        card_to_move = None
        source_list_data = self.boodesk_data["boards"][source_board][source_list]
        for i, card in enumerate(source_list_data):
            if card.get('card_id') == card_id:
                card_to_move = source_list_data.pop(i)
                break

        if not card_to_move:
            messagebox.showerror("Erro", "Cartão não encontrado para mover.")
            return

        # Verificar se está tentando mover para "Concluído" e se há subtarefas pendentes
        if target_list == "Concluído":
            subtasks = card_to_move.get('subtasks', [])
            if subtasks:
                uncompleted_subtasks = [subtask for subtask in subtasks if not subtask['completed']]
                if uncompleted_subtasks:
                    uncompleted_text = "\n".join([f"• {subtask['text']}" for subtask in uncompleted_subtasks])
                    messagebox.showwarning(
                        "Subtarefas Pendentes", 
                        f"Não é possível mover o cartão '{card_to_move['title']}' para 'Concluído' porque ainda existem subtarefas pendentes:\n\n{uncompleted_text}\n\nConclua todas as subtarefas antes de mover o cartão para 'Concluído'."
                    )
                    # If not moved, put the card back in the source list
                    source_list_data.insert(i, card_to_move) 
                    return
        
        # Add card to target
        self.boodesk_data["boards"][target_board][target_list].append(card_to_move)

        # Log the move in card history
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        user_name = self.current_user.username if self.current_user else "Sistema"
        card_to_move.setdefault('history', []).append({
            "timestamp": current_time,
            "action": f"Cartão movido de '{source_list}' para '{target_list}' no quadro '{source_board}' por {user_name}.",
            "user": user_name
        })

        # Email notification for card movement
        if hasattr(self, 'email_integration'):
            card_data = {
                "title": card_to_move.get("title", "Sem título"),
                "board": target_board,
                "column": target_list,
                "modified_by": user_name,
                "modified_date": current_time
            }
            changes = [f"Cartão movido de '{source_list}' para '{target_list}'"]
            self.email_integration.notify_card_modified(card_data, changes)

        self.save_trello_data()
        self.populate_boards()

    def handle_card_window_closed(self, board_name, list_name, card_id, saved=False):
        if not saved:
            # If the card window was closed without saving, and it was a new card,
            # remove the card that was just added to the data model.
            # This prevents empty cards from appearing if the user cancels creation.
            current_list_cards = self.boodesk_data["boards"][board_name][list_name]
            card_to_remove_index = -1
            for i, card in enumerate(current_list_cards):
                if card.get('card_id') == card_id:
                    card_to_remove_index = i
                    break

            if card_to_remove_index != -1:
                # Only remove if it's a newly added card that wasn't saved
                # and still has the default/empty title.
                if current_list_cards[card_to_remove_index].get('title') == "" or \
                   current_list_cards[card_to_remove_index].get('title') == "Sua primeira tarefa Trello":
                    self.boodesk_data["boards"][board_name][list_name].pop(card_to_remove_index)
                    self.save_trello_data()
        else:
            # Se o card foi salvo, verificar se precisa sincronizar com Google Calendar
            if self.settings.get('google_calendar_enabled', False):
                # Encontrar o card salvo
                for card in self.boodesk_data["boards"][board_name][list_name]:
                    if card.get('card_id') == card_id:
                        # Verificar se tem data de vencimento
                        if card.get('due_date'):
                            # Sincronizar com Google Calendar
                            self._sync_new_card_to_calendar(card, board_name, list_name)
                        break
        
        self.populate_boards() # Always repopulate to reflect changes or removals

    def _sync_new_card_to_calendar(self, card, board_name, list_name):
        """Sincroniza um card recém-criado com o Google Calendar"""
        try:
            # Verificar se o Google Calendar está configurado
            if not hasattr(self, 'google_calendar') or not self.google_calendar.is_authenticated:
                print("Google Calendar não está autenticado")
                return
            
            # Verificar se há data de vencimento
            if not card.get('due_date'):
                print("Card não possui data de vencimento")
                return
            
            # Usar função auxiliar para processar data brasileira
            event_datetime = self.parse_brazilian_date(card['due_date'])
            
            if not event_datetime:
                print(f"Formato de data inválido: {card['due_date']}")
                return
            
            # Criar evento no Google Calendar
            event_title = f"📋 {card['title']}"
            event_description = f"""
Card: {card['title']}
Descrição: {card.get('desc', 'Sem descrição')}
Importância: {card.get('importance', 'Normal')}
Assunto: {card.get('subject', '-')}
Objetivo: {card.get('goal', '-')}
Membros: {', '.join(card.get('members', []))}
Board: {board_name}
Lista: {list_name}
Card ID: {card.get('card_id', '')}
            """.strip()
            
            # Definir duração do evento (1 hora por padrão)
            event_duration = timedelta(hours=1)
            
            # Coletar emails para o evento
            attendees = []
            
            # Adicionar emails padrão se habilitado
            calendar_settings = self.settings.get('calendar_integration', {})
            if calendar_settings.get('include_default_emails', True):
                default_emails = calendar_settings.get('default_emails', [])
                attendees.extend(default_emails)
            
            # Adicionar membros do card se habilitado
            if calendar_settings.get('include_card_members', True):
                card_members = card.get('members', [])
                for member in card_members:
                    # Buscar email do membro no arquivo de membros
                    member_email = self._get_member_email(member)
                    if member_email:
                        attendees.append(member_email)
            
            # Remover duplicatas
            attendees = list(set(attendees))
            
            # Criar evento
            success = self.google_calendar.create_event(
                title=event_title,
                description=event_description,
                start_datetime=event_datetime,
                duration=event_duration,
                card_id=card.get('card_id', ''),
                attendees=attendees if attendees else None
            )
            
            if success:
                print(f"✅ Evento criado no Google Calendar para o card recém-criado: {card['title']}")
                # Adicionar ao histórico do card
                card.setdefault('history', []).append({
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "action": f"Evento criado no Google Calendar",
                    "user": self.current_user.username if self.current_user else "Sistema"
                })
                # Salvar dados atualizados
                self.save_trello_data()
            else:
                print(f"❌ Erro ao criar evento no Google Calendar para o card: {card['title']}")
                
        except Exception as e:
            print(f"❌ Erro na sincronização com Google Calendar: {e}")
            import traceback
            traceback.print_exc()

    def _get_member_email(self, member_name):
        """Busca o email de um membro no arquivo de membros"""
        try:
            if hasattr(self, 'members') and self.members:
                print(f"DEBUG: Buscando email para membro '{member_name}'")
                print(f"DEBUG: Total de membros carregados: {len(self.members)}")
                for member in self.members:
                    print(f"DEBUG: Verificando membro: {member}")
                    if member.get('Membro') == member_name:
                        email = member.get('email', '')
                        print(f"DEBUG: Email encontrado para '{member_name}': {email}")
                        return email
                print(f"DEBUG: Membro '{member_name}' não encontrado")
            else:
                print(f"DEBUG: Lista de membros não disponível ou vazia")
            return None
        except Exception as e:
            print(f"Erro ao buscar email do membro {member_name}: {e}")
            return None

    def _is_card_completed(self, card_full_title):
        # card_full_title format: "Board Name > List Name > Card Title"
        parts = card_full_title.split(' > ')
        if len(parts) != 3:
            return False # Invalid format
        
        board_name, list_name, card_title = parts

        if board_name not in self.boodesk_data["boards"]:
            return False
        if list_name not in self.boodesk_data["boards"][board_name]:
            return False
        
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card['title'] == card_title:
                # A card is considered completed if it's in the "Concluído" list
                return list_name == "Concluído"
        return False

    def _get_next_recurrence_date(self, current_date_str, recurrence_type):
        if not current_date_str:
            return ""
        
        try:
            current_date = datetime.strptime(current_date_str.split(' ')[0], "%Y-%m-%d")
        except ValueError:
            return "" # Invalid date format

        if recurrence_type == "Diariamente":
            next_date = current_date + timedelta(days=1)
        elif recurrence_type == "Semanalmente":
            next_date = current_date + timedelta(weeks=1)
        elif recurrence_type == "Mensalmente":
            # Advance by one month, handling end-of-month correctly
            year = current_date.year
            month = current_date.month + 1
            if month > 12:
                month = 1
                year += 1
            day = min(current_date.day, (datetime(year, month, 1) - timedelta(days=1)).day)
            next_date = datetime(year, month, day)
        elif recurrence_type == "Anualmente":
            next_date = current_date.replace(year=current_date.year + 1)
        else:
            return "" # No recurrence or invalid type

        return next_date.strftime("%Y-%m-%d")

    def complete_boodesk_card(self, board_name, list_name, card_id):
        card = None
        card_index = -1
        for i, c in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if c.get('card_id') == card_id:
                card = c
                card_index = i
                break
        
        if not card:
            messagebox.showerror("Erro", "Cartão não encontrado para concluir.")
            return

        recurrence = card.get('recurrence', 'Nenhuma')

        # Verificar se todas as subtarefas estão concluídas
        subtasks = card.get('subtasks', [])
        if subtasks:
            uncompleted_subtasks = [subtask for subtask in subtasks if not subtask['completed']]
            if uncompleted_subtasks:
                uncompleted_text = "\n".join([f"• {subtask['text']}" for subtask in uncompleted_subtasks])
                messagebox.showwarning(
                    "Subtarefas Pendentes", 
                    f"Não é possível concluir o cartão '{card['title']}' porque ainda existem subtarefas pendentes:\n\n{uncompleted_text}\n\nConclua todas as subtarefas antes de marcar o cartão como concluído."
                )
                return

        # Handle dependencies first
        completed_card_full_title = f"{board_name} > {list_name} > {card['title']}"
        for b_name, lists in self.boodesk_data["boards"].items():
            for l_name, cards_in_list in lists.items():
                for c in cards_in_list:
                    if completed_card_full_title in c.get('dependencies', []):
                        messagebox.showinfo("Dependência Concluída", f"O cartão '{c['title']}' agora está desbloqueado, pois sua dependência '{card['title']}' foi concluída.")

        if recurrence == "Nenhuma":
            # Move to "Concluído" list if not recurring
            if list_name != "Concluído":
                if "Concluído" in self.boodesk_data["boards"][board_name]:
                    self.boodesk_data["boards"][board_name][list_name].pop(card_index)
                    self.boodesk_data["boards"][board_name]["Concluído"].append(card)
                    self.save_trello_data()
                else:
                    messagebox.showwarning("Lista Não Encontrada", "A lista 'Concluído' não existe neste quadro.")
            else:
                messagebox.showinfo("Cartão Já Concluído", "Este cartão já está na lista 'Concluído'.")
        else:
            # Handle recurrence: Create a new instance and move the original to "Concluído"
            original_card_id = card.get('card_id')
            
            # Move original card to "Concluído"
            if list_name != "Concluído":
                if "Concluído" in self.boodesk_data["boards"][board_name]:
                    self.boodesk_data["boards"][board_name][list_name].pop(card_index)
                    self.boodesk_data["boards"][board_name]["Concluído"].append(card)
                    messagebox.showinfo("Cartão Concluído", f"Cartão '{card['title']}' concluído e movido para 'Concluído'.")
                else:
                    messagebox.showwarning("Lista Não Encontrada", "A lista 'Concluído' não existe neste quadro. O cartão original não foi movido.")
            else:
                messagebox.showinfo("Cartão Concluído", "Este cartão já está na lista 'Concluído'.")

            # Create a new recurring instance
            new_card = card.copy()
            new_card['card_id'] = str(uuid.uuid4()) # New unique ID
            new_card['parent_card_id'] = original_card_id # Link to original
            new_card['creation_date'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S") # New creation date for the instance
            new_card['is_archived'] = False # Ensure new instance is not archived

            # Calculate next due date
            original_due_date = card.get('due_date', '')
            new_card['due_date'] = self._get_next_recurrence_date(original_due_date, recurrence)

            # Place the new instance in "A Fazer"
            if "A Fazer" in self.boodesk_data["boards"][board_name]:
                self.boodesk_data["boards"][board_name]["A Fazer"].append(new_card)
                messagebox.showinfo("Cartão Recorrente Criado", f"Nova instância de '{new_card['title']}' criada e adicionada a 'A Fazer'.")
            else:
                messagebox.showwarning("Lista Não Encontrada", "A lista 'A Fazer' não existe neste quadro. A nova instância do cartão recorrente não foi adicionada.")
            self.save_trello_data()
        self.populate_boards()

    def can_start_card(self, card):
        """Check if a card can be started based on its dependencies"""
        dependencies = card.get('dependencies', [])
        if not dependencies:
            return True
        
        return all(self._is_card_completed(dep) for dep in dependencies)

    def get_card_dependency_status(self, card):
        """Get detailed dependency status for a card"""
        dependencies = card.get('dependencies', [])
        if not dependencies:
            return {"can_start": True, "completed": 0, "total": 0, "pending": []}
        
        completed = [dep for dep in dependencies if self._is_card_completed(dep)]
        pending = [dep for dep in dependencies if not self._is_card_completed(dep)]
        
        return {
            "can_start": len(pending) == 0,
            "completed": len(completed),
            "total": len(dependencies),
            "pending": pending
        }

    def add_subject_dialog(self, subject_type):
        # This method now opens the management window instead of a simple dialog
        if self.settings['unify_subjects']:
            # If subjects are unified, always manage the pomodoro list which is the master list
            SubjectManagerWindow(self.root, self, 'pomodoro')
        else:
            SubjectManagerWindow(self.root, self, subject_type)

    def add_goal(self):
        new_goal = simpledialog.askstring("Novo Objetivo", "Digite o novo objetivo:").strip()
        if new_goal and new_goal not in self.goals:
            new_goal_df = pd.DataFrame({'Objetivo': [new_goal]})
            self.goals_df = pd.concat([self.goals_df, new_goal_df], ignore_index=True)
            self.goals = self.goals_df['Objetivo'].tolist()
            self.goals_df.to_excel(self.goals_file, index=False, engine='openpyxl')
            messagebox.showinfo("Sucesso", f"Objetivo '{new_goal}' adicionado.")

    def add_pomodoro_task(self):
        task = self.add_task_entry.get().strip()
        if not task:
            messagebox.showwarning("Entrada Inválida", "Por favor, insira o nome da tarefa.")
            return

        subject = simpledialog.askstring("Assunto", "Digite o assunto da tarefa:")
        goal = simpledialog.askstring("Objetivo", "Digite o objetivo da tarefa:")

        new_task = pd.DataFrame({
            'Tarefa': [task],
            'Status': ['Pendente'],
            'Assunto': [subject if subject else '-'],
            'Objetivo': [goal if goal else '-']
        })
        self.pomodoro_tasks_df = pd.concat([self.pomodoro_tasks_df, new_task], ignore_index=True)
        self.save_pomodoro_tasks()
        self.update_pomodoro_task_list()
        self.add_task_entry.delete(0, tk.END)

    def remove_pomodoro_task(self):
        selected_item = self.pomodoro_task_list.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione uma tarefa para remover.")
            return

        task_name = self.pomodoro_task_list.item(selected_item, "values")[0]
        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover a tarefa '{task_name}'?"):
            self.pomodoro_tasks_df = self.pomodoro_tasks_df[self.pomodoro_tasks_df['Tarefa'] == task_name]
            self.save_pomodoro_tasks()
            self.update_pomodoro_task_list()

    def complete_pomodoro_task(self):
        selected_item = self.pomodoro_task_list.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione uma tarefa para concluir.")
            return

        task_name = self.pomodoro_task_list.item(selected_item, "values")[0]
        self.pomodoro_tasks_df.loc[self.pomodoro_tasks_df['Tarefa'] == task_name, 'Status'] = 'Concluído'
        self.save_pomodoro_tasks()
        self.update_pomodoro_task_list()

    def open_members_manager(self):
        MembersWindow(self.root, self)

    def open_categories_manager(self):
        """Abre o gerenciador de categorias"""
        CategoriesManagerWindow(self.root, self)

    def open_settings(self):
        SettingsWindow(self.root, self)

class SubjectManagerWindow(tk.Toplevel):
    def __init__(self, parent, app, subject_type):
        super().__init__(parent)
        self.app = app
        self.subject_type = subject_type
        
        if self.subject_type == 'pomodoro':
            self.title("Gerenciar Assuntos do Pomodoro")
            self.subjects_df = self.app.pomodoro_subjects_df
            self.subjects_list = self.app.pomodoro_subjects
            self.file_path = self.app.pomodoro_subjects_file
        else: # boodesk
            self.title("Gerenciar Assuntos do Boodesk")
            self.subjects_df = self.app.boodesk_subjects_df
            self.subjects_list = self.app.boodesk_subjects
            self.file_path = self.app.boodesk_subjects_file

        self.geometry("450x350")
        self.transient(parent)
        self.grab_set()

        self.create_widgets()
        self._populate_subjects_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Listbox Frame
        list_frame = ttk.LabelFrame(main_frame, text="Assuntos Cadastrados")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        self.subjects_listbox = tk.Listbox(list_frame, selectmode=tk.SINGLE)
        self.subjects_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.subjects_listbox.bind("<<ListboxSelect>>", self._on_subject_select)
        
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.subjects_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.subjects_listbox.config(yscrollcommand=scrollbar.set)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Assunto")
        entry_frame.pack(fill=tk.X, pady=5)
        entry_frame.columnconfigure(0, weight=1)

        self.subject_entry = ttk.Entry(entry_frame)
        self.subject_entry.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        
        self.add_edit_button = ttk.Button(entry_frame, text="Adicionar", command=self._add_subject)
        self.add_edit_button.grid(row=0, column=1, padx=5, pady=5)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Remover Selecionado", command=self._remove_subject).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", command=self.destroy).pack(side=tk.RIGHT, padx=5)

    def _populate_subjects_list(self):
        self.subjects_listbox.delete(0, tk.END)
        # Sort the list for better UX
        for subject in sorted(self.subjects_list):
            if subject != '-': # Don't show the default '-'
                self.subjects_listbox.insert(tk.END, subject)

    def _on_subject_select(self, event):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            self.subject_entry.delete(0, tk.END)
            self.add_edit_button.config(text="Adicionar", command=self._add_subject)
            return
        
        selected_subject = self.subjects_listbox.get(selected_indices[0])
        self.subject_entry.delete(0, tk.END)
        self.subject_entry.insert(0, selected_subject)
        self.add_edit_button.config(text="Salvar Edição", command=self._edit_subject)

    def _clear_selection(self):
        self.subjects_listbox.selection_clear(0, tk.END)
        self.subject_entry.delete(0, tk.END)
        self.add_edit_button.config(text="Adicionar", command=self._add_subject)
        # Manually trigger the event handler to reset the button state
        self._on_subject_select(None)


    def _add_subject(self):
        new_subject = self.subject_entry.get().strip()
        if not new_subject:
            messagebox.showwarning("Entrada Inválida", "O nome do assunto não pode estar vazio.", parent=self)
            return
        
        if new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' já existe.", parent=self)
            return

        # Update DataFrame and list
        new_subject_df = pd.DataFrame({'Assunto': [new_subject]})
        self.subjects_df = pd.concat([self.subjects_df, new_subject_df], ignore_index=True)
        self.subjects_list.append(new_subject)
        
        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{new_subject}' adicionado.", parent=self)

    def _edit_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um assunto para editar.", parent=self)
            return
            
        old_subject = self.subjects_listbox.get(selected_indices[0])
        new_subject = self.subject_entry.get().strip()

        if not new_subject:
            messagebox.showwarning("Entrada Inválida", "O nome do assunto não pode estar vazio.", parent=self)
            return

        if new_subject != old_subject and new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' já existe.", parent=self)
            return

        # Update DataFrame and list
        self.subjects_df.loc[self.subjects_df['Assunto'] == old_subject, 'Assunto'] = new_subject
        self.subjects_list[self.subjects_list.index(old_subject)] = new_subject

        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{old_subject}' atualizado para '{new_subject}'.", parent=self)

    def _remove_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um assunto para remover.", parent=self)
            return

        subject_to_remove = self.subjects_listbox.get(selected_indices[0])
        
        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover o assunto '{subject_to_remove}'?\nIsso não pode ser desfeito e não alterará os cartões existentes.", parent=self):
            # Update DataFrame and list
            self.subjects_df = self.subjects_df[self.subjects_df['Assunto'] != subject_to_remove]
            self.subjects_list.remove(subject_to_remove)
            
            # Save and refresh
            self._save_and_refresh()
            self._clear_selection()
            messagebox.showinfo("Sucesso", f"Assunto '{subject_to_remove}' removido.", parent=self)

    def _save_and_refresh(self):
        # Save the DataFrame to the Excel file
        self.subjects_df.to_excel(self.file_path, index=False)
        
        # Update the main app's data
        if self.subject_type == 'pomodoro':
            self.app.pomodoro_subjects_df = self.subjects_df
            self.app.pomodoro_subjects = self.subjects_list
        else: # boodesk
            self.app.boodesk_subjects_df = self.subjects_df
            self.app.boodesk_subjects = self.subjects_list
            
        # Reload all auxiliary data in the main app to update all UI components
        self.app.load_aux_data()
        self.app.update_all_displays() # A comprehensive update
        
        # Refresh the listbox in this window
        self._populate_subjects_list()

    def destroy(self):
        # Ensure the main app window gets focus back
        self.app.root.focus_set()
        super().destroy()

class ArchivedCardsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Cartões Arquivados")
        self.geometry("600x400")
        self.transient(parent)
        self.grab_set()

        if self.app.settings.get('open_on_current_screen', False):
            self.update_idletasks()
            parent_x = parent.winfo_x()
            parent_y = parent.winfo_y()
            parent_width = parent.winfo_width()
            parent_height = parent.winfo_height()

            x = parent_x + (parent_width // 2) - (self.winfo_width() // 2)
            y = parent_y + (parent_height // 2) - (self.winfo_height() // 2)
            self.geometry(f"+{x}+{y}")

        self.create_widgets()
        self._populate_archived_cards_listbox()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Cartões Arquivados:").pack(anchor="w", pady=5)

        self.archived_listbox = tk.Listbox(main_frame, selectmode=tk.SINGLE)
        self.archived_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        self.archived_listbox.bind("<Double-1>", self._restore_card_from_double_click)

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=5)

        ttk.Button(button_frame, text="Restaurar Cartão", command=self._restore_card).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Excluir Permanentemente", command=self._delete_card_permanently).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", command=self.destroy).pack(side=tk.LEFT, padx=5)

    def _populate_archived_cards_listbox(self):
        self.archived_listbox.delete(0, tk.END)
        self.archived_cards_data = [] # Store references to actual card objects

        for board_name, lists in self.app.trello_data["boards"].items():
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if card.get("is_archived", False):
                        display_text = f"{board_name} > {list_name} > {card['title']}"
                        self.archived_listbox.insert(tk.END, display_text)
                        self.archived_cards_data.append({"board": board_name, "list": list_name, "card": card})

    def _restore_card_from_double_click(self, event):
        self._restore_card()

    def _restore_card(self):
        selected_index = self.archived_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um cartão para restaurar.")
            return

        card_info = self.archived_cards_data[selected_index[0]]
        card = card_info["card"]
        board_name = card_info["board"]
        list_name = card_info["list"] # This is the original list name

        if messagebox.askyesno("Confirmar Restauração", f"Tem certeza que deseja restaurar o cartão '{card['title']}' para o quadro '{board_name}' na lista '{list_name}'?"):
            card["is_archived"] = False

            # Remove the card from its current list (where it was archived)
            # We need to find the card by its card_id and remove it from the list it's currently in.
            # This assumes the card is still in the list it was in when it was archived.
            found_and_removed = False
            if board_name in self.app.trello_data["boards"] and list_name in self.app.trello_data["boards"][board_name]:
                original_list = self.app.trello_data["boards"][board_name][list_name]
                for i, c in enumerate(original_list):
                    if c.get("card_id") == card.get("card_id"):
                        original_list.pop(i)
                        found_and_removed = True
                        break
            
            if not found_and_removed:
                messagebox.showerror("Erro de Restauração", "Não foi possível encontrar o cartão em sua lista original para remoção.")
                return

            # Add the card to the target list
            target_list_name = list_name # Default to original list
            if list_name not in self.app.trello_data["boards"][board_name]:
                # Fallback to "A Fazer" if original list was deleted
                if "A Fazer" in self.app.trello_data["boards"][board_name]:
                    target_list_name = "A Fazer"
                    messagebox.showinfo("Restauração", f"Lista original '{list_name}' não encontrada. Cartão restaurado para 'A Fazer'.")
                else:
                    messagebox.showerror("Erro de Restauração", "Não foi possível restaurar o cartão. A lista original e 'A Fazer' não existem.")
                    return
            
            self.app.trello_data["boards"][board_name][target_list_name].append(card)
            
            self.app.save_trello_data()
            self.app.populate_boards() # Refresh main board view
            self._populate_archived_cards_listbox() # Refresh archived list
            messagebox.showinfo("Sucesso", f"Cartão '{card['title']}' restaurado com sucesso!")

    def _delete_card_permanently(self):
        selected_index = self.archived_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um cartão para excluir permanentemente.")
            return

        card_info = self.archived_cards_data[selected_index[0]]
        card = card_info["card"]
        board_name = card_info["board"]
        list_name = card_info["list"]

        if messagebox.askyesno("Confirmar Exclusão Permanente", f"Tem certeza que deseja EXCLUIR PERMANENTEMENTE o cartão '{card['title']}'? Esta ação não pode ser desfeita."):
            # Find the card in the actual data structure and remove it
            if board_name in self.app.trello_data["boards"] and list_name in self.app.trello_data["boards"][board_name]:
                # Filter out the card by its unique card_id
                self.app.trello_data["boards"][board_name][list_name] = [
                    c for c in self.app.trello_data["boards"][board_name][list_name] if c.get("card_id") != card.get("card_id")
                ]
                self.app.save_trello_data()
                self.app.populate_boards() # Refresh main board view
                self._populate_archived_cards_listbox() # Refresh archived list
                messagebox.showinfo("Sucesso", f"Cartão '{card['title']}' excluído permanentemente.")
            else:
                messagebox.showerror("Erro", "Não foi possível encontrar o cartão na estrutura de dados para exclusão.")

class CardWindow(tk.Toplevel):
    def __init__(self, parent, app, board_name, list_name, card_id, current_user, callback_on_close=None):
        super().__init__(parent)
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self.card_id = card_id # Now using card_id instead of card_index
        self.current_user = current_user # Store the current user
        self.callback_on_close = callback_on_close
        
        # Find the card using its card_id - try both in-memory data and database
        self.card = None
        
        # First, try to find in the in-memory data structure
        if (self.board_name in self.app.boodesk_data["boards"] and 
            self.list_name in self.app.boodesk_data["boards"][self.board_name]):
            for card_data in self.app.boodesk_data["boards"][self.board_name][self.list_name]:
                if card_data.get('card_id') == self.card_id:
                    self.card = card_data
                    break
        
        # If not found in memory, try to get from database
        if not self.card and hasattr(self.app, 'db') and self.app.db:
            try:
                card_data = self.app.db.get_card_by_id(self.card_id)
                if card_data:
                    # Convert to dictionary if needed
                    if not isinstance(card_data, dict):
                        card_data = dict(card_data)
                    
                    # Add board and list information
                    card_data['board_name'] = self.board_name
                    card_data['list_name'] = self.list_name
                    self.card = card_data
                    print(f"DEBUG: Card encontrado no banco de dados: {self.card.get('title', 'Sem título')}")
            except Exception as e:
                print(f"Erro ao buscar card no banco: {e}")

        if not self.card:
            messagebox.showerror("Erro", "Cartão não encontrado. Pode ter sido excluído ou movido.")
            self.destroy()
            return

        self.title(f"Editar Tarefa: {self.card['title']}")
        self.geometry("1000x700")  # Tamanho fixo que funciona bem
        self.resizable(False, False)  # Impedir redimensionamento para evitar deformação
        
        # Centralizar a janela na tela
        self.center_window()
        
        # Tornar esta janela modal (usuário deve interagir com ela antes de voltar à janela principal)
        self.transient(parent)
        self.grab_set()

        # Initialize StringVars for Git integration
        self.git_branch_var = tk.StringVar(value=self.card.get('git_branch', ''))
        self.git_commit_var = tk.StringVar(value=self.card.get('git_commit', ''))
        self.git_pr_var = tk.StringVar(value=self.card.get('git_pr', ''))

        self.create_widgets()

    def center_window(self):
        """Centraliza a janela na tela"""
        self.update_idletasks()
        
        # Obter dimensões da tela
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Obter dimensões da janela
        window_width = self.winfo_width()
        window_height = self.winfo_height()
        
        # Calcular posição central
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        
        # Aplicar posição
        self.geometry(f"+{x}+{y}")

    def create_widgets(self):
        # Main container with proper layout
        main_container = ttk.Frame(self)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Configure main container for proper layout
        main_container.columnconfigure(0, weight=1)
        main_container.rowconfigure(0, weight=1)
        
        # Create a frame for the scrollable content
        content_frame = ttk.Frame(main_container)
        content_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 10))
        content_frame.columnconfigure(0, weight=1)
        content_frame.rowconfigure(0, weight=1)
        
        # Create canvas and scrollbar
        canvas = tk.Canvas(content_frame)
        scrollbar = ttk.Scrollbar(content_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # Main frame inside scrollable area
        main_frame = ttk.Frame(scrollable_frame, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure grid for 2 columns with proper weights
        main_frame.columnconfigure(0, weight=1)  # Left column
        main_frame.columnconfigure(1, weight=1)  # Right column
        main_frame.rowconfigure(0, weight=1)  # Allow vertical expansion

        # === LEFT COLUMN ===
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
        left_frame.columnconfigure(1, weight=1)
        left_frame.rowconfigure(0, weight=1)  # Allow expansion

        # --- Card Details Section ---
        details_frame = ttk.LabelFrame(left_frame, text="Detalhes do Cartão", padding="10")
        details_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        details_frame.columnconfigure(1, weight=1)

        ttk.Label(details_frame, text="Título:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
        self.title_entry = ttk.Entry(details_frame)
        self.title_entry.grid(row=0, column=1, sticky="ew", pady=3, padx=5)
        self.title_entry.insert(0, self.card['title'])

        ttk.Label(details_frame, text="Descrição:", font=("Arial", 9, "bold")).grid(row=1, column=0, sticky="nw", pady=3, padx=5)
        self.desc_text = tk.Text(details_frame, height=4, width=35, wrap=tk.WORD)
        self.desc_text.grid(row=1, column=1, sticky="ew", pady=3, padx=5)
        self.desc_text.insert("1.0", self.card.get('desc', ''))

        # --- Dates and Recurrence Section ---
        dates_frame = ttk.LabelFrame(left_frame, text="Datas e Recorrência", padding="10")
        dates_frame.pack(fill=tk.X, pady=(0, 10))
        dates_frame.columnconfigure(1, weight=1)

        ttk.Label(dates_frame, text="Prazo:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
        date_frame = ttk.Frame(dates_frame)
        date_frame.grid(row=0, column=1, sticky="ew", pady=3, padx=5)
        self.due_date_entry = ttk.Entry(date_frame, width=15, state="readonly")
        self.due_date_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(date_frame, image=self.app.icons.get('time_icon'), width=3, command=self.open_date_picker).pack(side=tk.LEFT, padx=2)

        self.include_time_var = tk.BooleanVar()
        self.include_time_var.set(False)
        self.include_time_check = ttk.Checkbutton(dates_frame, text="Incluir Horário", 
                                                variable=self.include_time_var, 
                                                command=self.toggle_time_fields)
        self.include_time_check.grid(row=1, column=0, sticky="w", pady=3, padx=5)

        time_frame = ttk.Frame(dates_frame)
        time_frame.grid(row=1, column=1, sticky="ew", pady=3, padx=5)
        self.hour_entry = tk.Spinbox(time_frame, from_=0, to=23, width=3, state="disabled", wrap=True)
        self.hour_entry.pack(side=tk.LEFT)
        ttk.Label(time_frame, text=":").pack(side=tk.LEFT)
        self.minute_entry = tk.Spinbox(time_frame, from_=0, to=59, width=3, state="disabled", wrap=True)
        self.minute_entry.pack(side=tk.LEFT)

        ttk.Label(dates_frame, text="Recorrência:", font=("Arial", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3, padx=5)
        self.recurrence_options = ["Nenhuma", "Diariamente", "Semanalmente", "Mensalmente", "Anualmente"]
        self.recurrence_combo = ttk.Combobox(dates_frame, values=self.recurrence_options, state="readonly")
        self.recurrence_combo.grid(row=2, column=1, sticky="ew", pady=3, padx=5)
        self.recurrence_combo.set(self.card.get('recurrence', 'Nenhuma'))

        # Git Integration Section (visible only in dev mode)
        if self.app.settings.get('dev_mode', False):
            git_frame = ttk.LabelFrame(left_frame, text="Integração Git", padding="10")
            git_frame.pack(fill=tk.X, pady=(0, 10))
            git_frame.columnconfigure(1, weight=1)

            # Git Status and Actions
            git_status_frame = ttk.Frame(git_frame)
            git_status_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 10))
            git_status_frame.columnconfigure(1, weight=1)

            ttk.Label(git_status_frame, text="Status Git:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
            self.git_status_label = ttk.Label(git_status_frame, text="Não configurado", foreground="gray")
            self.git_status_label.grid(row=0, column=1, sticky="w", pady=3, padx=5)

            # Git Actions Buttons
            git_actions_frame = ttk.Frame(git_frame)
            git_actions_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(0, 10))

            ttk.Button(git_actions_frame, text="Inicializar Repo", 
                      image=self.app.icons.get('add_icon'), compound=tk.LEFT,
                      command=self.init_git_repo).pack(side=tk.LEFT, padx=2)
            
            ttk.Button(git_actions_frame, text="Criar Branch", 
                      image=self.app.icons.get('add_folder_icon'), compound=tk.LEFT,
                      command=self.create_git_branch).pack(side=tk.LEFT, padx=2)
            
            ttk.Button(git_actions_frame, text="Commit", 
                      image=self.app.icons.get('save_icon'), compound=tk.LEFT,
                      command=self.make_git_commit).pack(side=tk.LEFT, padx=2)

            # Git Information Fields
            ttk.Label(git_frame, text="Branch Atual:", font=("Arial", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3, padx=5)
            self.git_branch_entry = ttk.Entry(git_frame, textvariable=self.git_branch_var)
            self.git_branch_entry.grid(row=2, column=1, sticky="ew", pady=3, padx=5)

            ttk.Label(git_frame, text="Último Commit:", font=("Arial", 9, "bold")).grid(row=3, column=0, sticky="w", pady=3, padx=5)
            self.git_commit_entry = ttk.Entry(git_frame, textvariable=self.git_commit_var)
            self.git_commit_entry.grid(row=3, column=1, sticky="ew", pady=3, padx=5)

            ttk.Label(git_frame, text="Pull Request:", font=("Arial", 9, "bold")).grid(row=4, column=0, sticky="w", pady=3, padx=5)
            self.git_pr_entry = ttk.Entry(git_frame, textvariable=self.git_pr_var)
            self.git_pr_entry.grid(row=4, column=1, sticky="ew", pady=3, padx=5)

            # Git History Section
            git_history_frame = ttk.LabelFrame(git_frame, text="Histórico Git", padding="5")
            git_history_frame.grid(row=5, column=0, columnspan=2, sticky="ew", pady=(10, 0))
            git_history_frame.columnconfigure(0, weight=1)

            self.git_history_text = tk.Text(git_history_frame, height=4, width=40, wrap=tk.WORD, state="disabled")
            self.git_history_text.pack(fill=tk.BOTH, expand=True, pady=5)
            
            # Update Git status
            self.update_git_status()

        # Populate due date and time if available
        if self.card.get('due_date'):
            try:
                # Tentar diferentes formatos de data
                due_date_str = self.card['due_date']
                dt_obj = None
                
                # Formato com data e hora: "2025-08-12 14:30"
                if ' ' in due_date_str:
                    try:
                        dt_obj = datetime.strptime(due_date_str, "%Y-%m-%d %H:%M")
                        self.include_time_var.set(True)
                        self.toggle_time_fields()
                    except ValueError:
                        try:
                            dt_obj = datetime.strptime(due_date_str, "%Y-%m-%d %H:%M:%S")
                            self.include_time_var.set(True)
                            self.toggle_time_fields()
                        except ValueError:
                            pass
                
                # Formato apenas data: "2025-08-12"
                if not dt_obj:
                    try:
                        dt_obj = datetime.strptime(due_date_str, "%Y-%m-%d")
                        self.include_time_var.set(False)
                        self.toggle_time_fields()
                    except ValueError:
                        # Formato brasileiro: "12/08/2025"
                        try:
                            dt_obj = datetime.strptime(due_date_str, "%d/%m/%Y")
                            self.include_time_var.set(False)
                            self.toggle_time_fields()
                        except ValueError:
                            pass
                
                if dt_obj:
                    self.due_date_entry.config(state="normal")
                    self.due_date_entry.delete(0, tk.END)
                    self.due_date_entry.insert(0, dt_obj.strftime("%Y-%m-%d"))
                    self.due_date_entry.config(state="readonly")
                    
                    if self.include_time_var.get():
                        self.hour_entry.config(state="normal")
                        self.minute_entry.config(state="normal")
                        self.hour_entry.delete(0, tk.END)
                        self.minute_entry.delete(0, tk.END)
                        self.hour_entry.insert(0, dt_obj.strftime("%H"))
                        self.minute_entry.insert(0, dt_obj.strftime("%M"))
                        
            except Exception as e:
                print(f"Erro ao processar data do card: {e}")
                # Se não conseguir processar, limpar os campos
                self.due_date_entry.config(state="normal")
                self.due_date_entry.delete(0, tk.END)
                self.due_date_entry.config(state="readonly")
                self.include_time_var.set(True)
            except ValueError:  # Only date available
                self.due_date_entry.config(state="normal")
                self.due_date_entry.delete(0, tk.END)
                self.due_date_entry.insert(0, self.card['due_date'])
                self.due_date_entry.config(state="readonly")
                self.include_time_var.set(False)
        self.toggle_time_fields()

        # --- Attributes Section ---
        attributes_frame = ttk.LabelFrame(left_frame, text="Atributos", padding="10")
        attributes_frame.pack(fill=tk.X, pady=(0, 10))
        attributes_frame.columnconfigure(1, weight=1)

        ttk.Label(attributes_frame, text="Importância:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
        self.importance_options = list(self.app.settings["importance_colors"].keys())
        self.importance_combo = ttk.Combobox(attributes_frame, values=self.importance_options, state="readonly")
        self.importance_combo.grid(row=0, column=1, sticky="ew", pady=3, padx=5)
        self.importance_combo.set(self.card.get('importance', 'Normal'))

        ttk.Label(attributes_frame, text="Categoria:", font=("Arial", 9, "bold")).grid(row=1, column=0, sticky="w", pady=3, padx=5)
        category_options = [cat['name'] for cat in self.app.categories]
        self.category_combo = ttk.Combobox(attributes_frame, values=category_options, state="readonly")
        self.category_combo.grid(row=1, column=1, sticky="ew", pady=3, padx=5)
        self.category_combo.set(self.card.get('category', '-'))

        ttk.Label(attributes_frame, text="Objetivo:", font=("Arial", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3, padx=5)
        self.goal_combo = ttk.Combobox(attributes_frame, values=self.app.goals, state="readonly")
        self.goal_combo.grid(row=2, column=1, sticky="ew", pady=3, padx=5)
        self.goal_combo.set(self.card.get('goal', '-'))

        # --- Members Section ---
        members_frame = ttk.LabelFrame(left_frame, text="Membros Responsáveis", padding="10")
        members_frame.pack(fill=tk.X, pady=(0, 10))
        members_frame.columnconfigure(0, weight=1)

        # Frame for the combobox and add button
        add_member_frame = ttk.Frame(members_frame)
        add_member_frame.pack(fill=tk.X, pady=2)
        add_member_frame.columnconfigure(0, weight=1)

        self.member_suggestions_combo = ttk.Combobox(add_member_frame, values=[member['Membro'] for member in self.app.members], state="readonly")
        self.member_suggestions_combo.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        self.member_suggestions_combo.set("Selecionar Membro para Adicionar")
        
        add_member_btn = ttk.Button(add_member_frame, text="Adicionar", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_member_from_combo)
        add_member_btn.grid(row=0, column=1)

        # Listbox for assigned members
        self.assigned_members_listbox = tk.Listbox(members_frame, selectmode=tk.SINGLE, height=3)
        self.assigned_members_listbox.pack(fill=tk.BOTH, expand=True, pady=2)
        for member in self.card.get('members', []):
            self.assigned_members_listbox.insert(tk.END, member)

        # Remove button
        remove_member_btn = ttk.Button(members_frame, text="Remover Selecionado", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_assigned_member)
        remove_member_btn.pack(pady=2)

        # --- Creation Date Section ---
        creation_frame = ttk.LabelFrame(left_frame, text="Informações do Sistema", padding="10")
        creation_frame.pack(fill=tk.X)
        
        ttk.Label(creation_frame, text="Data de Criação:", font=("Arial", 9, "bold")).pack(anchor="w", padx=5, pady=2)
        self.creation_date_label = ttk.Label(creation_frame, text=self.card.get('creation_date', 'N/A'))
        self.creation_date_label.pack(anchor="w", padx=5, pady=2)

        # === RIGHT COLUMN ===
        right_frame = ttk.Frame(main_frame)
        right_frame.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
        right_frame.columnconfigure(0, weight=1)
        right_frame.rowconfigure(0, weight=1)  # Allow expansion

        # --- Dependencies Section ---
        dependencies_frame = ttk.LabelFrame(right_frame, text="Dependências", padding="10")
        dependencies_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        dependencies_frame.columnconfigure(0, weight=1)
        
        # Configure the frame to expand properly
        dependencies_frame.pack_configure(fill=tk.BOTH, expand=True)

        # Dependency input area
        dependency_input_frame = ttk.Frame(dependencies_frame)
        dependency_input_frame.pack(fill=tk.X, pady=(0, 5))
        dependency_input_frame.columnconfigure(0, weight=1)
        
        self.dependency_combo = ttk.Combobox(dependency_input_frame, state="readonly")
        self.dependency_combo.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        add_dep_btn = ttk.Button(dependency_input_frame, text="Adicionar", 
                               image=self.app.icons.get('add_icon'), compound=tk.LEFT,
                               command=self._add_dependency)
        add_dep_btn.grid(row=0, column=1)

        # Dependencies list
        self.dependencies_listbox = tk.Listbox(dependencies_frame, selectmode=tk.SINGLE, height=6)
        self.dependencies_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        
        dep_scrollbar = ttk.Scrollbar(dependencies_frame, orient="vertical", command=self.dependencies_listbox.yview)
        dep_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.dependencies_listbox.config(yscrollcommand=dep_scrollbar.set)

        # Remove dependency button
        remove_dep_btn = ttk.Button(dependencies_frame, text="Remover Dependência", 
                                  image=self.app.icons.get('delete_icon'), compound=tk.LEFT,
                                  command=self._remove_dependency)
        remove_dep_btn.pack(pady=5)

        # --- Subtasks Section ---
        subtasks_frame = ttk.LabelFrame(right_frame, text="Subtarefas/Checklist", padding="10")
        subtasks_frame.pack(fill=tk.BOTH, expand=True)
        subtasks_frame.columnconfigure(0, weight=1)
        
        # Configure the frame to expand properly
        subtasks_frame.pack_configure(fill=tk.BOTH, expand=True)

        # Subtask input area
        subtask_input_frame = ttk.Frame(subtasks_frame)
        subtask_input_frame.pack(fill=tk.X, pady=(0, 5))
        subtask_input_frame.columnconfigure(0, weight=1)
        subtask_input_frame.columnconfigure(1, weight=1)
        
        # Subtask entry
        self.subtask_entry = ttk.Entry(subtask_input_frame)
        self.subtask_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        self.subtask_entry.bind('<Return>', lambda e: self._add_subtask())
        
        # Member assignment for subtask
        member_options = [member['Membro'] for member in self.app.members]
        self.subtask_member_combo = ttk.Combobox(subtask_input_frame, values=member_options, state="readonly")
        self.subtask_member_combo.grid(row=0, column=1, sticky="ew", padx=(0, 5))
        self.subtask_member_combo.set("Delegar para...")
        
        add_subtask_btn = ttk.Button(subtask_input_frame, text="Adicionar", 
                                   image=self.app.icons.get('add_icon'), compound=tk.LEFT,
                                   command=self._add_subtask)
        add_subtask_btn.grid(row=0, column=2)

        # Subtasks list
        self.subtasks_listbox = tk.Listbox(subtasks_frame, selectmode=tk.SINGLE, height=8)
        self.subtasks_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        self.subtasks_listbox.bind("<Double-1>", self._toggle_subtask_completion)
        
        subtask_scrollbar = ttk.Scrollbar(subtasks_frame, orient="vertical", command=self.subtasks_listbox.yview)
        subtask_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.subtasks_listbox.config(yscrollcommand=subtask_scrollbar.set)

        # Remove subtask button
        remove_subtask_btn = ttk.Button(subtasks_frame, text="Remover Subtarefa", 
                                      image=self.app.icons.get('delete_icon'), compound=tk.LEFT,
                                      command=self._remove_subtask)
        remove_subtask_btn.pack(pady=5)

        # --- Activity History Section ---
        history_frame = ttk.LabelFrame(right_frame, text="Histórico de Atividade", padding="10")
        history_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        history_frame.columnconfigure(0, weight=1)
        history_frame.rowconfigure(0, weight=1) # Allow treeview to expand

        self.history_treeview = ttk.Treeview(history_frame, columns=("Timestamp", "User", "Details"), show="headings")
        self.history_treeview.heading("Timestamp", text="Data/Hora")
        self.history_treeview.heading("User", text="Usuário")
        self.history_treeview.heading("Details", text="Detalhes")

        self.history_treeview.column("Timestamp", width=150, anchor="w")
        self.history_treeview.column("User", width=80, anchor="w")
        self.history_treeview.column("Details", width=300, anchor="w")

        self.history_treeview.grid(row=0, column=0, sticky="nsew", pady=5)

        history_scrollbar = ttk.Scrollbar(history_frame, orient="vertical", command=self.history_treeview.yview)
        history_scrollbar.grid(row=0, column=1, sticky="ns")
        self.history_treeview.config(yscrollcommand=history_scrollbar.set)

        # Pack canvas and scrollbar
        canvas.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")
        
        # Configure canvas to expand properly
        content_frame.columnconfigure(0, weight=1)
        content_frame.rowconfigure(0, weight=1)
        
        # === BOTTOM ACTION BUTTONS (FIXED AT BOTTOM) ===
        button_frame = ttk.LabelFrame(main_container, text="Ações", padding="10")
        button_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(10, 0))
        
        # Configure button frame for proper layout
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)
        
        # Create buttons with better spacing
        save_btn = ttk.Button(button_frame, text="Salvar", 
                            image=self.app.icons.get('save_icon'), compound=tk.LEFT,
                            command=self.save_card)
        save_btn.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        cancel_btn = ttk.Button(button_frame, text="Cancelar", 
                              image=self.app.icons.get('cancel_icon'), compound=tk.LEFT,
                              command=self.destroy)
        cancel_btn.grid(row=0, column=1, sticky="ew", padx=(0, 5))
        
        pomodoro_btn = ttk.Button(button_frame, text="Iniciar Pomodoro", 
                                image=self.app.icons.get('coffee_icon'), compound=tk.LEFT,
                                command=self.start_pomodoro_action)
        pomodoro_btn.grid(row=0, column=2, sticky="ew", padx=(0, 5))
        
        complete_btn = ttk.Button(button_frame, text="Concluir Cartão", 
                                image=self.app.icons.get('ok_icon'), compound=tk.LEFT,
                                command=self.complete_card_action)
        complete_btn.grid(row=0, column=3, sticky="ew")
        
        # Add keyboard shortcuts
        self.bind('<Control-s>', lambda e: self.save_card())
        self.bind('<Escape>', lambda e: self.destroy())
        self.bind('<Return>', lambda e: self.save_card())
        
        # Initialize data
        self._populate_dependency_combobox()
        self._populate_dependencies_listbox()
        self._populate_subtasks_listbox()
        self._populate_history_treeview()
        
        # Focus on title entry
        self.title_entry.focus_set()

    def _populate_history_treeview(self):
        self.history_treeview.delete(*self.history_treeview.get_children())
        history = self.card.get('history', [])
        for entry in history:
            timestamp = entry.get('timestamp', 'N/A')
            user = entry.get('user', 'Sistema')
            action = entry.get('action', 'Ação desconhecida')
            self.history_treeview.insert("", "end", values=(timestamp, user, action))

    def _add_member_from_combo(self):
        selected_member = self.member_suggestions_combo.get()
        if selected_member and selected_member != "Selecionar Membro para Adicionar":
            current_members = self.assigned_members_listbox.get(0, tk.END)
            if selected_member not in current_members:
                self.assigned_members_listbox.insert(tk.END, selected_member)
            self.member_suggestions_combo.set("Selecionar Membro para Adicionar")

    def _remove_assigned_member(self):
        selected_index = self.assigned_members_listbox.curselection()
        if selected_index:
            self.assigned_members_listbox.delete(selected_index)

    def _add_suggested_member(self, event):
        selected_member = self.member_suggestions_combo.get()
        current_members = [m.strip() for m in self.members_entry.get().split(',') if m.strip()]
        if selected_member and selected_member != "Selecionar Membro" and selected_member not in current_members:
            current_members.append(selected_member)
            self.members_entry.delete(0, tk.END)
            self.members_entry.insert(0, ", ".join(current_members))
        self.member_suggestions_combo.set("Selecionar Membro")

    def open_date_picker(self):
        current_date_str = self.due_date_entry.get()
        dialog = DatePickerDialog(self, current_date=current_date_str, icons=self.app.icons)
        self.wait_window(dialog)
        if dialog.result_date:
            self.due_date_entry.config(state="normal")
            self.due_date_entry.delete(0, tk.END)
            self.due_date_entry.insert(0, dialog.result_date.strftime("%Y-%m-%d"))
            self.due_date_entry.config(state="readonly")

    def toggle_time_fields(self):
        state = "normal" if self.include_time_var.get() else "disabled"
        self.hour_entry.config(state=state)
        self.minute_entry.config(state=state)

    def _add_subtask(self):
        subtask_text = self.subtask_entry.get().strip()
        if subtask_text:
            # Obter membro delegado
            assigned_member = self.subtask_member_combo.get()
            if assigned_member == "Delegar para...":
                assigned_member = None
            
            # Converter subtarefa para caixa alta
            subtask_data = {
                'text': subtask_text.upper(), 
                'completed': False,
                'assigned_member': assigned_member
            }
            self.card.setdefault('subtasks', []).append(subtask_data)
            self.subtask_entry.delete(0, tk.END)
            self.subtask_member_combo.set("Delegar para...")
            self._populate_subtasks_listbox()

    def _remove_subtask(self):
        selected_index = self.subtasks_listbox.curselection()
        if selected_index:
            # Adjust index to account for header and separator
            actual_index = selected_index[0] - 2
            if actual_index >= 0 and actual_index < len(self.card.get('subtasks', [])):
                del self.card['subtasks'][actual_index]
                self._populate_subtasks_listbox()

    def _toggle_subtask_completion(self, event):
        selected_index = self.subtasks_listbox.nearest(event.y)
        if selected_index != -1:
            # Adjust index to account for header and separator
            actual_index = selected_index - 2
            if actual_index >= 0 and actual_index < len(self.card.get('subtasks', [])):
                self.card['subtasks'][actual_index]['completed'] = not self.card['subtasks'][actual_index]['completed']
                self._populate_subtasks_listbox()

    def _populate_subtasks_listbox(self):
        self.subtasks_listbox.delete(0, tk.END)
        subtasks = self.card.get('subtasks', [])
        
        if not subtasks:
            self.subtasks_listbox.insert(tk.END, "Nenhuma subtarefa adicionada")
            return
            
        completed_count = sum(1 for subtask in subtasks if subtask['completed'])
        total_count = len(subtasks)
        
        # Add progress header
        progress_text = f"Progresso: {completed_count}/{total_count} ({completed_count/total_count*100:.0f}%)"
        self.subtasks_listbox.insert(tk.END, progress_text)
        self.subtasks_listbox.itemconfig(0, foreground='blue')
        
        # Add separator
        self.subtasks_listbox.insert(tk.END, "─" * 50)
        self.subtasks_listbox.itemconfig(1, foreground='gray')
        
        # Add subtasks
        for i, subtask in enumerate(subtasks):
            checkbox = "" if subtask['completed'] else ""
            display_text = f"{checkbox} {subtask['text']}"
            
            # Adicionar informação do membro delegado
            if subtask.get('assigned_member'):
                display_text += f" → {subtask['assigned_member']}"
            
            self.subtasks_listbox.insert(tk.END, display_text)
            listbox_index = i + 2  # +2 because of progress header and separator
            if subtask['completed']:
                self.subtasks_listbox.itemconfig(listbox_index, foreground='gray', selectforeground='gray')
            else:
                self.subtasks_listbox.itemconfig(listbox_index, foreground='black', selectforeground='black')

    def _populate_dependency_combobox(self):
        all_cards = []
        for board_name, lists in self.app.boodesk_data["boards"].items():
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                for i, card_data in enumerate(cards):
                    # Don't allow a card to be a dependency of itself or an archived card
                    if card_data.get("card_id") != self.card.get("card_id") and not card_data.get("is_archived", False):
                        all_cards.append(f"{board_name} > {list_name} > {card_data['title']}")
        self.dependency_combo['values'] = sorted(list(set(all_cards)))

    def _add_dependency(self):
        selected_dependency_str = self.dependency_combo.get()
        if selected_dependency_str and selected_dependency_str not in self.card.get('dependencies', []):
            self.card.setdefault('dependencies', []).append(selected_dependency_str)
            self._populate_dependencies_listbox()
            self.dependency_combo.set("")

    def _remove_dependency(self):
        selected_index = self.dependencies_listbox.curselection()
        if selected_index:
            # Adjust index to account for header and separator
            actual_index = selected_index[0] - 2
            if actual_index >= 0 and actual_index < len(self.card.get('dependencies', [])):
                del self.card['dependencies'][actual_index]
                self._populate_dependencies_listbox()

    def _populate_dependencies_listbox(self):
        self.dependencies_listbox.delete(0, tk.END)
        dependencies = self.card.get('dependencies', [])
        
        if not dependencies:
            self.dependencies_listbox.insert(tk.END, "Nenhuma dependência adicionada")
            return
            
        # Add header with dependency status
        completed_deps = sum(1 for dep in dependencies if self.app._is_card_completed(dep))
        total_deps = len(dependencies)
        status_text = f"Dependências: {completed_deps}/{total_deps} Concluídas"
        self.dependencies_listbox.insert(tk.END, status_text)
        self.dependencies_listbox.itemconfig(0, foreground='blue')
        
        # Add separator
        self.dependencies_listbox.insert(tk.END, "─" * 50)
        self.dependencies_listbox.itemconfig(1, foreground='gray')
        
        # Add dependencies with detailed status
        for i, dep in enumerate(dependencies):
            is_completed = self.app._is_card_completed(dep)
            status = "Concluída" if is_completed else "Pendente"
            
            # Get card details for better display
            dep_parts = dep.split(" > ")
            if len(dep_parts) >= 3:
                board_name, list_name, card_title = dep_parts[0], dep_parts[1], dep_parts[2]
                # Check if card is in "Concluído" list
                if list_name == "Concluído":
                    status = "Concluída"
                else:
                    status = "Pendente"
                    
                display_text = f"{status} | {card_title} ({list_name})"
            else:
                display_text = f"{status} | {dep}"
                
            self.dependencies_listbox.insert(tk.END, display_text)
            listbox_index = i + 2  # +2 because of header and separator
            
            if is_completed:
                self.dependencies_listbox.itemconfig(listbox_index, foreground='green')
            else:
                self.dependencies_listbox.itemconfig(listbox_index, foreground='orange')
                
        # Add footer with card status
        if dependencies:
            can_start = all(self.app._is_card_completed(dep) for dep in dependencies)
            if can_start:
                self.dependencies_listbox.insert(tk.END, "Status: Card pode ser iniciado!")
                self.dependencies_listbox.itemconfig(len(dependencies) + 2, foreground='green')
            else:
                pending_count = total_deps - completed_deps
                self.dependencies_listbox.insert(tk.END, f"Status: Aguardando {pending_count} dependência(s)")
                self.dependencies_listbox.itemconfig(len(dependencies) + 2, foreground='orange')

    def save_card(self):
        # Capture original card state for history logging
        original_card = self.card.copy()
        original_card['subtasks'] = [st.copy() for st in self.card.get('subtasks', [])]
        original_card['dependencies'] = self.card.get('dependencies', []).copy()
        original_card['members'] = self.card.get('members', []).copy()

        title = self.title_entry.get()
        desc = self.desc_text.get("1.0", tk.END).strip()
        due_date_str = self.due_date_entry.get()
        importance = self.importance_combo.get()
        category = self.category_combo.get()
        goal = self.goal_combo.get()
        members = list(self.assigned_members_listbox.get(0, tk.END)) # Convert tuple to list

        if not title:
            messagebox.showwarning("Campo Obrigatório", "O título da tarefa é obrigatório.")
            return

        full_due_date = due_date_str
        if self.include_time_var.get():
            hour = self.hour_entry.get().strip()
            minute = self.minute_entry.get().strip()
            if hour and minute:
                try:
                    h = int(hour)
                    m = int(minute)
                    if 0 <= h <= 23 and 0 <= m <= 59:
                        full_due_date = f"{due_date_str} {h:02d}:{m:02d}"
                    else:
                        messagebox.showwarning("Entrada Inválida", "Hora ou minuto inválidos.")
                        return
                except ValueError:
                    messagebox.showwarning("Entrada Inválida", "Hora e minuto devem ser números.")
                    return
            else:
                messagebox.showwarning("Entrada Inválida", "Preencha a hora e o minuto ou desmarque 'Incluir Horário'.")
                return
        
        # Update card data
        self.card['title'] = title.upper()
        self.card['desc'] = desc
        self.card['due_date'] = full_due_date
        self.card['importance'] = importance
        self.card['category'] = category
        self.card['goal'] = goal
        self.card['members'] = members
        if self.app.settings.get('dev_mode', False):
            self.card['git_branch'] = self.git_branch_var.get()
            self.card['git_commit'] = self.git_commit_var.get()
            self.card['git_pr'] = self.git_pr_var.get()
        # Subtasks and dependencies are already updated directly in self.card by their respective methods

        # Log changes to history
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        user_name = self.current_user.username

        def add_history_entry(action_desc):
            self.card.setdefault('history', []).append({"timestamp": current_time, "action": action_desc, "user": user_name})

        # Title
        if self.card['title'] != original_card['title']:
            add_history_entry(f"Título alterado de '{original_card['title']}' para '{self.card['title']}'.")

        # Description
        if self.card['desc'] != original_card['desc']:
            add_history_entry(f"Descrição alterada.")

        # Due Date
        if self.card['due_date'] != original_card['due_date']:
            add_history_entry(f"Prazo alterado de '{original_card['due_date']}' para '{self.card['due_date']}'.")

        # Importance
        if self.card['importance'] != original_card['importance']:
            add_history_entry(f"Importância alterada de '{original_card['importance']}' para '{self.card['importance']}'.")

        # Category
        if self.card['category'] != original_card.get('category', '-'):
            add_history_entry(f"Categoria alterada de '{original_card.get('category', '-')}' para '{self.card['category']}'.")

        # Goal
        if self.card['goal'] != original_card['goal']:
            add_history_entry(f"Objetivo alterado de '{original_card['goal']}' para '{self.card['goal']}'.")

        # Members
        added_members = [m for m in self.card['members'] if m not in original_card['members']]
        removed_members = [m for m in original_card['members'] if m not in self.card['members']]
        for member in added_members:
            add_history_entry(f"Membro '{member}' adicionado.")
        for member in removed_members:
            add_history_entry(f"Membro '{member}' removido.")

        # Subtasks (more complex, check for additions, removals, and completion changes)
        original_subtasks_map = {st['text']: st['completed'] for st in original_card.get('subtasks', [])}
        current_subtasks_map = {st['text']: st['completed'] for st in self.card.get('subtasks', [])}

        for subtask_text, completed_status in current_subtasks_map.items():
            if subtask_text not in original_subtasks_map:
                add_history_entry(f"Subtarefa '{subtask_text}' adicionada.")
            elif original_subtasks_map[subtask_text] != completed_status:
                status_change = "concluída" if completed_status else "reaberta"
                add_history_entry(f"Subtarefa '{subtask_text}' marcada como {status_change}.")
        
        for subtask_text in original_subtasks_map:
            if subtask_text not in current_subtasks_map:
                add_history_entry(f"Subtarefa '{subtask_text}' removida.")

        # Dependencies (check for additions and removals)
        added_dependencies = [d for d in self.card.get('dependencies', []) if d not in original_card.get('dependencies', [])]
        removed_dependencies = [d for d in original_card.get('dependencies', []) if d not in self.card.get('dependencies', [])]
        for dep in added_dependencies:
            add_history_entry(f"Dependência '{dep}' adicionada.")
        for dep in removed_dependencies:
            add_history_entry(f"Dependência '{dep}' removida.")

        # Find the card in the main data structure and update it
        found_card = False
        for i, card_data in enumerate(self.app.boodesk_data["boards"][self.board_name][self.list_name]):
            if card_data.get('card_id') == self.card_id:
                self.app.boodesk_data["boards"][self.board_name][self.list_name][i] = self.card
                found_card = True
                break
        
        if not found_card:
            messagebox.showerror("Erro", "Não foi possível encontrar o cartão para salvar as alterações.")
            return

        self.app.save_trello_data()
        
        # Sincronizar com Google Calendar se habilitado
        if self.app.settings.get('google_calendar_enabled', False):
            self._sync_card_to_calendar()
        
        if self.callback_on_close:
            self.callback_on_close(saved=True)
        self.destroy()

    def start_pomodoro_action(self):
        # Find the card index using card_id
        card_index = -1
        for i, card_data in enumerate(self.app.boodesk_data["boards"][self.board_name][self.list_name]):
            if card_data.get('card_id') == self.card_id:
                card_index = i
                break
        
        if card_index != -1:
            self.app.start_pomodoro_from_card(self.board_name, self.list_name, card_index)
        self.destroy()

    def complete_card_action(self):
        # Find the card index using card_id
        card_index = -1
        for i, card_data in enumerate(self.app.boodesk_data["boards"][self.board_name][self.list_name]):
            if card_data.get('card_id') == self.card_id:
                card_index = i
                break
        
        if card_index != -1:
            self.app.complete_trello_card(self.board_name, self.list_name, card_index)
        self.destroy()

    def _sync_card_to_calendar(self):
        """Sincroniza o card com o Google Calendar"""
        try:
            # Verificar se o Google Calendar está configurado
            if not hasattr(self.app, 'google_calendar') or not self.app.google_calendar.is_authenticated:
                print("Google Calendar não está autenticado")
                return
            
            # Verificar se há data de vencimento
            if not self.card.get('due_date'):
                print("Card não possui data de vencimento")
                return
            
            # Usar função auxiliar para processar data brasileira
            event_datetime = self.app.parse_brazilian_date(self.card['due_date'])
            
            if not event_datetime:
                print(f"Formato de data inválido: {self.card['due_date']}")
                return
            
            # Criar evento no Google Calendar
            event_title = f"📋 {self.card['title']}"
            event_description = f"""
Card: {self.card['title']}
Descrição: {self.card.get('desc', 'Sem descrição')}
Importância: {self.card.get('importance', 'Normal')}
Assunto: {self.card.get('subject', '-')}
Objetivo: {self.card.get('goal', '-')}
Membros: {', '.join(self.card.get('members', []))}
Board: {self.board_name}
Lista: {self.list_name}
Card ID: {self.card_id}
            """.strip()
            
            # Definir duração do evento (1 hora por padrão)
            event_duration = timedelta(hours=1)
            
            # Coletar emails para o evento
            attendees = []
            
            # Adicionar emails padrão se habilitado
            calendar_settings = self.app.settings.get('calendar_integration', {})
            if calendar_settings.get('include_default_emails', True):
                default_emails = calendar_settings.get('default_emails', [])
                attendees.extend(default_emails)
            
            # Adicionar membros do card se habilitado
            if calendar_settings.get('include_card_members', True):
                card_members = self.card.get('members', [])
                for member in card_members:
                    # Buscar email do membro no arquivo de membros
                    member_email = self._get_member_email(member)
                    if member_email:
                        attendees.append(member_email)
            
            # Remover duplicatas
            attendees = list(set(attendees))
            
            # Criar evento
            success = self.app.google_calendar.create_event(
                title=event_title,
                description=event_description,
                start_datetime=event_datetime,
                duration=event_duration,
                card_id=self.card_id,
                attendees=attendees if attendees else None
            )
            
            if success:
                print(f"✅ Evento criado no Google Calendar para o card: {self.card['title']}")
                # Adicionar ao histórico do card
                self.card.setdefault('history', []).append({
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "action": f"Evento criado no Google Calendar",
                    "user": self.current_user.username
                })
            else:
                print(f"❌ Erro ao criar evento no Google Calendar para o card: {self.card['title']}")
                
        except Exception as e:
            print(f"❌ Erro na sincronização com Google Calendar: {e}")
            import traceback
            traceback.print_exc()

    def _get_member_email(self, member_name):
        """Busca o email de um membro no arquivo de membros"""
        try:
            if hasattr(self.app, 'members') and self.app.members:
                print(f"DEBUG: Buscando email para membro '{member_name}' (CardWindow)")
                print(f"DEBUG: Total de membros carregados: {len(self.app.members)}")
                for member in self.app.members:
                    print(f"DEBUG: Verificando membro: {member}")
                    if member.get('Membro') == member_name:
                        email = member.get('email', '')
                        print(f"DEBUG: Email encontrado para '{member_name}': {email}")
                        return email
                print(f"DEBUG: Membro '{member_name}' não encontrado")
            else:
                print(f"DEBUG: Lista de membros não disponível ou vazia")
            return None
        except Exception as e:
            print(f"Erro ao buscar email do membro {member_name}: {e}")
            return None

    # Git Integration Methods
    def update_git_status(self):
        """Update the Git status display"""
        if hasattr(self, 'git_status_label'):
            if self.git_branch_var.get():
                self.git_status_label.config(text="Configurado", foreground="green")
            else:
                self.git_status_label.config(text="Não configurado", foreground="gray")
            
            # Update Git history
            if hasattr(self, 'git_history_text'):
                self.update_git_history()

    def update_git_history(self):
        """Update the Git history display"""
        if hasattr(self, 'git_history_text'):
            self.git_history_text.config(state="normal")
            self.git_history_text.delete("1.0", tk.END)
            
            history_text = "Histórico Git:\n"
            if self.git_branch_var.get():
                history_text += f"Branch: {self.git_branch_var.get()}\n"
            if self.git_commit_var.get():
                history_text += f"Commit: {self.git_commit_var.get()}\n"
            if self.git_pr_var.get():
                history_text += f"PR: {self.git_pr_var.get()}\n"
            
            if not any([self.git_branch_var.get(), self.git_commit_var.get(), self.git_pr_var.get()]):
                history_text += "Nenhuma informação Git disponível"
            
            self.git_history_text.insert("1.0", history_text)
            self.git_history_text.config(state="disabled")

    def init_git_repo(self):
        """Initialize Git repository for this card"""
        try:
            import subprocess
            import os
            
            # Create a directory for this card's Git repo
            repo_dir = os.path.join(self.app.base_dir, f"git_repos/{self.card_id}")
            os.makedirs(repo_dir, exist_ok=True)
            
            # Initialize Git repository
            result = subprocess.run(['git', 'init'], cwd=repo_dir, capture_output=True, text=True)
            
            if result.returncode == 0:
                messagebox.showinfo("Git", "Repositório Git inicializado com sucesso!")
                self.git_branch_var.set("main")
                self.update_git_status()
            else:
                messagebox.showerror("Erro Git", f"Erro ao inicializar repositório: {result.stderr}")
                
        except Exception as e:
            messagebox.showerror("Erro Git", f"Erro ao inicializar repositório Git: {e}")

    def create_git_branch(self):
        """Create a new Git branch for this card"""
        branch_name = simpledialog.askstring("Criar Branch", "Nome da nova branch:", parent=self)
        if branch_name:
            try:
                import subprocess
                import os
                
                repo_dir = os.path.join(self.app.base_dir, f"git_repos/{self.card_id}")
                
                if not os.path.exists(os.path.join(repo_dir, '.git')):
                    messagebox.showerror("Erro Git", "Repositório Git não inicializado. Use 'Inicializar Repo' primeiro.")
                    return
                
                # Create and checkout new branch
                result = subprocess.run(['git', 'checkout', '-b', branch_name], cwd=repo_dir, capture_output=True, text=True)
                
                if result.returncode == 0:
                    self.git_branch_var.set(branch_name)
                    self.update_git_status()
                    messagebox.showinfo("Git", f"Branch '{branch_name}' criada e ativada!")
                else:
                    messagebox.showerror("Erro Git", f"Erro ao criar branch: {result.stderr}")
                    
            except Exception as e:
                messagebox.showerror("Erro Git", f"Erro ao criar branch Git: {e}")

    def make_git_commit(self):
        """Make a Git commit for this card"""
        commit_message = simpledialog.askstring("Commit", "Mensagem do commit:", parent=self)
        if commit_message:
            try:
                import subprocess
                import os
                
                repo_dir = os.path.join(self.app.base_dir, f"git_repos/{self.card_id}")
                
                if not os.path.exists(os.path.join(repo_dir, '.git')):
                    messagebox.showerror("Erro Git", "Repositório Git não inicializado. Use 'Inicializar Repo' primeiro.")
                    return
                
                # Add all files and commit
                subprocess.run(['git', 'add', '.'], cwd=repo_dir, capture_output=True)
                result = subprocess.run(['git', 'commit', '-m', commit_message], cwd=repo_dir, capture_output=True, text=True)
                
                if result.returncode == 0:
                    # Get the commit hash
                    commit_result = subprocess.run(['git', 'rev-parse', 'HEAD'], cwd=repo_dir, capture_output=True, text=True)
                    if commit_result.returncode == 0:
                        commit_hash = commit_result.stdout.strip()[:8]  # First 8 characters
                        self.git_commit_var.set(commit_hash)
                        self.update_git_status()
                        messagebox.showinfo("Git", f"Commit realizado com sucesso!\nHash: {commit_hash}")
                    else:
                        messagebox.showinfo("Git", "Commit realizado com sucesso!")
                else:
                    messagebox.showerror("Erro Git", f"Erro ao fazer commit: {result.stderr}")
                    
            except Exception as e:
                messagebox.showerror("Erro Git", f"Erro ao fazer commit Git: {e}")

    def destroy(self):
        if self.callback_on_close:
            self.callback_on_close(saved=False)
        super().destroy()

    def _get_current_user_member(self):
        """Retorna o nome do membro associado ao usuário logado"""
        try:
            if not self.current_user:
                return None
            
            username = self.current_user.username
            
            # Buscar o membro associado ao usuário no banco SQLite
            import sqlite3
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("SELECT member_id FROM users WHERE username = ?", (username,))
            result = cursor.fetchone()
            conn.close()
            
            if result and result[0]:
                member_id = result[0]
                # Buscar o nome do membro usando o member_id
                conn = sqlite3.connect('boodesk_new.db')
                cursor = conn.cursor()
                cursor.execute("SELECT name FROM members WHERE id = ?", (member_id,))
                member_result = cursor.fetchone()
                conn.close()
                
                if member_result:
                    member_name = member_result[0]
                    print(f"DEBUG: Usuário {username} associado ao membro {member_name}")
                    return member_name
            
            print(f"DEBUG: Usuário {username} não tem membro associado")
            return None
            
        except Exception as e:
            print(f"DEBUG: Erro ao buscar membro do usuário: {e}")
            return None

    # Chamar update_all_displays após todos os métodos serem definidos
    def initialize_displays(self):
        """Inicializa todos os displays após a classe estar completamente definida"""
        print("DEBUG: Chamando update_all_displays")
        self.update_all_displays()
        print("DEBUG: update_all_displays concluído")

class MembersWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Gerenciar Membros")
        self.geometry("800x600") # Increased size to accommodate email column
        self.resizable(True, True)  # Allow resizing
        self.minsize(700, 550)  # Minimum size
        self.transient(parent)
        self.grab_set()
        
        # Variables for edit mode
        self.edit_mode = False
        self.selected_member = None

        # Center the window on screen
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 800
        window_height = 600
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

        self.create_widgets()
        self._populate_members_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure main frame for better layout
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)  # List frame should expand
        
        # Title
        title_label = ttk.Label(main_frame, text="Gerenciamento de Membros", font=("Arial", 12, "bold"))
        title_label.grid(row=0, column=0, pady=(0, 10), sticky="w")

        # Member List Frame
        list_frame = ttk.LabelFrame(main_frame, text="Lista de Membros", padding="5")
        list_frame.grid(row=1, column=0, sticky="nsew", pady=(0, 10))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        self.members_tree = ttk.Treeview(list_frame, columns=("Membro", "Cargo", "Email"), show="headings")
        self.members_tree.heading("Membro", text="Membro")
        self.members_tree.heading("Cargo", text="Cargo")
        self.members_tree.heading("Email", text="Email")
        self.members_tree.column("Membro", width=150, anchor="w")
        self.members_tree.column("Cargo", width=100, anchor="w")
        self.members_tree.column("Email", width=200, anchor="w")
        self.members_tree.grid(row=0, column=0, sticky="nsew", pady=5)
        self.members_tree.bind("<<TreeviewSelect>>", self._on_member_select)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Membro", padding="10")
        entry_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        entry_frame.columnconfigure(1, weight=1) # Make entry expandable

        ttk.Label(entry_frame, text="Nome do Membro:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.member_name_entry = ttk.Entry(entry_frame)
        self.member_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(entry_frame, text="Cargo:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.role_combo = ttk.Combobox(entry_frame, values=list(self.app.settings["roles"].keys()), state="readonly")
        self.role_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        self.role_combo.set("Usuário") # Default role

        ttk.Label(entry_frame, text="Email:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        self.email_entry = ttk.Entry(entry_frame)
        self.email_entry.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        
        # Adicionar instrução sobre o email
        email_info = ttk.Label(entry_frame, text="(Opcional - usado para convites do Google Calendar)", 
                              font=("Arial", 8), foreground="gray")
        email_info.grid(row=3, column=0, columnspan=2, sticky="w", padx=5, pady=(0, 5))

        button_row = ttk.Frame(entry_frame)
        button_row.grid(row=4, column=0, columnspan=2, pady=5)
        button_row.columnconfigure(0, weight=1)
        button_row.columnconfigure(1, weight=1)
        
        ttk.Button(button_row, text="Adicionar Membro", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_member).grid(row=0, column=0, padx=2)
        ttk.Button(button_row, text="Limpar", image=self.app.icons.get('clear_icon'), compound=tk.LEFT, command=self._clear_form).grid(row=0, column=1, padx=2)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=3, column=0, pady=5, sticky="ew")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)
        
        ttk.Button(button_frame, text="Editar Membro", image=self.app.icons.get('edit_icon'), compound=tk.LEFT, command=self._edit_member).grid(row=0, column=0, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Remover Membro", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_member).grid(row=0, column=1, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Cadastrar Cargo", image=self.app.icons.get('settings_icon'), compound=tk.LEFT, command=self._open_roles_settings).grid(row=0, column=2, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Cadastrar Usuário", image=self.app.icons.get('registration_icon'), compound=tk.LEFT, command=self._open_user_registration_for_member).grid(row=0, column=3, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Fechar", image=self.app.icons.get('cancel_icon'), compound=tk.LEFT, command=self.destroy).grid(row=0, column=4, padx=5, sticky="ew")

    def _open_roles_settings(self):
        """Open SettingsWindow and navigate to the Roles tab"""
        settings_window = SettingsWindow(self.master, self.app)
        settings_window.notebook.select(settings_window.roles_tab) # Select the roles tab
        self.master.wait_window(settings_window)
        
        # Refresh the roles combo after settings window is closed
        self.role_combo['values'] = list(self.app.settings["roles"].keys())
        if self.role_combo.get() not in self.app.settings["roles"]:
            self.role_combo.set("Usuário")  # Reset to default if current role was removed
        # Também atualizar combo de cargo na janela de usuários
        try:
            if hasattr(self, 'cargo_combo') and self.cargo_combo:
                self.cargo_combo['values'] = list(self.app.settings["roles"].keys())
                if self.cargo_combo.get() not in self.cargo_combo['values'] and self.cargo_combo['values']:
                    self.cargo_combo.set(self.cargo_combo['values'][0])
        except Exception:
            pass

    def _open_user_registration_for_member(self):
        """Abre a tela de usuários já com o membro selecionado"""
        try:
            selected_item = self.members_tree.selection()
            pre_member_id = None
            if selected_item:
                values = self.members_tree.item(selected_item, "values")
                member_name = values[0]
                # Buscar ID do membro por nome
                import sqlite3
                conn = sqlite3.connect('boodesk_new.db')
                cursor = conn.cursor()
                cursor.execute("SELECT id FROM members WHERE name = ?", (member_name,))
                row = cursor.fetchone()
                conn.close()
                if row:
                    pre_member_id = row[0]
            # Abrir a janela de usuários passando app e o member_id
            UserRegistrationWindow(self.master, self.app.user_management if hasattr(self.app, 'user_management') else None, self.app.icons, app=self.app, preselected_member_id=pre_member_id)
        except Exception as e:
            print(f"DEBUG: Erro ao abrir cadastro de usuário a partir de membros: {e}")

    def _populate_members_list(self):
        self.members_tree.delete(*self.members_tree.get_children())
        for index, row in self.app.members_df.iterrows():
            # Verificar se a coluna email existe, senão usar string vazia
            email = row.get('email', '') if 'email' in row else ''
            self.members_tree.insert("", "end", values=(row['Membro'], row['Cargo'], email))

    def _add_member(self):
        new_member_name = self.member_name_entry.get().strip()
        new_member_role = self.role_combo.get()
        new_member_email = self.email_entry.get().strip()

        if not new_member_name:
            messagebox.showwarning("Entrada Inválida", "O nome do membro não pode estar vazio.")
            return

        # Verificar se o membro já existe no banco SQLite
        try:
            import sqlite3
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM members WHERE name = ?", (new_member_name,))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este membro já existe.")
                conn.close()
                return
            conn.close()
        except Exception as e:
            print(f"Erro ao verificar membro existente: {e}")
            messagebox.showerror("Erro", f"Não foi possível verificar se o membro existe: {e}")
            return

        # Validar email se fornecido
        if new_member_email:
            import re
            email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
            if not email_pattern.match(new_member_email):
                messagebox.showwarning("Email Inválido", "Por favor, insira um email válido ou deixe em branco.")
                return

        # Adicionar membro diretamente no banco SQLite
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            # Verificar se o membro já existe
            cursor.execute("SELECT id FROM members WHERE name = ?", (new_member_name,))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este nome de membro já existe.")
                conn.close()
                return
            
            # Inserir novo membro
            cursor.execute("""
                INSERT INTO members (name, email, role, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?)
            """, (new_member_name, new_member_email, new_member_role, datetime.now(), datetime.now()))
            
            conn.commit()
            conn.close()
            
            # Recarregar membros na aplicação principal
            self.app.load_members()
            self._populate_members_list()
            
        except Exception as e:
            print(f"Erro ao adicionar membro: {e}")
            messagebox.showerror("Erro", f"Não foi possível adicionar o membro: {e}")
            return
        
        # Clear form
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usuário") # Reset to default
        self.email_entry.delete(0, tk.END)
        self.edit_mode = False
        self.selected_member = None
        
        messagebox.showinfo("Sucesso", f"Membro '{new_member_name}' adicionado com sucesso!")
        self.app.populate_boards() # Refresh boards to update member filter options

    def _on_member_select(self, event):
        """Handle member selection in treeview"""
        selected_item = self.members_tree.selection()
        if selected_item:
            values = self.members_tree.item(selected_item, "values")
            self.selected_member = values[0]  # Member name
            # Populate entry fields for editing
            self.member_name_entry.delete(0, tk.END)
            self.member_name_entry.insert(0, values[0])
            self.role_combo.set(values[1])
            # Preencher email se existir
            if len(values) > 2:
                self.email_entry.delete(0, tk.END)
                self.email_entry.insert(0, values[2])
            else:
                self.email_entry.delete(0, tk.END)
            self.edit_mode = True
        else:
            self.edit_mode = False
            self.selected_member = None

    def _edit_member(self):
        """Edit selected member"""
        if not self.selected_member:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um membro para editar.")
            return

        new_member_name = self.member_name_entry.get().strip()
        new_member_role = self.role_combo.get()
        new_member_email = self.email_entry.get().strip()

        if not new_member_name:
            messagebox.showwarning("Entrada Inválida", "O nome do membro não pode estar vazio.")
            return

        # Check if new name conflicts with existing members (excluding current member)
        try:
            import sqlite3
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM members WHERE name = ? AND name != ?", (new_member_name, self.selected_member))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este nome de membro já existe.")
                conn.close()
                return
            conn.close()
        except Exception as e:
            print(f"Erro ao verificar membro existente: {e}")
            messagebox.showerror("Erro", f"Não foi possível verificar se o membro existe: {e}")
            return

        # Validar email se fornecido
        if new_member_email:
            import re
            email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
            if not email_pattern.match(new_member_email):
                messagebox.showwarning("Email Inválido", "Por favor, insira um email válido ou deixe em branco.")
                return

        # Atualizar membro no banco SQLite
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            # Verificar se o novo nome já existe (excluindo o membro atual)
            cursor.execute("SELECT id FROM members WHERE name = ? AND name != ?", (new_member_name, self.selected_member))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este nome de membro já existe.")
                conn.close()
                return
            
            # Atualizar membro
            cursor.execute("""
                UPDATE members 
                SET name = ?, email = ?, role = ?, updated_at = ?
                WHERE name = ?
            """, (new_member_name, new_member_email, new_member_role, datetime.now(), self.selected_member))
            
            conn.commit()
            conn.close()
            
            # Recarregar membros na aplicação principal
            self.app.load_members()
            self._populate_members_list()
            
        except Exception as e:
            print(f"Erro ao atualizar membro: {e}")
            messagebox.showerror("Erro", f"Não foi possível atualizar o membro: {e}")
            return
        
        # Clear form
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usuário")
        self.email_entry.delete(0, tk.END)
        self.edit_mode = False
        self.selected_member = None
        
        messagebox.showinfo("Sucesso", f"Membro '{new_member_name}' atualizado com sucesso!")
        self.app.populate_boards()

    def _remove_member(self):
        selected_item = self.members_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um membro para remover.")
            return

        member_name_to_remove = self.members_tree.item(selected_item, "values")[0]
        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover '{member_name_to_remove}'?"):
            try:
                import sqlite3
                
                conn = sqlite3.connect('boodesk_new.db')
                cursor = conn.cursor()
                
                # Remover membro do banco
                cursor.execute("DELETE FROM members WHERE name = ?", (member_name_to_remove,))
                
                conn.commit()
                conn.close()
                
                # Recarregar membros na aplicação principal
                self.app.load_members()
                
            except Exception as e:
                print(f"Erro ao remover membro: {e}")
                messagebox.showerror("Erro", f"Não foi possível remover o membro: {e}")
                return
            self._populate_members_list()
            
            # Clear form if the removed member was selected
            if self.selected_member == member_name_to_remove:
                self.member_name_entry.delete(0, tk.END)
                self.role_combo.set("Usuário")
                self.edit_mode = False
                self.selected_member = None
            
            messagebox.showinfo("Sucesso", f"Membro '{member_name_to_remove}' removido com sucesso!")
            self.app.populate_boards() # Refresh boards to update member filter options

    def _clear_form(self):
        """Clear the form and reset to add mode"""
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usuário")
        self.email_entry.delete(0, tk.END)
        self.edit_mode = False
        self.selected_member = None
        self.members_tree.selection_remove(*self.members_tree.selection())

    def toggle_always_on_top(self):
        self.app.root.attributes("-topmost", self.always_on_top_var.get())

class SubjectManagerWindow(tk.Toplevel):
    def __init__(self, parent, app, subject_type):
        super().__init__(parent)
        self.app = app
        self.subject_type = subject_type
        
        if self.subject_type == 'pomodoro':
            self.title("Gerenciar Assuntos do Pomodoro")
            self.subjects_df = self.app.pomodoro_subjects_df
            self.subjects_list = self.app.pomodoro_subjects
            self.file_path = self.app.pomodoro_subjects_file
        else: # boodesk
            self.title("Gerenciar Assuntos do Boodesk")
            self.subjects_df = self.app.boodesk_subjects_df
            self.subjects_list = self.app.boodesk_subjects
            self.file_path = self.app.boodesk_subjects_file

        self.geometry("450x350")
        self.transient(parent)
        self.grab_set()

        self.create_widgets()
        self._populate_subjects_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Listbox Frame
        list_frame = ttk.LabelFrame(main_frame, text="Assuntos Cadastrados")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        self.subjects_listbox = tk.Listbox(list_frame, selectmode=tk.SINGLE)
        self.subjects_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.subjects_listbox.bind("<<ListboxSelect>>", self._on_subject_select)
        
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.subjects_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.subjects_listbox.config(yscrollcommand=scrollbar.set)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Assunto")
        entry_frame.pack(fill=tk.X, pady=5)
        entry_frame.columnconfigure(0, weight=1)

        self.subject_entry = ttk.Entry(entry_frame)
        self.subject_entry.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        
        self.add_edit_button = ttk.Button(entry_frame, text="Adicionar", command=self._add_subject)
        self.add_edit_button.grid(row=0, column=1, padx=5, pady=5)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Remover Selecionado", command=self._remove_subject).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", command=self.destroy).pack(side=tk.RIGHT, padx=5)

    def _populate_subjects_list(self):
        self.subjects_listbox.delete(0, tk.END)
        # Sort the list for better UX
        for subject in sorted(self.subjects_list):
            if subject != '-': # Don't show the default '-'
                self.subjects_listbox.insert(tk.END, subject)

    def _on_subject_select(self, event):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            self.subject_entry.delete(0, tk.END)
            self.add_edit_button.config(text="Adicionar", command=self._add_subject)
            return
        
        selected_subject = self.subjects_listbox.get(selected_indices[0])
        self.subject_entry.delete(0, tk.END)
        self.subject_entry.insert(0, selected_subject)
        self.add_edit_button.config(text="Salvar Edição", command=self._edit_subject)

    def _clear_selection(self):
        self.subjects_listbox.selection_clear(0, tk.END)
        self.subject_entry.delete(0, tk.END)
        self.add_edit_button.config(text="Adicionar", command=self._add_subject)
        # Manually trigger the event handler to reset the button state
        self._on_subject_select(None)


    def _add_subject(self):
        new_subject = self.subject_entry.get().strip()
        if not new_subject:
            messagebox.showwarning("Entrada Inválida", "O nome do assunto não pode estar vazio.", parent=self)
            return
        
        if new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' já existe.", parent=self)
            return

        # Update DataFrame and list
        new_subject_df = pd.DataFrame({'Assunto': [new_subject]})
        self.subjects_df = pd.concat([self.subjects_df, new_subject_df], ignore_index=True)
        self.subjects_list.append(new_subject)
        
        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{new_subject}' adicionado.", parent=self)

    def _edit_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um assunto para editar.", parent=self)
            return
            
        old_subject = self.subjects_listbox.get(selected_indices[0])
        new_subject = self.subject_entry.get().strip()

        if not new_subject:
            messagebox.showwarning("Entrada Inválida", "O nome do assunto não pode estar vazio.", parent=self)
            return

        if new_subject != old_subject and new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' já existe.", parent=self)
            return

        # Update DataFrame and list
        self.subjects_df.loc[self.subjects_df['Assunto'] == old_subject, 'Assunto'] = new_subject
        self.subjects_list[self.subjects_list.index(old_subject)] = new_subject

        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{old_subject}' atualizado para '{new_subject}'.", parent=self)

    def _remove_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um assunto para remover.", parent=self)
            return

        subject_to_remove = self.subjects_listbox.get(selected_indices[0])
        
        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover o assunto '{subject_to_remove}'?\nIsso não pode ser desfeito e não alterará os cartões existentes.", parent=self):
            # Update DataFrame and list
            self.subjects_df = self.subjects_df[self.subjects_df['Assunto'] != subject_to_remove]
            self.subjects_list.remove(subject_to_remove)
            
            # Save and refresh
            self._save_and_refresh()
            self._clear_selection()
            messagebox.showinfo("Sucesso", f"Assunto '{subject_to_remove}' removido.", parent=self)

    def _save_and_refresh(self):
        # Save the DataFrame to the Excel file
        self.subjects_df.to_excel(self.file_path, index=False)
        
        # Update the main app's data
        if self.subject_type == 'pomodoro':
            self.app.pomodoro_subjects_df = self.subjects_df
            self.app.pomodoro_subjects = self.subjects_list
        else: # boodesk
            self.app.boodesk_subjects_df = self.subjects_df
            self.app.boodesk_subjects = self.subjects_list
            
        # Reload all auxiliary data in the main app to update all UI components
        self.app.load_aux_data()
        self.app.update_all_displays() # A comprehensive update
        
        # Refresh the listbox in this window
        self._populate_subjects_list()

    def destroy(self):
        # Ensure the main app window gets focus back
        self.app.root.focus_set()
        super().destroy()

class SettingsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Configurações")
        self.geometry("1200x800")  # Tamanho maior para acomodar scrollbars
        self.resizable(True, True)  # Permitir redimensionamento
        self.transient(parent)
        self.grab_set()
        
        # Centralizar a janela na tela
        self.center_window()
        
        # Criar estilo vermelho para destacar a seção de ações
        style = ttk.Style()
        style.configure('Red.TFrame', background='#ffcccc')

        self.create_widgets()

    def center_window(self):
        """Centraliza a janela na tela - igual ao CardWindow"""
        self.update_idletasks()
        
        # Obter dimensões da tela
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Obter dimensões da janela
        window_width = self.winfo_width()
        window_height = self.winfo_height()
        
        # Calcular posição central
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        
        # Aplicar posição
        self.geometry(f"+{x}+{y}")

    def create_widgets(self):
        # Main container with proper layout - igual à tela de cards
        main_container = ttk.Frame(self)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Configure main container for proper layout
        main_container.columnconfigure(0, weight=1)
        main_container.rowconfigure(0, weight=1)
        
        # === CONTENT FRAME (TOP) ===
        content_frame = ttk.Frame(main_container)
        content_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 10))
        content_frame.columnconfigure(0, weight=1)
        content_frame.rowconfigure(0, weight=1)
        
        # Configure grid for 2 columns
        content_frame.columnconfigure(0, weight=1)  # Left column
        content_frame.columnconfigure(1, weight=1)  # Right column
        content_frame.rowconfigure(0, weight=1)

        # === LEFT COLUMN ===
        left_frame = ttk.Frame(content_frame)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
        
        # Notebook principal
        self.notebook = ttk.Notebook(left_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)

        # Create tabs with scrollbars
        self.geral_tab = self.create_scrollable_tab("Geral")
        self.quadros_tab = self.create_scrollable_tab("Quadros")
        self.pomodoro_tab = self.create_scrollable_tab("Pomodoro")
        self.roles_tab = self.create_scrollable_tab("Cargos")
        self.dashboard_tab = self.create_scrollable_tab("Dashboard")
        self.calendar_tab = self.create_scrollable_tab("Calendário")
        self.email_tab = self.create_scrollable_tab("Email")
        self.email_templates_tab = self.create_scrollable_tab("Templates de Email")

        # Create tab contents
        self.create_geral_tab()
        self.create_quadros_tab()
        self.create_pomodoro_tab()
        self.create_roles_tab()
        self.create_dashboard_tab()
        self.create_calendar_tab()
        self.create_email_tab()
        self.create_email_templates_tab()

        # === RIGHT COLUMN ===
        right_frame = ttk.Frame(content_frame)
        right_frame.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
        
        # Adicionar informações extras na coluna direita
        info_frame = ttk.LabelFrame(right_frame, text="Informações do Sistema", padding="10")
        info_frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(info_frame, text="Versão do Sistema: 2.0", font=("Arial", 10, "bold")).pack(anchor="w", pady=5)
        ttk.Label(info_frame, text="Status: Ativo", font=("Arial", 9)).pack(anchor="w", pady=2)
        ttk.Label(info_frame, text="Última Atualização: Hoje", font=("Arial", 9)).pack(anchor="w", pady=2)
        ttk.Label(info_frame, text="Configurações Salvas: Sim", font=("Arial", 9)).pack(anchor="w", pady=2)
        
        # === BOTTOM ACTION BUTTONS (FIXED AT BOTTOM) ===
        # Botões fixos na parte inferior - igual à tela de cards
        button_frame = ttk.LabelFrame(main_container, text="Ações", padding="10")
        button_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(10, 0))
        
        # Configure button frame for proper layout
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        
        # Create buttons with better spacing and icons like in CardWindow
        restore_btn = ttk.Button(button_frame, text="🔄 Restaurar Padrões", 
                                command=self.restore_defaults)
        restore_btn.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        cancel_btn = ttk.Button(button_frame, text="❌ Cancelar", 
                              command=self.destroy)
        cancel_btn.grid(row=0, column=1, sticky="ew", padx=(0, 5))
        
        save_btn = ttk.Button(button_frame, text="💾 Salvar", 
                            command=self.save_settings)
        save_btn.grid(row=0, column=2, sticky="ew")
        
        # Add keyboard shortcuts
        self.bind('<Control-s>', lambda e: self.save_settings())
        self.bind('<Escape>', lambda e: self.destroy())
        self.bind('<Return>', lambda e: self.save_settings())
        
        # Focus on save button
        save_btn.focus_set()
        
        # Forçar atualização da interface
        self.update_idletasks()
        
        # Debug: verificar se os botões foram criados
        print(f"DEBUG: Botões criados - Restaurar: {restore_btn.winfo_exists()}, Cancelar: {cancel_btn.winfo_exists()}, Salvar: {save_btn.winfo_exists()}")
        print(f"DEBUG: Layout igual à tela de cards - Botões fixos na parte inferior")

    def create_scrollable_tab(self, tab_name):
        """Cria uma aba com scrollbar vertical e horizontal"""
        # Frame principal da aba
        tab_frame = ttk.Frame(self.notebook)
        
        # Canvas para scroll
        canvas = tk.Canvas(tab_frame, bg='white')
        scrollbar_y = ttk.Scrollbar(tab_frame, orient="vertical", command=canvas.yview)
        scrollbar_x = ttk.Scrollbar(tab_frame, orient="horizontal", command=canvas.xview)
        
        # Frame interno para o conteúdo
        content_frame = ttk.Frame(canvas)
        
        # Configurar scroll
        canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        # Layout dos widgets
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar_y.pack(side="right", fill="y")
        scrollbar_x.pack(side="bottom", fill="x")
        
        # Criar janela no canvas
        canvas_window = canvas.create_window((0, 0), window=content_frame, anchor="nw")
        
        # Configurar redimensionamento
        def configure_scroll_region(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
        
        def configure_canvas_window(event):
            canvas.itemconfig(canvas_window, width=event.width)
        
        content_frame.bind("<Configure>", configure_scroll_region)
        canvas.bind("<Configure>", configure_canvas_window)
        
        # Adicionar aba ao notebook
        self.notebook.add(tab_frame, text=tab_name)
        
        # Retornar o frame de conteúdo para ser usado pelas funções de criação
        return content_frame

    def create_geral_tab(self):
        frame = self.geral_tab
        frame.grid_columnconfigure(0, weight=1)

        ttk.Label(frame, text="Tema do Aplicativo:").pack(anchor="w", padx=10, pady=(10, 0))
        self.theme_combo = ttk.Combobox(frame, values=self.app.root.get_themes(), state="readonly")
        self.theme_combo.pack(fill="x", padx=10, pady=5)
        self.theme_combo.set(self.app.settings.get('theme', 'aquativo'))

        self.always_on_top_var = tk.BooleanVar()
        self.always_on_top_var.set(self.app.root.attributes("-topmost"))
        ttk.Checkbutton(frame, text="Sempre no topo", variable=self.always_on_top_var, command=self.toggle_always_on_top).pack(anchor="w", padx=10, pady=5)

        self.dev_mode_var = tk.BooleanVar()
        self.dev_mode_var.set(self.app.settings.get('dev_mode', False))
        ttk.Checkbutton(frame, text="Modo Desenvolvedor (Recursos Ágeis)", variable=self.dev_mode_var).pack(anchor="w", padx=10, pady=5)

        self.git_integration_enabled_var = tk.BooleanVar()
        self.git_integration_enabled_var.set(self.app.settings.get('git_integration_enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integração Git (Modo Dev)", variable=self.git_integration_enabled_var).pack(anchor="w", padx=10, pady=5)

    def create_quadros_tab(self):
        frame = self.quadros_tab
        frame.grid_columnconfigure(1, weight=1)
        frame.grid_rowconfigure(2, weight=1)

        self.unify_subjects_var = tk.BooleanVar()
        self.unify_subjects_var.set(self.app.settings.get('unify_subjects', False))
        ttk.Checkbutton(frame, text="Unificar Assuntos (Boodesk e Pomodoro)", variable=self.unify_subjects_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)

        self.show_card_details_on_board_var = tk.BooleanVar()
        self.show_card_details_on_board_var.set(self.app.settings.get('show_card_details_on_board', False))
        ttk.Checkbutton(frame, text="Mostrar Detalhes do Cartão no Quadro (Responsável, Criação)", variable=self.show_card_details_on_board_var).grid(row=1, column=0, columnspan=2, sticky="w", padx=10, pady=5)

        # Importance Levels Management
        importance_frame = ttk.LabelFrame(frame, text="Gerenciar Níveis de Importância", padding=10)
        importance_frame.grid(row=2, column=0, columnspan=3, sticky="nsew", padx=10, pady=(15, 5))
        importance_frame.grid_columnconfigure(0, weight=1)

        self.importance_tree = ttk.Treeview(importance_frame, columns=("Nome", "Cor"), show="headings")
        self.importance_tree.heading("Nome", text="Nome")
        self.importance_tree.heading("Cor", text="Cor")
        self.importance_tree.column("Nome", width=150, anchor="w")
        self.importance_tree.column("Cor", width=100, anchor="center")
        self.importance_tree.pack(fill="both", expand=True, pady=5)
        self.importance_tree.bind("<Double-1>", self._edit_importance_color) # Double click to edit color

        importance_buttons_frame = ttk.Frame(importance_frame)
        importance_buttons_frame.pack(fill="x", pady=5)

        ttk.Button(importance_buttons_frame, text="Adicionar Nível", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_importance_level).pack(side="left", padx=5)
        ttk.Button(importance_buttons_frame, text="➖ Remover Nível", command=self._remove_importance_level).pack(side="left", padx=5)

        self._populate_importance_treeview()

    def create_dashboard_tab(self):
        """Cria a aba de configurações do dashboard"""
        frame = self.dashboard_tab
        frame.grid_columnconfigure(0, weight=1)
        
        # Widget settings
        widget_frame = ttk.LabelFrame(frame, text="Widgets do Dashboard", padding=10)
        widget_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Dashboard widget checkboxes
        self.dashboard_widget_vars = {}
        widget_settings = self.app.settings.get('dashboard_widgets', {})
        
        widgets = [
            ('overview', 'Visão Geral'),
            ('urgent_tasks', 'Tarefas Urgentes'),
            ('upcoming_deadlines', 'Próximos Prazos'),
            ('recent_activities', 'Atividades Recentes'),
            ('quick_links', 'Links Frequentes'),
            ('quick_actions', 'Ações Rápidas'),
            ('meeting_widget', 'Widget de Reuniões')
        ]
        
        for i, (widget_key, widget_name) in enumerate(widgets):
            if widget_key == 'meeting_widget':
                var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['show_widget'])
            else:
                var = tk.BooleanVar(value=widget_settings.get(widget_key, True))
            self.dashboard_widget_vars[widget_key] = var
            ttk.Checkbutton(widget_frame, text=widget_name, variable=var).pack(anchor=tk.W, pady=2)
        
        # Preview button
        ttk.Button(frame, text="Visualizar Dashboard", 
                  command=self.preview_dashboard_settings).pack(pady=10)

    def create_calendar_tab(self):
        """Cria a aba de configurações de calendário"""
        frame = self.calendar_tab
        frame.grid_columnconfigure(1, weight=1)
        
        calendar_settings = self.app.settings.get('calendar_integration', {})
        
        # Enable calendar integration
        self.calendar_enabled_var = tk.BooleanVar(value=calendar_settings.get('enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integração com Google Calendar", 
                       variable=self.calendar_enabled_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)
        
        # Tipo de autenticação
        ttk.Label(frame, text="Tipo de Autenticação:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        auth_frame = ttk.Frame(frame)
        auth_frame.grid(row=1, column=1, sticky="w", padx=10, pady=5)
        
        self.auth_type_var = tk.StringVar(value=calendar_settings.get('auth_type', 'json'))
        print(f"DEBUG: auth_type_var inicializado com: {self.auth_type_var.get()}")
        
        json_radio = ttk.Radiobutton(auth_frame, text="Arquivo JSON", 
                       variable=self.auth_type_var, value="json", 
                       command=self.toggle_auth_methods)
        json_radio.pack(side=tk.LEFT, padx=5)
        print("DEBUG: Radio button JSON criado")
        
        key_radio = ttk.Radiobutton(auth_frame, text="ID e Chave Privada", 
                       variable=self.auth_type_var, value="key", 
                       command=self.toggle_auth_methods)
        key_radio.pack(side=tk.LEFT, padx=5)
        print("DEBUG: Radio button ID/Chave criado")
        
        # Frame para arquivo JSON
        self.json_frame = ttk.LabelFrame(frame, text="Arquivo JSON de Credenciais", padding=10)
        self.json_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        self.json_frame.columnconfigure(1, weight=1)
        
        ttk.Label(self.json_frame, text="Arquivo:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        json_credentials_frame = ttk.Frame(self.json_frame)
        json_credentials_frame.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        json_credentials_frame.columnconfigure(0, weight=1)
        
        self.credentials_file_var = tk.StringVar(value=calendar_settings.get('credentials_file', ''))
        self.credentials_entry = ttk.Entry(json_credentials_frame, textvariable=self.credentials_file_var, width=50)
        self.credentials_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        ttk.Button(json_credentials_frame, text="Procurar", 
                  command=self.browse_credentials_file).grid(row=0, column=1)
        
        # Frame para ID e chave privada
        self.key_frame = ttk.LabelFrame(frame, text="ID e Chave Privada", padding=10)
        self.key_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        self.key_frame.columnconfigure(1, weight=1)
        
        ttk.Label(self.key_frame, text="Client ID:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.client_id_var = tk.StringVar(value=calendar_settings.get('client_id', ''))
        self.client_id_entry = ttk.Entry(self.key_frame, textvariable=self.client_id_var, width=50)
        self.client_id_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.key_frame, text="Client Secret:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.client_secret_var = tk.StringVar(value=calendar_settings.get('client_secret', ''))
        self.client_secret_entry = ttk.Entry(self.key_frame, textvariable=self.client_secret_var, width=50, show="*")
        self.client_secret_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        
        # Botão para mostrar/ocultar senha
        self.show_secret_var = tk.BooleanVar()
        ttk.Checkbutton(self.key_frame, text="Mostrar chave", 
                       variable=self.show_secret_var, 
                       command=self.toggle_secret_visibility).grid(row=1, column=2, padx=5, pady=2)
        
        # Instruções
        instructions_frame = ttk.LabelFrame(frame, text="Instruções Para configurar o Google Calendar:", padding=10)
        instructions_frame.grid(row=4, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        instructions = [
            "1. Acesse https://console.developers.google.com/",
            "2. Crie um novo projeto ou selecione um existente",
            "3. Ative a Google Calendar API",
            "4. Crie credenciais OAuth 2.0",
            "5. Baixe o arquivo JSON OU copie o Client ID e Secret",
            "6. Configure acima usando JSON ou ID/Chave"
        ]
        
        for instruction in instructions:
            ttk.Label(instructions_frame, text=instruction).pack(anchor="w", pady=1)
        
        # Sincronização automática
        sync_frame = ttk.LabelFrame(frame, text="Sincronização Automática", padding=10)
        sync_frame.grid(row=5, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        self.sync_auto_var = tk.BooleanVar(value=calendar_settings.get('sync_auto', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar automaticamente", 
                       variable=self.sync_auto_var).pack(anchor=tk.W, pady=2)
        
        self.sync_cards_deadline_var = tk.BooleanVar(value=calendar_settings.get('sync_cards_deadline', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar cartões com prazo", 
                       variable=self.sync_cards_deadline_var).pack(anchor=tk.W, pady=2)
        
        self.sync_calendar_events_var = tk.BooleanVar(value=calendar_settings.get('sync_calendar_events', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar eventos do calendário", 
                       variable=self.sync_calendar_events_var).pack(anchor=tk.W, pady=2)
        
        # Botões de validação e teste
        test_frame = ttk.LabelFrame(frame, text="Validação e Teste", padding=10)
        test_frame.grid(row=6, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        test_buttons_frame = ttk.Frame(test_frame)
        test_buttons_frame.pack(fill=tk.X)
        
        ttk.Button(test_buttons_frame, text="🔍 Validar Credenciais", 
                  command=self.validate_credentials).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(test_buttons_frame, text="🔄 Testar Conexão", 
                  command=self.test_calendar_connection).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(test_buttons_frame, text="📂 Configurar Credenciais", 
                  command=self.open_credentials_config).pack(side=tk.LEFT, padx=5)
        
        # Status da validação
        self.validation_status_var = tk.StringVar(value="Status: Não verificado")
        ttk.Label(test_frame, textvariable=self.validation_status_var, 
                 font=("Arial", 9)).pack(anchor="w", pady=(10, 0))
        
        # Configurar navegação com Enter
        self.setup_enter_navigation()
        
        # Inicializar visibilidade dos métodos de autenticação
        print("DEBUG: Inicializando visibilidade dos métodos de autenticação")
        self.toggle_auth_methods()
        print("DEBUG: Aba de calendário criada com sucesso")
        print("🎯 OPÇÃO 'ID E CHAVE PRIVADA' DEVE APARECER NA ABA CALENDÁRIO!")
    
    def setup_enter_navigation(self):
        """Configura navegação com Enter entre campos"""
        # Configurar Enter para navegar entre campos
        self.credentials_entry.bind('<Return>', lambda e: self.client_id_entry.focus())
        self.client_id_entry.bind('<Return>', lambda e: self.client_secret_entry.focus())
        self.client_secret_entry.bind('<Return>', lambda e: self.credentials_entry.focus())
    
    def toggle_auth_methods(self):
        """Alterna entre métodos de autenticação"""
        print(f"DEBUG: toggle_auth_methods chamado - auth_type: {self.auth_type_var.get()}")
        if self.auth_type_var.get() == 'json':
            print("DEBUG: Mostrando frame JSON, ocultando frame Key")
            self.json_frame.grid()
            self.key_frame.grid_remove()
        else:
            print("DEBUG: Mostrando frame Key, ocultando frame JSON")
            self.json_frame.grid_remove()
            self.key_frame.grid()
    
    def toggle_secret_visibility(self):
        """Alterna visibilidade da chave privada"""
        if self.show_secret_var.get():
            self.client_secret_entry.config(show="")
        else:
            self.client_secret_entry.config(show="*")
    
    def browse_credentials_file(self):
        """Abre diálogo para selecionar arquivo de credenciais"""
        from tkinter import filedialog
        file_path = filedialog.askopenfilename(
            title="Selecionar arquivo de credenciais do Google Calendar",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if file_path:
            self.credentials_file_var.set(file_path)
    
    def validate_credentials(self):
        """Valida as credenciais (JSON ou ID/Chave)"""
        auth_type = self.auth_type_var.get()
        
        if auth_type == 'json':
            self.validate_json_credentials()
        else:
            self.validate_key_credentials()
    
    def validate_json_credentials(self):
        """Valida o arquivo de credenciais JSON"""
        import json
        import os
        
        file_path = self.credentials_file_var.get()
        
        if not file_path:
            self.validation_status_var.set("Status: ❌ Nenhum arquivo selecionado")
            return
        
        if not os.path.exists(file_path):
            self.validation_status_var.set("Status: ❌ Arquivo não encontrado")
            return
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            if 'installed' in data:
                client_info = data['installed']
                project_id = client_info.get('project_id', 'N/A')
                client_id = client_info.get('client_id', 'N/A')
                
                self.validation_status_var.set(f"Status: ✅ JSON Válido - Projeto: {project_id}")
                messagebox.showinfo("Validação", 
                                  f"✅ Arquivo de credenciais válido!\n\n"
                                  f"📝 Projeto: {project_id}\n"
                                  f"🆔 Client ID: {client_id[:30]}...\n"
                                  f"📏 Tamanho: {os.path.getsize(file_path)} bytes")
                
            elif 'web' in data:
                client_info = data['web']
                project_id = client_info.get('project_id', 'N/A')
                client_id = client_info.get('client_id', 'N/A')
                
                self.validation_status_var.set(f"Status: ✅ JSON Válido (Web) - Projeto: {project_id}")
                messagebox.showinfo("Validação", 
                                  f"✅ Arquivo de credenciais válido!\n\n"
                                  f"📝 Projeto: {project_id}\n"
                                  f"🆔 Client ID: {client_id[:30]}...\n"
                                  f"📏 Tamanho: {os.path.getsize(file_path)} bytes")
                
            else:
                self.validation_status_var.set("Status: ❌ Formato inválido")
                messagebox.showerror("Erro", "❌ Arquivo não contém credenciais válidas!\n\nO arquivo deve conter 'installed' ou 'web'")
                
        except json.JSONDecodeError:
            self.validation_status_var.set("Status: ❌ JSON inválido")
            messagebox.showerror("Erro", "❌ Arquivo JSON inválido!")
        except Exception as e:
            self.validation_status_var.set("Status: ❌ Erro ao ler arquivo")
            messagebox.showerror("Erro", f"❌ Erro ao ler arquivo: {e}")
    
    def validate_key_credentials(self):
        """Valida o ID e chave privada"""
        client_id = self.client_id_var.get().strip()
        client_secret = self.client_secret_var.get().strip()
        
        if not client_id:
            self.validation_status_var.set("Status: ❌ Client ID não informado")
            messagebox.showerror("Erro", "❌ Client ID é obrigatório!")
            return
        
        if not client_secret:
            self.validation_status_var.set("Status: ❌ Client Secret não informado")
            messagebox.showerror("Erro", "❌ Client Secret é obrigatório!")
            return
        
        # Validar formato do Client ID
        if not client_id.endswith('.apps.googleusercontent.com'):
            self.validation_status_var.set("Status: ⚠️ Client ID pode estar incorreto")
            messagebox.showwarning("Aviso", "⚠️ Client ID deve terminar com '.apps.googleusercontent.com'")
            return
        
        # Validar formato do Client Secret
        if len(client_secret) < 10:
            self.validation_status_var.set("Status: ⚠️ Client Secret pode estar incorreto")
            messagebox.showwarning("Aviso", "⚠️ Client Secret parece muito curto")
            return
        
        self.validation_status_var.set("Status: ✅ ID e Chave válidos")
        messagebox.showinfo("Validação", 
                          f"✅ Credenciais válidas!\n\n"
                          f"🆔 Client ID: {client_id[:30]}...\n"
                          f"🔐 Client Secret: {client_secret[:10]}...\n"
                          f"📝 Tipo: ID e Chave Privada")
    
    def test_calendar_connection(self):
        """Testa a conexão com Google Calendar"""
        auth_type = self.auth_type_var.get()
        
        if auth_type == 'json':
            self.test_json_connection()
        else:
            self.test_key_connection()
    
    def test_json_connection(self):
        """Testa conexão usando arquivo JSON"""
        try:
            # Verificar se as bibliotecas estão instaladas
            try:
                from google.oauth2.credentials import Credentials
                from google_auth_oauthlib.flow import InstalledAppFlow
                from google.auth.transport.requests import Request
                from googleapiclient.discovery import build
                from googleapiclient.errors import HttpError
                import pickle
            except ImportError as e:
                messagebox.showerror("Erro", 
                                   f"❌ Bibliotecas não instaladas: {e}\n\n"
                                   f"💡 Execute:\n"
                                   f"pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
                return
            
            # Verificar arquivo de credenciais
            file_path = self.credentials_file_var.get()
            if not file_path or not os.path.exists(file_path):
                messagebox.showerror("Erro", "❌ Arquivo de credenciais não encontrado!\n\nSelecione um arquivo válido primeiro.")
                return
            
            # Validar formato do arquivo JSON
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    json_data = json.load(f)
                
                if 'installed' not in json_data:
                    messagebox.showerror("Erro", "❌ Formato de arquivo inválido!\n\nO arquivo deve conter credenciais OAuth 2.0 para aplicação instalada.")
                    return
                    
            except json.JSONDecodeError:
                messagebox.showerror("Erro", "❌ Arquivo JSON inválido!")
                return
            
            # Tentar autenticação
            SCOPES = ['https://www.googleapis.com/auth/calendar']
            
            creds = None
            token_file = os.path.join(self.app.base_dir, 'test_token.pickle')
            
            if os.path.exists(token_file):
                try:
                    with open(token_file, 'rb') as token:
                        creds = pickle.load(token)
                except Exception as e:
                    print(f"Erro ao carregar token de teste: {e}")
                    creds = None
            
            if not creds or not creds.valid:
                if creds and creds.expired and creds.refresh_token:
                    try:
                        creds.refresh(Request())
                    except Exception as e:
                        print(f"Erro ao renovar token: {e}")
                        creds = None
                
                if not creds:
                    try:
                        flow = InstalledAppFlow.from_client_secrets_file(file_path, SCOPES)
                        creds = flow.run_local_server(port=0)
                        
                        # Salvar token de teste
                        with open(token_file, 'wb') as token:
                            pickle.dump(creds, token)
                    except Exception as e:
                        messagebox.showerror("Erro", f"❌ Erro na autenticação OAuth:\n\n{e}")
                        return
            
            # Testar API
            service = build('calendar', 'v3', credentials=creds)
            
            try:
                calendar_list = service.calendarList().list().execute()
                calendars = calendar_list.get('items', [])
                
                if calendars:
                    self.validation_status_var.set("Status: ✅ Conectado (JSON) - Calendários disponíveis")
                    messagebox.showinfo("Sucesso", 
                                      f"🎉 Conexão bem-sucedida!\n\n"
                                      f"📅 Calendários encontrados: {len(calendars)}\n"
                                      f"📝 Primeiro calendário: {calendars[0]['summary']}\n"
                                      f"🔗 Tipo: Arquivo JSON")
                else:
                    self.validation_status_var.set("Status: ⚠️ Conectado (JSON) - Nenhum calendário")
                    messagebox.showwarning("Aviso", "⚠️ Conexão bem-sucedida, mas nenhum calendário encontrado!")
                    
            except HttpError as e:
                error_details = f"Erro {e.resp.status}: {e.content.decode()}"
                self.validation_status_var.set("Status: ❌ Erro de API (JSON)")
                messagebox.showerror("Erro de API", f"❌ Erro na API do Google Calendar:\n\n{error_details}")
                
        except Exception as e:
            self.validation_status_var.set("Status: ❌ Erro de conexão (JSON)")
            messagebox.showerror("Erro de Conexão", f"❌ Erro ao conectar com Google Calendar:\n\n{e}")
    
    def test_key_connection(self):
        """Testa conexão usando ID e chave privada"""
        try:
            # Verificar se as bibliotecas estão instaladas
            try:
                from google.oauth2.credentials import Credentials
                from google_auth_oauthlib.flow import InstalledAppFlow
                from google.auth.transport.requests import Request
                from googleapiclient.discovery import build
                from googleapiclient.errors import HttpError
                import pickle
            except ImportError as e:
                messagebox.showerror("Erro", 
                                   f"❌ Bibliotecas não instaladas: {e}\n\n"
                                   f"💡 Execute:\n"
                                   f"pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
                return
            
            # Verificar credenciais
            client_id = self.client_id_var.get().strip()
            client_secret = self.client_secret_var.get().strip()
            
            if not client_id or not client_secret:
                messagebox.showerror("Erro", "❌ Client ID e Client Secret são obrigatórios!")
                return
            
            # Validar formato do Client ID
            if not client_id.endswith('.apps.googleusercontent.com'):
                messagebox.showwarning("Aviso", "⚠️ Client ID deve terminar com '.apps.googleusercontent.com'")
            
            # Validar formato do Client Secret
            if len(client_secret) < 10:
                messagebox.showwarning("Aviso", "⚠️ Client Secret parece muito curto")
            
            # Criar arquivo temporário de credenciais
            import tempfile
            import json
            
            temp_creds = {
                "installed": {
                    "client_id": client_id,
                    "client_secret": client_secret,
                    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                    "token_uri": "https://oauth2.googleapis.com/token",
                    "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                    "redirect_uris": ["http://localhost"]
                }
            }
            
            # Criar arquivo temporário
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                json.dump(temp_creds, f)
                temp_file = f.name
            
            try:
                # Tentar autenticação
                SCOPES = ['https://www.googleapis.com/auth/calendar']
                
                creds = None
                token_file = os.path.join(self.app.base_dir, 'test_token.pickle')
                
                if os.path.exists(token_file):
                    try:
                        with open(token_file, 'rb') as token:
                            creds = pickle.load(token)
                    except Exception as e:
                        print(f"Erro ao carregar token de teste: {e}")
                        creds = None
                
                if not creds or not creds.valid:
                    if creds and creds.expired and creds.refresh_token:
                        try:
                            creds.refresh(Request())
                        except Exception as e:
                            print(f"Erro ao renovar token: {e}")
                            creds = None
                    
                    if not creds:
                        try:
                            flow = InstalledAppFlow.from_client_secrets_file(temp_file, SCOPES)
                            creds = flow.run_local_server(port=0)
                            
                            # Salvar token de teste
                            with open(token_file, 'wb') as token:
                                pickle.dump(creds, token)
                        except Exception as e:
                            messagebox.showerror("Erro", f"❌ Erro na autenticação OAuth:\n\n{e}")
                            return
                
                # Testar API
                service = build('calendar', 'v3', credentials=creds)
                
                try:
                    calendar_list = service.calendarList().list().execute()
                    calendars = calendar_list.get('items', [])
                    
                    if calendars:
                        self.validation_status_var.set("Status: ✅ Conectado (ID/Chave) - Calendários disponíveis")
                        messagebox.showinfo("Sucesso", 
                                          f"🎉 Conexão bem-sucedida!\n\n"
                                          f"📅 Calendários encontrados: {len(calendars)}\n"
                                          f"📝 Primeiro calendário: {calendars[0]['summary']}\n"
                                          f"🔗 Tipo: ID e Chave Privada")
                    else:
                        self.validation_status_var.set("Status: ⚠️ Conectado (ID/Chave) - Nenhum calendário")
                        messagebox.showwarning("Aviso", "⚠️ Conexão bem-sucedida, mas nenhum calendário encontrado!")
                        
                except HttpError as e:
                    error_details = f"Erro {e.resp.status}: {e.content.decode()}"
                    self.validation_status_var.set("Status: ❌ Erro de API (ID/Chave)")
                    messagebox.showerror("Erro de API", f"❌ Erro na API do Google Calendar:\n\n{error_details}")
                    
            finally:
                # Limpar arquivo temporário
                try:
                    os.unlink(temp_file)
                except:
                    pass
                    
        except Exception as e:
            self.validation_status_var.set("Status: ❌ Erro de conexão (ID/Chave)")
            messagebox.showerror("Erro de Conexão", f"❌ Erro ao conectar com Google Calendar:\n\n{e}")
    
    def open_credentials_config(self):
        """Abre o configurador de credenciais"""
        try:
            import subprocess
            import sys
            
            # Tentar executar o configurador
            subprocess.Popen([sys.executable, "config_google_calendar.py"])
            
        except Exception as e:
            messagebox.showerror("Erro", 
                               f"❌ Erro ao abrir configurador: {e}\n\n"
                               f"💡 Execute manualmente:\n"
                               f"python config_google_calendar.py")

    def create_email_tab(self):
        """Cria a aba de configurações de email"""
        frame = self.email_tab
        frame.grid_columnconfigure(1, weight=1)
        
        email_settings = self.app.settings.get('email_integration', {})
        
        # Enable email integration
        self.email_enabled_var = tk.BooleanVar(value=email_settings.get('enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integração de Email", 
                       variable=self.email_enabled_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)
        
        # Provider selection
        ttk.Label(frame, text="Provedor:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        self.email_provider_var = tk.StringVar(value=email_settings.get('provider', 'gmail'))
        provider_frame = ttk.Frame(frame)
        provider_frame.grid(row=1, column=1, sticky="w", padx=10, pady=5)
        
        ttk.Radiobutton(provider_frame, text="Gmail", 
                       variable=self.email_provider_var, value="gmail").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(provider_frame, text="Outlook", 
                       variable=self.email_provider_var, value="outlook").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(provider_frame, text="SMTP Personalizado", 
                       variable=self.email_provider_var, value="smtp").pack(side=tk.LEFT, padx=5)
        
        # Email credentials
        ttk.Label(frame, text="Email:").grid(row=2, column=0, sticky="w", padx=10, pady=5)
        self.email_address_entry = ttk.Entry(frame, width=50)
        self.email_address_entry.grid(row=2, column=1, sticky="ew", padx=10, pady=5)
        self.email_address_entry.insert(0, email_settings.get('email_address', ''))
        
        ttk.Label(frame, text="Senha:").grid(row=3, column=0, sticky="w", padx=10, pady=5)
        self.email_password_entry = ttk.Entry(frame, width=50, show="*")
        self.email_password_entry.grid(row=3, column=1, sticky="ew", padx=10, pady=5)
        self.email_password_entry.insert(0, email_settings.get('email_password', ''))
        
        ttk.Label(frame, text="Senha do App (Gmail):").grid(row=4, column=0, sticky="w", padx=10, pady=5)
        self.app_password_entry = ttk.Entry(frame, width=50, show="*")
        self.app_password_entry.grid(row=4, column=1, sticky="ew", padx=10, pady=5)
        self.app_password_entry.insert(0, email_settings.get('app_password', ''))
        
        # SMTP settings
        ttk.Label(frame, text="Servidor SMTP:").grid(row=5, column=0, sticky="w", padx=10, pady=5)
        self.smtp_server_entry = ttk.Entry(frame, width=50)
        self.smtp_server_entry.grid(row=5, column=1, sticky="ew", padx=10, pady=5)
        self.smtp_server_entry.insert(0, email_settings.get('smtp_server', 'smtp.gmail.com'))
        
        ttk.Label(frame, text="Porta SMTP:").grid(row=6, column=0, sticky="w", padx=10, pady=5)
        self.smtp_port_entry = ttk.Entry(frame, width=50)
        self.smtp_port_entry.grid(row=6, column=1, sticky="ew", padx=10, pady=5)
        self.smtp_port_entry.insert(0, str(email_settings.get('smtp_port', 587)))
        
        # Auto notifications
        notif_frame = ttk.LabelFrame(frame, text="Notificações Automáticas", padding=10)
        notif_frame.grid(row=7, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        auto_notifications = email_settings.get('auto_notifications', {})
        
        self.notify_card_created_var = tk.BooleanVar(value=auto_notifications.get('card_created', True))
        ttk.Checkbutton(notif_frame, text="Cartão Criado", 
                       variable=self.notify_card_created_var).pack(anchor=tk.W, pady=2)
        
        self.notify_card_modified_var = tk.BooleanVar(value=auto_notifications.get('card_modified', True))
        ttk.Checkbutton(notif_frame, text="Cartão Modificado", 
                       variable=self.notify_card_modified_var).pack(anchor=tk.W, pady=2)
        
        self.notify_card_moved_var = tk.BooleanVar(value=auto_notifications.get('card_moved', True))
        ttk.Checkbutton(notif_frame, text="Cartão Movido", 
                       variable=self.notify_card_moved_var).pack(anchor=tk.W, pady=2)
        
        self.notify_deadline_reminder_var = tk.BooleanVar(value=auto_notifications.get('deadline_reminder', True))
        ttk.Checkbutton(notif_frame, text="Lembrete de Prazo", 
                       variable=self.notify_deadline_reminder_var).pack(anchor=tk.W, pady=2)
        
        self.notify_weekly_report_var = tk.BooleanVar(value=auto_notifications.get('weekly_report', True))
        ttk.Checkbutton(notif_frame, text="Relatório Semanal", 
                       variable=self.notify_weekly_report_var).pack(anchor=tk.W, pady=2)
        
        # Recipients
        ttk.Label(frame, text="Destinatários (separados por vírgula):").grid(row=8, column=0, sticky="w", padx=10, pady=5)
        self.recipients_entry = ttk.Entry(frame, width=50)
        self.recipients_entry.grid(row=8, column=1, sticky="ew", padx=10, pady=5)
        recipients = email_settings.get('notification_recipients', [])
        self.recipients_entry.insert(0, ', '.join(recipients))
        
        # Reminder settings
        reminder_frame = ttk.LabelFrame(frame, text="Configurações de Lembrete", padding=10)
        reminder_frame.grid(row=9, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        ttk.Label(reminder_frame, text="Horas antes do prazo:").pack(anchor=tk.W, pady=2)
        self.reminder_hours_var = tk.StringVar(value=str(email_settings.get('deadline_reminder_hours', 24)))
        reminder_hours_spinbox = ttk.Spinbox(reminder_frame, from_=1, to=168, textvariable=self.reminder_hours_var, width=10)
        reminder_hours_spinbox.pack(anchor=tk.W, pady=2)
        
        # Weekly report settings
        report_frame = ttk.LabelFrame(frame, text="Relatório Semanal", padding=10)
        report_frame.grid(row=10, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        ttk.Label(report_frame, text="Dia da semana:").pack(anchor=tk.W, pady=2)

    def create_calendar_tab(self):
        """Cria a aba de configurações do Google Calendar"""
        frame = self.calendar_tab
        frame.grid_columnconfigure(1, weight=1)
        
        calendar_settings = self.app.settings.get('google_calendar', {})
        
        # Enable Google Calendar integration
        self.calendar_enabled_var = tk.BooleanVar(value=calendar_settings.get('enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integração com Google Calendar", 
                       variable=self.calendar_enabled_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)
        
        # Credentials file
        ttk.Label(frame, text="Arquivo de Credenciais:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        self.credentials_file_var = tk.StringVar(value=calendar_settings.get('credentials_file', ''))
        credentials_frame = ttk.Frame(frame)
        credentials_frame.grid(row=1, column=1, sticky="ew", padx=10, pady=5)
        
        self.credentials_entry = ttk.Entry(credentials_frame, textvariable=self.credentials_file_var, width=40)
        self.credentials_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(credentials_frame, text="Procurar", command=self.browse_credentials_file).pack(side=tk.RIGHT, padx=(5, 0))
        
        # Instructions
        instructions_frame = ttk.LabelFrame(frame, text="Instruções", padding=10)
        instructions_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        instructions_text = """
Para configurar o Google Calendar:

1. Acesse https://console.developers.google.com/
2. Crie um novo projeto ou selecione um existente
3. Ative a Google Calendar API
4. Crie credenciais OAuth 2.0
5. Baixe o arquivo JSON de credenciais
6. Selecione o arquivo acima
        """.strip()
        
        ttk.Label(instructions_frame, text=instructions_text, justify=tk.LEFT).pack(anchor=tk.W)
        
        # Auto sync settings
        sync_frame = ttk.LabelFrame(frame, text="Sincronização Automática", padding=10)
        sync_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        self.auto_sync_var = tk.BooleanVar(value=calendar_settings.get('auto_sync', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar automaticamente", 
                       variable=self.auto_sync_var).pack(anchor=tk.W, pady=2)
        
        self.sync_cards_var = tk.BooleanVar(value=calendar_settings.get('sync_cards', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar cartões com prazo", 
                       variable=self.sync_cards_var).pack(anchor=tk.W, pady=2)
        
        self.sync_events_var = tk.BooleanVar(value=calendar_settings.get('sync_events', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar eventos do calendário", 
                       variable=self.sync_events_var).pack(anchor=tk.W, pady=2)
        
        # Email management settings
        email_frame = ttk.LabelFrame(frame, text="Gerenciamento de Emails", padding=10)
        email_frame.grid(row=4, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        # Add default emails
        ttk.Label(email_frame, text="Emails Padrão (um por linha):").pack(anchor=tk.W, pady=(0, 5))
        
        email_text_frame = ttk.Frame(email_frame)
        email_text_frame.pack(fill=tk.X, pady=(0, 5))
        
        self.default_emails_text = tk.Text(email_text_frame, height=4, width=50)
        email_scrollbar = ttk.Scrollbar(email_text_frame, orient="vertical", command=self.default_emails_text.yview)
        self.default_emails_text.configure(yscrollcommand=email_scrollbar.set)
        
        self.default_emails_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        email_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Load existing emails
        default_emails = calendar_settings.get('default_emails', [])
        self.default_emails_text.insert("1.0", "\n".join(default_emails))
        
        # Email options
        email_options_frame = ttk.Frame(email_frame)
        email_options_frame.pack(fill=tk.X, pady=(5, 0))
        
        self.include_default_emails_var = tk.BooleanVar(value=calendar_settings.get('include_default_emails', True))
        ttk.Checkbutton(email_options_frame, text="Incluir emails padrão em todos os eventos", 
                       variable=self.include_default_emails_var).pack(side=tk.LEFT, padx=(0, 10))
        
        self.include_card_members_var = tk.BooleanVar(value=calendar_settings.get('include_card_members', True))
        ttk.Checkbutton(email_options_frame, text="Incluir membros do card automaticamente", 
                       variable=self.include_card_members_var).pack(side=tk.LEFT)
        
        # Instructions for emails
        email_instructions = ttk.LabelFrame(email_frame, text="Instruções para Emails", padding=5)
        email_instructions.pack(fill=tk.X, pady=(10, 0))
        
        instructions_text = """
* Emails padrão: Serão incluídos em todos os eventos criados
* Membros do card: Serão adicionados automaticamente se tiverem email configurado
* Formato: um email por linha (exemplo@email.com)
* Os emails receberão convites automáticos do Google Calendar
        """.strip()
        
        ttk.Label(email_instructions, text=instructions_text, justify=tk.LEFT, font=("TkDefaultFont", 8)).pack(anchor=tk.W)

    def create_email_templates_tab(self):
        """Cria a aba de gerenciamento de templates de email"""
        frame = self.email_templates_tab
        frame.grid_columnconfigure(1, weight=1)
        frame.grid_rowconfigure(2, weight=1)
        
        # Template selection
        ttk.Label(frame, text="Template:").grid(row=0, column=0, sticky="w", padx=10, pady=5)
        self.template_var = tk.StringVar()
        self.template_combo = ttk.Combobox(frame, textvariable=self.template_var, state="readonly", width=30)
        self.template_combo.grid(row=0, column=1, sticky="w", padx=10, pady=5)
        self.template_combo['values'] = self.app.email_template_manager.get_available_templates()
        self.template_combo.bind("<<ComboboxSelected>>", self.on_template_selected)
        
        # Template actions
        template_actions = ttk.Frame(frame)
        template_actions.grid(row=1, column=0, columnspan=2, sticky="w", padx=10, pady=5)
        
        ttk.Button(template_actions, text="Novo Template", command=self.create_new_template).pack(side=tk.LEFT, padx=2)
        ttk.Button(template_actions, text="Duplicar", command=self.duplicate_template).pack(side=tk.LEFT, padx=2)
        ttk.Button(template_actions, text="Excluir", command=self.delete_template).pack(side=tk.LEFT, padx=2)
        
        # Template editor
        editor_frame = ttk.LabelFrame(frame, text="Editor de Template", padding=10)
        editor_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", padx=10, pady=10)
        editor_frame.grid_columnconfigure(0, weight=1)
        editor_frame.grid_rowconfigure(1, weight=1)
        
        # Subject
        ttk.Label(editor_frame, text="Assunto:").grid(row=0, column=0, sticky="w", pady=(0, 5))
        self.subject_var = tk.StringVar()
        self.subject_entry = ttk.Entry(editor_frame, textvariable=self.subject_var, width=60)
        self.subject_entry.grid(row=0, column=1, sticky="ew", pady=(0, 5), padx=(10, 0))
        
        # Body
        ttk.Label(editor_frame, text="Corpo do Email:").grid(row=1, column=0, sticky="nw", pady=(0, 5))
        body_frame = ttk.Frame(editor_frame)
        body_frame.grid(row=1, column=1, sticky="nsew", padx=(10, 0))
        body_frame.grid_columnconfigure(0, weight=1)
        body_frame.grid_rowconfigure(0, weight=1)
        
        self.body_text = tk.Text(body_frame, height=15, width=60)
        body_scrollbar = ttk.Scrollbar(body_frame, orient="vertical", command=self.body_text.yview)
        self.body_text.configure(yscrollcommand=body_scrollbar.set)
        
        self.body_text.grid(row=0, column=0, sticky="nsew")
        body_scrollbar.grid(row=0, column=1, sticky="ns")
        
        # Variables help
        variables_frame = ttk.LabelFrame(frame, text="Variáveis Disponíveis", padding=10)
        variables_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        variables_text = """
Variáveis que podem ser usadas nos templates:
{card_title} - Título do cartão
{board_name} - Nome do quadro
{list_name} - Nome da lista
{card_description} - Descrição do cartão
{due_date} - Data de vencimento
{importance} - Nível de importância
{member_name} - Nome do membro
{changes} - Lista de alterações
{week_period} - Período do relatório
{completed_tasks} - Tarefas concluídas
{pending_tasks} - Tarefas pendentes
{total_pomodoro_time} - Tempo total de pomodoro
{productivity_score} - Score de produtividade
{important_completed_tasks} - Tarefas importantes concluídas
{upcoming_deadlines} - Próximos prazos
        """.strip()
        
        ttk.Label(variables_frame, text=variables_text, justify=tk.LEFT, font=("TkDefaultFont", 9)).pack(anchor=tk.W)
        
        # Save button
        save_frame = ttk.Frame(frame)
        save_frame.grid(row=4, column=0, columnspan=2, pady=10)
        
        ttk.Button(save_frame, text="Salvar Template", command=self.save_template).pack(side=tk.LEFT, padx=5)
        ttk.Button(save_frame, text="Testar Template", command=self.test_template).pack(side=tk.LEFT, padx=5)
        ttk.Button(save_frame, text="Restaurar Padrão", command=self.restore_default_template).pack(side=tk.LEFT, padx=5)

    def browse_credentials_file(self):
        """Abre diálogo para selecionar arquivo de credenciais"""
        from tkinter import filedialog
        filename = filedialog.askopenfilename(
            title="Selecionar arquivo de credenciais",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if filename:
            self.credentials_file_var.set(filename)

    def on_template_selected(self, event=None):
        """Chamado quando um template é selecionado"""
        template_name = self.template_var.get()
        if template_name:
            template = self.app.email_template_manager.get_template(template_name)
            if template:
                self.subject_var.set(template.get('subject', ''))
                self.body_text.delete("1.0", tk.END)
                self.body_text.insert("1.0", template.get('body', ''))

    def create_new_template(self):
        """Cria um novo template"""
        template_name = simpledialog.askstring("Novo Template", "Nome do template:")
        if template_name:
            if template_name in self.app.email_template_manager.get_available_templates():
                messagebox.showwarning("Aviso", "Template com este nome já existe!")
                return
            
            # Adicionar ao combo
            current_values = list(self.template_combo['values'])
            current_values.append(template_name)
            self.template_combo['values'] = current_values
            self.template_combo.set(template_name)
            
            # Limpar campos
            self.subject_var.set("")
            self.body_text.delete("1.0", tk.END)
            
            # Focar no campo de assunto
            self.subject_entry.focus()

    def duplicate_template(self):
        """Duplica o template selecionado"""
        current_template = self.template_var.get()
        if not current_template:
            messagebox.showwarning("Aviso", "Selecione um template para duplicar!")
            return
        
        new_name = simpledialog.askstring("Duplicar Template", f"Nome do novo template (baseado em {current_template}):")
        if new_name:
            if new_name in self.app.email_template_manager.get_available_templates():
                messagebox.showwarning("Aviso", "Template com este nome já existe!")
                return
            
            # Copiar template
            original_template = self.app.email_template_manager.get_template(current_template)
            self.app.email_template_manager.update_template(
                new_name, 
                original_template.get('subject', ''),
                original_template.get('body', '')
            )
            
            # Atualizar combo
            current_values = list(self.template_combo['values'])
            current_values.append(new_name)
            self.template_combo['values'] = current_values
            self.template_combo.set(new_name)

    def delete_template(self):
        """Exclui o template selecionado"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para excluir!")
            return
        
        if messagebox.askyesno("Confirmar", f"Tem certeza que deseja excluir o template '{template_name}'?"):
            # Remover template
            templates = self.app.email_template_manager.templates
            if template_name in templates:
                del templates[template_name]
                self.app.email_template_manager.save_templates()
            
            # Atualizar combo
            current_values = list(self.template_combo['values'])
            current_values.remove(template_name)
            self.template_combo['values'] = current_values
            self.template_combo.set("")
            
            # Limpar campos
            self.subject_var.set("")
            self.body_text.delete("1.0", tk.END)

    def save_template(self):
        """Salva o template atual"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para salvar!")
            return
        
        subject = self.subject_var.get().strip()
        body = self.body_text.get("1.0", tk.END).strip()
        
        if not subject:
            messagebox.showwarning("Aviso", "O assunto é obrigatório!")
            return
        
        # Salvar template
        self.app.email_template_manager.update_template(template_name, subject, body)
        messagebox.showinfo("Sucesso", "Template salvo com sucesso!")

    def test_template(self):
        """Testa o template atual com dados de exemplo"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para testar!")
            return
        
        # Dados de exemplo
        test_variables = {
            'card_title': 'Tarefa de Exemplo',
            'board_name': 'Quadro de Teste',
            'list_name': 'Em Progresso',
            'card_description': 'Esta é uma descrição de exemplo',
            'due_date': '2024-01-15',
            'importance': 'Alta',
            'member_name': 'João Silva',
            'changes': '- Título alterado\n- Prazo atualizado',
            'week_period': '01/01/2024 - 07/01/2024',
            'completed_tasks': '5',
            'pending_tasks': '3',
            'total_pomodoro_time': '12h 30m',
            'productivity_score': '85',
            'important_completed_tasks': '- Tarefa importante 1\n- Tarefa importante 2',
            'upcoming_deadlines': '- Reunião de equipe (15/01)\n- Relatório mensal (20/01)'
        }
        
        # Formatar template
        subject, body = self.app.email_template_manager.format_template(template_name, test_variables)
        
        # Mostrar preview
        preview_window = tk.Toplevel(self)
        preview_window.title("Preview do Template")
        preview_window.geometry("600x500")
        preview_window.transient(self)
        preview_window.grab_set()
        
        # Assunto
        ttk.Label(preview_window, text="Assunto:", font=("TkDefaultFont", 10, "bold")).pack(anchor="w", padx=10, pady=(10, 5))
        subject_text = tk.Text(preview_window, height=2, width=70)
        subject_text.pack(fill=tk.X, padx=10, pady=(0, 10))
        subject_text.insert("1.0", subject)
        subject_text.config(state="disabled")
        
        # Corpo
        ttk.Label(preview_window, text="Corpo:", font=("TkDefaultFont", 10, "bold")).pack(anchor="w", padx=10, pady=(10, 5))
        body_text = tk.Text(preview_window, height=20, width=70)
        body_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
        body_text.insert("1.0", body)
        body_text.config(state="disabled")
        
        # Botão fechar
        ttk.Button(preview_window, text="Fechar", command=preview_window.destroy).pack(pady=10)

    def restore_default_template(self):
        """Restaura o template padrão"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para restaurar!")
            return
        
        if messagebox.askyesno("Confirmar", f"Tem certeza que deseja restaurar o template '{template_name}' para o padrão?"):
            # Recarregar templates padrão
            self.app.email_template_manager.load_templates()
            
            # Atualizar campos
            self.on_template_selected()
            
            messagebox.showinfo("Sucesso", "Template restaurado para o padrão!")

    def toggle_config_frames(self):
        self.report_day_var = tk.StringVar(value=email_settings.get('weekly_report_day', 'monday'))
        report_day_combo = ttk.Combobox(report_frame, textvariable=self.report_day_var, 
                                       values=['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
                                       state="readonly")
        report_day_combo.pack(anchor=tk.W, pady=2)
        
        ttk.Label(report_frame, text="Horário (HH:MM):").pack(anchor=tk.W, pady=2)
        self.report_time_var = tk.StringVar(value=email_settings.get('weekly_report_time', '09:00'))
        report_time_entry = ttk.Entry(report_frame, textvariable=self.report_time_var, width=10)
        report_time_entry.pack(anchor=tk.W, pady=2)
        
        # Test connection button
        ttk.Button(frame, text="Testar Conexão", 
                  command=self.test_email_connection).grid(row=11, column=0, columnspan=2, pady=10)

    def toggle_config_frames(self):
        """Alterna a visibilidade dos frames de configuração"""
        if self.config_type_var.get() == "individual":
            self.individual_frame.grid()
            self.centralized_frame.grid_remove()
        else:
            self.individual_frame.grid_remove()
            self.centralized_frame.grid()

    def preview_dashboard_settings(self):
        """Mostra preview das configurações do dashboard"""
        enabled_widgets = [name for key, var in self.dashboard_widget_vars.items() if var.get()]
        messagebox.showinfo("Preview Dashboard", 
                          f"Widgets habilitados:\n" + "\n".join([f"• {name}" for name in enabled_widgets]))

    # Funções de teste e reautenticação do Google Calendar removidas - integração desabilitada

    def test_email_connection(self):
        """Testa a conexão de email"""
        try:
            # Create temporary email integration for testing
            temp_email = EmailIntegration(self.app)
            temp_email.settings = {
                'enabled': True,
                'provider': self.email_provider_var.get(),
                'email_address': self.email_address_entry.get(),
                'email_password': self.email_password_entry.get(),
                'app_password': self.app_password_entry.get(),
                'smtp_server': self.smtp_server_entry.get(),
                'smtp_port': int(self.smtp_port_entry.get()),
                'demo_mode': True  # Use demo mode for testing
            }
            
            # Test with demo mode
            if temp_email.send_email("test@example.com", "Teste de Conexão", "Este é um teste de conexão."):
                messagebox.showinfo("Teste de Conexão", "Conexão de email testada com sucesso (modo demo)!")
            else:
                messagebox.showerror("Erro de Conexão", "Falha ao testar conexão de email.")
                
        except Exception as e:
            messagebox.showerror("Erro de Conexão", f"Erro ao testar conexão: {e}")

    def create_pomodoro_tab(self):
        frame = self.pomodoro_tab
        frame.grid_columnconfigure(1, weight=1)

        ttk.Label(frame, text="Tempo do Pomodoro (minutos):").grid(row=0, column=0, sticky="w", padx=10, pady=(10, 2))
        self.pomodoro_entry = ttk.Spinbox(frame, from_=1, to=120, increment=1)
        self.pomodoro_entry.grid(row=0, column=1, sticky="ew", padx=10, pady=(10, 2))
        self.pomodoro_entry.set(self.app.settings['pomodoro'])

        ttk.Label(frame, text="Pausa Curta (minutos):").grid(row=1, column=0, sticky="w", padx=10, pady=2)
        self.short_break_entry = ttk.Spinbox(frame, from_=1, to=60, increment=1)
        self.short_break_entry.grid(row=1, column=1, sticky="ew", padx=10, pady=2)
        self.short_break_entry.set(self.app.settings['short_break'])

        ttk.Label(frame, text="Pausa Longa (minutos):").grid(row=2, column=0, sticky="w", padx=10, pady=2)
        self.long_break_entry = ttk.Spinbox(frame, from_=1, to=120, increment=1)
        self.long_break_entry.grid(row=2, column=1, sticky="ew", padx=10, pady=2)
        self.long_break_entry.set(self.app.settings['long_break'])

        ttk.Label(frame, text="Ciclos até a Pausa Longa:").grid(row=3, column=0, sticky="w", padx=10, pady=2)
        self.cycles_entry = ttk.Spinbox(frame, from_=1, to=10, increment=1)
        self.cycles_entry.grid(row=3, column=1, sticky="ew", padx=10, pady=2)
        self.cycles_entry.set(self.app.settings['cycles'])

    def _populate_importance_treeview(self):
        for i in self.importance_tree.get_children():
            self.importance_tree.delete(i)
        for name, color in self.app.settings["importance_colors"].items():
            self.importance_tree.insert("", "end", values=(name, color), tags=(name,))
            self.importance_tree.tag_configure(name, background=color)

    def _add_importance_level(self):
        new_name = simpledialog.askstring("Novo Nível de Importância", "Digite o nome para o novo nível de importância:", parent=self)
        if new_name:
            new_name = new_name.strip()
            if new_name in self.app.settings["importance_colors"]:
                messagebox.showwarning("Nome Duplicado", f"O nível de importância '{new_name}' já existe.", parent=self)
                return
            color_code = colorchooser.askcolor(title=f"Escolha a cor para {new_name}")
            if color_code[1]:
                self.app.settings["importance_colors"][new_name] = color_code[1]
                self._populate_importance_treeview()
            else:
                messagebox.showwarning("Cor Não Selecionada", "Nenhuma cor foi selecionada para o novo nível.", parent=self)

    def _remove_importance_level(self):
        selected_item = self.importance_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um nível de importância para remover.", parent=self)
            return
        
        importance_name = self.importance_tree.item(selected_item, "values")[0]
        
        # Prevent removal of default importance levels
        default_importance_levels = self.app.get_default_settings()["importance_colors"].keys()
        if importance_name in default_importance_levels:
            messagebox.showwarning("Nível Padrão", f"O nível de importância '{importance_name}' é padrão e não pode ser removido.", parent=self)
            return

        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover o nível de importância '{importance_name}'? Isso pode afetar cartões existentes.", parent=self):
            del self.app.settings["importance_colors"][importance_name]
            self._populate_importance_treeview()

    def _edit_importance_color(self, event):
        selected_item = self.importance_tree.selection()
        if not selected_item:
            return
        
        importance_name = self.importance_tree.item(selected_item, "values")[0]
        current_color = self.app.settings["importance_colors"][importance_name]

        color_code = colorchooser.askcolor(title=f"Escolha a nova cor para {importance_name}", initialcolor=current_color)
        if color_code[1]:
            self.app.settings["importance_colors"][importance_name] = color_code[1]
            self._populate_importance_treeview()

    def choose_color(self, importance, color_label):
        # This method is now deprecated but kept for compatibility if needed elsewhere
        color_code = colorchooser.askcolor(title=f"Escolha a cor para {importance}")
        if color_code[1]:
            color_label.config(bg=color_code[1], text=color_code[1])

    def create_roles_tab(self):
        frame = self.roles_tab
        frame.grid_columnconfigure(0, weight=1)
        frame.grid_rowconfigure(0, weight=1)

        roles_frame = ttk.LabelFrame(frame, text="Gerenciar Cargos", padding=10)
        roles_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        roles_frame.grid_columnconfigure(0, weight=1)

        self.roles_tree = ttk.Treeview(roles_frame, columns=("Nome", "Descrição"), show="headings")
        self.roles_tree.heading("Nome", text="Nome")
        self.roles_tree.heading("Descrição", text="Descrição")
        self.roles_tree.column("Nome", width=150, anchor="w")
        self.roles_tree.column("Descrição", width=300, anchor="w")
        self.roles_tree.pack(fill="both", expand=True, pady=5)
        self.roles_tree.bind("<Double-1>", self._edit_role_level) # Double click to edit

        roles_buttons_frame = ttk.Frame(roles_frame)
        roles_buttons_frame.pack(fill="x", pady=5)

        ttk.Button(roles_buttons_frame, text="Adicionar Cargo", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_role_level).pack(side="left", padx=5)
        ttk.Button(roles_buttons_frame, text="Remover Cargo", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_role_level).pack(side="left", padx=5)

        self.app.load_settings() # Ensure settings are up-to-date
        self._populate_roles_treeview()

    def _populate_roles_treeview(self):
        for i in self.roles_tree.get_children():
            self.roles_tree.delete(i)
        for name, desc in self.app.settings["roles"].items():
            self.roles_tree.insert("", "end", values=(name, desc), tags=(name,))

    def _add_role_level(self):
        new_name = simpledialog.askstring("Novo Cargo", "Digite o nome para o novo cargo:", parent=self)
        if new_name:
            new_name = new_name.strip()
            if new_name in self.app.settings["roles"]:
                messagebox.showwarning("Nome Duplicado", f"O cargo '{new_name}' já existe.", parent=self)
                return
            new_desc = simpledialog.askstring("Descrição do Cargo", f"Digite a descrição para o cargo '{new_name}':", parent=self)
            if new_desc is not None:
                self.app.settings["roles"][new_name] = new_desc.strip()
                self.app.save_settings_file()
                self._populate_roles_treeview()
            else:
                messagebox.showwarning("Descrição Necessária", "A descrição do cargo é necessária.", parent=self)

    def _edit_role_level(self, event):
        selected_item = self.roles_tree.selection()
        if not selected_item:
            return
        
        role_name = self.roles_tree.item(selected_item, "values")[0]
        current_desc = self.app.settings["roles"][role_name]

        new_desc = simpledialog.askstring("Editar Cargo", f"Editar descrição para '{role_name}':", initialvalue=current_desc, parent=self)
        if new_desc is not None:
            self.app.settings["roles"][role_name] = new_desc.strip()
            self.app.save_settings_file()
            self._populate_roles_treeview()

    def _remove_role_level(self):
        selected_item = self.roles_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um cargo para remover.", parent=self)
            return
        
        role_name = self.roles_tree.item(selected_item, "values")[0]
        
        # Prevent removal of default roles
        default_roles = self.app.get_default_settings()["roles"].keys()
        if role_name in default_roles:
            messagebox.showwarning("Cargo Padrão", f"O cargo '{role_name}' é padrão e não pode ser removido.", parent=self)
            return

        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover o cargo '{role_name}'?", parent=self):
            del self.app.settings["roles"][role_name]
            self.app.save_settings_file()
            self._populate_roles_treeview()

    def restore_defaults(self):
        if messagebox.askyesno("Restaurar Padrões", "Tem certeza que deseja restaurar todas as configurações para os valores de fábrica?"):
            self.app.settings = self.app.get_default_settings()
            self.app.save_settings_file()
            self.destroy()
            self.app.open_settings()

    def save_settings(self):
        try:
            # Verificar se as variáveis existem antes de acessá-las
            if hasattr(self, 'pomodoro_entry'):
                pomodoro = int(self.pomodoro_entry.get())
                short_break = int(self.short_break_entry.get())
                long_break = int(self.long_break_entry.get())
                cycles = int(self.cycles_entry.get())

                if not all(x > 0 for x in [pomodoro, short_break, long_break, cycles]):
                    raise ValueError("Todos os valores devem ser maiores que zero.")

                self.app.settings['pomodoro'] = pomodoro
                self.app.settings['short_break'] = short_break
                self.app.settings['long_break'] = long_break
                self.app.settings['cycles'] = cycles

            # Configurações gerais
            if hasattr(self, 'theme_combo'):
                self.app.settings['theme'] = self.theme_combo.get()
            if hasattr(self, 'unify_subjects_var'):
                self.app.settings['unify_subjects'] = self.unify_subjects_var.get()
            if hasattr(self, 'show_card_details_on_board_var'):
                self.app.settings['show_card_details_on_board'] = self.show_card_details_on_board_var.get()
            if hasattr(self, 'dev_mode_var'):
                self.app.settings['dev_mode'] = self.dev_mode_var.get()
            if hasattr(self, 'git_integration_enabled_var'):
                self.app.settings['git_integration_enabled'] = self.git_integration_enabled_var.get()

            # Save dashboard widget settings
            if hasattr(self, 'dashboard_widget_vars'):
                dashboard_widgets = {}
                for key, var in self.dashboard_widget_vars.items():
                    if key == 'meeting_widget':
                        # Salvar configuração do widget de reuniões
                        self.app.notification_manager.notification_settings['show_widget'] = var.get()
                        self.app.notification_manager.save_notification_settings()
                    else:
                        dashboard_widgets[key] = var.get()
                
                self.app.settings['dashboard_widgets'] = dashboard_widgets

            # Save Google Calendar settings
            if hasattr(self, 'calendar_enabled_var'):
                calendar_settings = {
                    'enabled': self.calendar_enabled_var.get(),
                    'auth_type': self.auth_type_var.get() if hasattr(self, 'auth_type_var') else 'json',
                    'credentials_file': self.credentials_file_var.get() if hasattr(self, 'credentials_file_var') else '',
                    'client_id': self.client_id_var.get() if hasattr(self, 'client_id_var') else '',
                    'client_secret': self.client_secret_var.get() if hasattr(self, 'client_secret_var') else '',
                    'sync_auto': self.sync_auto_var.get() if hasattr(self, 'sync_auto_var') else True,
                    'sync_cards_deadline': self.sync_cards_deadline_var.get() if hasattr(self, 'sync_cards_deadline_var') else True,
                    'sync_calendar_events': self.sync_calendar_events_var.get() if hasattr(self, 'sync_calendar_events_var') else True
                }
                
                # Validar configurações do Google Calendar antes de salvar
                if calendar_settings['enabled']:
                    if calendar_settings['auth_type'] == 'json':
                        if not calendar_settings['credentials_file'] or not os.path.exists(calendar_settings['credentials_file']):
                            messagebox.showerror("Erro", "❌ Arquivo de credenciais JSON não encontrado!\n\nConfigure um arquivo válido primeiro.")
                            return
                    elif calendar_settings['auth_type'] == 'key':
                        if not calendar_settings['client_id'].strip() or not calendar_settings['client_secret'].strip():
                            messagebox.showerror("Erro", "❌ Client ID e Client Secret são obrigatórios!\n\nConfigure as credenciais primeiro.")
                            return
                    else:
                        messagebox.showerror("Erro", "❌ Tipo de autenticação inválido!")
                        return
                
                self.app.settings['calendar_integration'] = calendar_settings

            # Save Google Calendar email settings
            if hasattr(self, 'default_emails_text'):
                # Get emails from text widget
                emails_text = self.default_emails_text.get("1.0", tk.END).strip()
                default_emails = [email.strip() for email in emails_text.split('\n') if email.strip()]
                
                # Validate email format
                import re
                email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
                valid_emails = []
                invalid_emails = []
                
                for email in default_emails:
                    if email_pattern.match(email):
                        valid_emails.append(email)
                    else:
                        invalid_emails.append(email)
                
                if invalid_emails:
                    messagebox.showwarning("Emails Inválidos", 
                                         f"Os seguintes emails não são válidos e serão ignorados:\n{', '.join(invalid_emails)}")
                
                # Update calendar settings with email configuration
                calendar_settings.update({
                    'default_emails': valid_emails,
                    'include_default_emails': self.include_default_emails_var.get() if hasattr(self, 'include_default_emails_var') else True,
                    'include_card_members': self.include_card_members_var.get() if hasattr(self, 'include_card_members_var') else True
                })
                
                self.app.settings['calendar_integration'] = calendar_settings

            # Save email integration settings
            if hasattr(self, 'email_enabled_var'):
                recipients = [email.strip() for email in self.recipients_entry.get().split(',') if email.strip()]
                self.app.settings['email_integration'] = {
                                    'enabled': self.email_enabled_var.get() if hasattr(self, 'email_enabled_var') else False,
                'provider': self.email_provider_var.get() if hasattr(self, 'email_provider_var') else 'gmail',
                    'email_address': self.email_address_entry.get() if hasattr(self, 'email_address_entry') else '',
                    'email_password': self.email_password_entry.get() if hasattr(self, 'email_password_entry') else '',
                    'app_password': self.app_password_entry.get() if hasattr(self, 'app_password_entry') else '',
                    'smtp_server': self.smtp_server_entry.get() if hasattr(self, 'smtp_server_entry') else 'smtp.gmail.com',
                    'smtp_port': int(self.smtp_port_entry.get()) if hasattr(self, 'smtp_port_entry') else 587,
                                    'auto_notifications': {
                    'card_created': self.notify_card_created_var.get() if hasattr(self, 'notify_card_created_var') else True,
                    'card_modified': self.notify_card_modified_var.get() if hasattr(self, 'notify_card_modified_var') else True,
                    'card_moved': self.notify_card_moved_var.get() if hasattr(self, 'notify_card_moved_var') else True,
                    'deadline_reminder': self.notify_deadline_reminder_var.get() if hasattr(self, 'notify_deadline_reminder_var') else True,
                    'weekly_report': self.notify_weekly_report_var.get() if hasattr(self, 'notify_weekly_report_var') else True
                },
                    'notification_recipients': recipients,
                    'deadline_reminder_hours': int(self.reminder_hours_var.get()) if hasattr(self, 'reminder_hours_var') else 24,
                    'weekly_report_day': self.report_day_var.get() if hasattr(self, 'report_day_var') else 'monday',
                    'weekly_report_time': self.report_time_var.get() if hasattr(self, 'report_time_var') else '09:00'
                }

            # Roles are already updated directly by _add_role_level, _edit_role_level, _remove_role_level
            # No need to iterate self.color_labels anymore

            self.app.save_settings_file()
            
            # Apply dashboard widget settings
            self.app.apply_dashboard_widget_settings()
            self.app.change_theme(self.app.settings['theme'])
            self.app.load_aux_data()
            self.app.update_timer_display()
            
            # Preservar o estado do calendário ANTES de atualizar os quadros
            calendar_state = None
            if hasattr(self.app, 'calendar_widget') and self.app.calendar_widget:
                try:
                    # Capturar estado atual do calendário
                    calendar_state = {
                        'selected_date': self.app.calendar_widget.get_date(),
                        'current_month': datetime.now().strftime("%Y-%m-%d"),  # Usar data atual em vez de calevent_date
                        'events': [],
                        'calendar_width': self.app.calendar_widget.winfo_width(),
                        'calendar_height': self.app.calendar_widget.winfo_height(),
                        'calendar_geometry': self.app.calendar_widget.winfo_geometry()
                    }
                    
                    # Capturar eventos se existirem
                    if hasattr(self.app, 'events_tree') and self.app.events_tree:
                        events = []
                        for item in self.app.events_tree.get_children():
                            values = self.app.events_tree.item(item)['values']
                            events.append(values)
                        calendar_state['events'] = events
                        
                    # Capturar estado do painel de eventos
                    if hasattr(self.app, 'events_tree') and self.app.events_tree:
                        calendar_state['events_tree_width'] = self.app.events_tree.winfo_width()
                        calendar_state['events_tree_height'] = self.app.events_tree.winfo_height()
                        
                except Exception as e:
                    print(f"Erro ao capturar estado do calendário: {e}")
                    calendar_state = None
            
            # Atualizar apenas os quadros sem recriar o calendário
            self.app.populate_boards()
            self.app.update_legend()
            self.app.update_pomodoro_task_list()
            
            # Restaurar o estado do calendário APÓS atualizar os quadros
            if calendar_state and hasattr(self.app, 'calendar_widget') and self.app.calendar_widget:
                try:
                    # Restaurar data selecionada
                    if calendar_state['selected_date']:
                        self.app.calendar_widget.selection_set(calendar_state['selected_date'])
                    
                    # Restaurar tamanho do calendário se necessário
                    if calendar_state.get('calendar_width') and calendar_state.get('calendar_height'):
                        try:
                            # Forçar redimensionamento do calendário
                            self.app.calendar_widget.configure(width=calendar_state['calendar_width'])
                            self.app.calendar_widget.update_idletasks()
                        except:
                            pass
                    
                    # Recarregar eventos do calendário se necessário
                    if hasattr(self.app, 'load_calendar_events'):
                        self.app.load_calendar_events()
                        
                    # Forçar atualização do layout
                    self.app.calendar_widget.update_idletasks()
                    if hasattr(self.app, 'events_tree') and self.app.events_tree:
                        self.app.events_tree.update_idletasks()
                        
                except Exception as e:
                    print(f"Erro ao restaurar estado do calendário: {e}")
            
            self.destroy()
            messagebox.showinfo("Configurações Salvas", "As configurações foram salvas com sucesso!")

        except ValueError as e:
            messagebox.showerror("Erro", f"Por favor, insira valores numéricos válidos e maiores que zero: {e}")

    def toggle_always_on_top(self):
        self.app.root.attributes("-topmost", self.always_on_top_var.get())

# Define CardDetailsWindow as an alias for CardWindow
CardDetailsWindow = CardWindow

class CategoriesManagerWindow:
    def __init__(self, parent, app):
        self.parent = parent
        self.app = app
        self.window = tk.Toplevel(parent)
        self.window.title("Gerenciar Categorias")
        self.window.geometry("600x500")
        self.window.transient(parent)
        self.window.grab_set()
        
        self.create_widgets()
    
    def create_widgets(self):
        """Cria widgets da janela de gerenciamento de categorias"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_label = ttk.Label(main_frame, text="Gerenciar Categorias", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Frame para lista de categorias
        list_frame = ttk.LabelFrame(main_frame, text="Categorias Cadastradas", padding="10")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Treeview para categorias
        columns = ("ID", "Nome", "Cor")
        self.categories_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=10)
        
        self.categories_tree.heading("ID", text="ID")
        self.categories_tree.heading("Nome", text="Nome")
        self.categories_tree.heading("Cor", text="Cor")
        
        self.categories_tree.column("ID", width=50, anchor="center")
        self.categories_tree.column("Nome", width=200, anchor="w")
        self.categories_tree.column("Cor", width=100, anchor="center")
        
        self.categories_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.categories_tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.categories_tree.configure(yscrollcommand=scrollbar.set)
        
        # Frame para adicionar/editar categoria
        edit_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Categoria", padding="10")
        edit_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Grid para campos
        edit_frame.columnconfigure(1, weight=1)
        
        # Nome da categoria
        ttk.Label(edit_frame, text="Nome:").grid(row=0, column=0, sticky="w", padx=(0, 10), pady=5)
        self.name_var = tk.StringVar()
        self.name_entry = ttk.Entry(edit_frame, textvariable=self.name_var, width=30)
        self.name_entry.grid(row=0, column=1, sticky="ew", padx=(0, 10), pady=5)
        
        # Cor da categoria
        ttk.Label(edit_frame, text="Cor:").grid(row=0, column=2, sticky="w", padx=(0, 10), pady=5)
        self.color_var = tk.StringVar(value="#3498db")
        self.color_entry = ttk.Entry(edit_frame, textvariable=self.color_var, width=10)
        self.color_entry.grid(row=0, column=3, sticky="w", padx=(0, 10), pady=5)
        
        # Botão para escolher cor
        self.color_button = tk.Button(edit_frame, text="Escolher", 
                                     command=self.choose_color, bg=self.color_var.get())
        self.color_button.grid(row=0, column=4, padx=(0, 10), pady=5)
        
        # Botões de ação
        button_frame = ttk.Frame(edit_frame)
        button_frame.grid(row=1, column=0, columnspan=5, pady=10)
        
        ttk.Button(button_frame, text="Adicionar", 
                  command=self.add_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Editar", 
                  command=self.edit_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Remover", 
                  command=self.remove_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Limpar", 
                  command=self.clear_form).pack(side=tk.LEFT, padx=5)
        
        # Botões principais
        main_button_frame = ttk.Frame(main_frame)
        main_button_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(main_button_frame, text="Fechar", 
                  command=self.window.destroy).pack(side=tk.RIGHT, padx=5)
        
        # Carregar categorias
        self.load_categories()
        
        # Bind para seleção
        self.categories_tree.bind("<<TreeviewSelect>>", self.on_category_select)
    
    def load_categories(self):
        """Carrega as categorias na treeview"""
        # Limpar treeview
        for item in self.categories_tree.get_children():
            self.categories_tree.delete(item)
        
        # Adicionar categorias
        for category in self.app.categories:
            self.categories_tree.insert("", "end", values=(
                category['id'],
                category['name'],
                category['color']
            ))
    
    def choose_color(self):
        """Abre o seletor de cores"""
        try:
            from tkinter import colorchooser
            color = colorchooser.askcolor(title="Escolher Cor da Categoria")[1]
            if color:
                self.color_var.set(color)
                self.color_button.config(bg=color)
        except ImportError:
            messagebox.showwarning("Aviso", "Seletor de cores não disponível")
    
    def add_category(self):
        """Adiciona uma nova categoria"""
        name = self.name_var.get().strip()
        color = self.color_var.get().strip()
        
        if not name:
            messagebox.showwarning("Aviso", "Nome da categoria é obrigatório!")
            return
        
        if not color:
            messagebox.showwarning("Aviso", "Cor da categoria é obrigatória!")
            return
        
        # Verificar se já existe
        for category in self.app.categories:
            if category['name'].lower() == name.lower():
                messagebox.showwarning("Aviso", f"Categoria '{name}' já existe!")
                return
        
        # Gerar novo ID
        new_id = max([cat['id'] for cat in self.app.categories], default=0) + 1
        
        # Adicionar categoria
        new_category = {
            'id': new_id,
            'name': name,
            'color': color
        }
        
        self.app.categories.append(new_category)
        self.app.save_categories()
        self.load_categories()
        self.clear_form()
        
        messagebox.showinfo("Sucesso", f"Categoria '{name}' adicionada com sucesso!")
    
    def edit_category(self):
        """Edita a categoria selecionada"""
        selected = self.categories_tree.selection()
        if not selected:
            messagebox.showwarning("Aviso", "Selecione uma categoria para editar!")
            return
        
        name = self.name_var.get().strip()
        color = self.color_var.get().strip()
        
        if not name:
            messagebox.showwarning("Aviso", "Nome da categoria é obrigatório!")
            return
        
        if not color:
            messagebox.showwarning("Aviso", "Cor da categoria é obrigatória!")
            return
        
        # Obter categoria selecionada
        item = self.categories_tree.item(selected[0])
        category_id = item['values'][0]
        
        # Verificar se nome já existe (exceto para a categoria atual)
        for category in self.app.categories:
            if category['id'] != category_id and category['name'].lower() == name.lower():
                messagebox.showwarning("Aviso", f"Categoria '{name}' já existe!")
                return
        
        # Atualizar categoria
        for category in self.app.categories:
            if category['id'] == category_id:
                category['name'] = name
                category['color'] = color
                break
        
        self.app.save_categories()
        self.load_categories()
        self.clear_form()
        
        messagebox.showinfo("Sucesso", f"Categoria '{name}' atualizada com sucesso!")
    
    def remove_category(self):
        """Remove a categoria selecionada"""
        selected = self.categories_tree.selection()
        if not selected:
            messagebox.showwarning("Aviso", "Selecione uma categoria para remover!")
            return
        
        item = self.categories_tree.item(selected[0])
        category_id = item['values'][0]
        category_name = item['values'][1]
        
        if messagebox.askyesno("Confirmar", f"Tem certeza que deseja remover a categoria '{category_name}'?"):
            # Remover categoria
            self.app.categories = [cat for cat in self.app.categories if cat['id'] != category_id]
            self.app.save_categories()
            self.load_categories()
            self.clear_form()
            
            messagebox.showinfo("Sucesso", f"Categoria '{category_name}' removida com sucesso!")
    
    def clear_form(self):
        """Limpa o formulário"""
        self.name_var.set("")
        self.color_var.set("#3498db")
        self.color_button.config(bg="#3498db")
        self.categories_tree.selection_remove(*self.categories_tree.selection())
    
    def on_category_select(self, event):
        """Chamado quando uma categoria é selecionada"""
        selected = self.categories_tree.selection()
        if selected:
            item = self.categories_tree.item(selected[0])
            values = item['values']
            
            self.name_var.set(values[1])
            self.color_var.set(values[2])
            self.color_button.config(bg=values[2])

if __name__ == "__main__":
    try:
        # Sistema de controle de concorrência para o banco de dados
        print("🔒 Iniciando controle de concorrência do banco de dados...")
        db_control = DatabaseConcurrencyControl('boodesk_new.db')
        
        # Tentar adquirir lock do banco
        if not db_control.acquire_lock(timeout=30):
            print("❌ Não foi possível adquirir lock do banco de dados")
            print("💡 Verifique se há outras instâncias do app rodando")
            messagebox.showerror("Erro", "Não foi possível acessar o banco de dados.\nVerifique se há outras instâncias do app rodando.")
            sys.exit(1)
        
        print("✅ Lock do banco adquirido com sucesso")
        
        # Determine base_dir for icons
        if getattr(sys, 'frozen', False):
            base_dir = sys._MEIPASS
        else:
            base_dir = os.path.dirname(os.path.abspath(__file__))

        root = ThemedTk(theme="aquativo")
        
        # Configure main window to start maximized
        try:
            root.state('zoomed')  # Maximize the window on Windows
        except:
            try:
                root.attributes('-zoomed', True)  # Alternative for some Linux systems
            except:
                # Fallback: maximize using geometry
                root.update_idletasks()
                screen_width = root.winfo_screenwidth()
                screen_height = root.winfo_screenheight()
                root.geometry(f"{screen_width}x{screen_height}+0+0")
        
        root.resizable(True, True)  # Permitir redimensionamento
        
        # Load icons AFTER the root window is created
        app_icons = load_app_icons(base_dir)

        # Criar aplicação sem usuário inicial
        print("DEBUG: Criando aplicação...")
        app = BoodeskApp(root, None, app_icons)
        root.app = app
        
        # Configurar protocolo de fechamento
        def on_closing_with_lock():
            """Handler de fechamento que libera o lock do banco"""
            try:
                print("🔓 Liberando lock do banco de dados (fechamento)...")
                db_control.release_lock()
            except:
                pass
            app.on_closing()
        
        root.protocol("WM_DELETE_WINDOW", on_closing_with_lock)
        
        print("DEBUG: Aplicação criada com sucesso")
        
        # Configurar sistema de login
        root.login_successful = False
        root.current_user = None
        print("DEBUG: Sistema de login configurado")
        
        # Criar janela de login de forma mais direta
        print("DEBUG: Criando janela de login...")
        
        # Criar uma janela de login simples e robusta
        login_window = tk.Toplevel()
        login_window.title("Login - Sistema Boodesk")
        login_window.geometry("400x300")
        login_window.resizable(False, False)
        
        # Centralizar na tela
        login_window.update_idletasks()
        x = (login_window.winfo_screenwidth() - 400) // 2
        y = (login_window.winfo_screenheight() - 300) // 2
        login_window.geometry(f"400x300+{x}+{y}")
        
        # Forçar exibição
        login_window.lift()
        login_window.focus_force()
        login_window.deiconify()
        login_window.update()
        
        # Ocultar janela principal após criar a janela de login
        root.withdraw()
        print("DEBUG: Janela principal ocultada")
        
        # Criar widgets básicos
        frame = ttk.Frame(login_window, padding="20")
        frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(frame, text="Login - Sistema Boodesk", font=("Arial", 16, "bold")).pack(pady=20)
        ttk.Label(frame, text="Usuário:").pack(pady=5)
        user_entry = ttk.Entry(frame, width=30)
        user_entry.pack(pady=5)
        ttk.Label(frame, text="Senha:").pack(pady=5)
        pass_entry = ttk.Entry(frame, show="*", width=30)
        pass_entry.pack(pady=5)
        
        def do_login():
            username = user_entry.get().strip()
            password = pass_entry.get()
            print(f"DEBUG: Tentativa de login - Usuário: '{username}', Senha: '{password}'")
            
            if username and password:
                # Verificar se o usuário existe no banco de dados
                try:
                    # Usar o banco de dados em vez do arquivo XLSX
                    user_data = app.db.get_user_by_username(username)
                    print(f"DEBUG: Usuário encontrado no banco: {user_data is not None}")
                    
                    if user_data and user_data['password_hash'] == password:
                        # Verificar se o usuário tem membro associado
                        if 'member_id' in user_data and user_data['member_id']:
                            # Criar usuário manualmente
                            user = User(
                                username=user_data['username'],
                                role=user_data['role'],
                                cargo=user_data.get('cargo', 'Usuário') if hasattr(user_data, 'get') else user_data['cargo'],
                                user_id=user_data.get('id', 1) if hasattr(user_data, 'get') else user_data['id']
                            )
                            user.is_authenticated = True
                            user.login_time = pd.Timestamp.now()
                            
                            root.login_successful = True
                            root.current_user = user
                            print(f"DEBUG: Login bem-sucedido para {username}")
                            login_window.destroy()
                        else:
                            print(f"DEBUG: Usuário {username} não tem membro associado")
                            messagebox.showerror("Erro", "Usuário não tem membro associado. Contate o administrador.")
                    else:
                        print(f"DEBUG: Usuário não encontrado ou senha incorreta")
                        messagebox.showerror("Erro", "Usuário ou senha incorretos!")
                except Exception as e:
                    print(f"DEBUG: Erro no login: {e}")
                    messagebox.showerror("Erro", f"Erro no sistema de login: {e}")
            else:
                messagebox.showerror("Erro", "Preencha todos os campos!")
        
        def cancel():
            root.login_successful = False
            login_window.destroy()
        
        ttk.Button(frame, text="Entrar", command=do_login).pack(pady=10)
        ttk.Button(frame, text="Cancelar", command=cancel).pack(pady=5)
        
        # Focar no campo de usuário
        user_entry.focus()
        
        # Forçar exibição novamente após criar widgets
        login_window.after(100, lambda: login_window.lift())
        login_window.after(200, lambda: login_window.focus_force())
        login_window.after(300, lambda: login_window.deiconify())
        
        print("DEBUG: Aguardando fechamento da janela de login...")
        try:
            root.wait_window(login_window)
            print("DEBUG: Janela de login fechada")
        except Exception as e:
            print(f"DEBUG: Erro ao aguardar janela de login: {e}")
            root.destroy()
        
        # Verificar se o login foi bem-sucedido
        print(f"DEBUG: login_successful = {root.login_successful}")
        print(f"DEBUG: current_user = {root.current_user}")
        
        if root.login_successful and root.current_user:
            print("DEBUG: Login bem-sucedido, configurando usuário...")
            # Configurar usuário na aplicação
            app.current_user = root.current_user
            app.apply_role_permissions()
            
            # Adicionar método _get_current_user_member à instância
            def _get_current_user_member(self):
                """Retorna o nome do membro associado ao usuario logado"""
                try:
                    if not self.current_user:
                        return None
                    
                    username = self.current_user.username
                    
                    # Buscar o membro associado ao usuário no banco SQLite
                    import sqlite3
                    conn = sqlite3.connect('boodesk_new.db')
                    cursor = conn.cursor()
                    
                    cursor.execute("SELECT member_id FROM users WHERE username = ?", (username,))
                    result = cursor.fetchone()
                    conn.close()
                    
                    if result and result[0]:
                        member_id = result[0]
                        # Buscar o nome do membro usando o member_id
                        conn = sqlite3.connect('boodesk_new.db')
                        cursor = conn.cursor()
                        cursor.execute("SELECT name FROM members WHERE id = ?", (member_id,))
                        member_result = cursor.fetchone()
                        conn.close()
                        
                        if member_result:
                            member_name = member_result[0]
                            print(f"DEBUG: Usuario {username} associado ao membro {member_name}")
                            return member_name
                    
                    print(f"DEBUG: Usuário {username} não tem membro associado")
                    return None
                    
                except Exception as e:
                    print(f"DEBUG: Erro ao buscar membro do usuário: {e}")
                    return None
            
            # Adicionar o método à instância
            import types
            app._get_current_user_member = types.MethodType(_get_current_user_member, app)
            
            # Inicializar displays após todos os métodos serem definidos
            print("DEBUG: Chamando update_all_displays")
            app.update_all_displays()
            print("DEBUG: update_all_displays concluído")
            
            # Aplicar tema salvo nas configurações
            try:
                saved_theme = app.settings.get('theme', 'aquativo')
                print(f"DEBUG: Aplicando tema: {saved_theme}")
                app.root.set_theme(saved_theme)
                print("DEBUG: Tema aplicado com sucesso")
            except Exception as e:
                print(f"DEBUG: Erro ao aplicar tema: {e}")
            
            # Mostrar/ocultar aba do dashboard baseado no tipo de usuário
            app.show_dashboard_for_admin()
            
            # Mostrar aplicação principal
            print("DEBUG: Mostrando aplicação principal...")
            root.deiconify()
            
            # Maximizar a janela principal
            try:
                root.state('zoomed')  # Windows
                print("DEBUG: Janela maximizada (Windows)")
            except:
                try:
                    root.attributes('-zoomed', True)  # Linux
                    print("DEBUG: Janela maximizada (Linux)")
                except:
                    # Fallback: maximizar usando geometry
                    root.update_idletasks()
                    screen_width = root.winfo_screenwidth()
                    screen_height = root.winfo_screenheight()
                    root.geometry(f"{screen_width}x{screen_height}+0+0")
                    print("DEBUG: Janela maximizada (Fallback)")
            
            # Mostrar notificações APÓS o login
            root.after(1000, app.show_deadline_notifications)
            
            root.mainloop()
        else:
            print("DEBUG: Login cancelado ou falhou, fechando aplicação...")
            # Login cancelado ou falhou
            root.destroy()
        
        # Liberar lock do banco ao sair
        print("🔓 Liberando lock do banco de dados...")
        db_control.release_lock()
            
    except Exception as e:
        import traceback
        error_msg = f"Ocorreu um erro inesperado: {e}\n\nDetalhes técnicos:\n{traceback.format_exc()}"
        print(f"DEBUG: Erro completo: {error_msg}")
        messagebox.showerror("Erro Inesperado", f"Ocorreu um erro inesperado: {e}")
        
        # Liberar lock do banco em caso de erro
        try:
            print("🔓 Liberando lock do banco de dados (erro)...")
            db_control.release_lock()
        except:
            pass
        
        # Tentar fechar a aplicação de forma limpa
        try:
            root.destroy()
        except:
            pass

# ============================================================================
# MELHORIAS IMPLEMENTADAS - SISTEMA DE FILTRO INTELIGENTE E NOTIFICAÇÕES
# ============================================================================

def get_boards_for_member(self, member_name):
    """Retorna apenas os quadros onde o membro participa de cards"""
    boards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards in board_data.items():
            if list_name == 'workflow':  # Ignorar metadados
                continue
            for card in cards:
                if member_name in card.get('members', []):
                    boards.append(board_name)
                    break  # Uma vez encontrado, não precisa verificar mais cards
    return list(set(boards))  # Remove duplicatas

def _should_show_board_for_user_improved(self, board_name, current_user_member):
    """Versão melhorada do filtro de quadros"""
    # Administradores veem todos os quadros
    if hasattr(self, 'current_user') and getattr(self.current_user, 'role', None) == 'admin':
        return True
    
    # Se não há membro associado, mostrar apenas quadros principais
    if not current_user_member:
        return board_name in ["Quadro Principal", "Quadro Geral"]
    
    # Verificar se o membro participa de algum card no quadro
    board_data = self.boodesk_data.get("boards", {}).get(board_name, {})
    if isinstance(board_data, dict):
        for list_name, cards in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards:
                if current_user_member in card.get('members', []):
                    return True
    
    # Quadros especiais sempre visíveis
    if board_name in ["Quadro Principal", "Quadro Geral"]:
        return True
    
    return False

def notify_member_added_to_card(self, card_id, member_name, added_by):
    """Notifica membro quando adicionado a um card"""
    card = self.get_card_by_id(card_id)
    if not card:
        return
    
    notification = {
        'type': 'member_added',
        'card_title': card['title'],
        'card_id': card_id,
        'member': member_name,
        'added_by': added_by,
        'board': card.get('board_name', ''),
        'list': card.get('list_name', ''),
        'timestamp': datetime.now().isoformat(),
        'read': False
    }
    
    # Salvar notificação no banco
    self.save_notification(notification)
    
    # Mostrar notificação na interface
    self.show_notification_popup(notification)

def show_notification_popup(self, notification):
    """Mostra popup de notificação"""
    popup = tk.Toplevel(self.root)
    popup.title("Nova Notificação")
    popup.geometry("400x200")
    
    message = f"Você foi adicionado ao card:\n'{notification['card_title']}'\n\nQuadro: {notification['board']}\nLista: {notification['list']}"
    
    ttk.Label(popup, text=message, wraplength=350).pack(pady=20)
    ttk.Button(popup, text="Ver Card", command=lambda: self.open_card(notification['card_id'])).pack(pady=10)
    ttk.Button(popup, text="Fechar", command=popup.destroy).pack(pady=5)

def save_notification(self, notification):
    """Salva notificação no banco de dados"""
    try:
        conn = sqlite3.connect('boodesk_new.db')
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO notifications (type, card_title, card_id, member, added_by, board, list_name, timestamp, read_status)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            notification['type'],
            notification['card_title'],
            notification['card_id'],
            notification['member'],
            notification['added_by'],
            notification['board'],
            notification['list'],
            notification['timestamp'],
            notification['read']
        ))
        
        conn.commit()
        conn.close()
        print(f"✅ Notificação salva para {notification['member']}")
    except Exception as e:
        print(f"❌ Erro ao salvar notificação: {e}")

def create_member_dashboard(self, member_name):
    """Cria dashboard personalizado para o membro"""
    dashboard = {
        'my_cards': self.get_cards_by_member(member_name),
        'my_boards': self.get_boards_for_member(member_name),
        'pending_tasks': self.get_pending_tasks(member_name),
        'completed_tasks': self.get_completed_tasks(member_name),
        'recent_activities': self.get_recent_activities(member_name),
        'upcoming_deadlines': self.get_upcoming_deadlines(member_name)
    }
    return dashboard

def get_cards_by_member(self, member_name):
    """Retorna todos os cards onde o membro participa"""
    cards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards_list in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards_list:
                if member_name in card.get('members', []):
                    card['board_name'] = board_name
                    card['list_name'] = list_name
                    cards.append(card)
    return cards

def get_pending_tasks(self, member_name):
    """Retorna tarefas pendentes do membro"""
    return [card for card in self.get_cards_by_member(member_name) 
            if card.get('status') != 'done']

def get_completed_tasks(self, member_name, days=30):
    """Retorna tarefas completadas nos últimos X dias"""
    cutoff_date = datetime.now() - timedelta(days=days)
    completed = []
    for card in self.get_cards_by_member(member_name):
        if card.get('status') == 'done':
            completed_date = card.get('completed_at')
            if completed_date and completed_date > cutoff_date:
                completed.append(card)
    return completed

def get_upcoming_deadlines(self, member_name, days=7):
    """Retorna prazos próximos do membro"""
    cutoff_date = datetime.now() + timedelta(days=days)
    upcoming = []
    for card in self.get_cards_by_member(member_name):
        deadline = card.get('deadline')
        if deadline and deadline <= cutoff_date and card.get('status') != 'done':
            upcoming.append(card)
    return upcoming

def log_activity(self, action, user, card_id=None, details=None):
    """Registra atividade no sistema"""
    activity = {
        'id': str(uuid.uuid4()),
        'action': action,
        'user': user,
        'card_id': card_id,
        'details': details,
        'timestamp': datetime.now().isoformat()
    }
    
    # Salvar no banco
    self.save_activity(activity)
    
    # Atualizar interface se necessário
    self.update_activity_display()

def save_activity(self, activity):
    """Salva atividade no banco de dados"""
    try:
        conn = sqlite3.connect('boodesk_new.db')
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO activities (id, action, user, card_id, details, timestamp)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (
            activity['id'],
            activity['action'],
            activity['user'],
            activity['card_id'],
            activity['details'],
            activity['timestamp']
        ))
        
        conn.commit()
        conn.close()
        print(f"✅ Atividade registrada: {activity['action']}")
    except Exception as e:
        print(f"❌ Erro ao salvar atividade: {e}")

def get_recent_activities(self, member_name, limit=10):
    """Retorna atividades recentes relacionadas ao membro"""
    try:
        conn = sqlite3.connect('boodesk_new.db')
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT action, details, timestamp FROM activities 
            WHERE user = ? OR details LIKE ?
            ORDER BY timestamp DESC LIMIT ?
        """, (member_name, f"%{member_name}%", limit))
        
        activities = cursor.fetchall()
        conn.close()
        
        return [{'action': a[0], 'details': a[1], 'timestamp': a[2]} for a in activities]
    except Exception as e:
        print(f"❌ Erro ao buscar atividades: {e}")
        return []

def update_activity_display(self):
    """Atualiza display de atividades na interface"""
    if hasattr(self, 'activity_frame'):
        # Limpar frame atual
        for widget in self.activity_frame.winfo_children():
            widget.destroy()
        
        # Obter atividades do usuário atual
        current_user_member = self._get_current_user_member()
        activities = self.get_recent_activities(current_user_member, 5)
        
        # Criar lista de atividades
        for activity in activities:
            activity_text = f"{activity['action']} - {activity['timestamp']}"
            ttk.Label(self.activity_frame, text=activity_text).pack(anchor='w')

def get_member_metrics(self, member_name, period='month'):
    """Calcula métricas de produtividade do membro"""
    start_date = self.get_period_start_date(period)
    
    metrics = {
        'cards_created': len(self.get_cards_created_by(member_name, start_date)),
        'cards_completed': len(self.get_cards_completed_by(member_name, start_date)),
        'average_completion_time': self.get_avg_completion_time(member_name, start_date),
        'productivity_score': self.calculate_productivity_score(member_name, start_date),
        'on_time_completion_rate': self.get_on_time_completion_rate(member_name, start_date),
        'active_boards': len(self.get_boards_for_member(member_name))
    }
    return metrics

def get_period_start_date(self, period):
    """Retorna data de início do período"""
    now = datetime.now()
    if period == 'week':
        return now - timedelta(days=7)
    elif period == 'month':
        return now - timedelta(days=30)
    elif period == 'quarter':
        return now - timedelta(days=90)
    else:
        return now - timedelta(days=365)

def get_cards_created_by(self, member_name, start_date):
    """Retorna cards criados pelo membro desde uma data"""
    cards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards_list in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards_list:
                if card.get('created_by') == member_name:
                    created_date = card.get('created_at')
                    if created_date and created_date >= start_date:
                        cards.append(card)
    return cards

def get_cards_completed_by(self, member_name, start_date):
    """Retorna cards completados pelo membro desde uma data"""
    cards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards_list in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards_list:
                if member_name in card.get('members', []) and card.get('status') == 'done':
                    completed_date = card.get('completed_at')
                    if completed_date and completed_date >= start_date:
                        cards.append(card)
    return cards

def get_avg_completion_time(self, member_name, start_date):
    """Calcula tempo médio de conclusão"""
    completed_cards = self.get_cards_completed_by(member_name, start_date)
    if not completed_cards:
        return 0
    
    total_time = 0
    for card in completed_cards:
        created = card.get('created_at')
        completed = card.get('completed_at')
        if created and completed:
            try:
                created_dt = datetime.fromisoformat(created)
                completed_dt = datetime.fromisoformat(completed)
                total_time += (completed_dt - created_dt).total_seconds() / 3600  # em horas
            except:
                pass
    
    return total_time / len(completed_cards) if completed_cards else 0

def get_on_time_completion_rate(self, member_name, start_date):
    """Calcula taxa de conclusão no prazo"""
    completed_cards = self.get_cards_completed_by(member_name, start_date)
    if not completed_cards:
        return 0
    
    on_time_count = 0
    for card in completed_cards:
        deadline = card.get('deadline')
        completed = card.get('completed_at')
        if deadline and completed:
            try:
                deadline_dt = datetime.fromisoformat(deadline)
                completed_dt = datetime.fromisoformat(completed)
                if completed_dt <= deadline_dt:
                    on_time_count += 1
            except:
                pass
    
    return on_time_count / len(completed_cards) if completed_cards else 0

def calculate_productivity_score(self, member_name, start_date):
    """Calcula score de produtividade (0-100)"""
    completed = len(self.get_cards_completed_by(member_name, start_date))
    total_assigned = len(self.get_cards_by_member(member_name))
    
    if total_assigned == 0:
        return 0
    
    on_time_rate = self.get_on_time_completion_rate(member_name, start_date)
    completion_rate = completed / total_assigned
    
    # Score baseado em conclusão e pontualidade
    score = (completion_rate * 0.7 + on_time_rate * 0.3) * 100
    return min(100, max(0, score))

def generate_member_report(self, member_name, period='month'):
    """Gera relatório completo do membro"""
    metrics = self.get_member_metrics(member_name, period)
    cards = self.get_cards_by_member(member_name)
    
    report = {
        'member': member_name,
        'period': period,
        'metrics': metrics,
        'cards_summary': {
            'total': len(cards),
            'pending': len([c for c in cards if c.get('status') != 'done']),
            'completed': len([c for c in cards if c.get('status') == 'done']),
            'overdue': len([c for c in cards if self.is_card_overdue(c)])
        },
        'boards_participation': self.get_boards_for_member(member_name),
        'recent_activities': self.get_recent_activities(member_name, 10)
    }
    
    return report

def is_card_overdue(self, card):
    """Verifica se um card está atrasado"""
    deadline = card.get('deadline')
    if not deadline or card.get('status') == 'done':
        return False
    
    try:
        deadline_dt = datetime.fromisoformat(deadline)
        return datetime.now() > deadline_dt
    except:
        return False

def create_progress_indicators(self, board_frame, member_name):
    """Cria indicadores visuais de progresso"""
    progress_frame = ttk.LabelFrame(board_frame, text="Meu Progresso")
    progress_frame.pack(fill=tk.X, pady=5)
    
    # Cards pendentes
    pending = len(self.get_pending_tasks(member_name))
    ttk.Label(progress_frame, text=f"📋 Pendentes: {pending}").pack(side=tk.LEFT, padx=10)
    
    # Cards completados hoje
    completed_today = len(self.get_completed_tasks(member_name, 1))
    ttk.Label(progress_frame, text=f"✅ Completados Hoje: {completed_today}").pack(side=tk.LEFT, padx=10)
    
    # Cards atrasados
    overdue = len([c for c in self.get_cards_by_member(member_name) if self.is_card_overdue(c)])
    ttk.Label(progress_frame, text=f"⚠️ Atrasados: {overdue}").pack(side=tk.LEFT, padx=10)

def create_advanced_filters(self, board_frame):
    """Cria filtros avançados para cards"""
    filter_frame = ttk.LabelFrame(board_frame, text="Filtros")
    filter_frame.pack(fill=tk.X, pady=5)
    
    # Filtro por status
    status_var = tk.StringVar(value="Todos")
    ttk.Label(filter_frame, text="Status:").pack(side=tk.LEFT, padx=5)
    status_combo = ttk.Combobox(filter_frame, textvariable=status_var, 
                               values=["Todos", "Pendentes", "Em Progresso", "Concluídos"])
    status_combo.pack(side=tk.LEFT, padx=5)
    
    # Filtro por prazo
    deadline_var = tk.StringVar(value="Todos")
    ttk.Label(filter_frame, text="Prazo:").pack(side=tk.LEFT, padx=5)
    deadline_combo = ttk.Combobox(filter_frame, textvariable=deadline_var,
                                 values=["Todos", "Hoje", "Esta Semana", "Atrasados"])
    deadline_combo.pack(side=tk.LEFT, padx=5)
    
    # Botão aplicar filtros
    ttk.Button(filter_frame, text="Aplicar", 
               command=lambda: self.apply_filters(status_var.get(), deadline_var.get())).pack(side=tk.LEFT, padx=10)

def apply_filters(self, status_filter, deadline_filter):
    """Aplica filtros aos cards"""
    # Implementar lógica de filtros aqui
    print(f"Aplicando filtros: Status={status_filter}, Prazo={deadline_filter}")
    # Atualizar display dos cards com base nos filtros

def open_personal_dashboard(self):
    """Abre dashboard personalizado do usuário"""
    current_user_member = self._get_current_user_member()
    if not current_user_member:
        messagebox.showwarning("Aviso", "Você precisa estar logado para acessar o dashboard pessoal.")
        return
    
    dashboard_data = self.create_member_dashboard(current_user_member)
    self.show_personal_dashboard_window(dashboard_data)

def show_personal_dashboard_window(self, dashboard_data):
    """Mostra janela do dashboard pessoal"""
    dashboard_window = tk.Toplevel(self.root)
    dashboard_window.title(f"Dashboard Pessoal - {dashboard_data['my_cards'][0]['members'][0] if dashboard_data['my_cards'] else 'Usuário'}")
    dashboard_window.geometry("800x600")
    
    # Criar notebook para organizar as seções
    notebook = ttk.Notebook(dashboard_window)
    notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    # Aba de Cards
    cards_frame = ttk.Frame(notebook)
    notebook.add(cards_frame, text="Meus Cards")
    
    # Lista de cards
    cards_text = tk.Text(cards_frame, wrap=tk.WORD, height=20)
    cards_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    for card in dashboard_data['my_cards']:
        status_icon = "✅" if card.get('status') == 'done' else "📋"
        card_text = f"{status_icon} {card['title']} - {card['board_name']} > {card['list_name']}\n"
        cards_text.insert(tk.END, card_text)
    
    # Aba de Métricas
    metrics_frame = ttk.Frame(notebook)
    notebook.add(metrics_frame, text="Métricas")
    
    metrics = self.get_member_metrics(dashboard_data['my_cards'][0]['members'][0] if dashboard_data['my_cards'] else 'Usuário')
    
    metrics_text = tk.Text(metrics_frame, wrap=tk.WORD, height=20)
    metrics_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    metrics_text.insert(tk.END, f"📊 MÉTRICAS DE PRODUTIVIDADE\n\n")
    metrics_text.insert(tk.END, f"Cards Criados: {metrics['cards_created']}\n")
    metrics_text.insert(tk.END, f"Cards Completados: {metrics['cards_completed']}\n")
    metrics_text.insert(tk.END, f"Tempo Médio de Conclusão: {metrics['average_completion_time']:.1f} horas\n")
    metrics_text.insert(tk.END, f"Score de Produtividade: {metrics['productivity_score']:.1f}%\n")
    metrics_text.insert(tk.END, f"Taxa de Conclusão no Prazo: {metrics['on_time_completion_rate']*100:.1f}%\n")
    metrics_text.insert(tk.END, f"Quadros Ativos: {metrics['active_boards']}\n")
    
    # Aba de Atividades
    activities_frame = ttk.Frame(notebook)
    notebook.add(activities_frame, text="Atividades Recentes")
    
    activities_text = tk.Text(activities_frame, wrap=tk.WORD, height=20)
    activities_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    for activity in dashboard_data['recent_activities']:
        activity_text = f"🕒 {activity['action']} - {activity['timestamp']}\n"
        activities_text.insert(tk.END, activity_text)

# ============================================================================
# FIM DAS MELHORIAS IMPLEMENTADAS
# ============================================================================