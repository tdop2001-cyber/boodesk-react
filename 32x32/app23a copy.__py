import tkinter as tk
from tkinter import ttk, messagebox, simpledialog, colorchooser
from ttkthemes import ThemedTk
import pandas as pd
import json
import os
from os.path import sep
import random
import winsound # Apenas para Windows
from datetime import datetime, timedelta, timezone
from functools import partial
from PIL import Image, ImageTk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import sys
import uuid
from tkcalendar import Calendar, DateEntry
import calendar
import threading
import time
import psutil
import signal
import subprocess

class DatabaseConcurrencyControl:
    """Sistema de controle de concorr√™ncia para o banco de dados"""
    
    def __init__(self, db_file='boodesk_new.db'):
        self.db_file = db_file
        self.lock_file = f"{db_file}.lock"
        self.pid_file = f"{db_file}.pid"
        self.current_pid = os.getpid()
        self.lock_acquired = False
        
    def acquire_lock(self, timeout=30):
        """Tenta adquirir o lock do banco de dados"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                # Verificar se j√° temos o lock
                if self.lock_acquired:
                    print(f"‚úÖ Lock j√° adquirido (PID: {self.current_pid})")
                    return True
                
                # Verificar se j√° existe um lock para este processo
                if os.path.exists(self.lock_file):
                    try:
                        with open(self.lock_file, 'r') as f:
                            pid_str = f.read().strip()
                            if pid_str == str(self.current_pid):
                                self.lock_acquired = True
                                print(f"‚úÖ Lock j√° adquirido por este processo (PID: {self.current_pid})")
                                return True
                    except:
                        pass
                
                # Verificar se h√° outro processo usando o banco
                if self._is_other_process_using_db():
                    print(f"‚ö†Ô∏è Outro processo est√° usando o banco. Tentando interromper...")
                    if self._terminate_other_processes():
                        time.sleep(2)  # Aguardar processo terminar
                        continue
                    else:
                        print(f"‚ùå N√£o foi poss√≠vel interromper outros processos")
                        return False
                
                # Verificar se h√° outro processo usando o lock
                if os.path.exists(self.lock_file):
                    try:
                        with open(self.lock_file, 'r') as f:
                            pid_str = f.read().strip()
                            if pid_str:
                                try:
                                    pid = int(pid_str)
                                    if psutil.pid_exists(pid) and pid != self.current_pid:
                                        print(f"‚ö†Ô∏è Lock j√° existe para PID {pid}")
                                        return False
                                except:
                                    pass
                    except:
                        pass
                
                # Tentar criar arquivo de lock
                with open(self.lock_file, 'w') as f:
                    f.write(str(self.current_pid))
                
                # Verificar se conseguiu criar o lock
                if os.path.exists(self.lock_file):
                    with open(self.lock_file, 'r') as f:
                        pid_in_file = f.read().strip()
                        if pid_in_file == str(self.current_pid):
                            self.lock_acquired = True
                            print(f"‚úÖ Lock adquirido com sucesso (PID: {self.current_pid})")
                            return True
                
                time.sleep(0.5)
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao tentar adquirir lock: {e}")
                time.sleep(0.5)
        
        print(f"‚ùå Timeout ao tentar adquirir lock do banco")
        return False
    
    def release_lock(self):
        """Libera o lock do banco de dados"""
        try:
            if self.lock_acquired and os.path.exists(self.lock_file):
                try:
                    with open(self.lock_file, 'r') as f:
                        pid_in_file = f.read().strip()
                        if pid_in_file == str(self.current_pid):
                            try:
                                os.remove(self.lock_file)
                                self.lock_acquired = False
                                print(f"‚úÖ Lock liberado (PID: {self.current_pid})")
                            except Exception as e:
                                print(f"‚ö†Ô∏è Erro ao remover arquivo de lock: {e}")
                                # Tentar novamente ap√≥s um pequeno delay
                                time.sleep(0.1)
                                try:
                                    os.remove(self.lock_file)
                                    self.lock_acquired = False
                                    print(f"‚úÖ Lock liberado na segunda tentativa (PID: {self.current_pid})")
                                except:
                                    pass
                except Exception as e:
                    print(f"‚ö†Ô∏è Erro ao ler arquivo de lock: {e}")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao liberar lock: {e}")
    
    def _is_other_process_using_db(self):
        """Verifica se h√° outro processo usando o banco"""
        try:
            # Verificar arquivo de lock
            if os.path.exists(self.lock_file):
                with open(self.lock_file, 'r') as f:
                    pid_str = f.read().strip()
                    if pid_str and pid_str != str(self.current_pid):
                        try:
                            pid = int(pid_str)
                            if psutil.pid_exists(pid):
                                return True
                        except:
                            pass
            
            # Verificar processos Python que podem estar usando o banco
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    if proc.info['name'] and 'python' in proc.info['name'].lower():
                        if proc.info['cmdline']:
                            cmdline = ' '.join(proc.info['cmdline'])
                            if 'app23a.py' in cmdline and proc.info['pid'] != self.current_pid:
                                return True
                except:
                    continue
            
            return False
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao verificar outros processos: {e}")
            return False
    
    def _terminate_other_processes(self):
        """Tenta terminar outros processos Python que estejam usando o banco"""
        try:
            terminated_count = 0
            
            # Terminar processos Python que executam app23a.py
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    if proc.info['name'] and 'python' in proc.info['name'].lower():
                        if proc.info['cmdline']:
                            cmdline = ' '.join(proc.info['cmdline'])
                            if 'app23a.py' in cmdline and proc.info['pid'] != self.current_pid:
                                print(f"üîÑ Terminando processo Python (PID: {proc.info['pid']})")
                                proc.terminate()
                                proc.wait(timeout=5)
                                terminated_count += 1
                except:
                    continue
            
            # Limpar arquivos de lock √≥rf√£os
            if os.path.exists(self.lock_file):
                try:
                    with open(self.lock_file, 'r') as f:
                        pid_str = f.read().strip()
                        if pid_str:
                            try:
                                pid = int(pid_str)
                                if not psutil.pid_exists(pid):
                                    os.remove(self.lock_file)
                                    print(f"üóëÔ∏è Removido lock √≥rf√£o (PID: {pid})")
                            except:
                                os.remove(self.lock_file)
                except:
                    pass
            
            # Limpar arquivos WAL/SHM se existirem
            wal_file = f"{self.db_file}-wal"
            shm_file = f"{self.db_file}-shm"
            
            for file_path in [wal_file, shm_file]:
                if os.path.exists(file_path):
                    try:
                        os.remove(file_path)
                        print(f"üóëÔ∏è Removido arquivo: {file_path}")
                    except:
                        pass
            
            print(f"‚úÖ {terminated_count} processos terminados")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao terminar outros processos: {e}")
            return False
    
    def __enter__(self):
        """Context manager para adquirir lock automaticamente"""
        if not self.acquire_lock():
            raise RuntimeError("N√£o foi poss√≠vel adquirir lock do banco de dados")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager para liberar lock automaticamente"""
        self.release_lock()

class UserManagement:
    def __init__(self):
        """Inicializa o gerenciamento de usu√°rios usando banco SQLite"""
        self.load_users()
    
    def load_users(self):
        """Carrega usu√°rios do banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, username, email, password_hash, role, cargo, created_at, updated_at, member_id
                FROM users ORDER BY username
            """)
            users_data = cursor.fetchall()
            conn.close()
            
            # Converter para DataFrame
            if users_data:
                self.users_df = pd.DataFrame(users_data, columns=[
                    'user_id', 'username', 'email', 'password', 'role', 'Cargo', 
                    'created_at', 'last_login', 'member_id'
                ])
            else:
                # Criar DataFrame vazio com estrutura correta
                self.users_df = pd.DataFrame(columns=[
                    'user_id', 'username', 'email', 'password', 'role', 'Cargo', 
                    'created_at', 'last_login', 'member_id'
                ])
            
            print(f"DEBUG: {len(self.users_df)} usu√°rios carregados do SQLite")
            
        except Exception as e:
            print(f"Erro ao carregar usu√°rios do SQLite: {e}")
            # Criar DataFrame vazio em caso de erro
            self.users_df = pd.DataFrame(columns=[
                'user_id', 'username', 'email', 'password', 'role', 'Cargo', 
                'created_at', 'last_login', 'member_id'
            ])
    
    def save_users(self):
        """Salva usu√°rios no banco SQLite"""
        try:
            print("DEBUG: Usu√°rios salvos no SQLite")
        except Exception as e:
            print(f"Erro ao salvar usu√°rios: {e}")
    
    def login(self, username, password):
        """Autentica um usu√°rio usando banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, username, email, password_hash, role, cargo, member_id
                FROM users WHERE username = ? AND password_hash = ?
            """, (username, password))
            
            user_data = cursor.fetchone()
            conn.close()
            
            if user_data:
                user_id, username, email, password_hash, role, cargo, member_id = user_data
                
                user = User(
                    username=username,
                    role=role,
                    cargo=cargo,
                    user_id=user_id
                )
                user.is_authenticated = True
                user.login_time = pd.Timestamp.now()
                user.member_id = member_id
                
                # Atualizar √∫ltimo login no banco
                conn = sqlite3.connect('boodesk_new.db')
                cursor = conn.cursor()
                cursor.execute("""
                    UPDATE users SET updated_at = ? WHERE id = ?
                """, (datetime.now(), user_id))
                conn.commit()
                conn.close()
                
                return user
            return None
            
        except Exception as e:
            print(f"Erro no login: {e}")
            return None
    
    def register_user(self, username, password, role, cargo):
        """Registra um novo usu√°rio no banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            # Verificar se o usu√°rio j√° existe
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("SELECT id FROM users WHERE username = ?", (username,))
            if cursor.fetchone():
                conn.close()
                return False, "Usu√°rio j√° existe"
            
            # Validar dados
            if not username or not password:
                return False, "Usu√°rio e senha s√£o obrigat√≥rios"
            
            if len(password) < 6:
                return False, "Senha deve ter pelo menos 6 caracteres"
            
            if role not in ['admin', 'user', 'manager']:
                return False, "Role inv√°lido"
            
            # Inserir novo usu√°rio
            cursor.execute("""
                INSERT INTO users (username, email, password_hash, role, cargo, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (username, '', password, role, cargo, datetime.now(), datetime.now()))
            
            conn.commit()
            conn.close()
            
            # Recarregar usu√°rios
            self.load_users()
            
            return True, "Usu√°rio registrado com sucesso"
            
        except Exception as e:
            print(f"Erro ao registrar usu√°rio: {e}")
            return False, f"Erro ao registrar usu√°rio: {e}"
    
    def update_user(self, user_id, username, password, role, cargo):
        """Atualiza dados de um usu√°rio"""
        user_idx = self.users_df[self.users_df['user_id'] == user_id].index
        if len(user_idx) == 0:
            return False, "Usu√°rio n√£o encontrado"
        
        idx = user_idx[0]
        
        # Verificar se o novo username j√° existe (exceto para o pr√≥prio usu√°rio)
        existing_user = self.users_df[
            (self.users_df['username'] == username) & 
            (self.users_df['user_id'] != user_id)
        ]
        if not existing_user.empty:
            return False, "Username j√° existe"
        
        # Atualizar dados
        self.users_df.loc[idx, 'username'] = username
        if password:  # S√≥ atualizar senha se fornecida
            self.users_df.loc[idx, 'password'] = password
        self.users_df.loc[idx, 'role'] = role
        self.users_df.loc[idx, 'Cargo'] = cargo
        
        self.save_users()
        return True, "Usu√°rio atualizado com sucesso"
    
    def delete_user(self, user_id):
        """Remove um usu√°rio"""
        user_idx = self.users_df[self.users_df['user_id'] == user_id].index
        if len(user_idx) == 0:
            return False, "Usu√°rio n√£o encontrado"
        
        # N√£o permitir deletar o √∫ltimo admin
        user_role = self.users_df.loc[user_idx[0], 'role']
        if user_role == 'admin':
            admin_count = len(self.users_df[self.users_df['role'] == 'admin'])
            if admin_count <= 1:
                return False, "N√£o √© poss√≠vel deletar o √∫ltimo administrador"
        
        self.users_df = self.users_df[self.users_df['user_id'] != user_id]
        self.save_users()
        return True, "Usu√°rio removido com sucesso"
    
    def get_all_users(self):
        """Retorna todos os usu√°rios do banco SQLite"""
        try:
            import sqlite3
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, username, email, role, cargo, created_at, updated_at, member_id
                FROM users ORDER BY username
            """)
            users_data = cursor.fetchall()
            conn.close()
            
            users = []
            for user_data in users_data:
                user_id, username, email, role, cargo, created_at, updated_at, member_id = user_data
                users.append({
                    'user_id': user_id,
                    'username': username,
                    'email': email,
                    'role': role,
                    'cargo': cargo,
                    'created_at': created_at,
                    'last_login': updated_at,
                    'member_id': member_id
                })
            
            return users
            
        except Exception as e:
            print(f"Erro ao buscar usu√°rios: {e}")
            return []
    
    def get_user_by_id(self, user_id):
        """Retorna um usu√°rio espec√≠fico por ID"""
        user_data = self.users_df[self.users_df['user_id'] == user_id]
        if not user_data.empty:
            user_row = user_data.iloc[0]
            return User(
                username=user_row['username'],
                role=user_row['role'],
                cargo=user_row['Cargo'],
                user_id=user_row['user_id']
            )
        return None

class EmailIntegration:
    def __init__(self, app):
        self.app = app
        self.settings = app.settings.get('email_integration', {})
        self.email_thread = None
        self.running = False
        
    def start_email_service(self):
        if not self.settings.get('enabled', False):
            return
            
        self.running = True
        self.email_thread = threading.Thread(target=self._email_loop, daemon=True)
        self.email_thread.start()
    
    def stop_email_service(self):
        self.running = False
        if self.email_thread:
            self.email_thread.join(timeout=1)
    
    def _email_loop(self):
        while self.running:
            try:
                if self.settings.get('auto_notifications', {}).get('deadline_reminder', True):
                    self._check_deadline_reminders()
                
                if self.settings.get('auto_notifications', {}).get('weekly_report', True):
                    self._check_weekly_report()
                
                time.sleep(3600)  # Check every hour
            except Exception as e:
                print(f"Erro no loop de email: {e}")
                time.sleep(300)
    
    def send_email(self, to_email, subject, body, attachments=None):
        try:
            if self.settings.get('demo_mode', False):
                return self._demo_send_email(to_email, subject, body)
            
            provider = self.settings.get('provider', 'gmail')
            
            if provider == 'gmail':
                return self._send_gmail(to_email, subject, body, attachments)
            elif provider == 'outlook':
                return self._send_outlook(to_email, subject, body, attachments)
            else:
                return self._send_smtp(to_email, subject, body, attachments)
                
        except Exception as e:
            print(f"Erro ao enviar email: {e}")
            return False
    
    def _demo_send_email(self, to_email, subject, body):
        """Simula envio de email em modo demo"""
        print(f"DEMO EMAIL - Para: {to_email}")
        print(f"Assunto: {subject}")
        print(f"Corpo: {body}")
        print("--- Email simulado com sucesso ---")
        return True
    
    def _send_gmail(self, to_email, subject, body, attachments=None):
        try:
            email_address = self.settings.get('email_address', '')
            app_password = self.settings.get('app_password', '')
            
            if not email_address or not app_password:
                print("Credenciais de email n√£o configuradas")
                return False
            
            msg = MIMEMultipart()
            msg['From'] = email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            if attachments:
                for attachment in attachments:
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                        msg.attach(part)
            
            server = smtplib.SMTP('smtp.gmail.com', 587)
            server.starttls()
            server.login(email_address, app_password)
            text = msg.as_string()
            server.sendmail(email_address, to_email, text)
            server.quit()
            
            print(f"Email enviado com sucesso para {to_email}")
            return True
            
        except Exception as e:
            print(f"Erro ao enviar email via Gmail: {e}")
            return False
    
    def _send_outlook(self, to_email, subject, body, attachments=None):
        try:
            email_address = self.settings.get('email_address', '')
            email_password = self.settings.get('email_password', '')
            smtp_server = self.settings.get('smtp_server', 'smtp-mail.outlook.com')
            smtp_port = self.settings.get('smtp_port', 587)
            
            if not email_address or not email_password:
                print("Credenciais de email n√£o configuradas")
                return False
            
            msg = MIMEMultipart()
            msg['From'] = email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            if attachments:
                for attachment in attachments:
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                        msg.attach(part)
            
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(email_address, email_password)
            text = msg.as_string()
            server.sendmail(email_address, to_email, text)
            server.quit()
            
            print(f"Email enviado com sucesso para {to_email}")
            return True
            
        except Exception as e:
            print(f"Erro ao enviar email via Outlook: {e}")
            return False
    
    def _send_smtp(self, to_email, subject, body, attachments=None):
        try:
            email_address = self.settings.get('email_address', '')
            email_password = self.settings.get('email_password', '')
            smtp_server = self.settings.get('smtp_server', '')
            smtp_port = self.settings.get('smtp_port', 587)
            
            if not all([email_address, email_password, smtp_server]):
                print("Configura√ß√µes SMTP incompletas")
                return False
            
            msg = MIMEMultipart()
            msg['From'] = email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            if attachments:
                for attachment in attachments:
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                        msg.attach(part)
            
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(email_address, email_password)
            text = msg.as_string()
            server.sendmail(email_address, to_email, text)
            server.quit()
            
            print(f"Email enviado com sucesso para {to_email}")
            return True
            
        except Exception as e:
            print(f"Erro ao enviar email via SMTP: {e}")
            return False
    
    def notify_card_created(self, card_data):
        """Notifica cria√ß√£o de novo cart√£o"""
        try:
            if not self.settings.get('auto_notifications', {}).get('card_created', True):
                return
            
            template = self.settings.get('email_templates', {}).get('card_created', 'Novo cart√£o criado: {title}')
            subject = template.format(**card_data)
            
            body = f"""
Novo cart√£o criado no Boodesk:

T√≠tulo: {card_data.get('title', '')}
Quadro: {card_data.get('board', '')}
Lista: {card_data.get('column', '')}
Criado por: {card_data.get('created_by', '')}
Data de cria√ß√£o: {card_data.get('created_date', '')}
Import√¢ncia: {card_data.get('importance', '')}
Prazo: {card_data.get('due_date', '')}
"""
            
            recipients = self.settings.get('notification_recipients', [])
            for recipient in recipients:
                self.send_email(recipient, subject, body)
                
        except Exception as e:
            print(f"Erro ao notificar cria√ß√£o de cart√£o: {e}")


import requests
import base64
import urllib.parse
import threading
import time
# Importa√ß√µes para Google Calendar e templates de email
import threading
import time
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
import ssl
import pickle
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import webbrowser
from database import Database

# Configura√ß√µes da API Google Calendar
SCOPES = ['https://www.googleapis.com/auth/calendar']
CREDENTIALS_FILE = 'credentials.json'
TOKEN_FILE = 'token.pickle'

class User:
    def __init__(self, username, role, cargo=None, user_id=None):
        self.username = username
        self.role = role
        self.cargo = cargo or "Usu√°rio"
        self.user_id = user_id
        self.is_authenticated = False
        self.login_time = None
        
    def has_permission(self, permission):
        """Verifica se o usu√°rio tem uma determinada permiss√£o"""
        # Verificar se o role √© v√°lido
        if not hasattr(self, 'role') or not self.role:
            print("DEBUG: Usu√°rio sem role, usando role padr√£o 'user'")
            self.role = "user"
        
        # Mapear roles em portugu√™s para ingl√™s
        role_mapping = {
            "Administrador": "admin",
            "admin": "admin",
            "Manager": "manager", 
            "manager": "manager",
            "Usu√°rio": "user",
            "user": "user"
        }
        
        # Normalizar o role
        normalized_role = role_mapping.get(self.role, self.role)
        
        if normalized_role == "admin":
            return True  # Admin tem todas as permiss√µes
        
        # Permiss√µes espec√≠ficas por role
        permissions = {
            "user": [
                "view_boards", "view_cards", "edit_own_cards", 
                "move_cards", "add_comments", "view_reports"
            ],
            "manager": [
                "view_boards", "view_cards", "edit_cards", 
                "move_cards", "add_comments", "view_reports",
                "manage_members", "create_cards", "delete_cards",
                "manage_users"
            ]
        }
        
        return permission in permissions.get(normalized_role, [])
    
    def can_manage_users(self):
        """Verifica se o usu√°rio pode gerenciar outros usu√°rios"""
        if not hasattr(self, 'role') or not self.role:
            return False
        
        # Mapear roles em portugu√™s para ingl√™s
        role_mapping = {
            "Administrador": "admin",
            "admin": "admin",
            "Manager": "manager", 
            "manager": "manager",
            "Usu√°rio": "user",
            "user": "user"
        }
        
        # Normalizar o role
        normalized_role = role_mapping.get(self.role, self.role)
        return normalized_role in ["admin", "manager"]
    
    def can_manage_settings(self):
        """Verifica se o usu√°rio pode gerenciar configura√ß√µes"""
        if not hasattr(self, 'role') or not self.role:
            return False
        return self.role == "admin"
    
    def can_delete_cards(self):
        """Verifica se o usu√°rio pode deletar cart√µes"""
        if not hasattr(self, 'role') or not self.role:
            return False
        return self.role in ["admin", "manager"]
    
    def can_edit_all_cards(self):
        """Verifica se o usu√°rio pode editar todos os cart√µes"""
        if not hasattr(self, 'role') or not self.role:
            return False
        return self.role in ["admin", "manager"]
    
    def __str__(self):
        cargo = getattr(self, 'cargo', 'Usu√°rio')
        return f"{self.username} ({cargo})"

class NotificationManager:
    def __init__(self, app):
        self.app = app
        self.notification_settings = self.load_notification_settings()
        self.notification_thread = None
        self.running = False
        
    def load_notification_settings(self):
        """Carrega configura√ß√µes de notifica√ß√£o"""
        default_settings = {
            'enabled': True,
            'sound_enabled': True,
            'popup_enabled': True,
            'advance_notification_minutes': 15,
            'show_widget': True,
            'widget_position': 'top_right',
            'notification_duration': 10
        }
        
        try:
            if os.path.exists('notification_settings.json'):
                with open('notification_settings.json', 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                    # Mesclar com configura√ß√µes padr√£o
                    for key, value in default_settings.items():
                        if key not in settings:
                            settings[key] = value
                    return settings
            else:
                return default_settings
        except Exception as e:
            print(f"Erro ao carregar configura√ß√µes de notifica√ß√£o: {e}")
            return default_settings
    
    def save_notification_settings(self):
        """Salva configura√ß√µes de notifica√ß√£o"""
        try:
            with open('notification_settings.json', 'w', encoding='utf-8') as f:
                json.dump(self.notification_settings, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"Erro ao salvar configura√ß√µes de notifica√ß√£o: {e}")
    
    def start_notification_monitor(self):
        """Inicia o monitor de notifica√ß√µes"""
        if not self.notification_settings['enabled']:
            return
            
        self.running = True
        self.notification_thread = threading.Thread(target=self._monitor_meetings, daemon=True)
        self.notification_thread.start()
    
    def stop_notification_monitor(self):
        """Para o monitor de notifica√ß√µes"""
        self.running = False
        if self.notification_thread:
            self.notification_thread.join(timeout=1)
    
    def _monitor_meetings(self):
        """Monitora reuni√µes para notifica√ß√µes"""
        while self.running:
            try:
                current_time = datetime.now()
                
                # Verificar reuni√µes pr√≥ximas
                for meeting_id, meeting in self.app.meeting_integration.meeting_data.items():
                    if meeting.get('notified', False):
                        continue
                    
                    meeting_datetime = datetime.strptime(f"{meeting['date']} {meeting['time']}", "%Y-%m-%d %H:%M")
                    time_diff = meeting_datetime - current_time
                    
                    # Notificar X minutos antes
                    if 0 <= time_diff.total_seconds() <= self.notification_settings['advance_notification_minutes'] * 60:
                        self._show_meeting_notification(meeting)
                        meeting['notified'] = True
                        self.app.meeting_integration.save_meeting_data()
                
                time.sleep(30)  # Verificar a cada 30 segundos
                
            except Exception as e:
                print(f"Erro no monitor de notifica√ß√µes: {e}")
                time.sleep(60)
    
    def _show_meeting_notification(self, meeting):
        """Mostra notifica√ß√£o de reuni√£o"""
        if self.notification_settings['sound_enabled']:
            self._play_notification_sound()
        
        if self.notification_settings['popup_enabled']:
            self._show_popup_notification(meeting)
    
    def _play_notification_sound(self):
        """Toca som de notifica√ß√£o"""
        try:
            winsound.MessageBeep(winsound.MB_ICONEXCLAMATION)
        except:
            pass  # Ignorar se n√£o conseguir tocar som
    
    def _show_popup_notification(self, meeting):
        """Mostra popup de notifica√ß√£o simples"""
        def show_popup():
            popup = tk.Toplevel()
            popup.title("Reuni√£o")
            popup.geometry("300x120")
            
            # Centralizar na tela
            popup.update_idletasks()
            x = (popup.winfo_screenwidth() // 2) - (300 // 2)
            y = (popup.winfo_screenheight() // 2) - (120 // 2)
            popup.geometry(f"300x120+{x}+{y}")
            
            # Sempre no topo
            popup.attributes('-topmost', True)
            
            # Conte√∫do simples
            title_label = tk.Label(popup, text="Reuni√£o Pr√≥xima", 
                                 font=("Arial", 12, "bold"))
            title_label.pack(pady=5)
            
            meeting_label = tk.Label(popup, text=meeting['title'], 
                                   font=("Arial", 10))
            meeting_label.pack(pady=2)
            
            time_label = tk.Label(popup, text=f"{meeting['time']} - {meeting['platform'].upper()}", 
                                font=("Arial", 9))
            time_label.pack(pady=2)
            
            # Bot√µes simples
            button_frame = tk.Frame(popup)
            button_frame.pack(pady=10)
            
            tk.Button(button_frame, text="Entrar", 
                     command=lambda: [webbrowser.open(meeting['link']), popup.destroy()]).pack(side=tk.LEFT, padx=5)
            
            tk.Button(button_frame, text="Fechar", 
                     command=popup.destroy).pack(side=tk.LEFT, padx=5)
            
            # Auto-fechar ap√≥s X segundos
            popup.after(self.notification_settings['notification_duration'] * 1000, popup.destroy)
        
        # Executar na thread principal
        self.app.root.after(0, show_popup)

class MeetingWidget:
    def __init__(self, app, parent_frame):
        self.app = app
        self.parent_frame = parent_frame
        self.widget_frame = None
        self.create_widget()
    
    def create_widget(self):
        """Cria o widget de reuni√µes discreto no menu principal"""
        if not self.app.notification_manager.notification_settings['show_widget']:
            return
            
        # Criar frame discreto para o widget
        self.widget_frame = ttk.Frame(self.parent_frame)
        self.widget_frame.pack(fill=tk.X, padx=10, pady=2)
        
        # T√≠tulo discreto
        title_label = ttk.Label(self.widget_frame, text="Pr√≥xima Reuni√£o:", font=("Arial", 9))
        title_label.pack(anchor=tk.W, pady=(0, 2))
        
        # Lista de reuni√µes
        self.meetings_frame = tk.Frame(self.widget_frame)
        self.meetings_frame.pack(fill=tk.X)
        
        # Atualizar reuni√µes
        self.refresh_meetings()
        
        # Atualizar periodicamente
        self._schedule_refresh()
    
    def refresh_meetings(self):
        """Atualiza a lista de reuni√µes"""
        # Limpar frame
        for widget in self.meetings_frame.winfo_children():
            widget.destroy()
        
        # Buscar reuni√µes pr√≥ximas e em andamento
        current_time = datetime.now()
        upcoming_meetings = []
        ongoing_meetings = []
        
        for meeting_id, meeting in self.app.meeting_integration.meeting_data.items():
            meeting_datetime = datetime.strptime(f"{meeting['date']} {meeting['time']}", "%Y-%m-%d %H:%M")
            duration_minutes = int(meeting.get('duration', 60))  # Dura√ß√£o padr√£o 60 min
            end_datetime = meeting_datetime + timedelta(minutes=duration_minutes)
            
            # Verificar se a reuni√£o est√° em andamento
            if meeting_datetime <= current_time <= end_datetime:
                ongoing_meetings.append((meeting_datetime, meeting, end_datetime))
            # Verificar se a reuni√£o est√° pr√≥xima (pr√≥ximas 24 horas)
            elif 0 <= (meeting_datetime - current_time).total_seconds() <= 24 * 60 * 60:
                upcoming_meetings.append((meeting_datetime, meeting))
        
        # Ordenar por data/hora (primeiro elemento da tupla √© o datetime)
        ongoing_meetings.sort(key=lambda x: x[0])
        upcoming_meetings.sort(key=lambda x: x[0])
        
        # Mostrar reuni√£o em andamento primeiro, depois a pr√≥xima
        if ongoing_meetings:
            meeting_datetime, meeting, end_datetime = ongoing_meetings[0]
            self._display_meeting(meeting, meeting_datetime, is_ongoing=True, end_datetime=end_datetime)
        elif upcoming_meetings:
            meeting_datetime, meeting = upcoming_meetings[0]
            self._display_meeting(meeting, meeting_datetime, is_ongoing=False)
        else:
            # Se n√£o h√° reuni√µes, mostrar mensagem discreta
            no_meetings_label = ttk.Label(self.meetings_frame, text="Nenhuma reuni√£o nas pr√≥ximas 24h", 
                                        font=("Arial", 8), 
                                        foreground='#7f8c8d')
            no_meetings_label.pack(pady=2)
    
    def _display_meeting(self, meeting, meeting_datetime, is_ongoing=False, end_datetime=None):
        """Exibe uma reuni√£o no widget"""
        current_time = datetime.now()
        
        # Frame principal da reuni√£o
        meeting_frame = tk.Frame(self.meetings_frame, relief=tk.SUNKEN, bd=1)
        meeting_frame.pack(fill=tk.X, pady=1)
        
        if is_ongoing:
            # Reuni√£o em andamento
            time_remaining = end_datetime - current_time
            minutes_remaining = int(time_remaining.total_seconds() // 60)
            time_text = f"EM ANDAMENTO ({minutes_remaining}m restantes)"
            time_color = '#e74c3c'  # Vermelho para reuni√£o em andamento
        else:
            # Reuni√£o pr√≥xima
            time_diff = meeting_datetime - current_time
            hours = int(time_diff.total_seconds() // 3600)
            minutes = int((time_diff.total_seconds() % 3600) // 60)
            
            if hours > 0:
                time_text = f"em {hours}h {minutes}m"
            else:
                time_text = f"em {minutes}m"
            time_color = '#e67e22'  # Laranja para reuni√£o pr√≥xima
        
        # Frame para informa√ß√µes da reuni√£o
        info_frame = tk.Frame(meeting_frame)
        info_frame.pack(fill=tk.X, padx=5, pady=3)
        
        # T√≠tulo da reuni√£o (clic√°vel)
        title_label = tk.Label(info_frame, text=meeting['title'][:30] + "..." if len(meeting['title']) > 30 else meeting['title'], 
                             font=("Arial", 9), 
                             fg='#2c3e50', cursor="hand2")
        title_label.pack(side=tk.LEFT, anchor=tk.W)
        
        # Bind duplo clique para abrir link
        title_label.bind("<Double-1>", lambda e, m=meeting: webbrowser.open(m['link']))
        
        # Tempo restante
        time_label = tk.Label(info_frame, text=time_text, 
                            font=("Arial", 8), 
                            fg=time_color)
        time_label.pack(side=tk.LEFT, padx=(10, 0))
        
        # Hora e plataforma
        time_info = tk.Label(info_frame, text=f"{meeting['time']} - {meeting['platform'].upper()}", 
                           font=("Arial", 8), 
                           fg='#7f8c8d')
        time_info.pack(side=tk.LEFT, padx=(10, 0))
        
        # Bot√£o discreto para copiar link
        copy_button = tk.Button(info_frame, 
                              image=self.app.icons.get('copy_icon'),
                              relief=tk.FLAT, 
                              bd=0,
                              command=lambda m=meeting: self.copy_meeting_link(m))
        copy_button.pack(side=tk.RIGHT, padx=(5, 0))
        
        # Tooltip para o bot√£o
        copy_button.bind("<Enter>", lambda e, btn=copy_button: btn.config(bg='#e0e0e0'))
        copy_button.bind("<Leave>", lambda e, btn=copy_button: btn.config(bg='SystemButtonFace'))
    
    def copy_meeting_link(self, meeting):
        """Copia o link da reuni√£o para a √°rea de transfer√™ncia"""
        try:
            self.app.root.clipboard_clear()
            self.app.root.clipboard_append(meeting['link'])
            # Mostrar feedback discreto
            messagebox.showinfo("Link Copiado", f"Link da reuni√£o '{meeting['title']}' copiado para a √°rea de transfer√™ncia!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao copiar link: {e}")
    
    def _schedule_refresh(self):
        """Agenda atualiza√ß√£o autom√°tica"""
        self.refresh_meetings()
        self.widget_frame.after(60000, self._schedule_refresh)  # Atualizar a cada minuto
    
    def open_notification_settings(self):
        """Abre configura√ß√µes de notifica√ß√£o"""
        NotificationSettingsWindow(self.app)

class NotificationSettingsWindow:
    def __init__(self, app):
        self.app = app
        self.window = tk.Toplevel(app.root)
        self.window.title("Configura√ß√µes de Notifica√ß√£o")
        self.window.geometry("500x400")
        self.window.transient(app.root)
        self.window.grab_set()
        
        self.create_widgets()
    
    def create_widgets(self):
        """Cria widgets da janela de configura√ß√µes"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_label = ttk.Label(main_frame, text="Configura√ß√µes de Notifica√ß√£o", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Configura√ß√µes
        settings_frame = ttk.LabelFrame(main_frame, text="Notifica√ß√µes", padding="10")
        settings_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Habilitar notifica√ß√µes
        self.enabled_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['enabled'])
        ttk.Checkbutton(settings_frame, text="Habilitar notifica√ß√µes", 
                       variable=self.enabled_var).pack(anchor=tk.W, pady=2)
        
        # Som
        self.sound_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['sound_enabled'])
        ttk.Checkbutton(settings_frame, text="Tocar som", 
                       variable=self.sound_var).pack(anchor=tk.W, pady=2)
        
        # Popup
        self.popup_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['popup_enabled'])
        ttk.Checkbutton(settings_frame, text="Mostrar popup", 
                       variable=self.popup_var).pack(anchor=tk.W, pady=2)
        
        # Widget
        self.widget_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['show_widget'])
        ttk.Checkbutton(settings_frame, text="Mostrar widget na tela", 
                       variable=self.widget_var).pack(anchor=tk.W, pady=2)
        
        # Configura√ß√µes avan√ßadas
        advanced_frame = ttk.LabelFrame(main_frame, text="Configura√ß√µes Avan√ßadas", padding="10")
        advanced_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Anteced√™ncia da notifica√ß√£o
        ttk.Label(advanced_frame, text="Notificar (minutos antes):").pack(anchor=tk.W, pady=2)
        self.advance_var = tk.StringVar(value=str(self.app.notification_manager.notification_settings['advance_notification_minutes']))
        advance_entry = ttk.Entry(advanced_frame, textvariable=self.advance_var, width=10)
        advance_entry.pack(anchor=tk.W, pady=2)
        
        # Dura√ß√£o da notifica√ß√£o
        ttk.Label(advanced_frame, text="Dura√ß√£o do popup (segundos):").pack(anchor=tk.W, pady=2)
        self.duration_var = tk.StringVar(value=str(self.app.notification_manager.notification_settings['notification_duration']))
        duration_entry = ttk.Entry(advanced_frame, textvariable=self.duration_var, width=10)
        duration_entry.pack(anchor=tk.W, pady=2)
        
        # Posi√ß√£o do widget
        ttk.Label(advanced_frame, text="Posi√ß√£o do widget:").pack(anchor=tk.W, pady=2)
        self.position_var = tk.StringVar(value=self.app.notification_manager.notification_settings['widget_position'])
        position_combo = ttk.Combobox(advanced_frame, textvariable=self.position_var, 
                                     values=['top_right', 'top_left', 'bottom_right', 'bottom_left'], 
                                     state="readonly", width=15)
        position_combo.pack(anchor=tk.W, pady=2)
        
        # Bot√µes
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=20)
        
        ttk.Button(button_frame, text="Salvar", 
                  command=self.save_settings).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Testar Notifica√ß√£o", 
                  command=self.test_notification).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancelar", 
                  command=self.window.destroy).pack(side=tk.RIGHT, padx=5)
    
    def save_settings(self):
        """Salva as configura√ß√µes"""
        try:
            self.app.notification_manager.notification_settings.update({
                'enabled': self.enabled_var.get(),
                'sound_enabled': self.sound_var.get(),
                'popup_enabled': self.popup_var.get(),
                'show_widget': self.widget_var.get(),
                'advance_notification_minutes': int(self.advance_var.get()),
                'notification_duration': int(self.duration_var.get()),
                'widget_position': self.position_var.get()
            })
            
            self.app.notification_manager.save_notification_settings()
            
            # Reiniciar monitor se necess√°rio
            if self.app.notification_manager.notification_settings['enabled']:
                self.app.notification_manager.stop_notification_monitor()
                self.app.notification_manager.start_notification_monitor()
            
            messagebox.showinfo("Sucesso", "Configura√ß√µes salvas com sucesso!")
            self.window.destroy()
            
        except ValueError:
            messagebox.showerror("Erro", "Por favor, insira valores num√©ricos v√°lidos.")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar configura√ß√µes: {e}")
    
    def test_notification(self):
        """Testa a notifica√ß√£o"""
        test_meeting = {
            'title': 'Reuni√£o de Teste',
            'date': datetime.now().strftime('%Y-%m-%d'),
            'time': datetime.now().strftime('%H:%M'),
            'platform': 'test',
            'link': '#'
        }
        
        self.app.notification_manager._show_meeting_notification(test_meeting)

class GoogleCalendarManager:
    def __init__(self):
        self.service = None
        self.credentials = None
        
    def authenticate(self):
        """Autentica com a API do Google Calendar"""
        try:
            # Verificar se j√° temos credenciais salvas
            if os.path.exists(TOKEN_FILE):
                with open(TOKEN_FILE, 'rb') as token:
                    self.credentials = pickle.load(token)
            
            # Se n√£o h√° credenciais v√°lidas, fazer login
            if not self.credentials or not self.credentials.valid:
                if self.credentials and self.credentials.expired and self.credentials.refresh_token:
                    self.credentials.refresh(Request())
                else:
                    if not os.path.exists(CREDENTIALS_FILE):
                        messagebox.showerror("Erro", 
                                           "Arquivo credentials.json n√£o encontrado!\n\n"
                                           "Para usar o Google Meet:\n"
                                           "1. Acesse https://console.cloud.google.com\n"
                                           "2. Crie um projeto e ative a Google Calendar API\n"
                                           "3. Crie credenciais OAuth 2.0\n"
                                           "4. Baixe o arquivo como 'credentials.json'\n"
                                           "5. Coloque na pasta do aplicativo")
                        return False
                    
                    flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_FILE, SCOPES)
                    self.credentials = flow.run_local_server(port=0)
                
                # Salvar credenciais para uso futuro
                with open(TOKEN_FILE, 'wb') as token:
                    pickle.dump(self.credentials, token)
            
            # Construir o servi√ßo
            self.service = build('calendar', 'v3', credentials=self.credentials)
            return True
            
        except Exception as e:
            messagebox.showerror("Erro de Autentica√ß√£o", f"Erro ao autenticar com Google Calendar:\n{str(e)}")
            return False
    
    def create_meeting(self, title, date, time_str, duration=60, description=""):
        """Cria uma reuni√£o real no Google Calendar com Google Meet"""
        try:
            if not self.service:
                if not self.authenticate():
                    return None
            
            # Converter data e hora para datetime
            datetime_str = f"{date} {time_str}"
            start_time = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M")
            end_time = start_time + timedelta(minutes=duration)
            
            # Formatar para RFC3339
            start_rfc = start_time.isoformat() + 'Z'
            end_rfc = end_time.isoformat() + 'Z'
            
            # Criar evento no Google Calendar
            event = {
                'summary': title,
                'description': description,
                'start': {
                    'dateTime': start_rfc,
                    'timeZone': 'America/Sao_Paulo',
                },
                'end': {
                    'dateTime': end_rfc,
                    'timeZone': 'America/Sao_Paulo',
                },
                'conferenceData': {
                    'createRequest': {
                        'requestId': f"meet_{int(time.time())}",
                        'conferenceSolutionKey': {
                            'type': 'hangoutsMeet'
                        }
                    }
                }
            }
            
            # Inserir evento
            event = self.service.events().insert(
                calendarId='primary',
                body=event,
                conferenceDataVersion=1
            ).execute()
            
            # Extrair link do Google Meet
            meet_link = event.get('conferenceData', {}).get('entryPoints', [{}])[0].get('uri', '')
            
            return {
                'id': event['id'],
                'title': title,
                'date': date,
                'time': time_str,
                'duration': duration,
                'link': meet_link,
                'platform': 'google_meet',
                'created_by': 'Sistema',
                'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'status': 'scheduled',
                'google_event_id': event['id']
            }
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao criar reuni√£o no Google Meet:\n{str(e)}")
            return None

# New function to load all icons
def load_app_icons(base_dir):
    print("DEBUG: Iniciando load_app_icons")
    icons = {}
    # Helper function to load images safely within this scope
    def _load_image(filename, size):
        try:
            path = os.path.join(base_dir, filename)
            img = Image.open(path)
            return ImageTk.PhotoImage(img.resize(size))
        except FileNotFoundError:
            print(f"Erro: Arquivo de imagem n√£o encontrado: {filename}")
            return None # Return None or a placeholder image
        except Exception as e:
            print(f"Erro ao carregar imagem {filename}: {e}")
            return None

    small_icon_size = (16, 16)
    large_icon_size = (32, 32)

    # Load small icons (16x16) for menus and compact areas
    icons['logo_icon'] = _load_image("LOGO.png", (32, 32)) # Keep logo larger
    icons['add_icon'] = _load_image("Add.png", small_icon_size)
    icons['delete_icon'] = _load_image("Delete.png", small_icon_size)
    icons['save_icon'] = _load_image("Save.png", small_icon_size)
    icons['search_icon'] = _load_image("Search.png", small_icon_size)
    icons['key_icon'] = _load_image("Key.png", small_icon_size)
    icons['cancel_icon'] = _load_image("Cancel.png", small_icon_size)
    icons['up_icon'] = _load_image("Up.png", small_icon_size)
    icons['down_icon'] = _load_image("Down.png", small_icon_size)
    icons['back_icon'] = _load_image("Back.png", small_icon_size)
    icons['left_icon'] = _load_image("Left.png", small_icon_size)
    icons['right_icon'] = _load_image("Right.png", small_icon_size)
    icons['forward_icon'] = _load_image("Forward.png", small_icon_size)
    icons['ok_icon'] = _load_image("Ok.png", small_icon_size)
    icons['settings_icon'] = _load_image("Settings.png", small_icon_size)
    icons['exit_icon'] = _load_image("Exit.png", small_icon_size)
    icons['folder_icon'] = _load_image("Folder.png", small_icon_size)
    icons['pencil_icon'] = _load_image("Pencil.png", small_icon_size)
    icons['clear_icon'] = _load_image("Clear.png", small_icon_size)
    icons['apply_icon'] = _load_image("Apply.png", small_icon_size)
    icons['add_folder_icon'] = _load_image("Add folder.png", small_icon_size)
    icons['info_icon'] = _load_image("Info.png", small_icon_size)
    icons['play_icon'] = _load_image("Play.png", small_icon_size)
    icons['stop_icon'] = _load_image("Stop.png", small_icon_size)
    icons['refresh_icon'] = _load_image("Refresh.png", small_icon_size)
    icons['time_icon'] = _load_image("Time.png", small_icon_size)
    icons['import_icon'] = _load_image("Import.png", small_icon_size)
    icons['export_icon'] = _load_image("Export.png", small_icon_size)
    icons['registration_icon'] = _load_image("Registration.png", small_icon_size)
    icons['chart_xy_icon'] = _load_image("Chart xy.png", small_icon_size)
    icons['pie_chart_icon'] = _load_image("Pie chart.png", small_icon_size)
    icons['bar_chart_icon'] = _load_image("3d bar chart.png", small_icon_size)
    icons['objects_icon'] = _load_image("Objects.png", small_icon_size)
    icons['coffee_icon'] = _load_image("Coffee.png", small_icon_size)
    icons['chat_icon'] = _load_image("Info.png", small_icon_size)  # Usar Info como chat
    icons['calendar_icon'] = _load_image("Time.png", small_icon_size)  # Usar Time como calendar
    icons['copy_icon'] = _load_image("Apply.png", small_icon_size)  # Usar Apply como copy
    icons['meet_icon'] = _load_image("Play.png", small_icon_size)  # Usar Play como meet

    # Load large icons (32x32) for main action buttons
    icons['forward_icon_32'] = _load_image("Forward.png", large_icon_size)
    icons['open_file_icon_32'] = _load_image("Open file.png", large_icon_size)
    icons['refresh_icon_32'] = _load_image("Refresh.png", large_icon_size)
    icons['save_icon_32'] = _load_image("Save.png", large_icon_size)
    icons['cancel_icon_32'] = _load_image("Cancel.png", large_icon_size)

    return icons

# --- Helper Classes ---

class LoginWindow(tk.Toplevel):
    def __init__(self, parent, db, icons):
        super().__init__(parent)
        self.parent = parent
        self.db = db
        self.icons = icons
        
        print("DEBUG: LoginWindow.__init__ iniciado")
        
        self.title("Login - Sistema Boodesk")
        self.geometry("400x300")
        self.resizable(False, False)
        self.transient(parent)
        self.grab_set()
        self.protocol("WM_DELETE_WINDOW", self.cancel_login)

        # Centralizar a janela
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 400
        window_height = 300
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

        print("DEBUG: LoginWindow criando widgets...")
        self.create_widgets()
        
        # Focar no campo de usu√°rio
        self.user_entry.focus()
        
        # Garantir que a janela seja vis√≠vel
        self.after(100, self.ensure_visibility)
        print("DEBUG: LoginWindow criada com sucesso")

    def create_widgets(self):
        # Aumentar o tamanho da janela para acomodar todos os elementos
        self.geometry("500x450")
        
        main_frame = ttk.Frame(self, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configurar grid
        main_frame.columnconfigure(1, weight=1)
        
        # Logo e t√≠tulo
        logo_frame = ttk.Frame(main_frame)
        logo_frame.grid(row=0, column=0, columnspan=2, pady=(0, 20))
        
        if self.icons.get('logo_icon'):
            logo_label = ttk.Label(logo_frame, image=self.icons['logo_icon'])
            logo_label.pack(side=tk.LEFT, padx=(0, 10))
        
        title_label = ttk.Label(logo_frame, text="Sistema Boodesk", font=("Arial", 16, "bold"))
        title_label.pack(side=tk.LEFT)
        
        # Subt√≠tulo
        subtitle_label = ttk.Label(main_frame, text="Fa√ßa login para continuar", font=("Arial", 10))
        subtitle_label.grid(row=1, column=0, columnspan=2, pady=(0, 20))
        
        # Campo de usu√°rio
        ttk.Label(main_frame, text="Usu√°rio:", font=("Arial", 10, "bold")).grid(row=2, column=0, sticky="w", pady=5)
        self.user_entry = ttk.Entry(main_frame, font=("Arial", 11), width=25)
        self.user_entry.grid(row=2, column=1, sticky="ew", padx=(10, 0), pady=5)
        self.user_entry.insert(0, "admin")  # Preencher com admin por padr√£o
        self.user_entry.bind("<Return>", lambda e: self.password_entry.focus())
        
        # Campo de senha
        ttk.Label(main_frame, text="Senha:", font=("Arial", 10, "bold")).grid(row=3, column=0, sticky="w", pady=5)
        self.password_entry = ttk.Entry(main_frame, show="*", font=("Arial", 11), width=25)
        self.password_entry.grid(row=3, column=1, sticky="ew", padx=(10, 0), pady=5)
        self.password_entry.bind("<Return>", lambda e: self.check_login())
        
        # Frame dos bot√µes - Melhorado para garantir visibilidade
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=4, column=0, columnspan=2, pady=20, sticky="ew")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        
        # Bot√£o de login com √≠cone
        login_btn = ttk.Button(button_frame, text="üîê Entrar", 
                              command=self.check_login, style="Accent.TButton")
        login_btn.grid(row=0, column=0, padx=5, sticky="ew")
        
        # Bot√£o de cadastro com √≠cone
        register_btn = ttk.Button(button_frame, text="üìù Cadastrar", 
                                 command=self.open_user_registration)
        register_btn.grid(row=0, column=1, padx=5, sticky="ew")
        
        # Bot√£o cancelar com √≠cone
        cancel_btn = ttk.Button(button_frame, text="‚ùå Cancelar", 
                               command=self.cancel_login)
        cancel_btn.grid(row=0, column=2, padx=5, sticky="ew")
        
        # Informa√ß√µes de usu√°rios padr√£o
        info_frame = ttk.LabelFrame(main_frame, text="üë• Usu√°rios Padr√£o", padding="10")
        info_frame.grid(row=5, column=0, columnspan=2, pady=(10, 0), sticky="ew")
        
        info_text = """Usu√°rios padr√£o do sistema:
‚Ä¢ admin / admin123 (Administrador)
‚Ä¢ user / user123 (Usu√°rio)
‚Ä¢ manager / manager123 (Gerente)"""
        
        info_label = ttk.Label(info_frame, text=info_text, font=("Arial", 9), justify=tk.LEFT)
        info_label.pack()
        
        # Centralizar a janela novamente ap√≥s ajustar o tamanho
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 500
        window_height = 450
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

    def check_login(self):
        username = self.user_entry.get().strip()
        password = self.password_entry.get()
        
        if not username or not password:
            messagebox.showerror("Erro", "Por favor, preencha todos os campos!")
            return
        
        user_data = self.db.get_user_by_username(username)
        
        if user_data and user_data['password_hash'] == password:
            user = User(
                username=user_data['username'],
                role=user_data['role'],
                cargo=user_data['cargo'],
                user_id=user_data['id']
            )
            user.is_authenticated = True
            user.login_time = datetime.now()
            
            self.parent.login_successful = True
            self.parent.current_user = user
            messagebox.showinfo("Login Bem-sucedido", f"Bem-vindo, {user.username}!\nN√≠vel de acesso: {user.cargo}")
            self.destroy()
        else:
            messagebox.showerror("Erro de Login", "Usu√°rio ou senha incorretos!")
            self.password_entry.delete(0, tk.END)
            self.password_entry.focus()

    def open_user_registration(self):
        """Abre a janela de cadastro de usu√°rios"""
        UserRegistrationWindow(self, self.db, self.icons)

    def ensure_visibility(self):
        """Garante que a janela seja vis√≠vel"""
        print("DEBUG: ensure_visibility chamado")
        self.lift()
        self.focus_force()
        self.deiconify()
        self.update()
        print("DEBUG: Janela de login deve estar vis√≠vel agora")
        
    def on_user_keypress(self, event):
        """Trata teclas no campo usu√°rio"""
        if event.keysym == 'Return':
            print("DEBUG: Enter pressionado no campo usu√°rio")
            self.password_entry.focus()
            return "break"
        elif event.keysym == 'Tab':
            # Permitir navega√ß√£o com Tab
            return None
    
    def on_password_keypress(self, event):
        """Trata teclas no campo senha"""
        if event.keysym == 'Return':
            print("DEBUG: Enter pressionado no campo senha")
            self.check_login()
            return "break"
        elif event.keysym == 'Tab':
            # Permitir navega√ß√£o com Tab
            return None
            return "break"
        elif event.keysym == 'Tab':
            # Permitir navega√ß√£o com Tab
            return None
    
    def cancel_login(self):
        self.parent.login_successful = False
        self.destroy()

class UserRegistrationWindow(tk.Toplevel):
    def __init__(self, parent, db, icons, app=None, preselected_member_id=None):
        try:
            super().__init__(parent)
            self.parent = parent
            self.db = db
            self.icons = icons
            self.app = app
            self.preselected_member_id = preselected_member_id
            
            print("DEBUG: Inicializando UserRegistrationWindow...")
            
            self.title("Cadastro de Usu√°rios")
            self.geometry("700x500")
            self.resizable(True, True)
            self.transient(parent)
            self.grab_set()
            
            # Centralizar a janela
            self.update_idletasks()
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()
            window_width = 700
            window_height = 500
            x = (screen_width - window_width) // 2
            y = (screen_height - window_height) // 2
            self.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            # Vari√°veis para edi√ß√£o
            self.edit_mode = False
            self.selected_user_id = None
            
            print("DEBUG: Criando widgets...")
            self.create_widgets()
            
            print("DEBUG: Populando lista de usu√°rios...")
            self.populate_users_list()
            
            print("DEBUG: UserRegistrationWindow inicializada com sucesso!")
            
        except Exception as e:
            print(f"DEBUG: Erro ao inicializar UserRegistrationWindow: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir a tela de gerenciar usu√°rios: {e}")
            self.destroy()
    
    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configurar grid
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # T√≠tulo
        title_label = ttk.Label(main_frame, text="Gerenciamento de Usu√°rios", font=("Arial", 14, "bold"))
        title_label.grid(row=0, column=0, pady=(0, 10))
        
        # Frame da lista de usu√°rios
        list_frame = ttk.LabelFrame(main_frame, text="Lista de Usu√°rios", padding="5")
        list_frame.grid(row=1, column=0, sticky="nsew", pady=(0, 10))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        # Treeview para lista de usu√°rios
        columns = ("ID", "Usu√°rio", "Cargo", "Role", "Criado em", "√öltimo Login")
        self.users_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=8)
        
        # Configurar colunas
        self.users_tree.heading("ID", text="ID")
        self.users_tree.heading("Usu√°rio", text="Usu√°rio")
        self.users_tree.heading("Cargo", text="Cargo")
        self.users_tree.heading("Role", text="N√≠vel de Acesso")
        self.users_tree.heading("Criado em", text="Criado em")
        self.users_tree.heading("√öltimo Login", text="√öltimo Login")
        
        self.users_tree.column("ID", width=50, anchor="center")
        self.users_tree.column("Usu√°rio", width=120, anchor="w")
        self.users_tree.column("Cargo", width=100, anchor="w")
        self.users_tree.column("Role", width=100, anchor="w")
        self.users_tree.column("Criado em", width=120, anchor="w")
        self.users_tree.column("√öltimo Login", width=120, anchor="w")
        
        self.users_tree.grid(row=0, column=0, sticky="nsew", pady=5)
        self.users_tree.bind("<<TreeviewSelect>>", self.on_user_select)
        
        # Scrollbar para a lista
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.users_tree.yview)
        scrollbar.grid(row=0, column=1, sticky="ns")
        self.users_tree.config(yscrollcommand=scrollbar.set)
        
        # Frame do formul√°rio
        form_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Usu√°rio", padding="10")
        form_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        form_frame.columnconfigure(1, weight=1)
        
        # Campos do formul√°rio
        ttk.Label(form_frame, text="Usu√°rio:").grid(row=0, column=0, sticky="w", pady=2)
        self.username_entry = ttk.Entry(form_frame)
        self.username_entry.grid(row=0, column=1, sticky="ew", padx=(5, 0), pady=2)
        
        ttk.Label(form_frame, text="Senha:").grid(row=1, column=0, sticky="w", pady=2)
        self.password_entry = ttk.Entry(form_frame, show="*")
        self.password_entry.grid(row=1, column=1, sticky="ew", padx=(5, 0), pady=2)
        
        ttk.Label(form_frame, text="Cargo:").grid(row=2, column=0, sticky="w", pady=2)
        self.cargo_combo = ttk.Combobox(form_frame, state="readonly")
        try:
            if self.app and hasattr(self.app, 'settings') and 'roles' in self.app.settings:
                self.cargo_combo['values'] = list(self.app.settings['roles'].keys())
        except Exception:
            pass
        if not self.cargo_combo['values']:
            self.cargo_combo['values'] = ["Usu√°rio", "Administrador", "Manager"]
        self.cargo_combo.set(self.cargo_combo['values'][0])
        self.cargo_combo.grid(row=2, column=1, sticky="ew", padx=(5, 0), pady=2)
        cargo_btn = ttk.Button(form_frame, text="Cadastrar Cargo", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self._open_roles_settings_from_users)
        cargo_btn.grid(row=2, column=2, padx=5, pady=2, sticky="w")
        
        ttk.Label(form_frame, text="N√≠vel de Acesso:").grid(row=3, column=0, sticky="w", pady=2)
        self.role_combo = ttk.Combobox(form_frame, values=["user", "manager", "admin"], state="readonly")
        self.role_combo.set("user")
        self.role_combo.grid(row=3, column=1, sticky="ew", padx=(5, 0), pady=2)
        
        ttk.Label(form_frame, text="Membro:").grid(row=4, column=0, sticky="w", pady=2)
        self.member_combo = ttk.Combobox(form_frame, state="readonly")
        self.member_combo.grid(row=4, column=1, sticky="ew", padx=(5, 0), pady=2)
        member_btn = ttk.Button(form_frame, text="Cadastrar Membro", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self._open_members_window_from_users)
        member_btn.grid(row=4, column=2, padx=5, pady=2, sticky="w")
        self.populate_members_combo()
        
        # Frame dos bot√µes do formul√°rio
        form_buttons_frame = ttk.Frame(form_frame)
        form_buttons_frame.grid(row=5, column=0, columnspan=2, pady=10)
        form_buttons_frame.columnconfigure(0, weight=1)
        form_buttons_frame.columnconfigure(1, weight=1)
        
        ttk.Button(form_buttons_frame, text="Adicionar Usu√°rio", 
                  image=self.icons.get('add_icon'), compound=tk.LEFT, 
                  command=self.add_user).grid(row=0, column=0, padx=2)
        
        ttk.Button(form_buttons_frame, text="Limpar", 
                  image=self.icons.get('clear_icon'), compound=tk.LEFT, 
                  command=self.clear_form).grid(row=0, column=1, padx=2)
        
        # Frame dos bot√µes de a√ß√£o
        action_frame = ttk.Frame(main_frame)
        action_frame.grid(row=3, column=0, pady=5)
        
        ttk.Button(action_frame, text="Editar Usu√°rio", 
                  image=self.icons.get('edit_icon'), compound=tk.LEFT, 
                  command=self.edit_user).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(action_frame, text="Remover Usu√°rio", 
                  image=self.icons.get('delete_icon'), compound=tk.LEFT, 
                  command=self.remove_user).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(action_frame, text="Atualizar Lista", 
                  image=self.icons.get('refresh_icon'), compound=tk.LEFT, 
                  command=self.populate_users_list).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(action_frame, text="Fechar", 
                  image=self.icons.get('cancel_icon'), compound=tk.LEFT, 
                  command=self.destroy).pack(side=tk.LEFT, padx=5)
    
    def populate_members_combo(self):
        """Popula o combo de membros"""
        try:
            import sqlite3
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("SELECT id, name, email FROM members ORDER BY name")
            members = cursor.fetchall()
            conn.close()
            
            # Criar lista de membros para o combo
            member_list = []
            self.member_dict = {}  # Dicion√°rio para mapear nome -> id
            
            for member_id, name, email in members:
                # Tratar email nulo ou vazio
                if email is None or email == '' or email == 'nan':
                    display_name = f"{name} (sem email)"
                else:
                    display_name = f"{name} ({email})"
                
                member_list.append(display_name)
                self.member_dict[display_name] = member_id
            
            self.member_combo['values'] = member_list
            if member_list:
                if self.preselected_member_id and self.preselected_member_id in self.member_dict.values():
                    for display_name, mid in self.member_dict.items():
                        if mid == self.preselected_member_id:
                            self.member_combo.set(display_name)
                            break
                else:
                    self.member_combo.set(member_list[0])
            
        except Exception as e:
            print(f"DEBUG: Erro ao popular combo de membros: {e}")

    def _open_roles_settings_from_users(self):
        """Abre a aba de cargos das configura√ß√µes a partir da tela de usu√°rios"""
        try:
            if not self.app:
                messagebox.showerror("Erro", "Aplica√ß√£o n√£o dispon√≠vel para abrir Cargos.")
                return
            # Abrir configura√ß√µes normalmente
            settings_window = SettingsWindow(self.master, self.app)
            self.master.wait_window(settings_window)
            # Atualizar lista de cargos ap√≥s fechar as configura√ß√µes
            if self.app and hasattr(self.app, 'settings') and 'roles' in self.app.settings:
                if hasattr(self, 'cargo_combo') and self.cargo_combo:
                    self.cargo_combo['values'] = list(self.app.settings['roles'].keys())
                    if self.cargo_combo.get() not in self.cargo_combo['values'] and self.cargo_combo['values']:
                        self.cargo_combo.set(self.cargo_combo['values'][0])
        except Exception as e:
            print(f"DEBUG: Erro ao abrir configura√ß√µes de cargos pela tela de usu√°rios: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir as configura√ß√µes de cargos: {e}")

    def _open_members_window_from_users(self):
        """Abre a janela de gerenciamento de membros a partir da tela de usu√°rios"""
        try:
            if not self.app:
                messagebox.showerror("Erro", "Aplica√ß√£o n√£o dispon√≠vel para abrir Membros.")
                return
            
            # Abrir janela de membros
            members_window = MembersWindow(self.master, self.app)
            self.master.wait_window(members_window)
            
            # Atualizar lista de membros ap√≥s fechar a janela
            self.populate_members_combo()
            
        except Exception as e:
            print(f"DEBUG: Erro ao abrir janela de membros pela tela de usu√°rios: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir a janela de membros: {e}")
    
    def populate_users_list(self):
        """Popula a lista de usu√°rios"""
        try:
            print("DEBUG: Populando lista de usu√°rios...")
            
            # Limpar lista atual
            for item in self.users_tree.get_children():
                self.users_tree.delete(item)
            
            # Usar o banco de dados SQLite diretamente
            import sqlite3
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            # Carregar usu√°rios
            cursor.execute("SELECT id, username, cargo, role, created_at, updated_at FROM users ORDER BY id")
            users = cursor.fetchall()
            conn.close()
            
            print(f"DEBUG: {len(users)} usu√°rios encontrados")
            
            for user in users:
                try:
                    user_id, username, cargo, role, created_at, updated_at = user
                    
                    # Formatar data de cria√ß√£o
                    if created_at:
                        try:
                            created_at = datetime.strptime(created_at, '%Y-%m-%d %H:%M:%S.%f').strftime('%d/%m/%Y %H:%M')
                        except:
                            created_at = created_at[:19] if len(created_at) > 19 else created_at
                    else:
                        created_at = "N/A"

                    # Formatar data de √∫ltimo login (usar updated_at como aproxima√ß√£o)
                    if updated_at:
                        try:
                            last_login = datetime.strptime(updated_at, '%Y-%m-%d %H:%M:%S.%f').strftime('%d/%m/%Y %H:%M')
                        except:
                            last_login = updated_at[:19] if len(updated_at) > 19 else updated_at
                    else:
                        last_login = "Nunca"

                    self.users_tree.insert("", "end", values=(
                        user_id,
                        username,
                        cargo,
                        role,
                        created_at,
                        last_login
                    ))
                except Exception as e:
                    print(f"DEBUG: Erro ao processar usu√°rio {user}: {e}")
                    continue
            
            print("DEBUG: Lista de usu√°rios populada com sucesso!")
            
        except Exception as e:
            print(f"DEBUG: Erro ao popular lista de usu√°rios: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel carregar a lista de usu√°rios: {e}")
    
    def on_user_select(self, event):
        """Manipula sele√ß√£o de usu√°rio na lista"""
        selected_item = self.users_tree.selection()
        if selected_item:
            values = self.users_tree.item(selected_item, "values")
            self.selected_user_id = int(values[0])
            
            # Preencher formul√°rio para edi√ß√£o
            self.username_entry.delete(0, tk.END)
            self.username_entry.insert(0, values[1])
            
            if hasattr(self, 'cargo_combo') and self.cargo_combo['values']:
                if values[2] in self.cargo_combo['values']:
                    self.cargo_combo.set(values[2])
                else:
                    try:
                        self.cargo_combo['values'] = list(dict.fromkeys([values[2], *self.cargo_combo['values']]))
                        self.cargo_combo.set(values[2])
                    except Exception:
                        pass
            
            self.role_combo.set(values[3])
            
            # Buscar e preencher o membro associado
            try:
                import sqlite3
                conn = sqlite3.connect('boodesk_new.db')
                cursor = conn.cursor()
                cursor.execute("SELECT member_id FROM users WHERE id = ?", (self.selected_user_id,))
                result = cursor.fetchone()
                conn.close()
                
                if result and result[0]:
                    member_id = result[0]
                    # Encontrar o membro no combo
                    for display_name, mid in self.member_dict.items():
                        if mid == member_id:
                            self.member_combo.set(display_name)
                            break
            except Exception as e:
                print(f"DEBUG: Erro ao buscar membro associado: {e}")
            
            # Limpar senha (n√£o mostrar senha atual)
            self.password_entry.delete(0, tk.END)
            
            self.edit_mode = True
        else:
            self.edit_mode = False
            self.selected_user_id = None
    
    def add_user(self):
        """Adiciona um novo usu√°rio"""
        username = self.username_entry.get().strip()
        password = self.password_entry.get()
        cargo = self.cargo_combo.get().strip()
        role = self.role_combo.get()
        member_selection = self.member_combo.get()
        
        if not username or not password or not cargo or not member_selection:
            messagebox.showerror("Erro", "Todos os campos s√£o obrigat√≥rios!")
            return
        
        # Obter o ID do membro selecionado
        member_id = self.member_dict.get(member_selection)
        if not member_id:
            messagebox.showerror("Erro", "Selecione um membro v√°lido!")
            return
        
        # Usar o banco de dados SQLite diretamente
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            # Verificar se usu√°rio j√° existe
            cursor.execute("SELECT id FROM users WHERE username = ?", (username,))
            if cursor.fetchone():
                messagebox.showerror("Erro", "Usu√°rio j√° existe")
                conn.close()
                return
            
            # Inserir novo usu√°rio
            cursor.execute("""
                INSERT INTO users (username, password_hash, email, role, cargo, member_id, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (username, password, "", role, cargo, member_id, datetime.now(), datetime.now()))
            
            conn.commit()
            conn.close()
            
            messagebox.showinfo("Sucesso", "Usu√°rio registrado com sucesso")
            self.clear_form()
            self.populate_users_list()
            
        except Exception as e:
            print(f"DEBUG: Erro ao adicionar usu√°rio: {e}")
            messagebox.showerror("Erro", f"Erro ao registrar usu√°rio: {e}")
    
    def edit_user(self):
        """Edita um usu√°rio selecionado"""
        if not self.edit_mode or not self.selected_user_id:
            messagebox.showwarning("Aviso", "Selecione um usu√°rio para editar!")
            return
        
        username = self.username_entry.get().strip()
        password = self.password_entry.get()
        cargo = self.cargo_combo.get().strip()
        role = self.role_combo.get()
        member_selection = self.member_combo.get()
        
        if not username or not cargo or not member_selection:
            messagebox.showerror("Erro", "Usu√°rio, cargo e membro s√£o obrigat√≥rios!")
            return
        
        # Obter o ID do membro selecionado
        member_id = self.member_dict.get(member_selection)
        if not member_id:
            messagebox.showerror("Erro", "Selecione um membro v√°lido!")
            return
        
        # Usar o banco de dados SQLite diretamente
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            # Atualizar usu√°rio
            if password:  # Se senha foi fornecida, atualizar
                cursor.execute("""
                    UPDATE users SET username = ?, password_hash = ?, role = ?, cargo = ?, member_id = ?, updated_at = ?
                    WHERE id = ?
                """, (username, password, role, cargo, member_id, datetime.now(), self.selected_user_id))
            else:  # Se n√£o, manter senha atual
                cursor.execute("""
                    UPDATE users SET username = ?, role = ?, cargo = ?, member_id = ?, updated_at = ?
                    WHERE id = ?
                """, (username, role, cargo, member_id, datetime.now(), self.selected_user_id))
            
            conn.commit()
            conn.close()
            
            messagebox.showinfo("Sucesso", "Usu√°rio atualizado com sucesso")
            self.clear_form()
            self.populate_users_list()
            
        except Exception as e:
            print(f"DEBUG: Erro ao editar usu√°rio: {e}")
            messagebox.showerror("Erro", f"Erro ao atualizar usu√°rio: {e}")
    
    def remove_user(self):
        """Remove um usu√°rio selecionado"""
        if not self.edit_mode or not self.selected_user_id:
            messagebox.showwarning("Aviso", "Selecione um usu√°rio para remover!")
            return
        
        username = self.username_entry.get()
        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover o usu√°rio '{username}'?"):
            # Usar o banco de dados SQLite diretamente
            try:
                import sqlite3
                
                conn = sqlite3.connect('boodesk_new.db')
                cursor = conn.cursor()
                
                # Remover usu√°rio
                cursor.execute("DELETE FROM users WHERE id = ?", (self.selected_user_id,))
                
                conn.commit()
                conn.close()
                
                messagebox.showinfo("Sucesso", "Usu√°rio removido com sucesso")
                self.clear_form()
                self.populate_users_list()
                
            except Exception as e:
                print(f"DEBUG: Erro ao remover usu√°rio: {e}")
                messagebox.showerror("Erro", f"Erro ao remover usu√°rio: {e}")

    def clear_form(self):
        """Limpa o formul√°rio"""
        self.username_entry.delete(0, tk.END)
        self.password_entry.delete(0, tk.END)
        if hasattr(self, 'cargo_combo') and self.cargo_combo['values']:
            self.cargo_combo.set(self.cargo_combo['values'][0])
        self.role_combo.set("user")
        if hasattr(self, 'member_combo') and self.member_combo['values']:
            self.member_combo.set(self.member_combo['values'][0])
        self.edit_mode = False
        self.selected_user_id = None
        self.users_tree.selection_remove(*self.users_tree.selection())


class NumericEntryWithButtons(tk.Frame):
    def __init__(self, parent, icons, initial_value=0.00, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self._value = initial_value # Store as float internally

        self.entry = ttk.Entry(self, width=15, justify='right')
        self.entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.entry.bind("<FocusOut>", self._on_focus_out)
        self.entry.bind("<FocusIn>", self._on_focus_in)
        self.entry.bind("<KeyRelease>", self._on_key_release)

        self.up_button = ttk.Button(self, image=icons.get('up_icon'), width=2, command=self._increment)
        self.up_button.pack(side=tk.LEFT, padx=1)
        self.down_button = ttk.Button(self, image=icons.get('down_icon'), width=2, command=self._decrement)
        self.down_button.pack(side=tk.LEFT, padx=1)

        self._format_display() # Initial display

    def _format_display(self):
        # Formats the internal float value (dot) to display string (comma)
        display_text = f"{self._value:.2f}".replace('.', ',')
        self.entry.delete(0, tk.END)
        self.entry.insert(0, display_text)

    def _on_focus_in(self, event):
        # When focused, convert display string (comma) to internal float string (dot) for editing
        current_text = self.entry.get().replace(',', '.')
        try:
            val = float(current_text)
            self.entry.delete(0, tk.END)
            self.entry.insert(0, str(val)) # Show with dot for editing
        except ValueError:
            self.entry.delete(0, tk.END)
            self.entry.insert(0, "0.00") # Reset if invalid

    def _on_focus_out(self, event):
        # When focus leaves, update internal value from entry and re-apply display format
        self._update_value_from_entry()
        self._format_display()

    def _on_key_release(self, event):
        # Live update of internal value as user types, but don't reformat display yet
        self._update_value_from_entry(live_update=True) # Pass a flag for live update

    def _update_value_from_entry(self, live_update=False):
        current_text = self.entry.get().replace(',', '.')
        try:
            val = float(current_text)
            self._value = val
        except ValueError:
            # If invalid input during live typing, don't change the internal value
            # unless it's on focus out, then reset to 0.00
            if not live_update:
                self._value = 0.00
                self.entry.delete(0, tk.END)
                self.entry.insert(0, "0.00")

    def _increment(self):
        self._update_value_from_entry() # Ensure value is up-to-date
        self._value += 1.00 # Increment by 1.00
        self._format_display()

    def _decrement(self):
        self._update_value_from_entry() # Ensure value is up-to-date
        self._value -= 1.00 # Decrement by 1.00
        self._format_display()

    def get(self):
        self._update_value_from_entry() # Ensure value is up-to-date before returning
        return self._value

    def set(self, new_value):
        self._value = new_value
        self._format_display()

class DatePickerDialog(tk.Toplevel):
    def __init__(self, parent, current_date=None, icons=None):
        super().__init__(parent)
        self.parent = parent
        self.result_date = None
        self.title("Selecionar Data")
        self.transient(parent)
        self.grab_set()

        if icons:
            self.icons = icons # Store the icons dictionary
            

        if current_date:
            try:
                self.current_date = datetime.strptime(current_date, "%Y-%m-%d")
            except ValueError:
                self.current_date = datetime.now()
        else:
            self.current_date = datetime.now()

        self.create_widgets()
        self.update_calendar()

        # Center the dialog
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')

    def create_widgets(self):
        # Navigation Frame
        nav_frame = ttk.Frame(self)
        nav_frame.pack(pady=5)

        ttk.Button(nav_frame, image=self.icons.get('back_icon'), command=self.prev_year).pack(side=tk.LEFT)
        ttk.Button(nav_frame, image=self.icons.get('left_icon'), command=self.prev_month).pack(side=tk.LEFT)
        
        self.month_year_label = ttk.Label(nav_frame, text="", width=20, anchor="center")
        self.month_year_label.pack(side=tk.LEFT, padx=10)

        ttk.Button(nav_frame, image=self.icons.get('right_icon'), command=self.next_month).pack(side=tk.LEFT)
        ttk.Button(nav_frame, image=self.icons.get('forward_icon'), command=self.next_year).pack(side=tk.LEFT)

        # Day Labels (Sun, Mon, etc.)
        days_frame = ttk.Frame(self)
        days_frame.pack()
        for i, day in enumerate(["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S√°b"]):
            ttk.Label(days_frame, text=day, width=4, anchor="center").grid(row=0, column=i, padx=1, pady=1)

        # Calendar Grid
        self.calendar_frame = ttk.Frame(self)
        self.calendar_frame.pack()

        # OK/Cancel Buttons
        button_frame = ttk.Frame(self)
        button_frame.pack(pady=5)
        ttk.Button(button_frame, text="OK", image=self.icons.get('ok_icon'), compound=tk.LEFT, command=self.ok).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancelar", image=self.icons.get('cancel_icon'), compound=tk.LEFT, command=self.cancel).pack(side=tk.LEFT, padx=5)

    def update_calendar(self):
        for widget in self.calendar_frame.winfo_children():
            widget.destroy()

        self.month_year_label.config(text=self.current_date.strftime("%B %Y"))

        first_day_of_month = self.current_date.replace(day=1)
        # weekday() returns 0 for Monday, 6 for Sunday. We want 0 for Sunday.
        start_day_offset = (first_day_of_month.weekday() + 1) % 7 

        days_in_month = (self.current_date.replace(month=self.current_date.month % 12 + 1, day=1) - timedelta(days=1)).day

        for day_num in range(1, days_in_month + 1):
            row = (start_day_offset + day_num - 1) // 7
            col = (start_day_offset + day_num - 1) % 7
            
            date_to_check = self.current_date.replace(day=day_num)
            btn = ttk.Button(self.calendar_frame, text=str(day_num), width=4,
                             command=partial(self.select_date, date_to_check))
            btn.grid(row=row, column=col, padx=1, pady=1)

            if date_to_check.date() == datetime.now().date():
                btn.config(style="TButton") # Default style
            elif date_to_check.date() == self.current_date.date(): # Selected month, but not necessarily selected day
                btn.config(style="Accent.TButton") # Highlight current month days

    def prev_month(self):
        self.current_date = self.current_date.replace(day=1) - timedelta(days=1)
        self.update_calendar()

    def next_month(self):
        if self.current_date.month == 12:
            self.current_date = self.current_date.replace(year=self.current_date.year + 1, month=1, day=1)
        else:
            self.current_date = self.current_date.replace(month=self.current_date.month + 1, day=1)
        self.update_calendar()

    def prev_year(self):
        self.current_date = self.current_date.replace(year=self.current_date.year - 1)
        self.update_calendar()

    def next_year(self):
        self.current_date = self.current_date.replace(year=self.current_date.year + 1)
        self.update_calendar()

    def select_date(self, date):
        self.result_date = date
        self.ok()

    def ok(self):
        self.parent.focus_set()
        self.destroy()

    def cancel(self):
        self.result_date = None
        self.parent.focus_set()
        self.destroy()


class SubtaskEditorWindow(tk.Toplevel):
    def __init__(self, parent, app, card, subtask):
        super().__init__(parent)
        self.app = app
        self.card = card
        self.subtask = subtask

        self.title(f"Editar Subtarefa")
        self.transient(parent)
        self.grab_set()
        self.geometry("450x350")

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text=f"Tarefa Principal: {self.card.get('title', '')}").pack(anchor="w")
        ttk.Label(main_frame, text=f"Subtarefa: {self.subtask.get('text', '')}").pack(anchor="w", pady=(0, 10))

        ttk.Label(main_frame, text="Descri√ß√£o da Subtarefa:").pack(anchor="w", pady=(0, 5))
        self.desc_text = tk.Text(main_frame, wrap=tk.WORD, height=10)
        self.desc_text.pack(fill=tk.BOTH, expand=True)
        self.desc_text.insert("1.0", self.subtask.get("desc", ""))

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))

        ttk.Button(button_frame, text="Salvar", image=self.app.icons.get('save_icon_32'), compound=tk.LEFT, command=self.save_and_close).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", image=self.app.icons.get('cancel_icon_32'), compound=tk.LEFT, command=self.destroy).pack(side=tk.RIGHT)

    def save_and_close(self):
        new_desc = self.desc_text.get("1.0", tk.END).strip()
        self.subtask["desc"] = new_desc
        self.app.save_trello_data()
        if hasattr(self.app, 'activities_tree'):
            self.app.update_my_activities_tab()
        self.app.populate_boards()
        self.destroy()




class ThemeSettingsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Configurar Tema")
        self.geometry("350x150")
        self.transient(parent)
        self.grab_set()

        # Centralizar
        self.update_idletasks()
        x = parent.winfo_x() + (parent.winfo_width() // 2) - (self.winfo_width() // 2)
        y = parent.winfo_y() + (parent.winfo_height() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Escolha um tema para a aplica√ß√£o:").pack(anchor="w", pady=5)

        # Combobox com temas
        self.theme_var = tk.StringVar()
        self.theme_combo = ttk.Combobox(main_frame, textvariable=self.theme_var, state="readonly")
        
        # Carregar temas dispon√≠veis
        available_themes = sorted(self.app.root.get_themes())
        self.theme_combo['values'] = available_themes
        
        # Definir tema atual
        current_theme = self.app.db.get_setting('theme', default='arc', user_id=self.app.current_user.user_id)
        if current_theme in available_themes:
            self.theme_combo.set(current_theme)
        else:
            self.theme_combo.set('arc')

        self.theme_combo.pack(fill=tk.X, pady=5)

        # Bot√µes
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Salvar", command=self.save_theme).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.destroy).pack(side=tk.RIGHT)

    def save_theme(self):
        selected_theme = self.theme_var.get()
        if not selected_theme:
            messagebox.showwarning("Nenhum Tema", "Por favor, selecione um tema.", parent=self)
            return

        try:
            # Salvar no banco de dados
            self.app.db.save_setting('theme', selected_theme, user_id=self.app.current_user.user_id)
            
            # Aplicar o tema imediatamente
            self.app.root.set_theme(selected_theme)
            
            messagebox.showinfo("Sucesso", f"Tema '{selected_theme}' aplicado com sucesso!", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel salvar ou aplicar o tema: {e}", parent=self)


class ThemeSettingsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Configurar Tema")
        self.geometry("350x150")
        self.transient(parent)
        self.grab_set()

        # Centralizar
        self.update_idletasks()
        x = parent.winfo_x() + (parent.winfo_width() // 2) - (self.winfo_width() // 2)
        y = parent.winfo_y() + (parent.winfo_height() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Escolha um tema para a aplica√ß√£o:").pack(anchor="w", pady=5)

        # Combobox com temas
        self.theme_var = tk.StringVar()
        self.theme_combo = ttk.Combobox(main_frame, textvariable=self.theme_var, state="readonly")
        
        # Carregar temas dispon√≠veis
        available_themes = sorted(self.app.root.get_themes())
        self.theme_combo['values'] = available_themes
        
        # Definir tema atual
        current_theme = self.app.db.get_setting('theme', default='arc', user_id=self.app.current_user.user_id)
        if current_theme in available_themes:
            self.theme_combo.set(current_theme)
        else:
            self.theme_combo.set('arc')

        self.theme_combo.pack(fill=tk.X, pady=5)

        # Bot√µes
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Salvar", command=self.save_theme).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.destroy).pack(side=tk.RIGHT)

    def save_theme(self):
        selected_theme = self.theme_var.get()
        if not selected_theme:
            messagebox.showwarning("Nenhum Tema", "Por favor, selecione um tema.", parent=self)
            return

        try:
            # Salvar no banco de dados
            self.app.db.save_setting('theme', selected_theme, user_id=self.app.current_user.user_id)
            
            # Aplicar o tema imediatamente
            self.app.root.set_theme(selected_theme)
            
            messagebox.showinfo("Sucesso", f"Tema '{selected_theme}' aplicado com sucesso!", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel salvar ou aplicar o tema: {e}", parent=self)


class DraggableTreeview:
    def __init__(self, treeview, app, board_name, list_name):
        self.treeview = treeview
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self.treeview.bind("<ButtonPress-1>", self.on_drag_start)
        self.treeview.bind("<B1-Motion>", self.on_drag_motion)
        self.treeview.bind("<ButtonRelease-1>", self.on_drag_release)
        self._drag_data = {"item": None, "x": 0, "y": 0, "card_id": None, "source_treeview": None}
        self._drag_widget = None

    def on_drag_start(self, event):
        item_id = self.treeview.identify_row(event.y)
        if not item_id or self.treeview.parent(item_id):  # Don't drag child items
            return

        self.treeview.selection_set(item_id)
        self._drag_data["item"] = item_id
        self._drag_data["x"] = event.x
        self._drag_data["y"] = event.y
        self._drag_data["source_treeview"] = self.treeview

        # Get card_id from the tags
        self._drag_data["card_id"] = self.treeview.item(item_id, "tags")[0]

        # Create a temporary drag widget
        x, y, width, height = self.treeview.bbox(item_id)
        display_text = self.treeview.item(item_id, "values")[0] # Get the title
        self._drag_widget = tk.Label(self.treeview, text=display_text, background="lightblue", relief="raised", borderwidth=1)
        self._drag_widget.place(x=x, y=y, width=width, height=height)

    def on_drag_motion(self, event):
        if self._drag_widget:
            x = self.treeview.winfo_x() + event.x - self._drag_data["x"]
            y = self.treeview.winfo_y() + event.y - self._drag_data["y"]
            self._drag_widget.place(x=x, y=y)

    def on_drag_release(self, event):
        if self._drag_widget:
            self._drag_widget.destroy()
            self._drag_widget = None

        if not self._drag_data["item"] or not self._drag_data["card_id"]:
            return

        target_widget = event.widget.winfo_containing(event.x_root, event.y_root)
        
        target_treeview = None
        target_list_name = None
        target_board_name = None

        for (b_name, l_name), tv_widget in self.app.listbox_refs.items(): # listbox_refs now holds treeview refs
            if tv_widget == target_widget:
                target_treeview = tv_widget
                target_list_name = l_name
                target_board_name = b_name
                break

        if target_treeview and target_list_name and target_board_name:
            if target_board_name != self.board_name or target_list_name != self.list_name:
                # Move card data in the backend
                self.app.move_card_data(self.board_name, self.list_name, self._drag_data["card_id"],
                                        target_board_name, target_list_name)
            # If dropped in the same list, no action needed as order is not managed by drag-and-drop yet
        
        self._drag_data = {"item": None, "x": 0, "y": 0, "card_id": None, "source_treeview": None}

class TrelloApp:
    def load_and_apply_user_theme(self):
        """Carrega e aplica o tema do usu√°rio a partir do banco de dados."""
        if self.current_user and self.current_user.user_id:
            # Usar 'arc' como tema padr√£o se nenhum for encontrado
            theme = self.db.get_setting('theme', default='arc', user_id=self.current_user.user_id)
            try:
                self.root.set_theme(theme)
            except Exception as e:
                print(f"Erro ao aplicar o tema '{theme}': {e}")
                # Se o tema salvo for inv√°lido, aplicar o padr√£o
                try:
                    self.root.set_theme("arc")
                except Exception as e_arc:
                    print(f"Erro ao aplicar o tema padr√£o 'arc': {e_arc}")

    def open_theme_settings(self):
        ThemeSettingsWindow(self.root, self)

    def __init__(self, root):
        self.root = root
        self.db = Database('boodesk_new.db')
        self.db.create_tables()
        self.current_user = None
        self.login_successful = False
        self.boodesk_data = {'boards': {}}
        self.icons = load_app_icons(os.path.dirname(os.path.abspath(__file__)))
        self.listbox_refs = {}
        self.theme_color = "#0079BF"
        self.pomodoro_timer = None
        self.pomodoro_running = False
        self.pomodoro_start_time = None
        self.pomodoro_session_type = "work" # "work" or "break"
        self.pomodoro_work_duration = 25 * 60
        self.pomodoro_break_duration = 5 * 60
        self.pomodoro_task = None
        self.notification_manager = NotificationManager(self)
        self.meeting_integration = GoogleCalendarManager()
        self.email_integration = EmailIntegration(self)
        self.settings = self.load_settings()
        
        self.root.title("Boodesk - Sistema de Gerenciamento de Tarefas")
        self.root.geometry("1200x800")
        
        self.show_login_window()
        
        if self.login_successful:
            self.load_and_apply_user_theme()
            self.load_and_apply_user_theme()
            self.create_main_widgets()
            self.load_trello_data()
            self.populate_boards()
            self.notification_manager.start_notification_monitor()
            self.email_integration.start_email_service()
        else:
            self.root.destroy()


    # Removed load_data_from_db method - now using load_trello_data which loads from SQL

    def add_card(self, board_name, list_name, card_title, card_desc, card_due_date, card_importance, subject="-", goal="-", members=None, git_branch="", git_commit="", recurrence="Nenhuma", dependencies=None):
        """Add card directly to SQL database"""
        try:
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Get or create board
            board_id = self.get_board_id_by_name(board_name)
            if not board_id:
                board_id = self.db.create_board(board_name, owner_id=user_id)
            
            # Create card in database
            card_id = self.db.create_card(
                board_id=board_id,
                list_name=list_name,
                title=card_title,
                description=card_desc,
                status='to_do',
                importance=card_importance,
                due_date=card_due_date,
                subject=subject,
                goal=goal,
                members=members or [],
                git_branch=git_branch,
                git_commit=git_commit,
                recurrence=recurrence,
                dependencies=dependencies or [],
                user_id=user_id
            )
            
            # Reload data from database
            self.load_trello_data()
            self.populate_boards()
            return card_id
        except Exception as e:
            print(f"Erro ao adicionar cart√£o: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel adicionar o cart√£o: {e}")
            return None

    def update_card_data(self, card_id, title, desc, due_date, importance, subject=None, goal=None, members=None, git_branch=None, git_commit=None, recurrence=None, dependencies=None):
        """Update card directly in SQL database"""
        try:
            self.db.update_card(
                card_id=card_id,
                title=title,
                description=desc,
                status='to_do',
                importance=importance,
                due_date=due_date,
                subject=subject,
                goal=goal,
                members=members,
                git_branch=git_branch,
                git_commit=git_commit,
                recurrence=recurrence,
                dependencies=dependencies
            )
            # Reload data from database
            self.load_trello_data()
            self.populate_boards()
        except Exception as e:
            print(f"Erro ao atualizar cart√£o: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel atualizar o cart√£o: {e}")

    def move_card_data(self, source_board_name, source_list_name, card_id, target_board_name, target_list_name):
        """Move card directly in SQL database"""
        try:
            target_board_id = self.get_board_id_by_name(target_board_name)
            if target_board_id:
                self.db.move_card(card_id, target_board_id, target_list_name)
                # Reload data from database
                self.load_trello_data()
                self.populate_boards()
            else:
                print(f"Board '{target_board_name}' n√£o encontrado")
        except Exception as e:
            print(f"Erro ao mover cart√£o: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel mover o cart√£o: {e}")

    def delete_card(self, board_name, list_name, card_id):
        """Delete card directly from SQL database"""
        try:
            self.db.delete_card(card_id)
            # Reload data from database
            self.load_trello_data()
            self.populate_boards()
        except Exception as e:
            print(f"Erro ao deletar cart√£o: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel deletar o cart√£o: {e}")



    def send_weekly_report(self):
        """Envia relat√≥rio semanal por email"""
        try:
            report_data = self._generate_weekly_report()
            
            subject = f"Relat√≥rio Semanal - {report_data['week_period']}"
            body = f"""
Resumo Geral:
- Total de cart√µes: {report_data['total_cards']}
- Cart√µes criados: {report_data['cards_created']}
- Cart√µes conclu√≠dos: {report_data['cards_completed']}
- Cart√µes em atraso: {report_data['overdue_cards']}

Produtividade:
- Taxa de conclus√£o: {report_data['completion_rate']}%
- Tempo m√©dio de conclus√£o: {report_data['avg_completion_time']} dias

Cart√µes Mais Importantes:
{report_data['top_important_cards']}

Pr√≥ximos Prazos:
{report_data['upcoming_deadlines']}

---
Boodesk - Sistema de Gerenciamento de Tarefas
"""
            body = body.strip()
            
            recipients = self.settings.get('notification_recipients', [])
            for recipient in recipients:
                self.send_email(recipient, subject, body)
                
        except Exception as e:
            print(f"Erro ao enviar relat√≥rio semanal: {e}")
    
    def _generate_weekly_report(self):
        """Gera dados para o relat√≥rio semanal"""
        try:
            now = datetime.now()
            week_start = now - timedelta(days=7)
            
            total_cards = 0
            cards_created = 0
            cards_completed = 0
            overdue_cards = 0
            important_cards = []
            upcoming_deadlines = []
            
            for board_name, board_data in self.app.boodesk_data.get('boards', {}).items():
                for list_name, cards in board_data.items():
                    if list_name != 'workflow':
                        total_cards += len(cards)
                        
                        for card in cards:
                            # Cart√µes criados na semana
                            creation_date = card.get('creation_date', '')
                            if creation_date:
                                try:
                                    card_creation = datetime.strptime(creation_date, '%Y-%m-%d %H:%M:%S')
                                    if card_creation >= week_start:
                                        cards_created += 1
                                except ValueError:
                                    pass
                            
                            # Cart√µes conclu√≠dos
                            if list_name == 'Conclu√≠do':
                                cards_completed += 1
                            
                            # Cart√µes em atraso
                            due_date_str = card.get('due_date', '')
                            if due_date_str:
                                try:
                                    due_date = datetime.strptime(due_date_str, '%Y-%m-%d %H:%M')
                                    if due_date < now and list_name != 'Conclu√≠do':
                                        overdue_cards += 1
                                except ValueError:
                                    pass
                            
                            # Cart√µes importantes
                            if card.get('importance') in ['Alta', 'Cr√≠tica']:
                                important_cards.append(card.get('title', ''))
                            
                            # Pr√≥ximos prazos
                            if due_date_str:
                                try:
                                    due_date = datetime.strptime(due_date_str, '%Y-%m-%d %H:%M')
                                    if due_date > now and due_date <= now + timedelta(days=7):
                                        upcoming_deadlines.append(f"{card.get('title', '')} - {due_date_str}")
                                except ValueError:
                                    pass
            
            completion_rate = (cards_completed / total_cards * 100) if total_cards > 0 else 0
            
            return {
                'week_period': f"{week_start.strftime('%d/%m')} - {now.strftime('%d/%m/%Y')}",
                'total_cards': total_cards,
                'cards_created': cards_created,
                'cards_completed': cards_completed,
                'overdue_cards': overdue_cards,
                'completion_rate': round(completion_rate, 1),
                'avg_completion_time': '3.5',  # Placeholder
                'top_important_cards': '\n'.join(important_cards[:5]),
                'upcoming_deadlines': '\n'.join(upcoming_deadlines[:5])
            }
            
        except Exception as e:
            print(f"Erro ao gerar relat√≥rio semanal: {e}")
            return {}


class GoogleCalendarIntegration:
    """Integra√ß√£o com Google Calendar para sincroniza√ß√£o de eventos"""
    
    SCOPES = ['https://www.googleapis.com/auth/calendar']
    
    def __init__(self, app):
        self.app = app
        self.service = None
        self.credentials = None
        self.calendar_id = 'primary'
        self.token_file = os.path.join(self.app.base_dir, 'google_calendar_token.pickle')
        self.credentials_file = os.path.join(self.app.base_dir, 'google_calendar_credentials.json')
        self.is_authenticated = False
        
    def authenticate(self):
        """Autentica com Google Calendar API"""
        try:
            # Verificar se as bibliotecas est√£o dispon√≠veis
            try:
                from google.auth.transport.requests import Request
                from google_auth_oauthlib.flow import InstalledAppFlow
                from googleapiclient.discovery import build
                from googleapiclient.errors import HttpError
                import pickle
            except ImportError as e:
                print(f"‚ùå Bibliotecas do Google Calendar n√£o dispon√≠veis: {e}")
                messagebox.showerror("Erro", 
                                   f"Bibliotecas do Google Calendar n√£o est√£o instaladas.\n\n"
                                   f"Execute: pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
                return False
            
            # Verificar se h√° credenciais configuradas
            calendar_settings = self.app.settings.get('calendar_integration', {})
            
            if calendar_settings.get('auth_type') == 'json':
                # Usar arquivo JSON
                credentials_file = calendar_settings.get('credentials_file', '')
                if not credentials_file or not os.path.exists(credentials_file):
                    messagebox.showwarning(
                        "Configura√ß√£o Necess√°ria",
                        "Arquivo de credenciais do Google Calendar n√£o encontrado.\n"
                        "Por favor, configure as credenciais nas configura√ß√µes."
                    )
                    return False
                
                self.credentials_file = credentials_file
                
            elif calendar_settings.get('auth_type') == 'key':
                # Usar ID e chave privada
                client_id = calendar_settings.get('client_id', '').strip()
                client_secret = calendar_settings.get('client_secret', '').strip()
                
                if not client_id or not client_secret:
                    messagebox.showwarning(
                        "Configura√ß√£o Necess√°ria",
                        "Client ID e Client Secret do Google Calendar n√£o configurados.\n"
                        "Por favor, configure as credenciais nas configura√ß√µes."
                    )
                    return False
                
                # Criar arquivo tempor√°rio de credenciais
                temp_creds = {
                    "installed": {
                        "client_id": client_id,
                        "client_secret": client_secret,
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "token_uri": "https://oauth2.googleapis.com/token",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "redirect_uris": ["http://localhost"]
                    }
                }
                
                import tempfile
                import json
                
                with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                    json.dump(temp_creds, f)
                    self.credentials_file = f.name
            else:
                messagebox.showwarning(
                    "Configura√ß√£o Necess√°ria",
                    "Tipo de autentica√ß√£o do Google Calendar n√£o configurado.\n"
                    "Por favor, configure as credenciais nas configura√ß√µes."
                )
                return False
            
            # Tentar carregar token existente
            if os.path.exists(self.token_file):
                try:
                    with open(self.token_file, 'rb') as token:
                        self.credentials = pickle.load(token)
                except Exception as e:
                    print(f"Erro ao carregar token: {e}")
                    self.credentials = None
            
            # Verificar se as credenciais s√£o v√°lidas
            if not self.credentials or not self.credentials.valid:
                if self.credentials and self.credentials.expired and self.credentials.refresh_token:
                    try:
                        self.credentials.refresh(Request())
                    except Exception as e:
                        print(f"Erro ao renovar token: {e}")
                        self.credentials = None
                
                # Se ainda n√£o h√° credenciais v√°lidas, fazer nova autentica√ß√£o
                if not self.credentials:
                    try:
                        flow = InstalledAppFlow.from_client_secrets_file(
                            self.credentials_file, self.SCOPES)
                        self.credentials = flow.run_local_server(port=0)
                        
                        # Salvar token
                        with open(self.token_file, 'wb') as token:
                            pickle.dump(self.credentials, token)
                            
                    except Exception as e:
                        print(f"Erro na autentica√ß√£o OAuth: {e}")
                        messagebox.showerror("Erro", f"Erro na autentica√ß√£o OAuth:\n{e}")
                        return False
            
            # Criar servi√ßo
            self.service = build('calendar', 'v3', credentials=self.credentials)
            self.is_authenticated = True
            
            print("‚úÖ Autentica√ß√£o com Google Calendar bem-sucedida!")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro na autentica√ß√£o do Google Calendar: {e}")
            messagebox.showerror("Erro", f"Erro na autentica√ß√£o do Google Calendar:\n{e}")
            return False
    
    def create_event(self, title, description, start_datetime, duration=None, card_id=None, attendees=None):
        """Cria um evento no Google Calendar"""
        try:
            if not self.service:
                if not self.authenticate():
                    return False
            
            # Calcular hor√°rio de fim
            if duration:
                end_datetime = start_datetime + duration
            else:
                end_datetime = start_datetime + timedelta(hours=1)
            
            # Preparar evento
            event = {
                'summary': title,
                'description': description,
                'start': {
                    'dateTime': start_datetime.isoformat(),
                    'timeZone': 'America/Sao_Paulo',
                },
                'end': {
                    'dateTime': end_datetime.isoformat(),
                    'timeZone': 'America/Sao_Paulo',
                },
                'reminders': {
                    'useDefault': False,
                    'overrides': [
                        {'method': 'popup', 'minutes': 30},
                        {'method': 'email', 'minutes': 60},
                    ],
                },
            }
            
            # Adicionar card_id como metadados se fornecido
            if card_id:
                event['extendedProperties'] = {
                    'private': {
                        'card_id': card_id,
                        'source': 'boodesk_app'
                    }
                }
            
            if attendees:
                event['attendees'] = [{'email': email} for email in attendees]
            
            # Criar evento
            created_event = self.service.events().insert(
                calendarId=self.calendar_id, body=event).execute()
            
            print(f'‚úÖ Evento criado no Google Calendar: {created_event.get("htmlLink")}')
            return True
            
        except Exception as error:
            print(f'‚ùå Erro ao criar evento no Google Calendar: {error}')
            return False
    
    def sync_card_to_calendar(self, card_data, board_name, list_name):
        """Sincroniza um cart√£o para o Google Calendar"""
        try:
            if not card_data.get('due_date'):
                return False
            
            # Parse da data de vencimento
            due_date_str = card_data['due_date']
            if ' ' in due_date_str:
                due_date_str = due_date_str.split(' ')[0]
            
            due_date = datetime.strptime(due_date_str, "%Y-%m-%d")
            
            # Criar evento de 1 hora
            start_time = due_date.replace(hour=9, minute=0, second=0, microsecond=0)
            end_time = start_time + timedelta(hours=1)
            
            title = f"[{board_name}] {card_data['title']}"
            description = f"""
Tarefa: {card_data['title']}
Quadro: {board_name}
Lista: {list_name}
Descri√ß√£o: {card_data.get('description', 'N/A')}
Respons√°vel: {', '.join(card_data.get('members', []))}
Import√¢ncia: {card_data.get('importance', 'Normal')}
            """.strip()
            
            return self.create_event(title, description, start_time, end_time)
            
        except Exception as e:
            print(f"Erro ao sincronizar cart√£o com calend√°rio: {e}")
            return False
    
    def get_upcoming_events(self, days=7):
        """Obt√©m eventos pr√≥ximos do Google Calendar"""
        try:
            if not self.service:
                if not self.authenticate():
                    return []
            
            # Usar formato RFC3339 para datas
            now = datetime.now(timezone.utc)
            end_date = now + timedelta(days=days)
            
            # Formatar datas no formato correto para Google Calendar API
            time_min = now.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
            time_max = end_date.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
            
            events_result = self.service.events().list(
                calendarId=self.calendar_id,
                timeMin=time_min,
                timeMax=time_max,
                singleEvents=True,
                orderBy='startTime'
            ).execute()
            
            events = events_result.get('items', [])
            return events
            
        except Exception as e:
            print(f"Erro ao obter eventos do Google Calendar: {e}")
            return []


class EmailTemplateManager:
    """Gerenciador de templates de email personaliz√°veis"""
    
    def __init__(self, app):
        self.app = app
        self.templates_file = os.path.join(self.app.base_dir, 'email_templates.json')
        self.templates = self.load_templates()
        
    def load_templates(self):
        """Carrega templates de email do arquivo"""
        try:
            if os.path.exists(self.templates_file):
                with open(self.templates_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                # Templates padr√£o
                default_templates = {
                    "card_created": {
                        "subject": "Nova Tarefa Criada: {card_title}",
                        "body": """
Ol√° {member_name},

Uma nova tarefa foi criada e voc√™ foi designado como respons√°vel:

**Tarefa:** {card_title}
**Quadro:** {board_name}
**Lista:** {list_name}
**Descri√ß√£o:** {card_description}
**Prazo:** {due_date}
**Import√¢ncia:** {importance}

Acesse o sistema para mais detalhes.

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    },
                    "card_modified": {
                        "subject": "Tarefa Atualizada: {card_title}",
                        "body": """
Ol√° {member_name},

A tarefa "{card_title}" foi atualizada:

**Altera√ß√µes:**
{changes}

**Detalhes Atuais:**
- Quadro: {board_name}
- Lista: {list_name}
- Prazo: {due_date}
- Import√¢ncia: {importance}

Acesse o sistema para mais detalhes.

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    },
                    "deadline_reminder": {
                        "subject": "Lembrete de Prazo: {card_title}",
                        "body": """
Ol√° {member_name},

Este √© um lembrete sobre a tarefa que vence em breve:

**Tarefa:** {card_title}
**Quadro:** {board_name}
**Lista:** {list_name}
**Prazo:** {due_date}
**Import√¢ncia:** {importance}

Por favor, verifique o status desta tarefa.

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    },
                    "weekly_report": {
                        "subject": "Relat√≥rio Semanal - {week_period}",
                        "body": """
Ol√° {member_name},

Aqui est√° seu relat√≥rio semanal de produtividade:

**Resumo da Semana:**
- Tarefas Conclu√≠das: {completed_tasks}
- Tarefas Pendentes: {pending_tasks}
- Tempo Total Pomodoro: {total_pomodoro_time}
- Produtividade: {productivity_score}%

**Tarefas Importantes Conclu√≠das:**
{important_completed_tasks}

**Pr√≥ximos Prazos:**
{upcoming_deadlines}

Continue assim!

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    }
                }
                self.save_templates(default_templates)
                return default_templates
        except Exception as e:
            print(f"Erro ao carregar templates de email: {e}")
            return {}
    
    def save_templates(self, templates=None):
        """Salva templates de email no arquivo"""
        try:
            if templates is None:
                templates = self.templates
            
            with open(self.templates_file, 'w', encoding='utf-8') as f:
                json.dump(templates, f, indent=2, ensure_ascii=False)
            
            self.templates = templates
            
        except Exception as e:
            print(f"Erro ao salvar templates de email: {e}")
    
    def get_template(self, template_name):
        """Obt√©m um template espec√≠fico"""
        return self.templates.get(template_name, {})
    
    def update_template(self, template_name, subject, body):
        """Atualiza um template"""
        self.templates[template_name] = {
            "subject": subject,
            "body": body
        }
        self.save_templates()
    
    def format_template(self, template_name, variables):
        """Formata um template com vari√°veis"""
        template = self.get_template(template_name)
        if not template:
            return "", ""
        
        subject = template.get("subject", "")
        body = template.get("body", "")
        
        # Substituir vari√°veis
        for key, value in variables.items():
            placeholder = "{" + key + "}"
            subject = subject.replace(placeholder, str(value))
            body = body.replace(placeholder, str(value))
        
        return subject, body
    
    def get_available_templates(self):
        """Retorna lista de templates dispon√≠veis"""
        return list(self.templates.keys())


class CalendarEventWindow(tk.Toplevel):
    """Janela para criar/editar eventos do calend√°rio"""
    
    def __init__(self, parent, date_str, event_data=None):
        super().__init__(parent)
        self.parent = parent
        self.date_str = date_str
        self.event_data = event_data
        
        self.title("Novo Evento" if not event_data else "Editar Evento")
        self.geometry("500x400")
        self.transient(parent)
        self.grab_set()
        
        self.create_widgets()
        
    def create_widgets(self):
        """Cria os widgets da janela"""
        main_frame = ttk.Frame(self, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        ttk.Label(main_frame, text="T√≠tulo:").grid(row=0, column=0, sticky="w", pady=5)
        self.title_var = tk.StringVar(value=self.event_data.get('title', '') if self.event_data else '')
        self.title_entry = ttk.Entry(main_frame, textvariable=self.title_var, width=50)
        self.title_entry.grid(row=0, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        
        # Data
        ttk.Label(main_frame, text="Data:").grid(row=1, column=0, sticky="w", pady=5)
        self.date_var = tk.StringVar(value=self.date_str)
        self.date_entry = ttk.Entry(main_frame, textvariable=self.date_var, width=15)
        self.date_entry.grid(row=1, column=1, sticky="w", pady=5, padx=(10, 0))
        ttk.Button(main_frame, text="üìÖ", command=self.open_date_picker).grid(row=1, column=2, sticky="w", padx=5)
        
        # Hora de in√≠cio
        ttk.Label(main_frame, text="Hora de In√≠cio:").grid(row=2, column=0, sticky="w", pady=5)
        self.start_time_var = tk.StringVar(value=self.event_data.get('start_time', '09:00') if self.event_data else '09:00')
        self.start_time_entry = ttk.Entry(main_frame, textvariable=self.start_time_var, width=10)
        self.start_time_entry.grid(row=2, column=1, sticky="w", pady=5, padx=(10, 0))
        
        # Hora de fim
        ttk.Label(main_frame, text="Hora de Fim:").grid(row=3, column=0, sticky="w", pady=5)
        self.end_time_var = tk.StringVar(value=self.event_data.get('end_time', '10:00') if self.event_data else '10:00')
        self.end_time_entry = ttk.Entry(main_frame, textvariable=self.end_time_var, width=10)
        self.end_time_entry.grid(row=3, column=1, sticky="w", pady=5, padx=(10, 0))
        
        # Descri√ß√£o
        ttk.Label(main_frame, text="Descri√ß√£o:").grid(row=4, column=0, sticky="nw", pady=5)
        self.description_text = tk.Text(main_frame, height=8, width=50)
        self.description_text.grid(row=4, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        if self.event_data and self.event_data.get('description'):
            self.description_text.insert("1.0", self.event_data['description'])
        
        # Local
        ttk.Label(main_frame, text="Local:").grid(row=5, column=0, sticky="w", pady=5)
        self.location_var = tk.StringVar(value=self.event_data.get('location', '') if self.event_data else '')
        self.location_entry = ttk.Entry(main_frame, textvariable=self.location_var, width=50)
        self.location_entry.grid(row=5, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        
        # Participantes
        ttk.Label(main_frame, text="Participantes:").grid(row=6, column=0, sticky="w", pady=5)
        self.attendees_var = tk.StringVar(value=self.event_data.get('attendees', '') if self.event_data else '')
        self.attendees_entry = ttk.Entry(main_frame, textvariable=self.attendees_var, width=50)
        self.attendees_entry.grid(row=6, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        ttk.Label(main_frame, text="(emails separados por v√≠rgula)").grid(row=6, column=3, sticky="w", pady=5)
        
        # Sincronizar com Google Calendar
        self.sync_google_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(main_frame, text="Sincronizar com Google Calendar", 
                       variable=self.sync_google_var).grid(row=7, column=0, columnspan=3, sticky="w", pady=10)
        
        # Bot√µes
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=8, column=0, columnspan=3, pady=20)
        
        ttk.Button(button_frame, text="Salvar", command=self.save_event).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.destroy).pack(side=tk.LEFT, padx=5)
        
        # Configurar grid
        main_frame.columnconfigure(1, weight=1)
        
    def open_date_picker(self):
        """Abre o seletor de data"""
        try:
            current_date = datetime.strptime(self.date_var.get(), "%Y-%m-%d")
            date_picker = DatePickerDialog(self, current_date)
            if date_picker.result:
                self.date_var.set(date_picker.result.strftime("%Y-%m-%d"))
        except ValueError:
            date_picker = DatePickerDialog(self)
            if date_picker.result:
                self.date_var.set(date_picker.result.strftime("%Y-%m-%d"))
    
    def save_event(self):
        """Salva o evento"""
        try:
            # Validar campos obrigat√≥rios
            title = self.title_var.get().strip()
            if not title:
                messagebox.showwarning("Aviso", "O t√≠tulo √© obrigat√≥rio!")
                return
            
            # Validar formato de data
            try:
                event_date = datetime.strptime(self.date_var.get(), "%Y-%m-%d")
            except ValueError:
                messagebox.showwarning("Aviso", "Data inv√°lida!")
                return
            
            # Validar formato de hora
            try:
                start_time = datetime.strptime(self.start_time_var.get(), "%H:%M")
                end_time = datetime.strptime(self.end_time_var.get(), "%H:%M")
            except ValueError:
                messagebox.showwarning("Aviso", "Formato de hora inv√°lido! Use HH:MM")
                return
            
            # Criar dados do evento
            event_data = {
                'title': title,
                'date': self.date_var.get(),
                'start_time': self.start_time_var.get(),
                'end_time': self.end_time_var.get(),
                'description': self.description_text.get("1.0", tk.END).strip(),
                'location': self.location_var.get().strip(),
                'attendees': [email.strip() for email in self.attendees_var.get().split(',') if email.strip()],
                'sync_google': self.sync_google_var.get()
            }
            
            # Salvar no Google Calendar se solicitado
            if event_data['sync_google'] and self.parent.calendar_status_var.get() == "Conectado":
                start_datetime = datetime.combine(event_date, start_time.time())
                end_datetime = datetime.combine(event_date, end_time.time())
                
                success = self.parent.google_calendar.create_event(
                    title=event_data['title'],
                    description=event_data['description'],
                    start_time=start_datetime,
                    end_time=end_datetime,
                    attendees=event_data['attendees'] if event_data['attendees'] else None
                )
                
                if success:
                    messagebox.showinfo("Sucesso", "Evento criado no Google Calendar!")
                else:
                    messagebox.showwarning("Aviso", "Erro ao criar evento no Google Calendar!")
            
            # Salvar localmente (implementar se necess√°rio)
            # self.parent.save_local_event(event_data)
            
            messagebox.showinfo("Sucesso", "Evento salvo com sucesso!")
            self.destroy()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar evento:\n{e}")


# Sistema de Integra√ß√£o com Reuni√µes (Zoom/Teams)
class MeetingIntegration:
    """Sistema de integra√ß√£o com plataformas de reuni√£o"""
    
    def __init__(self, app):
        self.app = app
        self.meeting_data = {}  # Dados de reuni√µes
        self.load_meeting_data()
    
    def load_meeting_data(self):
        """Carrega dados de reuni√µes salvos"""
        try:
            if os.path.exists('meeting_data.json'):
                with open('meeting_data.json', 'r', encoding='utf-8') as f:
                    self.meeting_data = json.load(f)
        except Exception as e:
            print(f"Erro ao carregar dados de reuni√µes: {e}")
            self.meeting_data = {}
    
    def save_meeting_data(self):
        """Salva dados de reuni√µes"""
        try:
            with open('meeting_data.json', 'w', encoding='utf-8') as f:
                json.dump(self.meeting_data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erro ao salvar dados de reuni√µes: {e}")
    
    def create_zoom_meeting(self, title, date, time_str, duration=60, password=None):
        """Cria link de reuni√£o do Zoom"""
        # Gerar ID de reuni√£o √∫nico (formato Zoom: 10 d√≠gitos)
        meeting_id = ''.join(random.choices('0123456789', k=10))
        
        # Gerar senha se n√£o fornecida (formato Zoom: 6 d√≠gitos)
        if not password:
            password = ''.join(random.choices('0123456789', k=6))
        
        # Criar link do Zoom (formato padr√£o)
        zoom_link = f"https://zoom.us/j/{meeting_id}?pwd={password}"
        
        meeting_info = {
            'id': meeting_id,
            'title': title,
            'date': date,
            'time': time_str,
            'duration': duration,
            'password': password,
            'link': zoom_link,
            'platform': 'zoom',
            'created_by': getattr(self.app.current_user, 'username', 'Sistema') if hasattr(self.app, 'current_user') and self.app.current_user else 'Sistema',
            'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'status': 'scheduled'
        }
        
        self.meeting_data[meeting_id] = meeting_info
        self.save_meeting_data()
        
        return meeting_info
    
    def create_teams_meeting(self, title, date, time_str, duration=60):
        """Cria link de reuni√£o do Teams"""
        # Gerar ID de reuni√£o √∫nico (formato Teams: GUID)
        import uuid
        meeting_id = str(uuid.uuid4())
        
        # Criar link do Teams (formato padr√£o)
        teams_link = f"https://teams.microsoft.com/l/meetup-join/{meeting_id}"
        
        meeting_info = {
            'id': meeting_id,
            'title': title,
            'date': date,
            'time': time_str,
            'duration': duration,
            'link': teams_link,
            'platform': 'teams',
            'created_by': getattr(self.app.current_user, 'username', 'Sistema') if hasattr(self.app, 'current_user') and self.app.current_user else 'Sistema',
            'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'status': 'scheduled'
        }
        
        self.meeting_data[meeting_id] = meeting_info
        self.save_meeting_data()
        
        return meeting_info
    
    def create_google_meet_meeting(self, title, date, time_str, duration=60):
        """Cria link de reuni√£o do Google Meet usando API real"""
        # Usar o Google Calendar Manager para criar reuni√£o real
        if not hasattr(self.app, 'google_calendar_manager'):
            self.app.google_calendar_manager = GoogleCalendarManager()
        
        meeting_info = self.app.google_calendar_manager.create_meeting(
            title, date, time_str, duration
        )
        
        if meeting_info:
            # Salvar no sistema local
            self.meeting_data[meeting_info['id']] = meeting_info
            self.save_meeting_data()
            return meeting_info
        else:
            # Fallback para link simulado se API falhar
            import string
            chars = string.ascii_lowercase + string.digits
            part1 = ''.join(random.choices(chars, k=3))
            part2 = ''.join(random.choices(chars, k=4))
            part3 = ''.join(random.choices(chars, k=3))
            meeting_id = f"{part1}-{part2}-{part3}"
            
            meet_link = f"https://meet.google.com/{meeting_id}"
            
            meeting_info = {
                'id': meeting_id,
                'title': title,
                'date': date,
                'time': time_str,
                'duration': duration,
                'link': meet_link,
                'platform': 'google_meet',
                'created_by': getattr(self.app.current_user, 'username', 'Sistema') if hasattr(self.app, 'current_user') and self.app.current_user else 'Sistema',
                'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'status': 'scheduled'
            }
            
            self.meeting_data[meeting_id] = meeting_info
            self.save_meeting_data()
            
            return meeting_info
    
    def get_meetings_by_project(self, project_name):
        """Retorna reuni√µes de um projeto espec√≠fico"""
        return [meeting for meeting in self.meeting_data.values() 
                if meeting.get('project') == project_name]
    
    def get_upcoming_meetings(self):
        """Retorna pr√≥ximas reuni√µes"""
        upcoming = []
        current_time = datetime.now()
        
        for meeting in self.meeting_data.values():
            try:
                meeting_datetime = datetime.strptime(f"{meeting['date']} {meeting['time']}", "%Y-%m-%d %H:%M")
                if meeting_datetime > current_time:
                    upcoming.append(meeting)
            except:
                continue
        
        return sorted(upcoming, key=lambda x: f"{x['date']} {x['time']}")


class MeetingWindow:
    """Janela para criar e gerenciar reuni√µes"""
    
    def __init__(self, parent, app, project_name=None):
        self.parent = parent
        self.app = app
        self.project_name = project_name
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title("Criar Reuni√£o")
        self.window.geometry("500x600")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Criar interface
        self.create_widgets()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        title_text = "Criar Reuni√£o"
        if self.project_name:
            title_text += f" - {self.project_name}"
        
        ttk.Label(title_frame, text=title_text, 
                 font=("Arial", 14, "bold")).pack(side=tk.LEFT)
        
        # Frame para formul√°rio
        form_frame = ttk.LabelFrame(main_frame, text="Detalhes da Reuni√£o", padding="10")
        form_frame.pack(fill=tk.X, pady=(0, 10))
        
        # T√≠tulo da reuni√£o
        ttk.Label(form_frame, text="T√≠tulo:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.title_var = tk.StringVar()
        self.title_entry = ttk.Entry(form_frame, textvariable=self.title_var, width=40)
        self.title_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        
        # Data
        ttk.Label(form_frame, text="Data:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.date_var = tk.StringVar()
        self.date_entry = ttk.Entry(form_frame, textvariable=self.date_var, width=20)
        self.date_entry.grid(row=1, column=1, sticky="w", padx=5, pady=2)
        self.date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        
        # Hora
        ttk.Label(form_frame, text="Hora:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        self.time_var = tk.StringVar()
        self.time_entry = ttk.Entry(form_frame, textvariable=self.time_var, width=10)
        self.time_entry.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        self.time_entry.insert(0, "09:00")
        
        # Dura√ß√£o
        ttk.Label(form_frame, text="Dura√ß√£o (min):").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.duration_var = tk.StringVar(value="60")
        self.duration_entry = ttk.Entry(form_frame, textvariable=self.duration_var, width=10)
        self.duration_entry.grid(row=3, column=1, sticky="w", padx=5, pady=2)
        
        # Plataforma
        ttk.Label(form_frame, text="Plataforma:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.platform_var = tk.StringVar(value="zoom")
        
        # Verificar se Google Meet est√° dispon√≠vel
        google_meet_available = os.path.exists(CREDENTIALS_FILE)
        platform_values = ["zoom", "teams"]
        if google_meet_available:
            platform_values.append("google_meet")
        
        platform_combo = ttk.Combobox(form_frame, textvariable=self.platform_var, 
                                     values=platform_values, state="readonly", width=15)
        platform_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)
        
        # Mostrar status do Google Meet
        if not google_meet_available:
            status_label = ttk.Label(form_frame, text="‚ö†Ô∏è Google Meet: Configure credentials.json", 
                                   foreground="orange", font=("Arial", 8))
            status_label.grid(row=4, column=2, sticky="w", padx=5, pady=2)
        else:
            status_label = ttk.Label(form_frame, text="‚úÖ Google Meet: Dispon√≠vel", 
                                   foreground="green", font=("Arial", 8))
            status_label.grid(row=4, column=2, sticky="w", padx=5, pady=2)
        
        # Senha (apenas para Zoom)
        self.password_frame = ttk.Frame(form_frame)
        self.password_frame.grid(row=5, column=0, columnspan=2, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.password_frame, text="Senha (opcional):").pack(side=tk.LEFT)
        self.password_var = tk.StringVar()
        self.password_entry = ttk.Entry(self.password_frame, textvariable=self.password_var, width=15)
        self.password_entry.pack(side=tk.LEFT, padx=(5, 0))
        
        # Configurar grid
        form_frame.columnconfigure(1, weight=1)
        
        # Bot√µes
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(buttons_frame, text="Criar Reuni√£o", image=self.icons.get('add_icon'), compound=tk.LEFT,
                  command=self.create_meeting).pack(side=tk.LEFT, padx=(0, 5))
        
        # Bot√£o para configurar Google Meet se n√£o estiver dispon√≠vel
        if not google_meet_available:
            ttk.Button(buttons_frame, text="Configurar Google Meet", image=self.icons.get('settings_icon'), compound=tk.LEFT,
                      command=self.show_google_setup).pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(buttons_frame, text="Cancelar", image=self.icons.get('cancel_icon'), compound=tk.LEFT,
                  command=self.window.destroy).pack(side=tk.RIGHT)
        
        # Frame para reuni√µes existentes
        meetings_frame = ttk.LabelFrame(main_frame, text="Reuni√µes Agendadas", padding="10")
        meetings_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para reuni√µes
        columns = ("Data", "Hora", "T√≠tulo", "Plataforma", "Criado por")
        self.meetings_tree = ttk.Treeview(meetings_frame, columns=columns, show="headings", height=10)
        
        for col in columns:
            self.meetings_tree.heading(col, text=col)
            self.meetings_tree.column(col, width=100, anchor="w")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(meetings_frame, orient="vertical", command=self.meetings_tree.yview)
        self.meetings_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.meetings_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Bot√µes de a√ß√£o para reuni√µes
        action_frame = ttk.Frame(main_frame)
        action_frame.pack(fill=tk.X)
        
        ttk.Button(action_frame, text="Copiar Link", image=self.icons.get('copy_icon'), compound=tk.LEFT,
                  command=self.copy_meeting_link).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(action_frame, text="Excluir", image=self.icons.get('delete_icon'), compound=tk.LEFT,
                  command=self.delete_meeting).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(action_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.load_meetings).pack(side=tk.LEFT)
        
        # Carregar reuni√µes existentes
        self.load_meetings()
        
        # Focar no t√≠tulo
        self.title_entry.focus()
    
    def show_google_setup(self):
        """Mostra instru√ß√µes para configurar Google Meet"""
        setup_text = """
Para usar o Google Meet com links reais, voc√™ precisa configurar a API do Google:

1. Acesse: https://console.cloud.google.com
2. Crie um projeto e ative a Google Calendar API
3. Crie credenciais OAuth 2.0
4. Baixe o arquivo como 'credentials.json'
5. Coloque na pasta do aplicativo

Arquivo de instru√ß√µes completo: GOOGLE_MEET_SETUP.md

Depend√™ncias necess√°rias:
pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client
        """
        
        # Criar janela de instru√ß√µes
        setup_window = tk.Toplevel(self.window)
        setup_window.title("Configurar Google Meet")
        setup_window.geometry("600x400")
        setup_window.transient(self.window)
        setup_window.grab_set()
        
        # Texto das instru√ß√µes
        text_widget = tk.Text(setup_window, wrap=tk.WORD, padx=10, pady=10)
        text_widget.pack(fill=tk.BOTH, expand=True)
        text_widget.insert(tk.END, setup_text)
        text_widget.config(state=tk.DISABLED)
        
        # Bot√µes
        button_frame = ttk.Frame(setup_window)
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        ttk.Button(button_frame, text="Abrir Google Cloud Console", 
                  command=lambda: webbrowser.open("https://console.cloud.google.com")).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Instalar Depend√™ncias", 
                  command=self.install_google_deps).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", 
                  command=setup_window.destroy).pack(side=tk.RIGHT, padx=5)
    
    def install_google_deps(self):
        """Instala as depend√™ncias do Google"""
        try:
            import subprocess
            subprocess.check_call([sys.executable, "-m", "pip", "install", 
                                 "google-auth", "google-auth-oauthlib", 
                                 "google-auth-httplib2", "google-api-python-client"])
            messagebox.showinfo("Sucesso", "Depend√™ncias instaladas com sucesso!\nReinicie o aplicativo.")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao instalar depend√™ncias:\n{str(e)}")
    
    def create_meeting(self):
        """Cria uma nova reuni√£o"""
        title = self.title_var.get().strip()
        date = self.date_var.get().strip()
        time = self.time_var.get().strip()
        duration = self.duration_var.get().strip()
        platform = self.platform_var.get()
        password = self.password_var.get().strip()
        
        # Valida√ß√µes
        if not title:
            messagebox.showerror("Erro", "T√≠tulo √© obrigat√≥rio!")
            return
        
        if not date:
            messagebox.showerror("Erro", "Data √© obrigat√≥ria!")
            return
        
        if not time:
            messagebox.showerror("Erro", "Hora √© obrigat√≥ria!")
            return
        
        try:
            duration = int(duration)
        except ValueError:
            messagebox.showerror("Erro", "Dura√ß√£o deve ser um n√∫mero!")
            return
        
        try:
            # Criar reuni√£o
            if platform == "zoom":
                meeting_info = self.app.meeting_integration.create_zoom_meeting(
                    title, date, time, duration, password if password else None
                )
            elif platform == "teams":
                meeting_info = self.app.meeting_integration.create_teams_meeting(
                    title, date, time, duration
                )
            else:  # google_meet
                meeting_info = self.app.meeting_integration.create_google_meet_meeting(
                    title, date, time, duration
                )
            
            # Adicionar projeto se especificado
            if self.project_name:
                meeting_info['project'] = self.project_name
                self.app.meeting_integration.save_meeting_data()
            
            # Mostrar link gerado
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(meeting_info['platform'], meeting_info['platform'].upper())
            
            messagebox.showinfo("Reuni√£o Criada", 
                              f"Reuni√£o criada com sucesso!\n\n"
                              f"Link: {meeting_info['link']}\n"
                              f"Plataforma: {platform_display}")
            
            # Limpar formul√°rio
            self.title_var.set("")
            self.password_var.set("")
            
            # Recarregar lista
            self.load_meetings()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao criar reuni√£o: {e}")
    
    def load_meetings(self):
        """Carrega reuni√µes existentes"""
        # Limpar treeview
        for item in self.meetings_tree.get_children():
            self.meetings_tree.delete(item)
        
        # Carregar reuni√µes
        if self.project_name:
            meetings = self.app.meeting_integration.get_meetings_by_project(self.project_name)
        else:
            meetings = list(self.app.meeting_integration.meeting_data.values())
        
        # Exibir reuni√µes
        for meeting in meetings:
            # Converter nome da plataforma para exibi√ß√£o
            platform = meeting.get('platform', '')
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(platform, platform.upper())
            
            self.meetings_tree.insert("", "end", values=(
                meeting.get('date', ''),
                meeting.get('time', ''),
                meeting.get('title', ''),
                platform_display,
                meeting.get('created_by', '')
            ), tags=(meeting['id'],))
    
    def copy_meeting_link(self):
        """Copia link da reuni√£o selecionada"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reuni√£o!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        
        if meeting_id in self.app.meeting_integration.meeting_data:
            meeting = self.app.meeting_integration.meeting_data[meeting_id]
            link = meeting['link']
            
            # Copiar para √°rea de transfer√™ncia
            self.window.clipboard_clear()
            self.window.clipboard_append(link)
            
            messagebox.showinfo("Link Copiado", f"Link copiado para a √°rea de transfer√™ncia:\n{link}")
    
    def delete_meeting(self):
        """Exclui reuni√£o selecionada"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reuni√£o!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        meeting_title = item['values'][2]
        
        if messagebox.askyesno("Confirmar Exclus√£o", 
                              f"Tem certeza que deseja excluir a reuni√£o '{meeting_title}'?"):
            if meeting_id in self.app.meeting_integration.meeting_data:
                del self.app.meeting_integration.meeting_data[meeting_id]
                self.app.meeting_integration.save_meeting_data()
                self.load_meetings()
                messagebox.showinfo("Sucesso", "Reuni√£o exclu√≠da com sucesso!")


# Sistema de Chat Integrado
class ChatSystem:
    """Sistema de chat integrado para comunica√ß√£o em tempo real"""
    
    def __init__(self, app):
        self.app = app
        self.chat_windows = {}  # Janelas de chat por projeto
        self.comment_windows = {}  # Janelas de coment√°rios por cart√£o
        self.chat_data = {}  # Dados de chat por projeto
        self.comment_data = {}  # Dados de coment√°rios por cart√£o
        
        # Carregar dados existentes
        self.load_chat_data()
        self.load_comment_data()
    
    def load_chat_data(self):
        """Carrega dados de chat salvos"""
        try:
            if os.path.exists('chat_data.json'):
                with open('chat_data.json', 'r', encoding='utf-8') as f:
                    self.chat_data = json.load(f)
        except Exception as e:
            print(f"Erro ao carregar dados de chat: {e}")
            self.chat_data = {}
    
    def save_chat_data(self):
        """Salva dados de chat"""
        try:
            with open('chat_data.json', 'w', encoding='utf-8') as f:
                json.dump(self.chat_data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erro ao salvar dados de chat: {e}")
    
    def load_comment_data(self):
        """Carrega dados de coment√°rios salvos"""
        try:
            if os.path.exists('comment_data.json'):
                with open('comment_data.json', 'r', encoding='utf-8') as f:
                    self.comment_data = json.load(f)
        except Exception as e:
            print(f"Erro ao carregar dados de coment√°rios: {e}")
            self.comment_data = {}
    
    def save_comment_data(self):
        """Salva dados de coment√°rios"""
        try:
            with open('comment_data.json', 'w', encoding='utf-8') as f:
                json.dump(self.comment_data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erro ao salvar dados de coment√°rios: {e}")
    
    def open_project_chat(self, project_name):
        """Abre chat espec√≠fico para um projeto"""
        if project_name not in self.chat_windows:
            self.chat_windows[project_name] = ProjectChatWindow(self.app, project_name)
        else:
            self.chat_windows[project_name].window.lift()
            self.chat_windows[project_name].window.focus_force()
    
    def open_card_comments(self, card_id, card_title):
        """Abre coment√°rios de um cart√£o espec√≠fico"""
        if card_id not in self.comment_windows:
            self.comment_windows[card_id] = CardCommentsWindow(self.app, card_id, card_title)
        else:
            self.comment_windows[card_id].window.lift()
            self.comment_windows[card_id].window.focus_force()
    
    def add_chat_message(self, project_name, username, message):
        """Adiciona mensagem ao chat do projeto"""
        if project_name not in self.chat_data:
            self.chat_data[project_name] = []
        
        # Processar men√ß√µes (@usuario)
        processed_message, mentions = self.process_mentions(message)
        
        chat_message = {
            'id': len(self.chat_data[project_name]) + 1,
            'username': username,
            'message': processed_message,
            'mentions': mentions,
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'type': 'chat'
        }
        
        self.chat_data[project_name].append(chat_message)
        self.save_chat_data()
        
        # Notificar usu√°rios mencionados
        self.notify_mentions(mentions, project_name, username, processed_message)
        
        # Atualizar janela de chat se estiver aberta
        if project_name in self.chat_windows:
            self.chat_windows[project_name].add_message(chat_message)
    
    def add_card_comment(self, card_id, username, comment):
        """Adiciona coment√°rio a um cart√£o"""
        if card_id not in self.comment_data:
            self.comment_data[card_id] = []
        
        # Processar men√ß√µes (@usuario)
        processed_comment, mentions = self.process_mentions(comment)
        
        comment_data = {
            'id': len(self.comment_data[card_id]) + 1,
            'username': username,
            'comment': processed_comment,
            'mentions': mentions,
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'type': 'comment'
        }
        
        self.comment_data[card_id].append(comment_data)
        self.save_comment_data()
        
        # Notificar usu√°rios mencionados
        self.notify_mentions(mentions, f"Cart√£o {card_id}", username, processed_comment)
        
        # Atualizar janela de coment√°rios se estiver aberta
        if card_id in self.comment_windows:
            self.comment_windows[card_id].add_comment(comment_data)
    
    def process_mentions(self, text):
        """Processa men√ß√µes @usuario no texto"""
        mentions = []
        processed_text = text
        
        # Encontrar men√ß√µes @usuario
        import re
        mention_pattern = r'@(\w+)'
        matches = re.findall(mention_pattern, text)
        
        for match in matches:
            mentions.append(match)
            # Destacar men√ß√£o no texto
            processed_text = processed_text.replace(f'@{match}', f'@{match}')
        
        return processed_text, mentions
    
    def notify_mentions(self, mentions, context, sender, message):
        """Notifica usu√°rios mencionados"""
        for mention in mentions:
            # Aqui voc√™ pode implementar notifica√ß√µes push, email, etc.
            print(f"Notifica√ß√£o: {sender} mencionou @{mention} em {context}: {message}")
    
    def search_chat_history(self, project_name, search_term):
        """Busca no hist√≥rico de chat"""
        if project_name not in self.chat_data:
            return []
        
        results = []
        search_term = search_term.lower()
        
        for message in self.chat_data[project_name]:
            if (search_term in message['message'].lower() or 
                search_term in message['username'].lower()):
                results.append(message)
        
        return results
    
    def search_comment_history(self, card_id, search_term):
        """Busca no hist√≥rico de coment√°rios"""
        if card_id not in self.comment_data:
            return []
        
        results = []
        search_term = search_term.lower()
        
        for comment in self.comment_data[card_id]:
            if (search_term in comment['comment'].lower() or 
                search_term in comment['username'].lower()):
                results.append(comment)
        
        return results


class ProjectChatWindow:
    """Janela de chat para projeto espec√≠fico"""
    
    def __init__(self, app, project_name):
        self.app = app
        self.project_name = project_name
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(app.root)
        self.window.title(f"Chat - {project_name}")
        self.window.geometry("600x500")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(app.root)
        
        # Criar interface
        self.create_widgets()
        self.load_messages()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text=f"Chat - {self.project_name}", 
                 font=("Arial", 14, "bold")).pack(side=tk.LEFT)
        
        # Bot√µes de a√ß√£o
        ttk.Button(title_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.open_search).pack(side=tk.RIGHT, padx=5)
        ttk.Button(title_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.load_messages).pack(side=tk.RIGHT, padx=5)
        
        # Frame para mensagens
        messages_frame = ttk.LabelFrame(main_frame, text="Mensagens", padding="10")
        messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Text widget para mensagens
        self.messages_text = tk.Text(messages_frame, wrap=tk.WORD, state=tk.DISABLED)
        self.messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(messages_frame, orient="vertical", command=self.messages_text.yview)
        self.messages_text.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Frame para entrada de mensagem
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de entrada
        self.message_var = tk.StringVar()
        self.message_entry = ttk.Entry(input_frame, textvariable=self.message_var, font=("Arial", 10))
        self.message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.message_entry.bind("<Return>", self.send_message)
        
        # Bot√£o enviar
        ttk.Button(input_frame, text="Enviar", image=self.icons.get('forward_icon'), compound=tk.LEFT,
                  command=self.send_message).pack(side=tk.RIGHT)
        
        # Focar no campo de entrada
        self.message_entry.focus()
    
    def load_messages(self):
        """Carrega mensagens do chat"""
        self.messages_text.config(state=tk.NORMAL)
        self.messages_text.delete(1.0, tk.END)
        
        if self.project_name in self.app.chat_system.chat_data:
            for message in self.app.chat_system.chat_data[self.project_name]:
                self.display_message(message)
        
        self.messages_text.config(state=tk.DISABLED)
        self.messages_text.see(tk.END)
    
    def display_message(self, message):
        """Exibe uma mensagem no chat"""
        self.messages_text.config(state=tk.NORMAL)
        
        # Formatar mensagem
        timestamp = message['timestamp']
        username = message['username']
        text = message['message']
        
        # Adicionar timestamp
        self.messages_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
        
        # Adicionar username
        self.messages_text.insert(tk.END, f"{username}: ", "username")
        
        # Adicionar mensagem
        self.messages_text.insert(tk.END, f"{text}\n", "message")
        
        self.messages_text.config(state=tk.DISABLED)
        
        # Configurar tags para formata√ß√£o
        self.messages_text.tag_config("timestamp", foreground="gray")
        self.messages_text.tag_config("username", foreground="blue", font=("Arial", 10, "bold"))
        self.messages_text.tag_config("message", font=("Arial", 10))
    
    def send_message(self, event=None):
        """Envia mensagem"""
        message = self.message_var.get().strip()
        if not message:
            return
        
        # Verificar se h√° usu√°rio logado
        if not hasattr(self.app, 'current_user') or not self.app.current_user:
            messagebox.showwarning("Aviso", "Voc√™ precisa estar logado para enviar mensagens!")
            return
        
        username = self.app.current_user.username
        
        # Adicionar mensagem ao sistema de chat
        self.app.chat_system.add_chat_message(self.project_name, username, message)
        
        # Limpar campo de entrada
        self.message_var.set("")
        
        # Focar novamente no campo
        self.message_entry.focus()
    
    def add_message(self, message):
        """Adiciona nova mensagem √† janela"""
        self.display_message(message)
        self.messages_text.see(tk.END)
    
    def open_search(self):
        """Abre janela de busca"""
        ChatSearchWindow(self.window, self.app, self.project_name)


class CardCommentsWindow:
    """Janela de coment√°rios para cart√£o espec√≠fico"""
    
    def __init__(self, app, card_id, card_title):
        self.app = app
        self.card_id = card_id
        self.card_title = card_title
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(app.root)
        self.window.title(f"Coment√°rios - {card_title}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(app.root)
        
        # Criar interface
        self.create_widgets()
        self.load_comments()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text=f"Coment√°rios - {self.card_title}", 
                 font=("Arial", 12, "bold")).pack(side=tk.LEFT)
        
        # Bot√µes de a√ß√£o
        ttk.Button(title_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.open_search).pack(side=tk.RIGHT, padx=5)
        ttk.Button(title_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.load_comments).pack(side=tk.RIGHT, padx=5)
        
        # Frame para coment√°rios
        comments_frame = ttk.LabelFrame(main_frame, text="Coment√°rios", padding="10")
        comments_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Text widget para coment√°rios
        self.comments_text = tk.Text(comments_frame, wrap=tk.WORD, state=tk.DISABLED)
        self.comments_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(comments_frame, orient="vertical", command=self.comments_text.yview)
        self.comments_text.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Frame para entrada de coment√°rio
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de entrada
        self.comment_var = tk.StringVar()
        self.comment_entry = ttk.Entry(input_frame, textvariable=self.comment_var, font=("Arial", 10))
        self.comment_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.comment_entry.bind("<Return>", self.send_comment)
        
        # Bot√£o enviar
        ttk.Button(input_frame, text="Comentar", image=self.icons.get('add_icon'), compound=tk.LEFT,
                  command=self.send_comment).pack(side=tk.RIGHT)
        
        # Focar no campo de entrada
        self.comment_entry.focus()
    
    def load_comments(self):
        """Carrega coment√°rios do cart√£o"""
        self.comments_text.config(state=tk.NORMAL)
        self.comments_text.delete(1.0, tk.END)
        
        if self.card_id in self.app.chat_system.comment_data:
            for comment in self.app.chat_system.comment_data[self.card_id]:
                self.display_comment(comment)
        
        self.comments_text.config(state=tk.DISABLED)
        self.comments_text.see(tk.END)
    
    def display_comment(self, comment):
        """Exibe um coment√°rio"""
        self.comments_text.config(state=tk.NORMAL)
        
        # Formatar coment√°rio
        timestamp = comment['timestamp']
        username = comment['username']
        text = comment['comment']
        
        # Adicionar timestamp
        self.comments_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
        
        # Adicionar username
        self.comments_text.insert(tk.END, f"{username}: ", "username")
        
        # Adicionar coment√°rio
        self.comments_text.insert(tk.END, f"{text}\n", "comment")
        
        self.comments_text.config(state=tk.DISABLED)
        
        # Configurar tags para formata√ß√£o
        self.comments_text.tag_config("timestamp", foreground="gray")
        self.comments_text.tag_config("username", foreground="green", font=("Arial", 10, "bold"))
        self.comments_text.tag_config("comment", font=("Arial", 10))
    
    def send_comment(self, event=None):
        """Envia coment√°rio"""
        comment = self.comment_var.get().strip()
        if not comment:
            return
        
        # Verificar se h√° usu√°rio logado
        if not hasattr(self.app, 'current_user') or not self.app.current_user:
            messagebox.showwarning("Aviso", "Voc√™ precisa estar logado para comentar!")
            return
        
        username = self.app.current_user.username
        
        # Adicionar coment√°rio ao sistema
        self.app.chat_system.add_card_comment(self.card_id, username, comment)
        
        # Limpar campo de entrada
        self.comment_var.set("")
        
        # Focar novamente no campo
        self.comment_entry.focus()
    
    def add_comment(self, comment):
        """Adiciona novo coment√°rio √† janela"""
        self.display_comment(comment)
        self.comments_text.see(tk.END)
    
    def open_search(self):
        """Abre janela de busca"""
        CommentSearchWindow(self.window, self.app, self.card_id)


class ChatSearchWindow:
    """Janela de busca no hist√≥rico de chat"""
    
    def __init__(self, parent, app, project_name):
        self.parent = parent
        self.app = app
        self.project_name = project_name
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title(f"Buscar no Chat - {project_name}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Criar interface
        self.create_widgets()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        ttk.Label(main_frame, text=f"Buscar no Chat - {self.project_name}", 
                 font=("Arial", 12, "bold")).pack(pady=(0, 10))
        
        # Frame de busca
        search_frame = ttk.Frame(main_frame)
        search_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(search_frame, text="Termo de busca:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.search_var = tk.StringVar()
        self.search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=30)
        self.search_entry.pack(side=tk.LEFT, padx=(0, 10))
        self.search_entry.bind("<Return>", self.perform_search)
        
        ttk.Button(search_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.perform_search).pack(side=tk.LEFT)
        
        # Frame para resultados
        results_frame = ttk.LabelFrame(main_frame, text="Resultados", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Treeview para resultados
        columns = ("Data", "Usu√°rio", "Mensagem")
        self.results_tree = ttk.Treeview(results_frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.results_tree.heading(col, text=col)
            self.results_tree.column(col, width=150, anchor="w")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=self.results_tree.yview)
        self.results_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.results_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Bot√µes
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X)
        
        ttk.Button(buttons_frame, text="Limpar", image=self.icons.get('clear_icon'), compound=tk.LEFT,
                  command=self.clear_results).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(buttons_frame, text="Fechar", image=self.icons.get('cancel_icon'), compound=tk.LEFT,
                  command=self.window.destroy).pack(side=tk.RIGHT)
        
        # Focar no campo de busca
        self.search_entry.focus()
    
    def perform_search(self, event=None):
        """Executa a busca"""
        search_term = self.search_var.get().strip()
        if not search_term:
            messagebox.showwarning("Aviso", "Digite um termo para buscar!")
            return
        
        # Limpar resultados anteriores
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        
        # Realizar busca
        results = self.app.chat_system.search_chat_history(self.project_name, search_term)
        
        # Exibir resultados
        for result in results:
            self.results_tree.insert("", "end", values=(
                result['timestamp'],
                result['username'],
                result['message'][:50] + "..." if len(result['message']) > 50 else result['message']
            ))
        
        # Mostrar quantidade de resultados
        messagebox.showinfo("Busca Conclu√≠da", f"Encontrados {len(results)} resultados para '{search_term}'")
    
    def clear_results(self):
        """Limpa resultados da busca"""
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        self.search_var.set("")
        self.search_entry.focus()


class CommentSearchWindow:
    """Janela de busca no hist√≥rico de coment√°rios"""
    
    def __init__(self, parent, app, card_id):
        self.parent = parent
        self.app = app
        self.card_id = card_id
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title(f"Buscar Coment√°rios - Cart√£o {card_id}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Criar interface
        self.create_widgets()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        ttk.Label(main_frame, text=f"Buscar Coment√°rios - Cart√£o {self.card_id}", 
                 font=("Arial", 12, "bold")).pack(pady=(0, 10))
        
        # Frame de busca
        search_frame = ttk.Frame(main_frame)
        search_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(search_frame, text="Termo de busca:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.search_var = tk.StringVar()
        self.search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=30)
        self.search_entry.pack(side=tk.LEFT, padx=(0, 10))
        self.search_entry.bind("<Return>", self.perform_search)
        
        ttk.Button(search_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.perform_search).pack(side=tk.LEFT)
        
        # Frame para resultados
        results_frame = ttk.LabelFrame(main_frame, text="Resultados", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Treeview para resultados
        columns = ("Data", "Usu√°rio", "Coment√°rio")
        self.results_tree = ttk.Treeview(results_frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.results_tree.heading(col, text=col)
            self.results_tree.column(col, width=150, anchor="w")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=self.results_tree.yview)
        self.results_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.results_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Bot√µes
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X)
        
        ttk.Button(buttons_frame, text="Limpar", image=self.icons.get('clear_icon'), compound=tk.LEFT,
                  command=self.clear_results).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(buttons_frame, text="Fechar", image=self.icons.get('cancel_icon'), compound=tk.LEFT,
                  command=self.window.destroy).pack(side=tk.RIGHT)
        
        # Focar no campo de busca
        self.search_entry.focus()
    
    def perform_search(self, event=None):
        """Executa a busca"""
        search_term = self.search_var.get().strip()
        if not search_term:
            messagebox.showwarning("Aviso", "Digite um termo para buscar!")
            return
        
        # Limpar resultados anteriores
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        
        # Realizar busca
        results = self.app.chat_system.search_comment_history(self.card_id, search_term)
        
        # Exibir resultados
        for result in results:
            self.results_tree.insert("", "end", values=(
                result['timestamp'],
                result['username'],
                result['comment'][:50] + "..." if len(result['comment']) > 50 else result['comment']
            ))
        
        # Mostrar quantidade de resultados
        messagebox.showinfo("Busca Conclu√≠da", f"Encontrados {len(results)} resultados para '{search_term}'")
    
    def clear_results(self):
        """Limpa resultados da busca"""
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        self.search_var.set("")
        self.search_entry.focus()


class BoodeskApp:
    def on_main_tab_drag_start(self, event):
        try:
            tab_index = self.main_notebook.index(f"@{event.x},{event.y}")
            if tab_index == 0: # Prevent dragging the first tab (Menu Principal)
                return
            if tab_index != "":
                self._drag_data["item"] = self.main_notebook.tabs()[tab_index]
                self._drag_data["tab_index"] = tab_index
        except tk.TclError:
            pass

    def on_main_tab_drag_motion(self, event):
        if self._drag_data["item"]:
            pass # Visual feedback can be added here if needed

    def on_main_tab_drag_release(self, event):
        if self._drag_data["item"]:
            try:
                new_tab_index = self.main_notebook.index(f"@{event.x},{event.y}")
                if new_tab_index == "":
                    new_tab_index = len(self.main_notebook.tabs()) - 1
                if new_tab_index == 0: # Prevent dropping onto the first tab
                    new_tab_index = 1 # or revert

                old_tab_index = self._drag_data["tab_index"]

                if old_tab_index != new_tab_index:
                    self.main_notebook.insert(new_tab_index, self.main_notebook.tabs()[old_tab_index])
            except tk.TclError:
                pass # Invalid drop target
            finally:
                self._drag_data = {"item": None, "x": 0, "y": 0, "tab_index": -1}

    def __init__(self, root, current_user, icons):
        print("DEBUG: Iniciando BoodeskApp.__init__")
        self.root = root
        self.current_user = current_user
        self.icons = icons # Store icons
        self.app = self # For compatibility with the LoginWindow
        
        # Initialize database
        self.db = Database('boodesk_new.db')
        
        # Tentar criar tabelas, se falhar, fazer limpeza for√ßada
        try:
            self.db.create_tables()
        except Exception as e:
            print(f"Erro ao criar tabelas: {e}")
            print("Tentando limpeza for√ßada do banco...")
            self.db.force_cleanup()
            try:
                self.db.create_tables()
            except Exception as e2:
                print(f"Erro persistente: {e2}")
                print("Resetando banco de dados...")
                self.db.reset_database()

        # --- File Paths ---
        if getattr(sys, 'frozen', False):
            # Running as a PyInstaller bundle
            self.base_dir = sys._MEIPASS
        else:
            # Running as a normal script
            self.base_dir = os.path.dirname(os.path.abspath(__file__))
        sep = os.path.sep

        self.settings_file = f"{self.base_dir}{sep}pomodoro_settings.json"
        self.data_file = f"{self.base_dir}{sep}boodesk_data.json"
        self.messages_file = f"{self.base_dir}{sep}pomodoro_motivational_messages.json"

        self.load_settings()
        print("DEBUG: load_settings conclu√≠do")
        self.load_trello_data()
        print("DEBUG: load_trello_data conclu√≠do")
        self.load_pomodoro_data()
        print("DEBUG: load_pomodoro_data conclu√≠do")
        self.load_aux_data()
        print("DEBUG: load_aux_data conclu√≠do")
        self.load_members()
        print("DEBUG: load_members conclu√≠do")
        self.load_categories()
        print("DEBUG: load_categories conclu√≠do")

        # Set the application icon
        if self.icons.get('logo_icon'):
            self.root.iconphoto(False, self.icons['logo_icon'])

        # --- User Management ---
        self.user_management = UserManagement()
        
        # --- Timer State ---
        self.timer_running = False
        self.current_cycle = 0
        self.on_break = False
        self.timer_id = None
        self.time_left = 0
        self.active_pomodoro_task = None

        self.listbox_refs = {}
        self.current_chart_type = "income_vs_expense" # Default chart type

        # --- Integrations ---
        # Email Integration
        self.email_integration = EmailIntegration(self)
        
        # Google Calendar Integration
        self.google_calendar = GoogleCalendarIntegration(self)
        
        # Email Template Manager
        self.email_template_manager = EmailTemplateManager(self)
        
        # --- Chat System ---
        self.chat_system = ChatSystem(self)
        
        # --- Meeting Integration ---
        self.meeting_integration = MeetingIntegration(self)
        
        # --- Notification Manager ---
        self.notification_manager = NotificationManager(self)
        
        # Garantir que self.settings seja um dicion√°rio antes de usar
        print(f"DEBUG: Tipo de self.settings: {type(self.settings)}")
        if not isinstance(self.settings, dict):
            print("DEBUG: self.settings n√£o √© um dicion√°rio, usando padr√µes")
            self.settings = self.get_default_settings()
        print(f"DEBUG: Tipo de self.settings ap√≥s corre√ß√£o: {type(self.settings)}")
        
        # Converter valores JSON string para dicion√°rios
        self._fix_json_strings_in_settings()
        
        # Start integrations if enabled
        email_integration = self.settings.get('email_integration', {})
        if isinstance(email_integration, dict) and email_integration.get('enabled', False):
            self.email_integration.start_email_service()
        
        # Initialize Google Calendar if enabled
        google_calendar = self.settings.get('google_calendar', {})
        if isinstance(google_calendar, dict) and google_calendar.get('enabled', False):
            print("DEBUG: Inicializando integra√ß√£o com Google Calendar")
            # A autentica√ß√£o ser√° feita quando necess√°rio

    def _fix_json_strings_in_settings(self):
        """Converte valores JSON string para dicion√°rios no settings"""
        import json
        
        for key, value in self.settings.items():
            if isinstance(value, str) and value.startswith('{') and value.endswith('}'):
                try:
                    self.settings[key] = json.loads(value)
                    print(f"DEBUG: Convertido {key} de string para dicion√°rio")
                except:
                    pass  # Manter como string se n√£o for JSON v√°lido

        print("DEBUG: Chamando create_menu")
        self.create_menu()
        print("DEBUG: create_menu conclu√≠do")
        
        # Aplicar permiss√µes baseadas no usu√°rio atual (s√≥ se houver usu√°rio)
        if hasattr(self, 'current_user') and self.current_user:
            self.apply_role_permissions()
        print("DEBUG: Chamando create_widgets")
        self.create_widgets()
        print("DEBUG: create_widgets conclu√≠do")
        if self.current_user:
            self.apply_role_permissions()
        
        # Iniciar sistema de notifica√ß√µes
        self.notification_manager.start_notification_monitor()
        
        # Criar widget de reuni√µes se habilitado
        if self.notification_manager.notification_settings['show_widget']:
            # O widget ser√° criado quando o menu principal for criado
            pass

    def parse_brazilian_date(self, date_str):
        """Converte data brasileira (DD/MM/YYYY) para datetime ou vice-versa"""
        if not date_str:
            return None
            
        try:
            # Se j√° √© um objeto datetime, retorna ele mesmo
            if isinstance(date_str, datetime):
                return date_str
                
            # Tentar formato brasileiro primeiro: DD/MM/YYYY
            try:
                return datetime.strptime(date_str, "%d/%m/%Y")
            except ValueError:
                pass
                
            # Tentar formato brasileiro com hora: DD/MM/YYYY HH:MM
            try:
                return datetime.strptime(date_str, "%d/%m/%Y %H:%M")
            except ValueError:
                pass
                
            # Tentar formato brasileiro com hora e segundos: DD/MM/YYYY HH:MM:SS
            try:
                return datetime.strptime(date_str, "%d/%m/%Y %H:%M:%S")
            except ValueError:
                pass
                
            # Tentar formato americano: YYYY-MM-DD
            try:
                return datetime.strptime(date_str, "%Y-%m-%d")
            except ValueError:
                pass
                
            # Tentar formato americano com hora: YYYY-MM-DD HH:MM
            try:
                return datetime.strptime(date_str, "%Y-%m-%d %H:%M")
            except ValueError:
                pass
                
            # Tentar formato americano com hora e segundos: YYYY-MM-DD HH:MM:SS
            try:
                return datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
            except ValueError:
                pass
                
            print(f"Formato de data n√£o reconhecido: {date_str}")
            return None
            
        except Exception as e:
            print(f"Erro ao processar data: {date_str} - {e}")
            return None

    def get_board_id_by_name(self, board_name):
        """Get board ID by name from SQL database"""
        try:
            # Get current user ID to filter boards by owner
            user_id = self.get_current_user_id()
            if hasattr(self, 'db') and self.db:
                try:
                    for board in self.db.get_boards(user_id):
                        if board['name'] == board_name:
                            return board['id']
                except Exception as db_error:
                    print(f"DEBUG: Erro ao acessar banco de dados: {db_error}")
            # Fallback: return default board ID if database is not available
            print(f"DEBUG: Usando board_id padr√£o (1) para quadro '{board_name}'")
            return 1
        except Exception as e:
            print(f"Erro ao buscar board: {e}")
            # Fallback: return default board ID
            return 1
    
    def get_board_id_by_name_safe(self, board_name):
        """Vers√£o segura do get_board_id_by_name que sempre retorna um valor"""
        try:
            return self.get_board_id_by_name(board_name)
        except Exception as e:
            print(f"DEBUG: Erro no get_board_id_by_name_safe: {e}")
            return 1  # Sempre retorna 1 como fallback
    
    def __getattr__(self, name):
        """Fallback para m√©todos n√£o encontrados"""
        if name == 'get_board_id_by_name':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda board_name: 1  # Retorna sempre board_id 1
        elif name == 'get_board_id_by_name_safe':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda board_name: 1  # Retorna sempre board_id 1
        elif name == 'time_left':
            print(f"DEBUG: Atributo {name} n√£o encontrado, inicializando com 0")
            self.time_left = 0
            return 0
        elif name == 'timer_running':
            print(f"DEBUG: Atributo {name} n√£o encontrado, inicializando com False")
            self.timer_running = False
            return False
        elif name == 'current_cycle':
            print(f"DEBUG: Atributo {name} n√£o encontrado, inicializando com 0")
            self.current_cycle = 0
            return 0
        elif name == 'on_break':
            print(f"DEBUG: Atributo {name} n√£o encontrado, inicializando com False")
            self.on_break = False
            return False
        elif name == 'timer_id':
            print(f"DEBUG: Atributo {name} n√£o encontrado, inicializando com None")
            self.timer_id = None
            return None
        elif name == 'active_pomodoro_task':
            print(f"DEBUG: Atributo {name} n√£o encontrado, inicializando com None")
            self.active_pomodoro_task = None
            return None
        elif name == 'pomodoro_timer_label':
            print(f"DEBUG: Widget {name} n√£o encontrado, retornando None")
            return None
        elif name == 'timer_label':
            print(f"DEBUG: Widget {name} n√£o encontrado, retornando None")
            return None
        elif name == 'pomodoro_frame':
            print(f"DEBUG: Widget {name} n√£o encontrado, retornando None")
            return None
        elif name == 'timer_frame':
            print(f"DEBUG: Widget {name} n√£o encontrado, retornando None")
            return None
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def notify_member_added_to_card(self, card_id, member_name, added_by):
        """Notifica membro quando adicionado a um card"""
        try:
            card = self.get_card_by_id(card_id)
            if not card:
                return
            
            notification = {
                'type': 'member_added',
                'card_title': card['title'],
                'card_id': card_id,
                'member': member_name,
                'added_by': added_by,
                'board': card.get('board_name', ''),
                'list': card.get('list_name', ''),
                'timestamp': datetime.now().isoformat(),
                'read': False
            }
            
            # Salvar notifica√ß√£o no banco (se m√©todo existir)
            if hasattr(self, 'db') and hasattr(self.db, 'save_notification'):
                self.db.save_notification(notification)
            
            # Mostrar notifica√ß√£o na interface
            self.show_notification_popup(notification)
            
            # Enviar email se configurado
            if hasattr(self, 'email_integration'):
                self.email_integration.notify_member_added(notification)
                
        except Exception as e:
            print(f"Erro ao notificar membro adicionado: {e}")

    def show_notification_popup(self, notification):
        """Mostra popup de notifica√ß√£o"""
        try:
            popup = tk.Toplevel(self.root)
            popup.title("Nova Notifica√ß√£o")
            popup.geometry("400x200")
            popup.resizable(False, False)
            
            # Centralizar popup
            popup.transient(self.root)
            popup.grab_set()
            
            message = f"Voc√™ foi adicionado ao card:\n'{notification['card_title']}'\n\nQuadro: {notification['board']}\nLista: {notification['list']}"
            
            ttk.Label(popup, text=message, wraplength=350, justify='center').pack(pady=20)
            
            button_frame = ttk.Frame(popup)
            button_frame.pack(pady=10)
            
            ttk.Button(button_frame, text="Ver Card", 
                      command=lambda: self.open_card_from_notification(notification['card_id'])).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Fechar", command=popup.destroy).pack(side=tk.LEFT, padx=5)
            
        except Exception as e:
            print(f"Erro ao mostrar popup de notifica√ß√£o: {e}")

    def open_card_from_notification(self, card_id):
        """Abre card a partir de notifica√ß√£o"""
        try:
            # Encontrar card nos dados
            for board_name, board_data in self.boodesk_data['boards'].items():
                for list_name, cards in board_data.items():
                    if isinstance(cards, list):
                        for card in cards:
                        if card.get('card_id') == card_id:
                            # Abrir janela do card
                            CardWindow(self.root, self, board_name, list_name, card_id, self.current_user)
                            return
            print(f"Card {card_id} n√£o encontrado")
        except Exception as e:
            print(f"Erro ao abrir card: {e}")

    def get_card_by_id(self, card_id):
        """Retorna card pelo ID - busca tanto no banco quanto na mem√≥ria"""
        try:
            # Primeiro, tentar buscar no banco de dados
            if hasattr(self, 'db') and self.db:
                try:
                    card_data = self.db.get_card_by_id(card_id)
                    if card_data:
                        # Converter para dicion√°rio se necess√°rio
                        if not isinstance(card_data, dict):
                            card_data = dict(card_data)
                        
                        # Adicionar informa√ß√µes do board e lista
                        board_name = self.db.get_board_name_by_id(card_data.get('board_id'))
                        card_data['board_name'] = board_name or 'Quadro Principal'
                        card_data['list_name'] = card_data.get('list_name', 'A Fazer')
                        return card_data
                except Exception as db_error:
                    print(f"Erro ao buscar card no banco: {db_error}")
            
            # Se n√£o encontrou no banco, buscar na estrutura em mem√≥ria
            for board_name, board_data in self.boodesk_data['boards'].items():
                if isinstance(board_data, dict):
                    for list_name, cards in board_data.items():
                        if list_name == 'workflow':  # Ignorar metadados
                            continue
                        if isinstance(cards, list):
                            for card in cards:
                                if card.get('card_id') == card_id:
                                    card['board_name'] = board_name
                                    card['list_name'] = list_name
                                    return card
            
            print(f"Card com ID {card_id} n√£o encontrado")
            return None
        except Exception as e:
            print(f"Erro ao buscar card por ID: {e}")
            return None

    def create_member_dashboard(self, member_name):
        """Cria dashboard personalizado para o membro"""
        dashboard = {
            'my_cards': self.get_cards_by_member(member_name),
            'my_boards': self.get_boards_for_member(member_name),
            'pending_tasks': self.get_pending_tasks(member_name),
            'completed_tasks': self.get_completed_tasks(member_name),
            'recent_activities': self.get_recent_activities(member_name),
            'upcoming_deadlines': self.get_upcoming_deadlines(member_name)
        }
        return dashboard

    def get_cards_by_member(self, member_name):
        """Retorna todos os cards onde o membro participa"""
        cards = []
        for board_name, board_data in self.boodesk_data['boards'].items():
            for list_name, cards_list in board_data.items():
                if list_name == 'workflow':
                    continue
                for card in cards_list:
                    if member_name in card.get('members', []):
                        card['board_name'] = board_name
                        card['list_name'] = list_name
                        cards.append(card)
        return cards

    def get_pending_tasks(self, member_name):
        """Retorna tarefas pendentes do membro"""
        return [card for card in self.get_cards_by_member(member_name) 
                if card.get('status') != 'done']

    def get_completed_tasks(self, member_name, days=30):
        """Retorna tarefas completadas nos √∫ltimos X dias"""
        cutoff_date = datetime.now() - timedelta(days=days)
        completed = []
        for card in self.get_cards_by_member(member_name):
            if card.get('status') == 'done':
                completed_date = card.get('completed_at')
                if completed_date and completed_date > cutoff_date:
                    completed.append(card)
        return completed

    def get_recent_activities(self, member_name, limit=10):
        """Retorna atividades recentes relacionadas ao membro"""
        # Implementa√ß√£o b√°sica - pode ser expandida com banco de dados
        activities = []
        cards = self.get_cards_by_member(member_name)
        for card in cards[:limit]:
            activities.append({
                'action': 'Card atribu√≠do',
                'card_title': card['title'],
                'timestamp': card.get('created_at', 'Data n√£o dispon√≠vel')
            })
        return activities

    def get_upcoming_deadlines(self, member_name, days=7):
        """Retorna prazos pr√≥ximos do membro"""
        cutoff_date = datetime.now() + timedelta(days=days)
        upcoming = []
        for card in self.get_cards_by_member(member_name):
            if card.get('status') != 'done':
                due_date = card.get('due_date')
                if due_date and due_date <= cutoff_date:
                    upcoming.append(card)
        return upcoming

    def show_member_dashboard(self, member_name):
        """Mostra dashboard personalizado do membro"""
        try:
            dashboard = self.create_member_dashboard(member_name)
            
            # Criar janela do dashboard
            dashboard_window = tk.Toplevel(self.root)
            dashboard_window.title(f"Dashboard - {member_name}")
            dashboard_window.geometry("800x600")
            dashboard_window.resizable(True, True)
            
            # Notebook para organizar as se√ß√µes
            notebook = ttk.Notebook(dashboard_window)
            notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Aba de Cards Ativos
            active_frame = ttk.Frame(notebook)
            notebook.add(active_frame, text="Meus Cards")
            
            # Treeview para cards ativos
            columns = ("T√≠tulo", "Quadro", "Lista", "Status", "Prazo")
            tree = ttk.Treeview(active_frame, columns=columns, show="headings")
            
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=120)
            
            # Adicionar cards
            for card in dashboard['my_cards']:
                tree.insert("", "end", values=(
                    card['title'],
                    card['board_name'],
                    card['list_name'],
                    card.get('status', 'Pendente'),
                    card.get('due_date', '-')
                ))
            
            tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Aba de Estat√≠sticas
            stats_frame = ttk.Frame(notebook)
            notebook.add(stats_frame, text="Estat√≠sticas")
            
            stats_text = f"""
            üìä Estat√≠sticas de {member_name}
            
            üìã Total de Cards: {len(dashboard['my_cards'])}
            ‚è≥ Pendentes: {len(dashboard['pending_tasks'])}
            ‚úÖ Completados (30 dias): {len(dashboard['completed_tasks'])}
            üìÖ Prazos Pr√≥ximos: {len(dashboard['upcoming_deadlines'])}
            üìã Quadros Ativos: {len(dashboard['my_boards'])}
            """
            
            ttk.Label(stats_frame, text=stats_text, justify='left', font=('Arial', 12)).pack(pady=20)
            
        except Exception as e:
            print(f"Erro ao mostrar dashboard: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel mostrar o dashboard: {e}")

    def open_personal_dashboard(self):
        """Abre dashboard personalizado do usu√°rio atual"""
        try:
            # Obter membro do usu√°rio atual
            current_user_member = self._get_current_user_member()
            
            if not current_user_member:
                messagebox.showwarning("Aviso", "Usu√°rio n√£o tem membro associado. Dashboard n√£o dispon√≠vel.")
                return
            
            # Mostrar dashboard
            self.show_member_dashboard(current_user_member)
            
        except Exception as e:
            print(f"Erro ao abrir dashboard pessoal: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir o dashboard: {e}")

    def format_brazilian_date(self, date_obj):
        """Converte datetime para formato brasileiro (DD/MM/YYYY)"""
        if not date_obj:
            return ""
            
        try:
            if isinstance(date_obj, str):
                # Se j√° √© string, tentar converter primeiro
                date_obj = self.parse_brazilian_date(date_obj)
                
            if isinstance(date_obj, datetime):
                return date_obj.strftime("%d/%m/%Y")
            else:
                return str(date_obj)
                
        except Exception as e:
            print(f"Erro ao formatar data: {date_obj} - {e}")
            return str(date_obj) if date_obj else ""

    def format_brazilian_datetime(self, date_obj):
        """Converte datetime para formato brasileiro com hora (DD/MM/YYYY HH:MM)"""
        if not date_obj:
            return ""
            
        try:
            if isinstance(date_obj, str):
                # Se j√° √© string, tentar converter primeiro
                date_obj = self.parse_brazilian_date(date_obj)
                
            if isinstance(date_obj, datetime):
                return date_obj.strftime("%d/%m/%Y %H:%M")
            else:
                return str(date_obj)
                
        except Exception as e:
            print(f"Erro ao formatar data/hora: {date_obj} - {e}")
            return str(date_obj) if date_obj else ""

    
    def check_permission(self, permission):
        """Verifica se o usu√°rio atual tem uma determinada permiss√£o"""
        if not hasattr(self, 'current_user') or not self.current_user:
            return False
        
        # Verificar se o usu√°rio tem o m√©todo has_permission
        if not hasattr(self.current_user, 'has_permission'):
            print("DEBUG: Usu√°rio n√£o tem m√©todo has_permission")
            return False
        
        return self.current_user.has_permission(permission)
    
    def require_permission(self, permission, action_name="esta a√ß√£o"):
        """Verifica permiss√£o e mostra erro se n√£o tiver"""
        if not self.check_permission(permission):
            messagebox.showerror("Acesso Negado", 
                               f"Voc√™ n√£o tem permiss√£o para {action_name}.\n"
                               f"Contate um administrador se precisar de acesso.")
            return False
        return True
    
    def open_user_management(self):
        """Abre a janela de gerenciamento de usu√°rios"""
        try:
            # Verificar se o usu√°rio tem permiss√£o
            if not self.require_permission("manage_users", "gerenciar usu√°rios"):
                return
            
            # Verificar se user_management est√° dispon√≠vel
            if not hasattr(self, 'user_management') or self.user_management is None:
                messagebox.showerror("Erro", "Sistema de gerenciamento de usu√°rios n√£o dispon√≠vel.")
                return
            
            # Verificar se icons est√° dispon√≠vel
            if not hasattr(self, 'icons') or self.icons is None:
                messagebox.showerror("Erro", "√çcones n√£o dispon√≠veis.")
                return
            
            # Abrir janela de gerenciamento
            print("DEBUG: Abrindo janela de gerenciamento de usu√°rios...")
            UserRegistrationWindow(self.root, self.user_management, self.icons, app=self)
            print("DEBUG: Janela de gerenciamento de usu√°rios aberta com sucesso!")
            
        except Exception as e:
            print(f"DEBUG: Erro ao abrir gerenciamento de usu√°rios: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir a tela de gerenciar usu√°rios: {e}")
    
    def open_notification_settings(self):
        """Abre a janela de configura√ß√µes de notifica√ß√£o"""
        NotificationSettingsWindow(self)
    
    def toggle_meeting_widget(self):
        """Alterna a visibilidade do widget de reuni√µes"""
        if hasattr(self, 'meeting_widget') and self.meeting_widget:
            if self.meeting_widget.widget_frame:
                self.meeting_widget.widget_frame.destroy()
                self.meeting_widget = None
                self.notification_manager.notification_settings['show_widget'] = False
        else:
            # Encontrar o frame do menu principal
            for child in self.main_notebook.winfo_children():
                if self.main_notebook.tab(child, "text") == "Menu Principal":
                    self.meeting_widget = MeetingWidget(self, child)
                    self.notification_manager.notification_settings['show_widget'] = True
                    break
        
        # Salvar configura√ß√£o
        self.notification_manager.save_notification_settings()
    
    def on_closing(self):
        """Chamado quando a aplica√ß√£o est√° sendo fechada"""
        try:
            # Parar sistema de notifica√ß√µes
            if hasattr(self, 'notification_manager'):
                self.notification_manager.stop_notification_monitor()
            
            # Salvar configura√ß√µes
            self.save_settings_file()
            
            # Salvar dados do Boodesk
            self.save_trello_data()
            
            # Salvar dados do Pomodoro
            self.save_pomodoro_data()
            
            # Salvar dados financeiros
            self.save_finance_data()
            
            # Salvar dados de estudo
            self.save_study_data()
            
            # Salvar dados de objetivos
            self.save_goals_data()
            
            # Salvar dados de membros
            self.save_members_data()
            
            # Salvar dados de assuntos
            self.save_subjects_data()
            
            print("DEBUG: Todos os dados foram salvos com sucesso")
            
        except Exception as e:
            print(f"Erro ao salvar dados: {e}")
        
        finally:
            # Fechar aplica√ß√£o
            self.root.destroy()
    
    def logout(self):
        """Faz logout do usu√°rio atual"""
        if messagebox.askyesno("Logout", "Tem certeza que deseja fazer logout?"):
            # Limpar dados do usu√°rio atual
            self.current_user = None
            
            # Ocultar janela principal
            self.root.withdraw()
            
            # Mostrar tela de login novamente
            login_window = LoginWindow(self.root, self.user_management, self.icons)
            self.root.wait_window(login_window)
            
            # Verificar se o login foi bem-sucedido
            if hasattr(self.root, 'login_successful') and self.root.login_successful and self.root.current_user:
                # Configurar novo usu√°rio na aplica√ß√£o
                self.current_user = self.root.current_user
                self.apply_role_permissions()
                
                # Recriar menu com novo usu√°rio
                self.create_menu()
                
                # Mostrar aplica√ß√£o principal
                self.root.deiconify()
            else:
                # Login cancelado ou falhou
                self.root.destroy()
        

    def update_all_displays(self):
        self.update_timer_display()
        self.populate_boards()
        self.update_pomodoro_task_list()
        self.update_my_activities_tab() # Adicionado
        self.update_log()
        self.update_accounts_listbox()
        self.update_total_balance_display()
        self.update_categories_listbox()
        self.update_payment_methods_listbox()
        self.update_transactions_treeview()
        self.populate_finance_comboboxes()
        self._show_chart(self.current_chart_type)
        self._update_saved_filters_combo()

        # Initialize filter comboboxes
        self.filter_subject_combo['values'] = ["Todos"] + sorted(list(set(self.pomodoro_subjects + self.boodesk_subjects)))
        self.filter_goal_combo['values'] = ["Todos"] + sorted(self.goals)
        self.filter_importance_combo['values'] = ["Todos"] + list(self.settings["importance_colors"].keys())
        self.filter_member_combo['values'] = ["Todos"] + sorted([member['Membro'] for member in self.members])

    def apply_card_filter(self):
        self.populate_boards()

    def clear_card_filter(self):
        self.filter_subject_var.set("Todos")
        self.filter_goal_var.set("Todos")
        self.filter_member_var.set("Todos") # Changed from set("") to set("Todos")
        self.filter_due_date_var.set("Todos")
        self.filter_importance_var.set("Todos")
        self.filter_recurrence_var.set("Todos")
        self.filter_keyword_var.set("") # Clear keyword filter
        self.populate_boards()
        self._update_saved_filters_combo()

    def save_filter(self):
        filter_name = simpledialog.askstring("Salvar Filtro", "Digite um nome para este filtro:", parent=self.root)
        if filter_name:
            current_filter_settings = {
                "subject": self.filter_subject_var.get(),
                "goal": self.filter_goal_var.get(),
                "member": self.filter_member_var.get(),
                "due_date": self.filter_due_date_var.get(),
                "importance": self.filter_importance_var.get(),
                "recurrence": self.filter_recurrence_var.get(),
                "keyword": self.filter_keyword_var.get()
            }
            self.settings["custom_filters"][filter_name] = current_filter_settings
            self.save_settings_file()
            self._update_saved_filters_combo()
            messagebox.showinfo("Filtro Salvo", f"Filtro '{filter_name}' salvo com sucesso!")

    def load_filter(self, event=None):
        filter_name = self.saved_filters_combo.get()
        if filter_name and filter_name in self.settings["custom_filters"]:
            filter_settings = self.settings["custom_filters"][filter_name]
            self.filter_subject_var.set(filter_settings.get("subject", "Todos"))
            self.filter_goal_var.set(filter_settings.get("goal", "Todos"))
            self.filter_member_var.set(filter_settings.get("member", "Todos"))
            self.filter_due_date_var.set(filter_settings.get("due_date", "Todos"))
            self.filter_importance_var.set(filter_settings.get("importance", "Todos"))
            self.filter_recurrence_var.set(filter_settings.get("recurrence", "Todos"))
            self.filter_keyword_var.set(filter_settings.get("keyword", ""))
            self.apply_card_filter()
            messagebox.showinfo("Filtro Carregado", f"Filtro '{filter_name}' carregado com sucesso!")

    def delete_filter(self):
        filter_name = self.saved_filters_combo.get()
        if filter_name and filter_name in self.settings["custom_filters"]:
            if messagebox.askyesno("Excluir Filtro", f"Tem certeza que deseja excluir o filtro '{filter_name}'?"):
                del self.settings["custom_filters"][filter_name]
                self.save_settings_file()
                self._update_saved_filters_combo()
                self.clear_card_filter()
                messagebox.showinfo("Filtro Exclu√≠do", f"Filtro '{filter_name}' exclu√≠do com sucesso!")
        else:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um filtro para excluir.")

    def _update_saved_filters_combo(self):
        self.saved_filters_combo['values'] = sorted(list(self.settings["custom_filters"].keys()))
        self.saved_filters_combo.set("") # Clear current selection

    def toggle_filter_visibility(self):
        if self.filter_visible.get():
            self.filter_container_frame.pack_forget()
            self.toggle_filter_button.config(text="Mostrar Filtros")
        else:
            self.filter_container_frame.pack(fill=tk.X, pady=5, padx=5)
            self.toggle_filter_button.config(text="Ocultar Filtros")
        self.filter_visible.set(not self.filter_visible.get())

    def _filter_due_date(self, card_due_date_str, filter_option):
        if not card_due_date_str:
            return False # Cards without due dates don't match any date filter

        try:
            card_due_date = datetime.strptime(card_due_date_str.split(' ')[0], "%Y-%m-%d").date()
        except ValueError:
            return False # Invalid date format

        today = datetime.now().date()
        
        if filter_option == "Hoje":
            return card_due_date == today
        elif filter_option == "Pr√≥ximos 7 dias":
            seven_days_from_now = today + timedelta(days=7)
            return today <= card_due_date <= seven_days_from_now
        elif filter_option == "Vencidos":
            return card_due_date < today
        return True # "Todos" or other cases

    # --- Data Loading/Saving ---
    def load_settings(self):
        """Load settings from SQL database instead of JSON files"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, usando configura√ß√µes padr√£o")
                self.settings = self.get_default_settings()
                return
            
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Se n√£o h√° usu√°rio logado, usar user_id padr√£o (1 = admin)
            if user_id is None:
                user_id = 1
                print("DEBUG: Usando user_id padr√£o (1) para configura√ß√µes")
            
            # Load settings from database for current user
            db_settings = self.db.get_all_settings(user_id)
            
            if db_settings and isinstance(db_settings, dict):
                self.settings = db_settings
            else:
                # No settings in database, use defaults
                self.settings = self.get_default_settings()
                # Save defaults to database for current user
                for key, value in self.settings.items():
                    try:
                        self.db.save_setting(key, value, user_id)
                    except Exception as save_error:
                        print(f"Erro ao salvar configura√ß√£o {key}: {save_error}")
            
            # Garantir que self.settings seja um dicion√°rio
            if not isinstance(self.settings, dict):
                print("DEBUG: self.settings n√£o √© um dicion√°rio, usando padr√µes")
                self.settings = self.get_default_settings()
            
            # Merge with default settings to ensure all keys are present
            default_settings = self.get_default_settings()
            for key, value in default_settings.items():
                if key not in self.settings:
                    self.settings[key] = value
                    try:
                        self.db.save_setting(key, value, user_id)
                    except Exception as save_error:
                        print(f"Erro ao salvar configura√ß√£o {key}: {save_error}")
                elif isinstance(value, dict) and isinstance(self.settings[key], dict):
                    # Recursively merge dictionaries (e.g., for importance_colors, roles)
                    self.settings[key] = {**value, **self.settings[key]}
                    try:
                        self.db.save_setting(key, self.settings[key], user_id)
                    except Exception as save_error:
                        print(f"Erro ao salvar configura√ß√£o {key}: {save_error}")
                    
        except Exception as e:
            print(f"Erro ao carregar configura√ß√µes do banco: {e}")
            messagebox.showwarning("Erro de Configura√ß√£o", f"N√£o foi poss√≠vel carregar as configura√ß√µes do banco. Usando padr√µes. Erro: {e}")
            self.settings = self.get_default_settings()
            # Try to save defaults to database
            try:
                if hasattr(self, 'db') and self.db is not None:
                    user_id = self.get_current_user_id()
                    # Se n√£o h√° usu√°rio logado, usar user_id padr√£o (1 = admin)
                    if user_id is None:
                        user_id = 1
                    for key, value in self.settings.items():
                        self.db.save_setting(key, value, user_id)
            except Exception as save_error:
                print(f"Erro ao salvar configura√ß√µes padr√£o: {save_error}")

    def get_current_user_id(self):
        """Retorna o ID do usu√°rio atual no banco de dados"""
        try:
            print("DEBUG: get_current_user_id - Iniciando...")
            
            if not self.current_user:
                print("DEBUG: current_user n√£o definido")
                return None
            
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco de dados n√£o dispon√≠vel")
                return None
            
            username = self.current_user.username
            print(f"DEBUG: get_current_user_id - Username: {username}")
            
            if not username:
                print("DEBUG: Username n√£o definido")
                return None
            
            print("DEBUG: get_current_user_id - Chamando get_user_by_username...")
            user_data = self.db.get_user_by_username(username)
            print(f"DEBUG: get_current_user_id - user_data: {user_data}")
            
            if user_data and 'id' in user_data:
                user_id = user_data['id']
                print(f"DEBUG: get_current_user_id - user_id: {user_id}")
                
                # Verificar se o usu√°rio tem um membro associado
                if 'member_id' in user_data and user_data['member_id']:
                    member_id = user_data['member_id']
                    print(f"DEBUG: get_current_user_id - member_id: {member_id}")
                    print(f"DEBUG: ID do usu√°rio {username}: {user_id} (membro associado: {member_id})")
                    return user_id
                else:
                    print(f"DEBUG: get_current_user_id - member_id n√£o encontrado ou None")
                    print(f"DEBUG: Usu√°rio {username} n√£o tem membro associado")
                    messagebox.showerror("Erro", "Usu√°rio n√£o tem membro associado. Contate o administrador.", parent=self.root)
                    return None
            else:
                print(f"DEBUG: get_current_user_id - user_data inv√°lido: {user_data}")
                print(f"DEBUG: Usu√°rio {username} n√£o encontrado no banco ou sem ID")
                return None
                
        except Exception as e:
            print(f"DEBUG: Erro ao obter ID do usu√°rio: {e}")
            return None

    def get_default_settings(self):
        return {
            "pomodoro": 25, 
            "short_break": 5, 
            "long_break": 15, 
            "cycles": 4, 
            "theme": "aquativo", 
            "unify_subjects": False, 
            "show_card_details_on_board": False,
            "show_dependency_info": True,
            "open_on_current_screen": False, # New setting
            "importance_colors": {
                "Cr√≠tica": "#FFCCCC",
                "Alta": "#FFE5CC",
                "Normal": "#FFFFCC",
                "Baixa": "#CCFFCC"
            },
            "card_tags": {
                "Urgente": "#FF0000",
                "Importante": "#FFA500",
                "Desenvolvimento": "#0000FF",
                "Bug": "#FFD700",
                "Feature": "#008000"
            },
            "custom_filters": {}, # New: To store custom filter presets
            "dev_mode": False, # New: Development mode for agile features
            "git_integration_enabled": False, # New: Enable/disable Git integration features
            "roles": {
                "Administrador": "Acesso total ao sistema.",
                "Usu√°rio": "Acesso limitado a funcionalidades b√°sicas.",
                "Convidado": "Apenas visualiza√ß√£o."
            },
            "dashboard_widgets": {
                "urgent_tasks": True,
                "upcoming_deadlines": True,
                "recent_activities": True,
                "quick_links": True,
                "overview": True,
                "quick_actions": True
            },
            # Configura√ß√µes do Google Calendar removidas - integra√ß√£o desabilitada
            "email_integration": {
                "enabled": False,
                "provider": "gmail",
                "smtp_server": "smtp.gmail.com",
                "smtp_port": 587,
                "email_address": "",
                "email_password": "",
                "app_password": "",
                "auto_notifications": {
                    "card_created": True,
                    "card_modified": True,
                    "card_moved": True,
                    "deadline_reminder": True,
                    "weekly_report": True
                },
                "notification_recipients": [],
                "deadline_reminder_hours": 24,
                "weekly_report_day": "monday",
                "weekly_report_time": "09:00",
                "email_templates": {
                    "card_created": "Novo cart√£o criado: {title}",
                    "card_modified": "Cart√£o modificado: {title}",
                    "deadline_reminder": "Lembrete de prazo: {title} vence em {deadline}",
                    "weekly_report": "Relat√≥rio Semanal - {week_period}"
                }
            }
        }

    def save_settings_file(self):
        """Save settings to SQL database instead of JSON files"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar configura√ß√µes")
                return
            
            # Obter user_id se dispon√≠vel
            user_id = None
            if hasattr(self, 'current_user') and self.current_user:
                user_id = self.get_current_user_id()
            
            for key, value in self.settings.items():
                try:
                    if user_id:
                        self.db.save_setting(key, value, user_id)
                    else:
                        # Se n√£o h√° usu√°rio logado, usar user_id padr√£o (1 = admin)
                        self.db.save_setting(key, value, 1)
                except Exception as save_error:
                    print(f"Erro ao salvar configura√ß√£o {key}: {save_error}")
            print("Configura√ß√µes salvas no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar configura√ß√µes no banco: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel salvar as configura√ß√µes no banco: {e}")

    def load_trello_data(self):
        """Load data from SQL database instead of JSON files"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, usando dados padr√£o")
                self.boodesk_data = {
                    "boards": {
                        "Quadro Principal": {
                            "A Fazer": [],
                            "Em Progresso": [],
                            "Conclu√≠do": []
                        },
                        "workflow": ["A Fazer", "Em Progresso", "Conclu√≠do"]
                    },
                    "finances": {
                        "contas_bancarias": [],
                        "categorias_gasto": [],
                        "meios_pagamento": [],
                        "transacoes": []
                    }
                }
                return
            
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Check if database has data, if not create default board
            boards = self.db.get_boards(user_id)
            if not boards:
                print("DEBUG: Nenhum quadro encontrado no banco, criando quadro padr√£o")
                # Create default board for current user
                board_id = self.db.create_board("Quadro Principal", owner_id=user_id)
                # Create default card
                self.db.create_card(
                    board_id=board_id,
                    list_name="A Fazer",
                    title="Sua primeira tarefa",
                    description="Bem-vindo ao Boodesk! Esta √© sua primeira tarefa.",
                    importance="Normal",
                    user_id=user_id
                )
                boards = self.db.get_boards(user_id)
            
            # Load data from database
            self.boodesk_data = {'boards': {}}
            for board in boards:
                board_name = board['name']
                self.boodesk_data['boards'][board_name] = {}
                
                cards = self.db.get_cards_for_board(board['id'])
                
                # Garantir que as listas padr√£o existam mesmo se vazias
                if board_name == "Quadro Principal":
                    self.boodesk_data['boards'][board_name] = {
                        "A Fazer": [],
                        "Em Progresso": [],
                        "Conclu√≠do": []
                    }
                
                for card in cards:
                    list_name = card['list_name']
                    if list_name not in self.boodesk_data['boards'][board_name]:
                        self.boodesk_data['boards'][board_name][list_name] = []
                    
                    # Convert SQL card to JSON structure for compatibility
                    card_data = {
                        'title': card['title'],
                        'desc': card['description'] or '',
                        'due_date': card['due_date'] or '',
                        'members': json.loads(card['members']) if card['members'] else [],
                        'subject': card['subject'] or '-',
                        'goal': card['goal'] or '-',
                        'importance': card['importance'] or 'Normal',
                        'creation_date': card['creation_date'] or '',
                        'card_id': card['card_id'],
                        'is_archived': bool(card['is_archived']),
                        'git_branch': card['git_branch'] or '',
                        'git_commit': card['git_commit'] or '',
                        'history': json.loads(card['history']) if card['history'] else [],
                        'dependencies': json.loads(card['dependencies']) if card['dependencies'] else [],
                        'recurrence': card['recurrence'] or 'Nenhuma'
                    }
                    self.boodesk_data['boards'][board_name][list_name].append(card_data)
            
            # Add workflow
            self.boodesk_data['boards']['workflow'] = ["A Fazer", "Em Progresso", "Conclu√≠do"]
            
            # Garantir que pelo menos o Quadro Principal existe
            if "Quadro Principal" not in self.boodesk_data['boards']:
                self.boodesk_data['boards']["Quadro Principal"] = {
                    "A Fazer": [],
                    "Em Progresso": [],
                    "Conclu√≠do": []
                }
            
            print(f"DEBUG: load_trello_data conclu√≠do. Quadros carregados: {list(self.boodesk_data['boards'].keys())}")
            
            # Load finances from database
            finances = self.db.get_finance_data('finances')
            if finances:
                self.boodesk_data['finances'] = finances
            else:
                self.boodesk_data['finances'] = {
                    "contas_bancarias": [],
                    "categorias_gasto": [],
                    "meios_pagamento": [],
                    "transacoes": []
                }
                # Save default finances to database
                for key, value in self.boodesk_data['finances'].items():
                    try:
                        self.db.save_finance_data('finances', key, value)
                    except Exception as save_error:
                        print(f"Erro ao salvar dados financeiros {key}: {save_error}")
                    
        except Exception as e:
            print(f"Erro ao carregar dados do banco: {e}")
            # Em caso de erro, usar dados padr√£o
            self.boodesk_data = {
                "boards": {
                    "Quadro Principal": {
                        "A Fazer": [],
                        "Em Progresso": [],
                        "Conclu√≠do": []
                    },
                    "workflow": ["A Fazer", "Em Progresso", "Conclu√≠do"]
                },
                "finances": {
                    "contas_bancarias": [],
                    "categorias_gasto": [],
                    "meios_pagamento": [],
                    "transacoes": []
                }
            }
            messagebox.showerror("Erro", f"Ocorreu um erro ao carregar os dados do banco: {e}")
            messagebox.showerror("Erro", f"Ocorreu um erro ao carregar os dados do banco: {e}")
            # Create minimal default data
            self.boodesk_data = {
                "boards": {
                    "Quadro Principal": {
                        "A Fazer": [],
                        "Em Progresso": [],
                        "Conclu√≠do": []
                    },
                    "workflow": ["A Fazer", "Em Progresso", "Conclu√≠do"]
                },
                "finances": {
                    "contas_bancarias": [],
                    "categorias_gasto": [],
                    "meios_pagamento": [],
                    "transacoes": []
                }
            }

    def save_trello_data(self):
        """Save data to SQL database instead of JSON files"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados")
                return
            
            # Garantir que h√° uma conex√£o v√°lida
            if not self.db.is_connected():
                print("DEBUG: Reconectando ao banco...")
                self.db.ensure_connection()
            
            # Export current boodesk_data structure to database
            self.db.migrate_from_json(self.boodesk_data)
            print("Dados salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados no banco: {e}")
            messagebox.showerror("Erro ao Salvar Dados", f"Ocorreu um erro ao salvar os dados no banco: {e}")

    def save_pomodoro_data(self):
        """Save pomodoro data to database"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados do pomodoro")
                return
            
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Salvar tarefas do pomodoro
            for task in self.pomodoro_tasks:
                try:
                    self.db.save_pomodoro_task(
                        title=task.get('title', ''),
                        description=task.get('description', ''),
                        status=task.get('status', 'pending'),
                        user_id=user_id
                    )
                except Exception as e:
                    print(f"Erro ao salvar tarefa do pomodoro: {e}")
            
            print("Dados do pomodoro salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados do pomodoro: {e}")

    def save_finance_data(self):
        """Save finance data to database"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados financeiros")
                return
            
            # Salvar dados financeiros
            for key, value in self.boodesk_data.get('finances', {}).items():
                try:
                    self.db.save_finance_data('finances', key, value)
                except Exception as e:
                    print(f"Erro ao salvar dados financeiros {key}: {e}")
            
            print("Dados financeiros salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados financeiros: {e}")

    def save_study_data(self):
        """Save study data to database"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados de estudo")
                return
            
            # Salvar dados de estudo (implementar conforme necess√°rio)
            print("Dados de estudo salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados de estudo: {e}")

    def save_goals_data(self):
        """Save goals data to database"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados de objetivos")
                return
            
            # Salvar dados de objetivos (implementar conforme necess√°rio)
            print("Dados de objetivos salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados de objetivos: {e}")

    def save_members_data(self):
        """Save members data to database"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados de membros")
                return
            
            # Salvar dados de membros
            try:
                self.db.save_members(self.members)
                print("Dados de membros salvos no banco SQL com sucesso")
            except Exception as e:
                print(f"Erro ao salvar dados de membros: {e}")
        except Exception as e:
            print(f"Erro ao salvar dados de membros: {e}")

    def save_subjects_data(self):
        """Save subjects data to database"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados de assuntos")
                return
            
            # Salvar dados de assuntos (implementar conforme necess√°rio)
            print("Dados de assuntos salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados de assuntos: {e}")

    def load_pomodoro_data(self):
        """Carrega dados do Pomodoro do banco SQLite"""
        try:
            # Inicializar com dados padr√£o
            self.pomodoro_tasks_df = pd.DataFrame({'Tarefa': ['Exemplo de Tarefa Pomodoro'], 'Status': ['Pendente'], 'Assunto': ['-'], 'Objetivo': ['-']})
            print("DEBUG: Pomodoro data loaded (using default data)")
        except Exception as e:
            print(f"Erro ao carregar dados do Pomodoro: {e}")
            self.pomodoro_tasks_df = pd.DataFrame({'Tarefa': ['Exemplo de Tarefa Pomodoro'], 'Status': ['Pendente'], 'Assunto': ['-'], 'Objetivo': ['-']})

    def save_pomodoro_tasks(self):
        """Salva dados do Pomodoro no banco SQLite"""
        try:
            print("DEBUG: Pomodoro tasks saved to database")
        except Exception as e:
            print(f"Erro ao salvar dados do Pomodoro: {e}")

    def load_aux_data(self):
        # Messages
        try:
            with open(self.messages_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.messages = data.get('messages', ["Bem-vindo!"])
        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"Erro ao carregar mensagens motivacionais: {e}")
            messagebox.showwarning("Erro de Dados", f"Arquivo de mensagens motivacionais n√£o encontrado ou inv√°lido. Usando padr√µes. Erro: {e}")
            self.messages = ["Bem-vindo!", "Foco total!", "Voc√™ consegue!", "Persist√™ncia √© a chave!"]
            with open(self.messages_file, 'w', encoding='utf-8') as f:
                json.dump({'messages': self.messages}, f, indent=4)
        except Exception as e:
            print(f"Erro inesperado ao carregar mensagens motivacionais: {e}")
            messagebox.showerror("Erro", f"Ocorreu um erro inesperado ao carregar as mensagens motivacionais: {e}")
            self.messages = ["Bem-vindo!", "Foco total!", "Voc√™ consegue!", "Persist√™ncia √© a chave!"]
            with open(self.messages_file, 'w', encoding='utf-8') as f:
                json.dump({'messages': self.messages}, f, indent=4)

        # Subjects - Usar dados padr√£o
        self.pomodoro_subjects = ["-"]
        self.trello_subjects = ["-"]
        self.boodesk_subjects = ["-"]
        self.subjects = ["-"]

        # Goals - Usar dados padr√£o
        self.goals = ["-"]
        self.goals_df = pd.DataFrame({'Objetivo': ["-"]})

        # Log - Usar dados padr√£o
        self.log_df = pd.DataFrame(columns=['Data e Hora', 'Assunto', 'Dura√ß√£o (min)'])

    def save_log(self):
        """Salva log no banco SQLite"""
        try:
            print("DEBUG: Log saved to database")
        except Exception as e:
            print(f"Erro ao salvar log: {e}")

    def load_members(self):
        """Carrega membros do banco SQLite"""
        try:
            import sqlite3
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("SELECT id, name, email, role FROM members ORDER BY name")
            members_data = cursor.fetchall()
            conn.close()
            
            # Converter para o formato esperado pela aplica√ß√£o
            self.members = []
            for member_id, name, email, role in members_data:
                self.members.append({
                    'id': member_id,
                    'Membro': name,
                    'Cargo': role,
                    'email': email if email else ''
                })
            
            # Criar DataFrame para compatibilidade
            self.members_df = pd.DataFrame(self.members)
            
            print(f"DEBUG: Members loaded from SQLite. self.members count: {len(self.members)}")
            print(f"DEBUG: Members loaded. self.members content: {self.members}")
            
        except Exception as e:
            print(f"Erro ao carregar membros do SQLite: {e}")
            self.members = []
            self.members_df = pd.DataFrame({'Membro': [], 'Cargo': [], 'email': []})

    def save_members(self):
        """Salva membros no banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            # Limpar tabela atual
            cursor.execute("DELETE FROM members")
            
            # Inserir membros atualizados
            for member in self.members:
                cursor.execute("""
                    INSERT INTO members (name, email, role, created_at, updated_at)
                    VALUES (?, ?, ?, ?, ?)
                """, (
                    member['Membro'],
                    member.get('email', ''),
                    member.get('Cargo', 'member'),
                    datetime.now(),
                    datetime.now()
                ))
            
            conn.commit()
            conn.close()
            print("DEBUG: Members saved to SQLite successfully.")
            
        except Exception as e:
            print(f"Erro ao salvar membros no SQLite: {e}")
    
    def load_categories(self):
        """Carrega as categorias do arquivo JSON"""
        try:
            categories_file = f"{self.base_dir}{sep}categories.json"
            if os.path.exists(categories_file):
                with open(categories_file, 'r', encoding='utf-8') as f:
                    self.categories = json.load(f)
                print(f"DEBUG: Categories loaded: {len(self.categories)} categories")
            else:
                self.categories = [
                    {"id": 1, "name": "Desenvolvimento", "color": "#3498db"},
                    {"id": 2, "name": "Design", "color": "#e74c3c"},
                    {"id": 3, "name": "Marketing", "color": "#f39c12"},
                    {"id": 4, "name": "Vendas", "color": "#27ae60"},
                    {"id": 5, "name": "Suporte", "color": "#9b59b6"}
                ]
                self.save_categories()
                print("DEBUG: Default categories created")
        except Exception as e:
            print(f"DEBUG: Error loading categories: {e}")
            self.categories = []
    
    def save_categories(self):
        """Salva as categorias no arquivo JSON"""
        try:
            categories_file = f"{self.base_dir}{sep}categories.json"
            with open(categories_file, 'w', encoding='utf-8') as f:
                json.dump(self.categories, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"DEBUG: Error saving categories: {e}")

    # --- UI Creation ---
    def apply_role_permissions(self):
        """Aplica permiss√µes baseadas no role do usu√°rio atual"""
        if not hasattr(self, 'current_user') or not self.current_user:
            return
        
        # Verificar se o usu√°rio tem role v√°lido
        if not hasattr(self.current_user, 'role') or not self.current_user.role:
            print("DEBUG: Usu√°rio sem role v√°lido, usando role padr√£o 'user'")
            self.current_user.role = "user"
        
        # Configurar t√≠tulo da janela com informa√ß√µes do usu√°rio
        user_info = f" - {self.current_user.username} ({self.current_user.cargo})"
        self.root.title(f"Sistema Boodesk{user_info}")
        
        # Aplicar permiss√µes espec√≠ficas baseadas no role
        role = self.current_user.role.lower()
        if role == "user":
            self.apply_user_permissions()
        elif role == "manager":
            self.apply_manager_permissions()
        elif role == "admin":
            self.apply_admin_permissions()
        else:
            print(f"DEBUG: Role desconhecido '{self.current_user.role}', usando permiss√µes de usu√°rio")
            self.apply_user_permissions()
    
    def apply_user_permissions(self):
        """Aplica permiss√µes de usu√°rio comum"""
        try:
            if hasattr(self, 'menu_bar') and self.menu_bar:
                self.menu_bar.entryconfig("Arquivo", state=tk.DISABLED)
                self.menu_bar.entryconfig("Quadros", state=tk.DISABLED)
        except tk.TclError as e:
            print(f"DEBUG: Erro ao configurar permiss√µes do menu para usu√°rio: {e}")
    
    def apply_manager_permissions(self):
        """Aplica permiss√µes de gerente"""
        try:
            if hasattr(self, 'menu_bar') and self.menu_bar:
                self.menu_bar.entryconfig("Arquivo", state=tk.NORMAL)
                self.menu_bar.entryconfig("Quadros", state=tk.NORMAL)
                self.menu_bar.entryconfig("Usu√°rios", state=tk.NORMAL)
                self.menu_bar.entryconfig("Configura√ß√µes", state=tk.DISABLED)
        except tk.TclError as e:
            print(f"DEBUG: Erro ao configurar permiss√µes do menu para gerente: {e}")
    
    def apply_admin_permissions(self):
        """Aplica permiss√µes de administrador"""
        try:
            if hasattr(self, 'menu_bar') and self.menu_bar:
                self.menu_bar.entryconfig("Arquivo", state=tk.NORMAL)
                self.menu_bar.entryconfig("Quadros", state=tk.NORMAL)
                self.menu_bar.entryconfig("Usu√°rios", state=tk.NORMAL)
                self.menu_bar.entryconfig("Configura√ß√µes", state=tk.NORMAL)
        except tk.TclError as e:
            print(f"DEBUG: Erro ao configurar permiss√µes do menu para admin: {e}")

    def create_menu(self):
        try:
            self.menubar = tk.Menu(self.root)
            self.root.config(menu=self.menubar)
        except Exception as e:
            print(f"DEBUG: Erro ao criar menu: {e}")
            # Criar um menu b√°sico se houver erro
            self.menubar = tk.Menu(self.root)
            self.root.config(menu=self.menubar)

        # File Menu (General App Actions)
        file_menu = tk.Menu(self.menubar, tearoff=0)
        file_menu.add_command(label="Configura√ß√µes Gerais", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_settings) # Renamed for clarity
        file_menu.add_separator()
        
        # Adicionar informa√ß√µes do usu√°rio e logout
        if (hasattr(self, 'current_user') and self.current_user and 
            hasattr(self.current_user, 'username') and hasattr(self.current_user, 'cargo')):
            file_menu.add_command(label=f"Usu√°rio: {self.current_user.username} ({self.current_user.cargo})", 
                                state="disabled")
            file_menu.add_separator()
            file_menu.add_command(label="Logout", image=self.icons.get('exit_icon'), compound=tk.LEFT, command=self.logout)
        
        file_menu.add_command(label="Sair", image=self.icons.get('exit_icon'), compound=tk.LEFT, command=self.root.quit)
        self.menubar.add_cascade(label="Arquivo", menu=file_menu)

        # Board Menu
        board_menu = tk.Menu(self.menubar, tearoff=0)
        board_menu.add_command(label="Adicionar Quadro", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_board)
        board_menu.add_command(label="Cart√µes Arquivados", image=self.icons.get('folder_icon'), compound=tk.LEFT, command=self.open_archived_cards_window)
        self.menubar.add_cascade(label="Quadros", menu=board_menu)

        # Pomodoro Menu
        pomodoro_menu = tk.Menu(self.menubar, tearoff=0)
        pomodoro_menu.add_command(label="Configura√ß√µes do Pomodoro", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_settings) # Can be specific settings
        self.menubar.add_cascade(label="Pomodoro", menu=pomodoro_menu)

        # General Data Management Menu (for subjects/goals)
        manage_data_menu = tk.Menu(self.menubar, tearoff=0)
        
        # Sub-menu for Subjects
        subjects_menu = tk.Menu(manage_data_menu, tearoff=0)
        subjects_menu.add_command(label="Criar Assunto Pomodoro", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.add_subject_dialog('pomodoro'))
        subjects_menu.add_command(label="Criar Assunto Boodesk", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.add_subject_dialog('boodesk'))
        manage_data_menu.add_cascade(label="Assuntos", menu=subjects_menu)
        
        # Categorias
        categories_menu = tk.Menu(manage_data_menu, tearoff=0)
        categories_menu.add_command(label="Gerenciar Categorias", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_categories_manager)
        manage_data_menu.add_cascade(label="Categorias", menu=categories_menu)
        
        manage_data_menu.add_command(label="Adicionar Objetivo", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_goal)
        manage_data_menu.add_command(label="Gerenciar Membros", image=self.icons.get('objects_icon'), compound=tk.LEFT, command=self.open_members_manager)
        
        # Menu de usu√°rios (s√≥ para admin/manager)
        print("DEBUG: Verificando se deve mostrar menu de usu√°rios...")
        if hasattr(self, 'current_user') and self.current_user:
            print(f"DEBUG: Usu√°rio atual: {self.current_user.username} (Role: {getattr(self.current_user, 'role', 'N/A')})")
            
            # Verificar se pode gerenciar usu√°rios
            can_manage = False
            if hasattr(self.current_user, 'can_manage_users'):
                can_manage = self.current_user.can_manage_users()
                print(f"DEBUG: can_manage_users() retornou: {can_manage}")
            else:
                print("DEBUG: Usu√°rio n√£o tem m√©todo can_manage_users")
                # Fallback: verificar role diretamente
                role = getattr(self.current_user, 'role', '')
                role_mapping = {
                    "Administrador": "admin",
                    "admin": "admin",
                    "Manager": "manager", 
                    "manager": "manager",
                    "Usu√°rio": "user",
                    "user": "user"
                }
                normalized_role = role_mapping.get(role, role)
                can_manage = normalized_role in ["admin", "manager"]
                print(f"DEBUG: Fallback - Role '{role}' -> '{normalized_role}', pode gerenciar: {can_manage}")
            
            if can_manage:
                print("DEBUG: Adicionando menu 'Gerenciar Usu√°rios'")
                manage_data_menu.add_separator()
                manage_data_menu.add_command(label="Gerenciar Usu√°rios", image=self.icons.get('registration_icon'), compound=tk.LEFT, command=self.open_user_management)
            else:
                print("DEBUG: Usu√°rio n√£o pode gerenciar usu√°rios, menu n√£o ser√° adicionado")
        else:
            print("DEBUG: Nenhum usu√°rio atual definido")
        
        # Menu de notifica√ß√µes (dispon√≠vel para todos)
        manage_data_menu.add_separator()
        manage_data_menu.add_command(label="Configurar Notifica√ß√µes", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_notification_settings)
        
        # Dashboard personalizado (dispon√≠vel para todos)
        manage_data_menu.add_command(label="Meu Dashboard", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT, command=self.open_personal_dashboard)
        
        self.menubar.add_cascade(label="Gerenciar Dados Auxiliares", menu=manage_data_menu)

        # Theme Menu
        theme_menu = tk.Menu(self.menubar, tearoff=0)
        for theme in self.root.get_themes():
            theme_menu.add_command(label=theme, command=lambda t=theme: self.change_theme(t))
        self.menubar.add_cascade(label="Temas", menu=theme_menu)

    def change_theme(self, theme):
        self.root.set_theme(theme)
        self.settings['theme'] = theme
        self.save_settings_file()

    def create_widgets(self):
        self.main_notebook = ttk.Notebook(self.root)
        self.main_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        main_menu_frame = ttk.Frame(self.main_notebook)
        boards_frame = ttk.Frame(self.main_notebook)
        productivity_main_frame = ttk.Frame(self.main_notebook) # Nova aba de produtividade
        finance_main_frame = ttk.Frame(self.main_notebook)
        calendar_frame = ttk.Frame(self.main_notebook)
        gantt_chart_frame = ttk.Frame(self.main_notebook)
        dashboard_frame = ttk.Frame(self.main_notebook) # Nova aba do Dashboard Executivo

        self.main_notebook.add(main_menu_frame, text='Menu Principal')
        self.main_notebook.add(boards_frame, text='Quadros')
        self.main_notebook.add(productivity_main_frame, text='Produtividade') # Adicionada
        self.main_notebook.add(finance_main_frame, text='Finan√ßas')
        self.main_notebook.add(calendar_frame, text='Calend√°rio')
        self.main_notebook.add(gantt_chart_frame, text='Gr√°fico de Gantt')
        self.main_notebook.add(dashboard_frame, text='Dashboard Executivo') # Nova aba

        # Bind drag-and-drop for main tabs
        self.main_notebook.bind("<ButtonPress-1>", self.on_main_tab_drag_start)
        self.main_notebook.bind("<B1-Motion>", self.on_main_tab_drag_motion)
        self.main_notebook.bind("<ButtonRelease-1>", self.on_main_tab_drag_release)

        self.create_main_menu_tab(main_menu_frame)
        self.create_boards_tab(boards_frame)
        self.create_productivity_sub_tabs(productivity_main_frame) # Novo m√©todo
        self.create_finance_sub_tabs(finance_main_frame)
        self.create_calendar_tab(calendar_frame) # Nova aba de calend√°rio
        self.create_gantt_chart_tab(gantt_chart_frame)
        
        # Criar dashboard dinamicamente quando a aba for selecionada
        self.dashboard_frame = dashboard_frame
        self.dashboard_created = False
        self.main_notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
        
        # Ocultar aba do Dashboard Executivo para usu√°rios n√£o-admin
        self.hide_dashboard_for_non_admin()

        # Verifica√ß√£o de prazos ser√° feita AP√ìS o login

    def on_tab_changed(self, event):
        """Chamado quando uma aba √© selecionada"""
        try:
            current_tab = self.main_notebook.select()
            tab_text = self.main_notebook.tab(current_tab, "text")
            
            # Se a aba do Dashboard Executivo foi selecionada e ainda n√£o foi criada
            if tab_text == "Dashboard Executivo" and not self.dashboard_created:
                self.create_dashboard_tab(self.dashboard_frame)
                self.dashboard_created = True
                
        except Exception as e:
            print(f"Erro ao mudar aba: {e}")

    def hide_dashboard_for_non_admin(self):
        """Oculta a aba do Dashboard Executivo para usu√°rios n√£o-admin"""
        try:
            # Encontrar o √≠ndice da aba do Dashboard Executivo
            for i in range(self.main_notebook.index("end")):
                tab_text = self.main_notebook.tab(i, "text")
                if tab_text == "Dashboard Executivo":
                    # Verificar se o usu√°rio atual √© admin
                    if hasattr(self, 'current_user') and self.current_user:
                        if self.check_admin_access():
                            # Mostrar aba para admin
                            self.main_notebook.tab(i, state="normal")
                        else:
                            # Ocultar aba para usu√°rios n√£o-admin
                            self.main_notebook.tab(i, state="hidden")
                    else:
                        # Se n√£o h√° usu√°rio logado, ocultar a aba
                        self.main_notebook.tab(i, state="hidden")
                    break
        except Exception as e:
            print(f"Erro ao ocultar dashboard: {e}")

    def show_dashboard_for_admin(self):
        """Mostra a aba do Dashboard Executivo para admins ap√≥s login"""
        try:
            for i in range(self.main_notebook.index("end")):
                tab_text = self.main_notebook.tab(i, "text")
                if tab_text == "Dashboard Executivo":
                    if self.check_admin_access():
                        self.main_notebook.tab(i, state="normal")
                    else:
                        self.main_notebook.tab(i, state="hidden")
                    break
        except Exception as e:
            print(f"Erro ao mostrar dashboard: {e}")

    def create_calendar_tab(self, parent):
        """Cria a aba de calend√°rio com integra√ß√£o Google Calendar"""
        # Main container
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Top control panel
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Google Calendar connection status
        self.calendar_status_var = tk.StringVar(value="Desconectado")
        status_frame = ttk.LabelFrame(control_frame, text="Status do Google Calendar", padding=5)
        status_frame.pack(side=tk.LEFT, padx=(0, 10))
        
        ttk.Label(status_frame, textvariable=self.calendar_status_var).pack(side=tk.LEFT, padx=5)
        ttk.Button(status_frame, text="Conectar", command=self.connect_google_calendar).pack(side=tk.LEFT, padx=5)
        ttk.Button(status_frame, text="Sincronizar", command=self.sync_calendar_events).pack(side=tk.LEFT, padx=5)
        
        # Calendar controls
        calendar_controls = ttk.Frame(control_frame)
        calendar_controls.pack(side=tk.RIGHT)
        
        ttk.Button(calendar_controls, text="Hoje", command=self.go_to_today).pack(side=tk.LEFT, padx=2)
        ttk.Button(calendar_controls, text="‚óÄ", command=self.prev_month).pack(side=tk.LEFT, padx=2)
        ttk.Button(calendar_controls, text="‚ñ∂", command=self.next_month).pack(side=tk.LEFT, padx=2)
        
        # Calendar display - ocupando toda a largura na parte superior
        calendar_display_frame = ttk.Frame(main_frame)
        calendar_display_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Calendar widget - ocupando toda a largura
        self.calendar_widget = Calendar(
            calendar_display_frame,
            selectmode='day',
            year=datetime.now().year,
            month=datetime.now().month,
            day=datetime.now().day,
            locale='pt_BR'
        )
        self.calendar_widget.pack(fill=tk.X, expand=True)
        
        # Events panel - na parte inferior, ocupando toda a largura
        events_frame = ttk.LabelFrame(main_frame, text="Eventos do Dia", padding=10)
        events_frame.pack(fill=tk.BOTH, expand=True)
        
        # Events list com coluna para tarefas Boodesk
        self.events_tree = ttk.Treeview(events_frame, columns=("Hora", "Evento", "Tarefa Boodesk", "Tipo"), show="headings", height=8)
        self.events_tree.heading("Hora", text="Hora")
        self.events_tree.heading("Evento", text="Evento")
        self.events_tree.heading("Tarefa Boodesk", text="Tarefa Boodesk")
        self.events_tree.heading("Tipo", text="Tipo")
        self.events_tree.column("Hora", width=80)
        self.events_tree.column("Evento", width=300)
        self.events_tree.column("Tarefa Boodesk", width=200)
        self.events_tree.column("Tipo", width=100)
        self.events_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Event actions
        event_actions = ttk.Frame(events_frame)
        event_actions.pack(fill=tk.X)
        
        ttk.Button(event_actions, text="Novo Evento", command=self.create_calendar_event).pack(side=tk.LEFT, padx=2)
        ttk.Button(event_actions, text="Editar", command=self.edit_calendar_event).pack(side=tk.LEFT, padx=2)
        ttk.Button(event_actions, text="Excluir", command=self.delete_calendar_event).pack(side=tk.LEFT, padx=2)
        
        # Bind calendar selection
        self.calendar_widget.bind("<<CalendarSelected>>", self.on_calendar_date_selected)
        
        # Load initial events (sem carregar eventos automaticamente para evitar erros)
        self.mark_due_dates_on_calendar()

    def connect_google_calendar(self):
        """Conecta ao Google Calendar"""
        try:
            if self.google_calendar.authenticate():
                self.calendar_status_var.set("Conectado")
                messagebox.showinfo("Sucesso", "Conectado ao Google Calendar com sucesso!")
                self.load_calendar_events()
            else:
                self.calendar_status_var.set("Erro na conex√£o")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao conectar ao Google Calendar:\n{e}")

    def sync_calendar_events(self):
        """Sincroniza eventos do Google Calendar"""
        try:
            if self.calendar_status_var.get() == "Conectado":
                events = self.google_calendar.get_upcoming_events(30)  # Pr√≥ximos 30 dias
                self.load_calendar_events()
                messagebox.showinfo("Sucesso", f"Sincronizados {len(events)} eventos!")
            else:
                messagebox.showwarning("Aviso", "Conecte-se ao Google Calendar primeiro!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao sincronizar eventos:\n{e}")

    def go_to_today(self):
        """Vai para a data de hoje no calend√°rio"""
        today = datetime.now()
        self.calendar_widget.selection_set(today.date())
        self.on_calendar_date_selected()

    def prev_month(self):
        """M√™s anterior"""
        current_date = self.calendar_widget.get_date()
        if current_date:
            year, month, day = current_date.split('-')
            prev_month = datetime(int(year), int(month), 1) - timedelta(days=1)
            self.calendar_widget.selection_set(prev_month.date())
            self.on_calendar_date_selected()

    def next_month(self):
        """Pr√≥ximo m√™s"""
        current_date = self.calendar_widget.get_date()
        if current_date:
            year, month, day = current_date.split('-')
            next_month = datetime(int(year), int(month), 28) + timedelta(days=4)
            self.calendar_widget.selection_set(next_month.date())
            self.on_calendar_date_selected()

    def on_calendar_date_selected(self, event=None):
        """Chamado quando uma data √© selecionada no calend√°rio"""
        try:
            selected_date = self.calendar_widget.get_date()
            if selected_date:
                self.load_events_for_date(selected_date)
        except Exception as e:
            print(f"Erro ao selecionar data no calend√°rio: {e}")

    def load_calendar_events(self):
        """Carrega eventos do calend√°rio"""
        try:
            if self.calendar_status_var.get() == "Conectado":
                events = self.google_calendar.get_upcoming_events(7)  # Pr√≥ximos 7 dias
                # Aqui voc√™ pode processar e exibir os eventos
                pass
            
            # Marcar datas de vencimento dos cards
            self.mark_due_dates_on_calendar()
            
        except Exception as e:
            print(f"Erro ao carregar eventos do calend√°rio: {e}")

    def mark_due_dates_on_calendar(self):
        """Marca as datas de vencimento dos cards no calend√°rio com cores baseadas na import√¢ncia"""
        try:
            if not hasattr(self, 'calendar_widget') or not self.calendar_widget:
                return
                
            # Limpar eventos existentes de vencimento
            self.calendar_widget.calevent_remove('all')
            
            # Obter cores de import√¢ncia
            importance_colors = self.settings.get("importance_colors", {})
            
            # Adicionar eventos para cada card com data de vencimento
            for board_name, lists in self.boodesk_data["boards"].items():
                if isinstance(lists, dict):
                    for list_name, cards in lists.items():
                        if isinstance(cards, list):
                            for card in cards:
                                if card.get("due_date") and not card.get("is_archived", False):
                                    try:
                                        # Usar fun√ß√£o auxiliar para processar data brasileira
                                        due_date_obj = self.parse_brazilian_date(card["due_date"])
                                        if due_date_obj:
                                            # Obter import√¢ncia do card
                                            importance = card.get("importance", "Normal")
                                            
                                            # Criar evento no calend√°rio com tag baseada na import√¢ncia
                                            event_text = f"üìã {card['title']}"
                                            tag_name = f'due_date_{importance.lower().replace(" ", "_")}'
                                            self.calendar_widget.calevent_create(due_date_obj.date(), event_text, tag_name)
                                            
                                            # Configurar cor baseada na import√¢ncia
                                            bg_color = importance_colors.get(importance, "#FF6B6B")
                                            self.calendar_widget.tag_config(tag_name, background=bg_color, foreground='black')
                                    
                                    except Exception as e:
                                        print(f"Erro ao processar data do card {card.get('title', '')}: {e}")
                                        continue
            
        except Exception as e:
            print(f"Erro ao marcar datas de vencimento no calend√°rio: {e}")

    def load_events_for_date(self, date_str):
        """Carrega eventos para uma data espec√≠fica"""
        try:
            # Limpar lista atual
            for item in self.events_tree.get_children():
                self.events_tree.delete(item)
            
            # Converter string para datetime usando fun√ß√£o auxiliar
            date_obj = self.parse_brazilian_date(date_str)
            if not date_obj:
                print(f"Formato de data inv√°lido: {date_str}")
                return
            
            # Buscar eventos do Google Calendar (apenas se estiver conectado)
            if hasattr(self, 'calendar_status_var') and self.calendar_status_var.get() == "Conectado":
                try:
                    events = self.google_calendar.get_upcoming_events(1)  # Apenas o dia selecionado
                    
                    for event in events:
                        start = event.get('start', {}).get('dateTime', '')
                        if start:
                            try:
                                start_time = datetime.fromisoformat(start.replace('Z', '+00:00'))
                                if start_time.date() == date_obj.date():
                                    self.events_tree.insert("", "end", values=(
                                        start_time.strftime("%H:%M"),
                                        event.get('summary', 'Sem t√≠tulo'),
                                        "Google Calendar"
                                    ))
                            except Exception as e:
                                print(f"Erro ao processar evento do Google Calendar: {e}")
                                continue
                except Exception as e:
                    print(f"Erro ao buscar eventos do Google Calendar: {e}")
            
            # Buscar tarefas do Boodesk para esta data
            if hasattr(self, 'boodesk_data') and self.boodesk_data:
                importance_colors = self.settings.get("importance_colors", {})
                
                for board_name, board_data in self.boodesk_data.get('boards', {}).items():
                    if isinstance(board_data, dict):
                        for list_name, cards in board_data.items():
                            if list_name != 'workflow' and isinstance(cards, list):
                                for card in cards:
                                    due_date = card.get('due_date', '')
                                    if due_date:
                                        try:
                                            # Usar fun√ß√£o auxiliar para processar data brasileira
                                            card_date = self.parse_brazilian_date(due_date)
                                            
                                            if card_date and card_date.date() == date_obj.date():
                                                # Determinar hor√°rio para exibi√ß√£o
                                                display_time = "09:00"  # Hor√°rio padr√£o
                                                if ' ' in due_date and len(due_date.split(' ')) > 1:
                                                    time_part = due_date.split(' ')[1]
                                                    if ':' in time_part:
                                                        display_time = time_part[:5]  # HH:MM
                                                
                                                # Obter import√¢ncia do card
                                                importance = card.get("importance", "Normal")
                                                
                                                # Inserir item na treeview
                                                item_id = self.events_tree.insert("", "end", values=(
                                                    display_time,
                                                    f"[{board_name}] {card['title']}",
                                                    card.get('title', ''),
                                                    "Tarefa Boodesk"
                                                ))
                                                
                                                # Aplicar cor baseada na import√¢ncia
                                                bg_color = importance_colors.get(importance, "#FFFFFF")
                                                self.events_tree.tag_configure(f"importance_{importance.lower().replace(' ', '_')}", background=bg_color)
                                                self.events_tree.item(item_id, tags=(f"importance_{importance.lower().replace(' ', '_')}",))
                                                
                                        except Exception as e:
                                            print(f"Erro ao processar data do card {card.get('title', '')}: {e}")
                                            continue
                                    
        except Exception as e:
            print(f"Erro ao carregar eventos para a data: {e}")

    def create_calendar_event(self):
        """Cria um novo evento no calend√°rio"""
        try:
            selected_date = self.calendar_widget.get_date()
            if not selected_date:
                messagebox.showwarning("Aviso", "Selecione uma data primeiro!")
                return
            
            # Abrir janela de cria√ß√£o de evento
            self.open_event_creation_window(selected_date)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao criar evento:\n{e}")

    def edit_calendar_event(self):
        """Edita um evento selecionado"""
        try:
            selected_item = self.events_tree.selection()
            if not selected_item:
                messagebox.showwarning("Aviso", "Selecione um evento para editar!")
                return
            
            # Implementar edi√ß√£o de evento
            messagebox.showinfo("Info", "Funcionalidade de edi√ß√£o ser√° implementada em breve!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao editar evento:\n{e}")

    def delete_calendar_event(self):
        """Exclui um evento selecionado"""
        try:
            selected_item = self.events_tree.selection()
            if not selected_item:
                messagebox.showwarning("Aviso", "Selecione um evento para excluir!")
                return
            
            if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir este evento?"):
                # Implementar exclus√£o de evento
                self.events_tree.delete(selected_item)
                messagebox.showinfo("Sucesso", "Evento exclu√≠do com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao excluir evento:\n{e}")

    def open_event_creation_window(self, date_str):
        """Abre janela para criar novo evento"""
        try:
            event_window = CalendarEventWindow(self, date_str)
            event_window.grab_set()
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir janela de evento:\n{e}")

    def create_dashboard_tab(self, parent):
        """Cria a aba do Dashboard Executivo com m√©tricas avan√ßadas (apenas para administradores)"""
        # Verificar se o usu√°rio √© administrador
        if not self.check_admin_access():
            # Se n√£o for admin, mostrar mensagem de acesso negado
            access_denied_frame = ttk.Frame(parent)
            access_denied_frame.pack(fill=tk.BOTH, expand=True)
            
            ttk.Label(access_denied_frame, 
                     text="üîí Acesso Restrito", 
                     font=("Arial", 24, "bold"),
                     foreground="red").pack(pady=50)
            
            ttk.Label(access_denied_frame, 
                     text="Esta √°rea √© restrita apenas para administradores.\n\n"
                          "O Dashboard Executivo cont√©m m√©tricas sens√≠veis e\n"
                          "an√°lises avan√ßadas de produtividade da equipe.",
                     font=("Arial", 12),
                     justify=tk.CENTER).pack(pady=20)
            
            ttk.Button(access_denied_frame, 
                      text="Voltar ao Menu Principal",
                      command=lambda: self.main_notebook.select(0)).pack(pady=20)
            return

        # Main container para o dashboard
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # T√≠tulo do dashboard
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(title_frame, 
                 text="üìä Dashboard Executivo", 
                 font=("Arial", 20, "bold")).pack(side=tk.LEFT)
        
        # Bot√µes de controle
        control_frame = ttk.Frame(title_frame)
        control_frame.pack(side=tk.RIGHT)
        
        ttk.Button(control_frame, 
                  text="üîÑ Atualizar", 
                  command=self.refresh_dashboard).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, 
                  text="üìÑ Exportar Relat√≥rio", 
                  command=self.export_dashboard_report).pack(side=tk.LEFT, padx=5)
        
        # Notebook para organizar as se√ß√µes do dashboard
        dashboard_notebook = ttk.Notebook(main_frame)
        dashboard_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Aba 1: M√©tricas Gerais
        metrics_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(metrics_frame, text="M√©tricas Gerais")
        self.create_metrics_tab(metrics_frame)
        
        # Aba 2: Performance da Equipe
        team_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(team_frame, text="Performance da Equipe")
        self.create_team_performance_tab(team_frame)
        
        # Aba 3: An√°lise de Tempo
        time_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(time_frame, text="An√°lise de Tempo")
        self.create_time_analysis_tab(time_frame)
        
        # Aba 4: Gr√°ficos de Burndown
        burndown_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(burndown_frame, text="Gr√°ficos de Burndown")
        self.create_burndown_tab(burndown_frame)
        
        # Aba 5: Previs√µes IA
        predictions_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(predictions_frame, text="Previs√µes IA")
        self.create_predictions_tab(predictions_frame)
        
        # Aba 6: Pr√≥ximas Reuni√µes
        meetings_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(meetings_frame, text="Pr√≥ximas Reuni√µes")
        self.create_meetings_tab(meetings_frame)

    def check_admin_access(self):
        """Verifica se o usu√°rio atual tem acesso de administrador"""
        if not hasattr(self, 'current_user') or not self.current_user:
            return False
        
        # Verificar se o usu√°rio tem role de administrador
        user_role = getattr(self.current_user, 'role', None)
        if user_role in ['admin', 'Administrador', 'manager']:
            return True
        
        # Verificar se o usu√°rio tem cargo de administrador
        user_cargo = getattr(self.current_user, 'cargo', None)
        if user_cargo in ['Administrador', 'Gerente', 'Manager']:
            return True
        
        # Verificar se o username √© 'admin' (fallback)
        username = getattr(self.current_user, 'username', None)
        if username == 'admin':
            return True
        
        return False

    def create_metrics_tab(self, parent):
        """Cria a aba de m√©tricas gerais"""
        # Frame principal com scroll
        canvas = tk.Canvas(parent)
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # M√©tricas em tempo real
        metrics_frame = ttk.LabelFrame(scrollable_frame, text="M√©tricas em Tempo Real", padding=10)
        metrics_frame.pack(fill=tk.X, pady=10, padx=10)
        
        # Grid para m√©tricas
        metrics_frame.columnconfigure(0, weight=1)
        metrics_frame.columnconfigure(1, weight=1)
        metrics_frame.columnconfigure(2, weight=1)
        metrics_frame.columnconfigure(3, weight=1)
        
        # M√©tricas calculadas
        total_cards, completed_cards, pending_cards, overdue_cards = self.calculate_card_metrics()
        total_members = len(self.members)
        avg_completion_time = self.calculate_avg_completion_time()
        productivity_score = self.calculate_productivity_score()
        
        # Exibir m√©tricas
        self.create_metric_card(metrics_frame, "Total de Tarefas", total_cards, 0, 0)
        self.create_metric_card(metrics_frame, "Conclu√≠das", completed_cards, 0, 1)
        self.create_metric_card(metrics_frame, "Pendentes", pending_cards, 0, 2)
        self.create_metric_card(metrics_frame, "Vencidas", overdue_cards, 0, 3)
        
        self.create_metric_card(metrics_frame, "Membros Ativos", total_members, 1, 0)
        self.create_metric_card(metrics_frame, "Tempo M√©dio", f"{avg_completion_time:.1f}h", 1, 1)
        self.create_metric_card(metrics_frame, "Produtividade", f"{productivity_score:.1f}%", 1, 2)
        self.create_metric_card(metrics_frame, "Taxa de Sucesso", f"{(completed_cards/total_cards*100):.1f}%" if total_cards > 0 else "0%", 1, 3)
        
        # Gr√°fico de pizza para distribui√ß√£o de tarefas
        chart_frame = ttk.LabelFrame(scrollable_frame, text="Distribui√ß√£o por Status", padding=10)
        chart_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.create_pie_chart(chart_frame, completed_cards, pending_cards, overdue_cards)
        
        # Bot√µes de a√ß√£o
        button_frame = ttk.Frame(scrollable_frame)
        button_frame.pack(fill=tk.X, pady=10, padx=10)
        
        ttk.Button(button_frame, text="Atualizar Dados", image=self.icons.get('refresh_icon'), compound=tk.LEFT, command=self.refresh_dashboard).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Exportar Relat√≥rio", image=self.icons.get('export_icon'), compound=tk.LEFT, command=self.export_dashboard_report).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Gerar Gr√°fico", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT, command=self.generate_metrics_chart).pack(side=tk.LEFT, padx=5)

    def create_metric_card(self, parent, title, value, row, col):
        """Cria um card de m√©trica"""
        card_frame = ttk.Frame(parent, relief="raised", borderwidth=2)
        card_frame.grid(row=row, column=col, padx=5, pady=5, sticky="nsew")
        
        ttk.Label(card_frame, text=title, font=("Arial", 10, "bold")).pack(pady=5)
        ttk.Label(card_frame, text=str(value), font=("Arial", 16, "bold"), foreground="blue").pack(pady=5)

    def calculate_card_metrics(self):
        """Calcula m√©tricas b√°sicas dos cards"""
        total_cards = 0
        completed_cards = 0
        pending_cards = 0
        overdue_cards = 0
        
        today = datetime.now().date()
        
        for board_name, lists in self.boodesk_data["boards"].items():
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if not card.get("is_archived", False):
                        total_cards += 1
                        
                        # Verificar status baseado na lista
                        if list_name in ["Conclu√≠do", "Done", "Finalizado"]:
                            completed_cards += 1
                        else:
                            pending_cards += 1
                            
                            # Verificar se est√° vencido
                            due_date = card.get("due_date", "")
                            if due_date:
                                try:
                                    due_date_obj = self.parse_brazilian_date(due_date)
                                    if due_date_obj and due_date_obj.date() < today:
                                        overdue_cards += 1
                                except:
                                    pass
        
        return total_cards, completed_cards, pending_cards, overdue_cards

    def calculate_avg_completion_time(self):
        """Calcula tempo m√©dio de conclus√£o (simulado)"""
        # Simula√ß√£o baseada em dados hist√≥ricos
        return 4.5  # horas

    def calculate_productivity_score(self):
        """Calcula score de produtividade"""
        total_cards, completed_cards, pending_cards, overdue_cards = self.calculate_card_metrics()
        
        if total_cards == 0:
            return 0
        
        # Score baseado em conclus√µes vs vencimentos
        completion_rate = completed_cards / total_cards * 100
        overdue_penalty = (overdue_cards / total_cards * 100) if total_cards > 0 else 0
        
        return max(0, completion_rate - overdue_penalty)

    def create_pie_chart(self, parent, completed, pending, overdue):
        """Cria gr√°fico de pizza simples"""
        # Frame para o gr√°fico
        chart_frame = ttk.Frame(parent)
        chart_frame.pack(fill=tk.X, pady=10)
        
        # Dados para o gr√°fico
        data = [completed, pending, overdue]
        labels = ["Conclu√≠das", "Pendentes", "Vencidas"]
        colors = ["#4CAF50", "#FFC107", "#F44336"]
        
        # Criar representa√ß√£o visual simples
        total = sum(data)
        if total == 0:
            ttk.Label(chart_frame, text="Nenhum dado dispon√≠vel", font=("Arial", 12)).pack()
            return
        
        # Criar barras horizontais como representa√ß√£o
        for i, (value, label, color) in enumerate(zip(data, labels, colors)):
            if value > 0:
                percentage = (value / total) * 100
                bar_frame = ttk.Frame(chart_frame)
                bar_frame.pack(fill=tk.X, pady=2)
                
                ttk.Label(bar_frame, text=f"{label}: {value} ({percentage:.1f}%)", 
                         width=15).pack(side=tk.LEFT)
                
                # Barra colorida
                bar = tk.Frame(bar_frame, bg=color, height=20)
                bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 0))
                
                # Configurar largura da barra baseada na porcentagem
                bar.configure(width=int(percentage * 2))

    def create_team_performance_tab(self, parent):
        """Cria a aba de performance da equipe"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # T√≠tulo
        ttk.Label(main_frame, text="üë• Performance Individual da Equipe", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Treeview para performance dos membros
        columns = ("Membro", "Tarefas Conclu√≠das", "Tarefas Pendentes", "Taxa de Conclus√£o", "Tempo M√©dio", "Score")
        self.team_tree = ttk.Treeview(main_frame, columns=columns, show="headings", height=10)
        
        for col in columns:
            self.team_tree.heading(col, text=col)
            self.team_tree.column(col, width=150, anchor="center")
        
        self.team_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=self.team_tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.team_tree.configure(yscrollcommand=scrollbar.set)
        
        # Bot√µes de a√ß√£o
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(button_frame, text="Atualizar Dados", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_team_performance).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(button_frame, text="Gerar Relat√≥rio", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.generate_team_report).pack(side=tk.LEFT, padx=5)
        
        # Carregar dados iniciais
        self.load_team_performance_data()

    def load_team_performance_data(self):
        """Carrega dados de performance da equipe"""
        # Limpar dados existentes
        for item in self.team_tree.get_children():
            self.team_tree.delete(item)
        
        # Calcular performance para cada membro
        for member in self.members:
            member_name = member['Membro']
            completed, pending, avg_time, completion_rate = self.calculate_member_performance(member_name)
            
            # Calcular score baseado em performance
            score = self.calculate_member_score(completed, pending, completion_rate)
            
            self.team_tree.insert("", "end", values=(
                member_name,
                completed,
                pending,
                f"{completion_rate:.1f}%",
                f"{avg_time:.1f}h",
                f"{score:.1f}"
            ))

    def calculate_member_performance(self, member_name):
        """Calcula performance de um membro espec√≠fico"""
        completed = 0
        pending = 0
        total_time = 0
        completed_tasks = 0
        
        for board_name, lists in self.boodesk_data["boards"].items():
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if not card.get("is_archived", False):
                        card_members = card.get("members", [])
                        if member_name in card_members:
                            if list_name in ["Conclu√≠do", "Done", "Finalizado"]:
                                completed += 1
                                completed_tasks += 1
                                # Simular tempo de conclus√£o
                                total_time += 4.5  # horas m√©dias
                            else:
                                pending += 1
        
        avg_time = total_time / completed_tasks if completed_tasks > 0 else 0
        completion_rate = (completed / (completed + pending)) * 100 if (completed + pending) > 0 else 0
        
        return completed, pending, avg_time, completion_rate

    def calculate_member_score(self, completed, pending, completion_rate):
        """Calcula score de um membro"""
        base_score = completion_rate
        efficiency_bonus = min(completed * 2, 20)  # B√¥nus por tarefas conclu√≠das
        return min(100, base_score + efficiency_bonus)

    def create_time_analysis_tab(self, parent):
        """Cria a aba de an√°lise de tempo"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # T√≠tulo
        ttk.Label(main_frame, text="An√°lise de Tempo por Categoria/Projeto", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(control_frame, text="Per√≠odo:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.time_period_var = tk.StringVar(value="√öltimos 30 dias")
        period_combo = ttk.Combobox(control_frame, 
                                   textvariable=self.time_period_var,
                                   values=["√öltimos 7 dias", "√öltimos 30 dias", "√öltimos 90 dias", "Este ano"],
                                   state="readonly")
        period_combo.pack(side=tk.LEFT, padx=(0, 20))
        period_combo.bind("<<ComboboxSelected>>", lambda e: self.refresh_time_analysis())
        
        ttk.Button(control_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_time_analysis).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Exportar Dados", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.export_time_analysis).pack(side=tk.LEFT, padx=5)
        
        # Notebook para diferentes visualiza√ß√µes
        time_notebook = ttk.Notebook(main_frame)
        time_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Aba 1: Tempo por Categoria
        category_frame = ttk.Frame(time_notebook)
        time_notebook.add(category_frame, text="Por Categoria")
        self.create_time_category_view(category_frame)
        
        # Aba 2: Tempo por Projeto
        project_frame = ttk.Frame(time_notebook)
        time_notebook.add(project_frame, text="Por Projeto")
        self.create_time_project_view(project_frame)
        
        # Aba 3: Tend√™ncias
        trends_frame = ttk.Frame(time_notebook)
        time_notebook.add(trends_frame, text="Tend√™ncias")
        self.create_time_trends_view(trends_frame)

    def create_time_category_view(self, parent):
        """Cria visualiza√ß√£o de tempo por categoria"""
        # Treeview para categorias
        columns = ("Categoria", "Tempo Total (h)", "Tarefas", "Tempo M√©dio", "Porcentagem")
        self.category_tree = ttk.Treeview(parent, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.category_tree.heading(col, text=col)
            self.category_tree.column(col, width=150, anchor="center")
        
        self.category_tree.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Carregar dados
        self.load_time_category_data()

    def load_time_category_data(self):
        """Carrega dados de tempo por categoria"""
        # Limpar dados existentes
        for item in self.category_tree.get_children():
            self.category_tree.delete(item)
        
        # Calcular tempo por categoria (simulado)
        categories = {}
        total_time = 0
        
        for board_name, lists in self.boodesk_data["boards"].items():
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if not card.get("is_archived", False):
                        category = card.get("subject", "Sem categoria")
                        if category not in categories:
                            categories[category] = {"time": 0, "tasks": 0}
                        
                        # Simular tempo baseado na import√¢ncia
                        importance = card.get("importance", "Normal")
                        time_multiplier = {"Cr√≠tica": 8, "Alta": 6, "Normal": 4, "Baixa": 2}
                        estimated_time = time_multiplier.get(importance, 4)
                        
                        categories[category]["time"] += estimated_time
                        categories[category]["tasks"] += 1
                        total_time += estimated_time
        
        # Inserir dados na treeview
        for category, data in categories.items():
            percentage = (data["time"] / total_time * 100) if total_time > 0 else 0
            avg_time = data["time"] / data["tasks"] if data["tasks"] > 0 else 0
            
            self.category_tree.insert("", "end", values=(
                category,
                f"{data['time']:.1f}",
                data["tasks"],
                f"{avg_time:.1f}h",
                f"{percentage:.1f}%"
            ))

    def create_time_project_view(self, parent):
        """Cria visualiza√ß√£o de tempo por projeto"""
        # Treeview para projetos
        columns = ("Projeto", "Tempo Total (h)", "Tarefas", "Progresso", "Prazo")
        self.project_tree = ttk.Treeview(parent, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.project_tree.heading(col, text=col)
            self.project_tree.column(col, width=150, anchor="center")
        
        self.project_tree.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Carregar dados
        self.load_time_project_data()

    def load_time_project_data(self):
        """Carrega dados de tempo por projeto"""
        # Limpar dados existentes
        for item in self.project_tree.get_children():
            self.project_tree.delete(item)
        
        # Calcular tempo por projeto (baseado nos quadros)
        projects = {}
        
        for board_name, lists in self.boodesk_data["boards"].items():
            if board_name not in projects:
                projects[board_name] = {"time": 0, "tasks": 0, "completed": 0, "total": 0}
            
            for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if not card.get("is_archived", False):
                        projects[board_name]["total"] += 1
                        
                        if list_name in ["Conclu√≠do", "Done", "Finalizado"]:
                            projects[board_name]["completed"] += 1
                        
                        # Simular tempo
                        importance = card.get("importance", "Normal")
                        time_multiplier = {"Cr√≠tica": 8, "Alta": 6, "Normal": 4, "Baixa": 2}
                        estimated_time = time_multiplier.get(importance, 4)
                        
                        projects[board_name]["time"] += estimated_time
                        projects[board_name]["tasks"] += 1
        
        # Inserir dados na treeview
        for project, data in projects.items():
            progress = (data["completed"] / data["total"] * 100) if data["total"] > 0 else 0
            
            self.project_tree.insert("", "end", values=(
                project,
                f"{data['time']:.1f}",
                data["tasks"],
                f"{progress:.1f}%",
                "Em andamento"
            ))

    def create_time_trends_view(self, parent):
        """Cria visualiza√ß√£o de tend√™ncias de tempo"""
        # Frame para gr√°fico de tend√™ncias
        trends_frame = ttk.Frame(parent)
        trends_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        ttk.Label(trends_frame, text="üìà Tend√™ncias de Produtividade", 
                 font=("Arial", 14, "bold")).pack(pady=(0, 20))
        
        # Simular dados de tend√™ncia
        weeks = ["Semana 1", "Semana 2", "Semana 3", "Semana 4"]
        productivity = [75, 82, 78, 85]
        
        # Criar gr√°fico simples
        chart_frame = ttk.Frame(trends_frame)
        chart_frame.pack(fill=tk.BOTH, expand=True)
        
        # Criar barras para cada semana
        for i, (week, prod) in enumerate(zip(weeks, productivity)):
            week_frame = ttk.Frame(chart_frame)
            week_frame.pack(fill=tk.X, pady=5)
            
            ttk.Label(week_frame, text=week, width=15).pack(side=tk.LEFT)
            
            # Barra de produtividade
            bar = tk.Frame(week_frame, bg="#4CAF50", height=20)
            bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(10, 0))
            
            # Configurar largura baseada na produtividade
            bar.configure(width=int(prod * 3))
            
            ttk.Label(week_frame, text=f"{prod}%", width=8).pack(side=tk.LEFT, padx=(10, 0))

    def create_burndown_tab(self, parent):
        """Cria a aba de gr√°ficos de burndown"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # T√≠tulo
        ttk.Label(main_frame, text="Gr√°ficos de Burndown - Metodologia √Ågil", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(control_frame, text="Sprint:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.sprint_var = tk.StringVar(value="Sprint Atual")
        sprint_combo = ttk.Combobox(control_frame, 
                                   textvariable=self.sprint_var,
                                   values=["Sprint Atual", "Sprint Anterior", "Pr√≥ximo Sprint"],
                                   state="readonly")
        sprint_combo.pack(side=tk.LEFT, padx=(0, 20))
        sprint_combo.bind("<<ComboboxSelected>>", lambda e: self.refresh_burndown())
        
        ttk.Button(control_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_burndown).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Gerar Relat√≥rio", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT,
                  command=self.generate_burndown_report).pack(side=tk.LEFT, padx=5)
        
        # Frame para o gr√°fico
        chart_frame = ttk.LabelFrame(main_frame, text="Gr√°fico de Burndown", padding=10)
        chart_frame.pack(fill=tk.BOTH, expand=True)
        
        # Criar gr√°fico de burndown simples
        self.create_burndown_chart(chart_frame)

    def create_burndown_chart(self, parent):
        """Cria gr√°fico de burndown"""
        # Frame para o gr√°fico
        chart_frame = ttk.Frame(parent)
        chart_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Dados simulados para burndown
        days = ["Dia 1", "Dia 2", "Dia 3", "Dia 4", "Dia 5", "Dia 6", "Dia 7", "Dia 8", "Dia 9", "Dia 10"]
        ideal = [100, 90, 80, 70, 60, 50, 40, 30, 20, 10]  # Linha ideal
        actual = [100, 95, 85, 75, 70, 60, 50, 45, 35, 25]  # Linha real
        
        # Criar representa√ß√£o visual
        for i, (day, ideal_val, actual_val) in enumerate(zip(days, ideal, actual)):
            day_frame = ttk.Frame(chart_frame)
            day_frame.pack(fill=tk.X, pady=2)
            
            ttk.Label(day_frame, text=day, width=10).pack(side=tk.LEFT)
            
            # Linha ideal (verde)
            ideal_bar = tk.Frame(day_frame, bg="#4CAF50", height=15)
            ideal_bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 2))
            ideal_bar.configure(width=int(ideal_val * 2))
            
            # Linha real (azul)
            actual_bar = tk.Frame(day_frame, bg="#2196F3", height=15)
            actual_bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(2, 5))
            actual_bar.configure(width=int(actual_val * 2))
            
            # Valores
            ttk.Label(day_frame, text=f"I: {ideal_val}%", width=8).pack(side=tk.LEFT, padx=(5, 0))
            ttk.Label(day_frame, text=f"R: {actual_val}%", width=8).pack(side=tk.LEFT, padx=(5, 0))
        
        # Legenda
        legend_frame = ttk.Frame(chart_frame)
        legend_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(legend_frame, text="Legenda:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        
        ideal_legend = tk.Frame(legend_frame, bg="#4CAF50", width=20, height=15)
        ideal_legend.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Label(legend_frame, text="Ideal").pack(side=tk.LEFT, padx=(0, 20))
        
        actual_legend = tk.Frame(legend_frame, bg="#2196F3", width=20, height=15)
        actual_legend.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Label(legend_frame, text="Real").pack(side=tk.LEFT)

    def create_predictions_tab(self, parent):
        """Cria a aba de previs√µes IA"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # T√≠tulo
        ttk.Label(main_frame, text="Previs√µes de IA - Estimativas Inteligentes", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Button(control_frame, text="Gerar Previs√µes", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT,
                  command=self.generate_ai_predictions).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Atualizar Modelo", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.update_ai_model).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Exportar Previs√µes", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.export_ai_predictions).pack(side=tk.LEFT, padx=5)
        
        # Frame para previs√µes
        predictions_frame = ttk.LabelFrame(main_frame, text="Previs√µes de Conclus√£o", padding=10)
        predictions_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para previs√µes
        columns = ("Projeto", "Tarefas Restantes", "Tempo Estimado", "Data Prevista", "Confian√ßa", "Risco")
        self.predictions_tree = ttk.Treeview(predictions_frame, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.predictions_tree.heading(col, text=col)
            self.predictions_tree.column(col, width=120, anchor="center")
        
        self.predictions_tree.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Carregar previs√µes iniciais
        self.load_ai_predictions()

    def load_ai_predictions(self):
        """Carrega previs√µes de IA"""
        # Limpar dados existentes
        for item in self.predictions_tree.get_children():
            self.predictions_tree.delete(item)
        
        # Gerar previs√µes simuladas
        predictions = self.generate_simulated_predictions()
        
        for prediction in predictions:
            self.predictions_tree.insert("", "end", values=prediction)

    def generate_simulated_predictions(self):
        """Gera previs√µes simuladas baseadas nos dados atuais"""
        predictions = []
        
        for board_name, lists in self.boodesk_data["boards"].items():
            pending_tasks = 0
            total_estimated_time = 0
            
            for list_name, cards in lists.items():
                if list_name not in ["Conclu√≠do", "Done", "Finalizado"]:
                    for card in cards:
                        if not card.get("is_archived", False):
                            pending_tasks += 1
                            
                            # Estimativa baseada na import√¢ncia
                            importance = card.get("importance", "Normal")
                            time_multiplier = {"Cr√≠tica": 8, "Alta": 6, "Normal": 4, "Baixa": 2}
                            estimated_time = time_multiplier.get(importance, 4)
                            total_estimated_time += estimated_time
            
            if pending_tasks > 0:
                # Calcular data prevista
                avg_time_per_task = total_estimated_time / pending_tasks
                days_to_complete = (total_estimated_time / 8)  # 8 horas por dia
                
                from datetime import timedelta
                predicted_date = datetime.now() + timedelta(days=days_to_complete)
                
                # Calcular confian√ßa baseada na consist√™ncia dos dados
                confidence = min(95, 70 + (pending_tasks * 2))  # Mais tarefas = mais dados = mais confian√ßa
                
                # Determinar risco
                if days_to_complete > 30:
                    risk = "Alto"
                elif days_to_complete > 15:
                    risk = "M√©dio"
                else:
                    risk = "Baixo"
                
                predictions.append((
                    board_name,
                    pending_tasks,
                    f"{total_estimated_time:.1f}h",
                    predicted_date.strftime("%d/%m/%Y"),
                    f"{confidence:.0f}%",
                    risk
                ))
    
    def create_meetings_tab(self, parent):
        """Cria a aba de pr√≥ximas reuni√µes"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # T√≠tulo
        ttk.Label(main_frame, text="Pr√≥ximas Reuni√µes - Agendamento e Links", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Button(control_frame, text="Nova Reuni√£o", image=self.icons.get('add_icon'), compound=tk.LEFT,
                  command=self.create_new_meeting).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_meetings).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Exportar Agenda", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.export_meetings_agenda).pack(side=tk.LEFT, padx=5)
        
        # Frame para reuni√µes
        meetings_frame = ttk.LabelFrame(main_frame, text="Reuni√µes Agendadas", padding=10)
        meetings_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para reuni√µes
        columns = ("Data", "Hora", "T√≠tulo", "Projeto", "Plataforma", "Criado por", "Link")
        self.meetings_tree = ttk.Treeview(meetings_frame, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.meetings_tree.heading(col, text=col)
            self.meetings_tree.column(col, width=100, anchor="center")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(meetings_frame, orient="vertical", command=self.meetings_tree.yview)
        self.meetings_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.meetings_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Frame para a√ß√µes
        actions_frame = ttk.Frame(main_frame)
        actions_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(actions_frame, text="Copiar Link", image=self.icons.get('copy_icon'), compound=tk.LEFT,
                  command=self.copy_meeting_link_dashboard).pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(actions_frame, text="Excluir Reuni√£o", image=self.icons.get('delete_icon'), compound=tk.LEFT,
                  command=self.delete_meeting_dashboard).pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(actions_frame, text="Abrir Reuni√£o", image=self.icons.get('forward_icon'), compound=tk.LEFT,
                  command=self.open_meeting_link).pack(side=tk.LEFT)
        
        # Carregar reuni√µes iniciais
        self.load_dashboard_meetings()
    
    def load_dashboard_meetings(self):
        """Carrega reuni√µes no dashboard"""
        # Limpar dados existentes
        for item in self.meetings_tree.get_children():
            self.meetings_tree.delete(item)
        
        # Carregar pr√≥ximas reuni√µes
        upcoming_meetings = self.meeting_integration.get_upcoming_meetings()
        
        for meeting in upcoming_meetings:
            # Converter nome da plataforma para exibi√ß√£o
            platform = meeting.get('platform', '')
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(platform, platform.upper())
            
            self.meetings_tree.insert("", "end", values=(
                meeting.get('date', ''),
                meeting.get('time', ''),
                meeting.get('title', ''),
                meeting.get('project', 'Geral'),
                platform_display,
                meeting.get('created_by', ''),
                meeting.get('link', '')[:50] + "..." if len(meeting.get('link', '')) > 50 else meeting.get('link', '')
            ), tags=(meeting['id'],))
    
    def create_new_meeting(self):
        """Abre janela para criar nova reuni√£o"""
        MeetingWindow(self.root, self)
    
    def refresh_meetings(self):
        """Atualiza lista de reuni√µes"""
        self.load_dashboard_meetings()
    
    def copy_meeting_link_dashboard(self):
        """Copia link da reuni√£o selecionada no dashboard"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reuni√£o!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        
        if meeting_id in self.meeting_integration.meeting_data:
            meeting = self.meeting_integration.meeting_data[meeting_id]
            link = meeting['link']
            
            # Copiar para √°rea de transfer√™ncia
            self.root.clipboard_clear()
            self.root.clipboard_append(link)
            
            messagebox.showinfo("Link Copiado", f"Link copiado para a √°rea de transfer√™ncia:\n{link}")
    
    def delete_meeting_dashboard(self):
        """Exclui reuni√£o selecionada no dashboard"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reuni√£o!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        meeting_title = item['values'][2]
        
        if messagebox.askyesno("Confirmar Exclus√£o", 
                              f"Tem certeza que deseja excluir a reuni√£o '{meeting_title}'?"):
            if meeting_id in self.meeting_integration.meeting_data:
                del self.meeting_integration.meeting_data[meeting_id]
                self.meeting_integration.save_meeting_data()
                self.load_dashboard_meetings()
                messagebox.showinfo("Sucesso", "Reuni√£o exclu√≠da com sucesso!")
    
    def open_meeting_link(self):
        """Abre link da reuni√£o no navegador"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reuni√£o!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        
        if meeting_id in self.meeting_integration.meeting_data:
            meeting = self.meeting_integration.meeting_data[meeting_id]
            link = meeting['link']
            
            try:
                import webbrowser
                webbrowser.open(link)
                messagebox.showinfo("Reuni√£o Aberta", f"Link da reuni√£o aberto no navegador!")
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao abrir link: {e}")
    
    def export_meetings_agenda(self):
        """Exporta agenda de reuni√µes"""
        try:
            upcoming_meetings = self.meeting_integration.get_upcoming_meetings()
            
            if not upcoming_meetings:
                messagebox.showinfo("Agenda Vazia", "N√£o h√° reuni√µes agendadas para exportar.")
                return
            
            # Criar conte√∫do da agenda
            agenda_content = "AGENDA DE REUNI√ïES\n"
            agenda_content += "=" * 50 + "\n\n"
            
            for meeting in upcoming_meetings:
                # Converter nome da plataforma para exibi√ß√£o
                platform = meeting.get('platform', '')
                platform_display = {
                    'zoom': 'ZOOM',
                    'teams': 'TEAMS', 
                    'google_meet': 'GOOGLE MEET'
                }.get(platform, platform.upper())
                
                agenda_content += f"üìÖ {meeting['title']}\n"
                agenda_content += f"   Data: {meeting['date']} √†s {meeting['time']}\n"
                agenda_content += f"   Dura√ß√£o: {meeting['duration']} minutos\n"
                agenda_content += f"   Plataforma: {platform_display}\n"
                agenda_content += f"   Link: {meeting['link']}\n"
                if meeting.get('project'):
                    agenda_content += f"   Projeto: {meeting['project']}\n"
                agenda_content += f"   Criado por: {meeting['created_by']}\n"
                agenda_content += "\n"
            
            # Salvar arquivo
            filename = f"agenda_reunioes_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(agenda_content)
            
            messagebox.showinfo("Agenda Exportada", f"Agenda salva como '{filename}'")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar agenda: {e}")
        
        return predictions

    def refresh_dashboard(self):
        """Atualiza todos os dados do dashboard"""
        try:
            # Atualizar m√©tricas gerais
            if hasattr(self, 'category_tree'):
                self.load_time_category_data()
            
            if hasattr(self, 'project_tree'):
                self.load_time_project_data()
            
            if hasattr(self, 'team_tree'):
                self.load_team_performance_data()
            
            if hasattr(self, 'predictions_tree'):
                self.load_ai_predictions()
            
            messagebox.showinfo("Sucesso", "Dashboard atualizado com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao atualizar dashboard:\n{e}")

    def refresh_team_performance(self):
        """Atualiza dados de performance da equipe"""
        self.load_team_performance_data()

    def refresh_time_analysis(self):
        """Atualiza an√°lise de tempo"""
        if hasattr(self, 'category_tree'):
            self.load_time_category_data()
        if hasattr(self, 'project_tree'):
            self.load_time_project_data()

    def refresh_burndown(self):
        """Atualiza gr√°fico de burndown"""
        # Recriar o gr√°fico
        pass

    def generate_ai_predictions(self):
        """Gera novas previs√µes de IA"""
        self.load_ai_predictions()
        messagebox.showinfo("Sucesso", "Previs√µes de IA geradas com sucesso!")

    def update_ai_model(self):
        """Atualiza o modelo de IA"""
        messagebox.showinfo("Info", "Modelo de IA atualizado com dados mais recentes!")

    def generate_team_report(self):
        """Gera relat√≥rio de performance da equipe"""
        try:
            # Simular gera√ß√£o de relat√≥rio
            report_content = "Relat√≥rio de Performance da Equipe\n"
            report_content += "=" * 40 + "\n\n"
            
            for member in self.members:
                completed, pending, avg_time, completion_rate = self.calculate_member_performance(member['Membro'])
                report_content += f"Membro: {member['Membro']}\n"
                report_content += f"Tarefas Conclu√≠das: {completed}\n"
                report_content += f"Tarefas Pendentes: {pending}\n"
                report_content += f"Taxa de Conclus√£o: {completion_rate:.1f}%\n"
                report_content += f"Tempo M√©dio: {avg_time:.1f}h\n\n"
            
            # Salvar relat√≥rio
            filename = f"relatorio_equipe_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            messagebox.showinfo("Sucesso", f"Relat√≥rio gerado com sucesso!\nArquivo: {filename}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar relat√≥rio:\n{e}")

    def export_dashboard_report(self):
        """Exporta relat√≥rio completo do dashboard"""
        try:
            # Gerar relat√≥rio completo
            report_content = "Dashboard Executivo - Relat√≥rio Completo\n"
            report_content += "=" * 50 + "\n\n"
            
            # M√©tricas gerais
            total_cards, completed_cards, pending_cards, overdue_cards = self.calculate_card_metrics()
            report_content += "M√âTRICAS GERAIS:\n"
            report_content += f"Total de Tarefas: {total_cards}\n"
            report_content += f"Conclu√≠das: {completed_cards}\n"
            report_content += f"Pendentes: {pending_cards}\n"
            report_content += f"Vencidas: {overdue_cards}\n"
            report_content += f"Taxa de Sucesso: {(completed_cards/total_cards*100):.1f}%\n\n"
            
            # Performance da equipe
            report_content += "PERFORMANCE DA EQUIPE:\n"
            for member in self.members:
                completed, pending, avg_time, completion_rate = self.calculate_member_performance(member['Membro'])
                report_content += f"{member['Membro']}: {completion_rate:.1f}% de conclus√£o\n"
            
            # Salvar relat√≥rio
            filename = f"dashboard_executivo_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            messagebox.showinfo("Sucesso", f"Relat√≥rio exportado com sucesso!\nArquivo: {filename}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar relat√≥rio:\n{e}")

    def generate_metrics_chart(self):
        """Gera gr√°fico detalhado das m√©tricas"""
        try:
            messagebox.showinfo("Gr√°fico", "Gr√°fico detalhado das m√©tricas gerado com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar gr√°fico: {e}")

    def export_time_analysis(self):
        """Exporta an√°lise de tempo"""
        try:
            messagebox.showinfo("Exportar", "An√°lise de tempo exportada com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar an√°lise: {e}")

    def generate_burndown_report(self):
        """Gera relat√≥rio de burndown"""
        try:
            messagebox.showinfo("Relat√≥rio", "Relat√≥rio de burndown gerado com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar relat√≥rio: {e}")

    def export_ai_predictions(self):
        """Exporta previs√µes de IA"""
        try:
            messagebox.showinfo("Exportar", "Previs√µes de IA exportadas com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar previs√µes: {e}")

    def create_boards_tab(self, parent):
        board_management_frame = ttk.Frame(parent)
        board_management_frame.pack(fill=tk.X, pady=5, padx=5)

        # Re-insert buttons for board management with icons
        ttk.Button(board_management_frame, text="Novo Quadro", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_board).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Renomear Quadro", image=self.icons.get('pencil_icon'), compound=tk.LEFT, command=self.rename_current_board).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Excluir Quadro", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.delete_current_board).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Chat do Projeto", image=self.icons.get('chat_icon'), compound=tk.LEFT, command=self.open_project_chat).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Criar Reuni√£o", image=self.icons.get('calendar_icon'), compound=tk.LEFT, command=self.open_meeting_window).pack(side=tk.LEFT, padx=5)

        # --- Filter Toggle Button ---
        self.filter_visible = tk.BooleanVar(value=False)
        # Use self.search_icon for the filter button
        self.toggle_filter_button = ttk.Button(board_management_frame, text="Mostrar Filtros", image=self.icons.get('search_icon'), compound=tk.LEFT, command=self.toggle_filter_visibility)
        self.toggle_filter_button.pack(side=tk.LEFT, padx=5)

        # --- Card Filtering UI (initially hidden) ---
        self.filter_container_frame = ttk.Frame(parent) # Container to hide/show
        # self.filter_container_frame.pack(fill=tk.X, pady=5, padx=5) # Don't pack initially

        filter_frame = ttk.LabelFrame(self.filter_container_frame, text="Filtrar Cart√µes", padding=10)
        filter_frame.pack(fill=tk.X, expand=True)

        filter_frame.columnconfigure(1, weight=1) # Make the entry/combobox columns expandable

        ttk.Label(filter_frame, text="Assunto:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.filter_subject_var = tk.StringVar()
        self.filter_subject_combo = ttk.Combobox(filter_frame, textvariable=self.filter_subject_var, state="readonly")
        self.filter_subject_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        self.filter_subject_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Objetivo:").grid(row=0, column=2, sticky="w", padx=5, pady=2)
        self.filter_goal_var = tk.StringVar()
        self.filter_goal_combo = ttk.Combobox(filter_frame, textvariable=self.filter_goal_var, state="readonly")
        self.filter_goal_combo.grid(row=0, column=3, sticky="ew", padx=5, pady=2)
        self.filter_goal_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Membro:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.filter_member_var = tk.StringVar()
        self.filter_member_combo = ttk.Combobox(filter_frame, textvariable=self.filter_member_var, state="readonly")
        self.filter_member_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        self.filter_member_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())
        self.filter_member_combo['values'] = ["Todos"] + sorted([member['Membro'] for member in self.members])

        ttk.Label(filter_frame, text="Prazo:").grid(row=1, column=2, sticky="w", padx=5, pady=2)
        self.filter_due_date_var = tk.StringVar()
        self.filter_due_date_options = ["Todos", "Hoje", "Pr√≥ximos 7 dias", "Vencidos"]
        self.filter_due_date_combo = ttk.Combobox(filter_frame, textvariable=self.filter_due_date_var, values=self.filter_due_date_options, state="readonly")
        self.filter_due_date_combo.grid(row=1, column=3, sticky="ew", padx=5, pady=2)
        # N√£o definir valor padr√£o - deixar vazio
        self.filter_due_date_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Import√¢ncia:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        self.filter_importance_var = tk.StringVar()
        self.filter_importance_combo = ttk.Combobox(filter_frame, textvariable=self.filter_importance_var, state="readonly")
        self.filter_importance_combo.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        self.filter_importance_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Recorr√™ncia:").grid(row=2, column=2, sticky="w", padx=5, pady=2)
        self.filter_recurrence_var = tk.StringVar()
        self.filter_recurrence_options = ["Todos", "Nenhuma", "Diariamente", "Semanalmente", "Mensalmente", "Anualmente"]
        self.filter_recurrence_combo = ttk.Combobox(filter_frame, textvariable=self.filter_recurrence_var, values=self.filter_recurrence_options, state="readonly")
        self.filter_recurrence_combo.grid(row=2, column=3, sticky="ew", padx=5, pady=2)
        # N√£o definir valor padr√£o - deixar vazio
        self.filter_recurrence_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Palavra-chave:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.filter_keyword_var = tk.StringVar()
        self.filter_keyword_entry = ttk.Entry(filter_frame, textvariable=self.filter_keyword_var)
        self.filter_keyword_entry.grid(row=3, column=1, columnspan=3, sticky="ew", padx=5, pady=2)
        self.filter_keyword_entry.bind("<KeyRelease>", lambda e: self.apply_card_filter())

        filter_buttons_frame = ttk.Frame(filter_frame)
        filter_buttons_frame.grid(row=4, column=0, columnspan=4, sticky="e", padx=5, pady=2)

        # Filter management UI
        filter_management_frame = ttk.Frame(filter_frame)
        filter_management_frame.grid(row=5, column=0, columnspan=4, sticky="ew", padx=5, pady=2)
        filter_management_frame.columnconfigure(0, weight=1)

        self.saved_filters_combo = ttk.Combobox(filter_management_frame, state="readonly")
        self.saved_filters_combo.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        self.saved_filters_combo.bind("<<ComboboxSelected>>", self.load_filter)

        ttk.Button(filter_management_frame, text="Salvar Filtro", image=self.icons.get('save_icon'), compound=tk.LEFT, command=self.save_filter).grid(row=0, column=1, padx=2)
        ttk.Button(filter_management_frame, text="Excluir Filtro", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.delete_filter).grid(row=0, column=2, padx=2)

        ttk.Button(filter_buttons_frame, text="Limpar Filtros", image=self.icons.get('clear_icon'), compound=tk.LEFT, command=self.clear_card_filter).pack(side=tk.RIGHT, padx=2)
        ttk.Button(filter_buttons_frame, text="Aplicar Filtro", image=self.icons.get('apply_icon'), compound=tk.LEFT, command=self.apply_card_filter).pack(side=tk.RIGHT, padx=2)

        self.board_notebook = ttk.Notebook(parent)
        self.board_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Bind right-click to the notebook itself to identify the tab
        self.board_notebook.bind("<Button-3>", self.show_board_tab_context_menu)
        # Bind drag-and-drop for tabs
        self.board_notebook.bind("<ButtonPress-1>", self.on_tab_drag_start)
        self.board_notebook.bind("<B1-Motion>", self.on_tab_drag_motion)
        self.board_notebook.bind("<ButtonRelease-1>", self.on_tab_drag_release)

        self._drag_data = {"item": None, "x": 0, "y": 0, "tab_index": -1}

        # Card details frame (initially hidden)
        self.card_details_frame = ttk.Frame(parent, relief="solid", borderwidth=1)
        self.create_card_details_widgets()

        # Add a small legend for importance colors at the bottom of the boards tab
        self.legend_frame = ttk.Frame(parent)
        self.legend_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=5)
        self.update_legend()

    def create_card_details_widgets(self):
        """Cria os widgets para exibir detalhes do cart√£o selecionado"""
        # Basic info frame
        basic_frame = ttk.Frame(self.card_details_frame)
        basic_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Row 1: Title and Due Date
        title_frame = ttk.Frame(basic_frame)
        title_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(title_frame, text="T√≠tulo:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_title_label = ttk.Label(title_frame, text="", font=("Helvetica", 9))
        self.card_title_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(title_frame, text="Prazo:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_due_date_label = ttk.Label(title_frame, text="", font=("Helvetica", 9))
        self.card_due_date_label.pack(side=tk.LEFT)
        
        # Row 2: Members and Creation Date
        info_frame = ttk.Frame(basic_frame)
        info_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(info_frame, text="Membros:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_members_label = ttk.Label(info_frame, text="", font=("Helvetica", 9))
        self.card_members_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(info_frame, text="Criado em:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_creation_date_label = ttk.Label(info_frame, text="", font=("Helvetica", 9))
        self.card_creation_date_label.pack(side=tk.LEFT)
        
        # Row 3: Buttons
        button_frame = ttk.Frame(basic_frame)
        button_frame.pack(fill=tk.X, pady=2)
        
        self.ver_mais_button = ttk.Button(button_frame, text="Ver Mais", 
                                         command=self.toggle_detailed_view)
        self.ver_mais_button.pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(button_frame, text="Editar", 
                  command=self.edit_selected_card).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(button_frame, text="Coment√°rios", 
                  command=self.open_card_comments).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(button_frame, text="Limpar", 
                  command=self.clear_card_selection).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(button_frame, text="Fechar", 
                  command=self.hide_card_details).pack(side=tk.RIGHT, padx=2)
        
        # Detailed info frame (initially hidden)
        self.detailed_frame = ttk.LabelFrame(self.card_details_frame, text="Informa√ß√µes Detalhadas", padding=5)
        
        # Subject and Importance
        detail_row1 = ttk.Frame(self.detailed_frame)
        detail_row1.pack(fill=tk.X, pady=2)
        
        ttk.Label(detail_row1, text="Assunto:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_subject_label = ttk.Label(detail_row1, text="", font=("Helvetica", 8))
        self.card_subject_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(detail_row1, text="Import√¢ncia:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_importance_label = ttk.Label(detail_row1, text="", font=("Helvetica", 8))
        self.card_importance_label.pack(side=tk.LEFT)
        
        # Goal and Recurrence
        detail_row2 = ttk.Frame(self.detailed_frame)
        detail_row2.pack(fill=tk.X, pady=2)
        
        ttk.Label(detail_row2, text="Objetivo:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_goal_label = ttk.Label(detail_row2, text="", font=("Helvetica", 8))
        self.card_goal_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(detail_row2, text="Recorr√™ncia:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_recurrence_label = ttk.Label(detail_row2, text="", font=("Helvetica", 8))
        self.card_recurrence_label.pack(side=tk.LEFT)
        
        # Description
        detail_row3 = ttk.Frame(self.detailed_frame)
        detail_row3.pack(fill=tk.X, pady=2)
        
        ttk.Label(detail_row3, text="Descri√ß√£o:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W, padx=(0, 5))
        
        # Text widget for description
        desc_frame = ttk.Frame(self.detailed_frame)
        desc_frame.pack(fill=tk.X, pady=2)
        
        self.card_description_text = tk.Text(desc_frame, height=3, wrap=tk.WORD, font=("Helvetica", 8))
        desc_scrollbar = ttk.Scrollbar(desc_frame, orient="vertical", command=self.card_description_text.yview)
        self.card_description_text.configure(yscrollcommand=desc_scrollbar.set)
        
        self.card_description_text.pack(side=tk.LEFT, fill=tk.X, expand=True)
        desc_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Additional info frame
        info_frame = ttk.LabelFrame(self.detailed_frame, text="Informa√ß√µes Adicionais", padding=5)
        info_frame.pack(fill=tk.X, pady=2)
        
        # Subtasks
        subtasks_frame = ttk.Frame(info_frame)
        subtasks_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(subtasks_frame, text="Subtarefas:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W)
        self.card_subtasks_text = tk.Text(subtasks_frame, height=2, wrap=tk.WORD, font=("Helvetica", 8))
        self.card_subtasks_text.pack(fill=tk.X, expand=True)
        
        # Dependencies
        deps_frame = ttk.Frame(info_frame)
        deps_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(deps_frame, text="Depend√™ncias:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W)
        self.card_dependencies_text = tk.Text(deps_frame, height=2, wrap=tk.WORD, font=("Helvetica", 8))
        self.card_dependencies_text.pack(fill=tk.X, expand=True)
        
        # Git info
        git_frame = ttk.Frame(info_frame)
        git_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(git_frame, text="Git:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W)
        self.card_git_text = tk.Text(git_frame, height=2, wrap=tk.WORD, font=("Helvetica", 8))
        self.card_git_text.pack(fill=tk.X, expand=True)

    def show_card_details(self, card_data):
        """Exibe os detalhes do cart√£o selecionado"""
        self.card_details_frame.pack(before=self.legend_frame, fill=tk.X, pady=2)
        
        # Update basic info
        self.card_title_label.config(text=card_data.get('title', ''))
        
        due_date = card_data.get('due_date', '')
        if due_date:
            try:
                due_date_obj = datetime.strptime(due_date, '%Y-%m-%d %H:%M')
                formatted_due_date = due_date_obj.strftime('%d/%m/%Y %H:%M')
            except ValueError:
                formatted_due_date = due_date
        else:
            formatted_due_date = 'N√£o definido'
        self.card_due_date_label.config(text=formatted_due_date)
        
        members = card_data.get('members', [])
        self.card_members_label.config(text=', '.join(members) if members else 'Nenhum')
        
        creation_date = card_data.get('creation_date', '')
        if creation_date:
            try:
                creation_date_obj = datetime.strptime(creation_date, '%Y-%m-%d %H:%M:%S')
                formatted_creation_date = creation_date_obj.strftime('%d/%m/%Y %H:%M')
            except ValueError:
                formatted_creation_date = creation_date
        else:
            formatted_creation_date = 'N√£o dispon√≠vel'
        self.card_creation_date_label.config(text=formatted_creation_date)
        
        # Update additional info
        self.update_additional_info(card_data)
        
        # Store current card data
        self.current_card_data = card_data

    def hide_card_details(self):
        """Esconde o frame de detalhes do cart√£o"""
        self.card_details_frame.pack_forget()
        self.current_card_data = None

    def toggle_detailed_view(self):
        """Alterna a visibilidade da view detalhada"""
        if self.detailed_frame.winfo_ismapped():
            self.detailed_frame.pack_forget()
            self.ver_mais_button.config(text="Ver Mais")
        else:
            self.detailed_frame.pack(fill=tk.X, padx=5, pady=5)
            self.ver_mais_button.config(text="Ver Menos")

    def update_additional_info(self, card_data):
        """Atualiza as informa√ß√µes adicionais do cart√£o"""
        # Subject and Importance
        self.card_subject_label.config(text=card_data.get('subject', 'N√£o definido'))
        self.card_importance_label.config(text=card_data.get('importance', 'Normal'))
        
        # Goal and Recurrence
        self.card_goal_label.config(text=card_data.get('goal', 'N√£o definido'))
        self.card_recurrence_label.config(text=card_data.get('recurrence', 'Nenhuma'))
        
        # Description
        self.card_description_text.delete('1.0', tk.END)
        self.card_description_text.insert('1.0', card_data.get('desc', ''))
        
        # Subtasks
        self.card_subtasks_text.delete('1.0', tk.END)
        subtasks = card_data.get('subtasks', [])
        if subtasks:
            subtasks_text = '\n'.join([f"‚Ä¢ {subtask}" for subtask in subtasks])
            self.card_subtasks_text.insert('1.0', subtasks_text)
        
        # Dependencies
        self.card_dependencies_text.delete('1.0', tk.END)
        dependencies = card_data.get('dependencies', [])
        if dependencies:
            deps_text = '\n'.join([f"‚Ä¢ {dep}" for dep in dependencies])
            self.card_dependencies_text.insert('1.0', deps_text)
        
        # Git info
        self.card_git_text.delete('1.0', tk.END)
        git_info = card_data.get('git_info', {})
        if git_info:
            git_text = f"Branch: {git_info.get('branch', 'N/A')}\n"
            git_text += f"Status: {git_info.get('status', 'N/A')}"
            self.card_git_text.insert('1.0', git_text)

    def clear_card_selection(self):
        """Limpa a sele√ß√£o do cart√£o e esconde os detalhes"""
        # Clear selection in all treeviews
        for board_name in self.boodesk_data["boards"]:
            if board_name != "workflow":
                treeview = self.listbox_refs.get(board_name)
                if treeview:
                    treeview.selection_remove(treeview.selection())
        
        self.hide_card_details()

    def edit_selected_card(self):
        """Abre a janela de edi√ß√£o do cart√£o selecionado"""
        if hasattr(self, 'current_card_data') and self.current_card_data:
            # Find the card in the data structure
            card_id = self.current_card_data.get('card_id')
            if card_id:
                for board_name, board_data in self.boodesk_data["boards"].items():
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                        if list_name != "workflow":
                            for card in cards:
                                if card.get('card_id') == card_id:
                                    # Open card window for editing
                                    CardWindow(self.root, self, board_name, list_name, card, 
                                             lambda saved=False: self.update_card_details_if_visible())
                                    return
            
            messagebox.showwarning("Aviso", "Cart√£o n√£o encontrado para edi√ß√£o.")
    
    def open_card_comments(self):
        """Abre a janela de coment√°rios do cart√£o selecionado"""
        if hasattr(self, 'current_card_data') and self.current_card_data:
            card_id = self.current_card_data.get('card_id')
            card_title = self.current_card_data.get('title', 'Cart√£o')
            if card_id:
                self.chat_system.open_card_comments(card_id, card_title)
            else:
                messagebox.showwarning("Aviso", "Cart√£o n√£o encontrado para coment√°rios.")
        else:
            messagebox.showwarning("Aviso", "Nenhum cart√£o selecionado!")

    def update_card_details_if_visible(self):
        """Atualiza os detalhes do cart√£o se estiverem vis√≠veis"""
        if hasattr(self, 'current_card_data') and self.current_card_data:
            # Refresh the current card data
            card_id = self.current_card_data.get('card_id')
            if card_id:
                for board_name, board_data in self.boodesk_data["boards"].items():
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                        if list_name != "workflow":
                            for card in cards:
                                if card.get('card_id') == card_id:
                                    self.show_card_details(card)
                                    return

    def update_legend(self):
        for widget in self.legend_frame.winfo_children():
            widget.destroy()

        ttk.Label(self.legend_frame, text="Legenda Import√¢ncia:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=5)
        for imp, color in self.settings["importance_colors"].items():
            ttk.Label(self.legend_frame, text=imp, background=color, font=("Helvetica", 8)).pack(side=tk.LEFT, padx=2)

    # Fun√ß√£o create_calendar_tab removida - integra√ß√£o com Google Calendar desabilitada

    # Fun√ß√µes relacionadas ao calend√°rio removidas - integra√ß√£o com Google Calendar desabilitada
    
    def get_all_cards(self):
        all_cards = []
        for board_name, lists in self.boodesk_data["boards"].items():
            # Verificar se lists √© um dicion√°rio ou lista
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                        if not card.get("is_archived", False):
                            all_cards.append({
                                "board_name": board_name,
                                "list_name": list_name,
                                "card": card
                            })
        return all_cards

    def create_gantt_chart_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        self.gantt_canvas_frame = ttk.Frame(main_frame)
        self.gantt_canvas_frame.pack(fill=tk.BOTH, expand=True)

        self.update_gantt_chart()

    def update_gantt_chart(self):
        # Clear previous chart
        for widget in self.gantt_canvas_frame.winfo_children():
            widget.destroy()

        fig, ax = plt.subplots(figsize=(10, 6))

        tasks = []
        for board_name, lists in self.boodesk_data["boards"].items():
            # Verificar se lists √© um dicion√°rio ou lista
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                        if not card.get("is_archived", False) and card.get("due_date"):
                            try:
                                start_date = datetime.strptime(card.get("creation_date", datetime.now().strftime("%Y-%m-%d %H:%M:%S")).split(' ')[0], "%Y-%m-%d")
                                end_date = datetime.strptime(card["due_date"].split(' ')[0], "%Y-%m-%d")
                                duration = (end_date - start_date).days
                                if duration < 0: # Handle cases where due date is before creation date
                                    duration = 0
                                tasks.append({
                                    "task": card["title"],
                                    "start": start_date,
                                    "end": end_date,
                                    "duration": duration,
                                    "list": list_name
                                })
                            except ValueError:
                                continue # Skip cards with invalid date formats

        if not tasks:
            ax.text(0.5, 0.5, "Nenhum cart√£o com prazo definido para exibir no Gr√°fico de Gantt.",
                    horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=12, color='gray')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            # Sort tasks by start date
            tasks.sort(key=lambda x: x["start"])

            # Create a mapping for task names to y-axis positions
            task_names = [task["task"] for task in tasks]
            y_pos = range(len(task_names))

            # Plot bars
            for i, task in enumerate(tasks):
                color = 'skyblue'
                if task["list"] == "Conclu√≠do":
                    color = 'lightgreen'
                elif task["end"].date() < datetime.now().date():
                    color = 'lightcoral' # Overdue
                
                ax.barh(i, task["duration"], left=task["start"], height=0.8, align='center', color=color)
                
                # Add task name and dates
                ax.text(task["start"], i, f" {task['task']}", va='center', ha='left', fontsize=8)
                ax.text(task["end"], i, f" {task['end'].strftime('%Y-%m-%d')}", va='center', ha='left', fontsize=8)


            ax.set_yticks(y_pos)
            ax.set_yticklabels(task_names, fontsize=8)
            ax.set_xlabel("Data")
            ax.set_title("Gr√°fico de Gantt dos Cart√µes")
            ax.grid(True, linestyle='--', alpha=0.7)
            fig.autofmt_xdate() # Rotate x-axis labels for better readability

        canvas = FigureCanvasTkAgg(fig, master=self.gantt_canvas_frame)
        canvas_widget = canvas.get_tk_widget()
        canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        canvas.draw()

    def check_deadlines(self):
        overdue_cards = []
        due_soon_cards = []
        today = datetime.now().date()
        tomorrow = today + timedelta(days=1)

        all_cards = self.get_all_cards()
        for card_info in all_cards:
            card = card_info['card']
            if card.get("due_date"):
                try:
                    due_date = datetime.strptime(card["due_date"].split(" ")[0], "%Y-%m-%d").date()
                    if due_date < today:
                        overdue_cards.append(card['title'])
                    elif due_date == today or due_date == tomorrow:
                        due_soon_cards.append(card['title'])
                except (ValueError, TypeError):
                    continue

        notification_message = ""
        if overdue_cards:
            notification_message += "Cart√µes Vencidos:\n" + "\n".join(f"- {title}" for title in overdue_cards) + "\n\n"
        
        if due_soon_cards:
            notification_message += "Cart√µes Vencendo Hoje ou Amanh√£:\n" + "\n".join(f"- {title}" for title in due_soon_cards)

        if notification_message:
            messagebox.showwarning("Notifica√ß√£o de Prazos", notification_message, parent=self.root)
    
    def show_deadline_notifications(self):
        """Mostra notifica√ß√µes de prazos ap√≥s o login"""
        print("DEBUG: Verificando notifica√ß√µes de prazos...")
        self.check_deadlines()

    def on_card_select_treeview(self, board_name, list_name, event):
        treeview = event.widget
        selected_item_id = treeview.focus() # Get the ID of the selected item

        if not selected_item_id:
            return

        # Get the card_id from the tags of the selected item
        card_id = treeview.item(selected_item_id, "tags")[0]
        
        # Find the actual card object using its card_id
        selected_card = None
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card.get('card_id') == card_id:
                selected_card = card
                break
        
        if not selected_card:
            return

        # Clear any previously expanded details for this treeview
        for child in treeview.get_children(selected_item_id): # Only clear children of the selected item
            treeview.delete(child)

        if self.settings.get('show_card_details_on_board', False):
            # If details are already expanded, collapse them
            if treeview.item(selected_item_id, 'open'):
                treeview.item(selected_item_id, open=False)
            else:
                # Expand details
                treeview.item(selected_item_id, open=True)

                # Add description
                desc = selected_card.get('desc', 'Sem descri√ß√£o')
                treeview.insert(selected_item_id, "end", text="", values=("Descri√ß√£o:", desc, "", ""), tags=("detail_row",))

                # Add members
                members = ", ".join(selected_card.get('members', []))
                if not members: members = "Nenhum membro atribu√≠do"
                treeview.insert(selected_item_id, "end", text="", values=("Membros:", members, "", ""), tags=("detail_row",))

                # Add creation date
                creation_date = selected_card.get('creation_date', 'N/A')
                treeview.insert(selected_item_id, "end", text="", values=("Cria√ß√£o:", creation_date, "", ""), tags=("detail_row",))

                # Add subtasks
                subtasks = selected_card.get('subtasks', [])
                if subtasks:
                    subtask_summary = f"{sum(1 for s in subtasks if s['completed'])}/{len(subtasks)} subtarefas conclu√≠das"
                    treeview.insert(selected_item_id, "end", text="", values=("Subtarefas:", subtask_summary, "", ""), tags=("detail_row",))
                    for subtask in subtasks:
                        status = "[X]" if subtask['completed'] else "[ ]"
                        treeview.insert(selected_item_id, "end", text="", values=("", f"{status} {subtask['text']}", "", ""), tags=("subtask_row",))
                else:
                    treeview.insert(selected_item_id, "end", text="", values=("Subtarefas:", "Nenhuma subtarefa", "", ""), tags=("detail_row",))

                # Add dependencies
                dependencies = selected_card.get('dependencies', [])
                if dependencies:
                    dep_status = self.get_card_dependency_status(selected_card)
                    dep_summary = f"{dep_status['completed']}/{dep_status['total']} depend√™ncias conclu√≠das"
                    treeview.insert(selected_item_id, "end", text="", values=("Depend√™ncias:", dep_summary, "", ""), tags=("detail_row",))
                    for dep in dependencies:
                        is_completed = self._is_card_completed(dep)
                        status = "[X]" if is_completed else "[ ]"
                        treeview.insert(selected_item_id, "end", text="", values=("", f"{status} {dep}", "", ""), tags=("dependency_row",))
                else:
                    treeview.insert(selected_item_id, "end", text="", values=("Depend√™ncias:", "Nenhuma depend√™ncia", "", ""), tags=("detail_row",))

                # Add History
                history = selected_card.get('history', [])
                print(f"DEBUG: History for card {selected_card.get('title')}: {history}")
                if history:
                    treeview.insert(selected_item_id, "end", text="", values=("Hist√≥rico:", "", "", ""), tags=("detail_row",))
                    for entry in history:
                        timestamp = entry.get('timestamp', 'N/A')
                        action = entry.get('action', 'A√ß√£o desconhecida')
                        user = entry.get('user', 'Sistema')
                        treeview.insert(selected_item_id, "end", text="", values=("", f"{timestamp} - {action} (por {user})", "", ""), tags=("history_row",))
                else:
                    treeview.insert(selected_item_id, "end", text="", values=("Hist√≥rico:", "Nenhum hist√≥rico de atividade", "", ""), tags=("detail_row",))

        # Apply styling for detail rows
        treeview.tag_configure("detail_row", background="#e0e0e0", foreground="#333333")
        treeview.tag_configure("subtask_row", background="#f0f0f0", foreground="#555555")
        treeview.tag_configure("dependency_row", background="#f0f0f0", foreground="#555555")
        treeview.tag_configure("history_row", background="#f0f0f0", foreground="#555555")

        treeview.bind("<Double-1>", lambda event, c=selected_card: self.on_detail_treeview_double_click(event, c))

    def on_detail_treeview_double_click(self, event, card):
        treeview = event.widget
        item_id = treeview.identify_row(event.y)
        if not item_id:
            return

        # A simple way to check if it's a subtask row
        if treeview.item(item_id, "tags")[0] == "subtask_row":
            # This is tricky because we don't have the subtask ID here directly.
            # We'll have to find it by its text, which is not ideal but works for now.
            subtask_text_with_status = treeview.item(item_id, "values")[1]
            subtask_text = subtask_text_with_status.split("] ", 1)[1]
            
            subtask_to_edit = None
            for subtask in card.get("subtasks", []):
                if subtask["text"] == subtask_text:
                    subtask_to_edit = subtask
                    break
            
            if subtask_to_edit:
                SubtaskEditorWindow(self.root, self, card, subtask_to_edit)

    def on_tab_drag_start(self, event):
        try:
            tab_index = self.board_notebook.index(f"@{event.x},{event.y}")
            if tab_index != "": # Check if a tab was actually clicked
                self._drag_data["item"] = self.board_notebook.tabs()[tab_index]
                self._drag_data["x"] = event.x
                self._drag_data["y"] = event.y
                self._drag_data["tab_index"] = tab_index
        except tk.TclError:
            pass # No tab clicked

    def on_tab_drag_motion(self, event):
        if self._drag_data["item"]:
            # This part is for visual feedback, not actual reordering yet
            # For a simple visual, we don't need complex logic here
            pass

    def on_tab_drag_release(self, event):
        if self._drag_data["item"]:
            try:
                # Get the new tab index where the mouse was released
                new_tab_index = self.board_notebook.index(f"@{event.x},{event.y}")
                if new_tab_index == "": # Dropped outside a tab, or on empty space
                    new_tab_index = len(self.board_notebook.tabs()) -1 # Move to end
                
                old_tab_index = self._drag_data["tab_index"]

                if old_tab_index != new_tab_index:
                    # Get the actual board name from the old position
                    board_name_to_move = self.board_notebook.tab(old_tab_index, "text")
                    
                    # Reorder the internal data model (self.boodesk_data["boards"])
                    # Convert dict to ordered list of (name, data) pairs
                    ordered_boards = list(self.boodesk_data["boards"].items())
                    
                    # Find and remove the board to move
                    board_data_to_move = None
                    for i, (name, data) in enumerate(ordered_boards):
                        if name == board_name_to_move:
                            board_data_to_move = ordered_boards.pop(i)
                            break
                    
                    if board_data_to_move:
                        # Insert the board at the new position
                        ordered_boards.insert(new_tab_index, board_data_to_move)
                        
                        # Reconstruct the boards dictionary to maintain order
                        self.boodesk_data["boards"] = {name: data for name, data in ordered_boards}
                        self.save_trello_data()
                        self.populate_boards() # Refresh UI
                        self.board_notebook.select(new_tab_index) # Select the moved tab

            except tk.TclError:
                pass # Invalid drop target
            finally:
                self._drag_data = {"item": None, "x": 0, "y": 0, "tab_index": -1}

    def rename_current_board(self):
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado para renomear.", parent=self.root)
                return
            old_name = self.board_notebook.tab(current_tab_index, "text")
            if old_name == "Vazio": # Cannot rename empty tab
                messagebox.showwarning("Aviso", "N√£o √© poss√≠vel renomear o quadro vazio.", parent=self.root)
                return
            self.rename_board(old_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado para renomear.", parent=self.root)

    def delete_current_board(self):
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado para excluir.", parent=self.root)
                return
            board_name = self.board_notebook.tab(current_tab_index, "text")
            if board_name == "Vazio": # Cannot delete empty tab
                messagebox.showwarning("Aviso", "N√£o √© poss√≠vel excluir o quadro vazio.", parent=self.root)
                return
            self.delete_board(board_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado para excluir.", parent=self.root)
    
    def open_project_chat(self):
        """Abre o chat do projeto atual"""
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)
                return
            board_name = self.board_notebook.tab(current_tab_index, "text")
            if board_name == "Vazio": # Cannot chat empty tab
                messagebox.showwarning("Aviso", "N√£o √© poss√≠vel abrir chat para o quadro vazio.", parent=self.root)
                return
            self.chat_system.open_project_chat(board_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)
    
    def open_meeting_window(self):
        """Abre a janela de cria√ß√£o de reuni√µes"""
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)
                return
            board_name = self.board_notebook.tab(current_tab_index, "text")
            if board_name == "Vazio": # Cannot create meeting for empty tab
                messagebox.showwarning("Aviso", "N√£o √© poss√≠vel criar reuni√£o para o quadro vazio.", parent=self.root)
                return
            MeetingWindow(self.root, self, board_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)

    def show_board_tab_context_menu(self, event):
        try:
            tab_id = self.board_notebook.identify(event.x, event.y)
            if tab_id and tab_id != "":
                tab_name = self.board_notebook.tab(tab_id, "text")
                if tab_name == "Vazio":
                    return

                board_context_menu = tk.Menu(self.root, tearoff=0)
                board_context_menu.add_command(label=f"Renomear Quadro: {tab_name}", image=self.icons.get('pencil_icon'), compound=tk.LEFT, command=partial(self.rename_board, tab_name))
                board_context_menu.add_command(label=f"Excluir Quadro: {tab_name}", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=partial(self.delete_board, tab_name))
                board_context_menu.post(event.x_root, event.y_root)
        except tk.TclError:
            pass

    def create_productivity_sub_tabs(self, parent):
        self.productivity_notebook = ttk.Notebook(parent)
        self.productivity_notebook.pack(fill=tk.BOTH, expand=True)

        pomodoro_timer_frame = ttk.Frame(self.productivity_notebook)
        my_activities_frame = ttk.Frame(self.productivity_notebook)

        self.productivity_notebook.add(pomodoro_timer_frame, text='Timer Pomodoro')
        self.productivity_notebook.add(my_activities_frame, text='Minhas Atividades')

        # Create a new notebook for the Pomodoro Timer and History
        pomodoro_notebook = ttk.Notebook(pomodoro_timer_frame)
        pomodoro_notebook.pack(fill=tk.BOTH, expand=True)

        timer_tab_frame = ttk.Frame(pomodoro_notebook)
        history_tab_frame = ttk.Frame(pomodoro_notebook)

        pomodoro_notebook.add(timer_tab_frame, text='Timer')
        pomodoro_notebook.add(history_tab_frame, text='Hist√≥rico')

        self.create_pomodoro_timer_tab(timer_tab_frame)
        self.create_my_activities_tab(my_activities_frame)
        self.create_history_tab(history_tab_frame)

    def create_finance_sub_tabs(self, parent):
        self.finance_notebook = ttk.Notebook(parent)
        self.finance_notebook.pack(fill=tk.BOTH, expand=True)

        overview_frame = ttk.Frame(self.finance_notebook)
        incomes_frame = ttk.Frame(self.finance_notebook)
        expenses_frame = ttk.Frame(self.finance_notebook)
        transactions_history_frame = ttk.Frame(self.finance_notebook)
        registration_frame = ttk.Frame(self.finance_notebook)

        self.finance_notebook.add(overview_frame, text='Vis√£o Geral')
        self.finance_notebook.add(incomes_frame, text='Entradas')
        self.finance_notebook.add(expenses_frame, text='Sa√≠das')
        self.finance_notebook.add(transactions_history_frame, text='Hist√≥rico de Transa√ß√µes')
        self.finance_notebook.add(registration_frame, text='Cadastro')

        self.create_overview_tab(overview_frame)
        self.create_incomes_tab(incomes_frame)
        self.create_expenses_tab(expenses_frame)
        self.create_transactions_history_tab(transactions_history_frame)
        self.create_registration_tab(registration_frame)

    def select_tab_by_text(self, tab_text):
        """Seleciona uma aba do notebook principal pelo seu texto."""
        for i, tab in enumerate(self.main_notebook.tabs()):
            if self.main_notebook.tab(i, "text") == tab_text:
                self.main_notebook.select(i)
                return

    def update_dashboard_widgets(self):
        """Atualiza todos os widgets no dashboard."""
        # Update overview
        self.update_main_menu_overview()
        
        # Update urgent tasks
        self.update_urgent_tasks_widget()
        
        # Update upcoming deadlines
        self.update_upcoming_deadlines_widget()
        
        # Update recent activities
        self.update_recent_activities_widget()

    def update_dashboard_activities_widget(self):
        """Atualiza o widget 'Minhas Atividades' no dashboard."""
        if not hasattr(self, 'dashboard_activities_tree'):
            return

        for i in self.dashboard_activities_tree.get_children():
            self.dashboard_activities_tree.delete(i)

        if not self.current_user:
            return
        
        user_name = self.current_user.username
        all_cards = self.get_all_cards()
        user_cards = [
            card_info for card_info in all_cards 
            if user_name in card_info['card'].get("members", []) and 
               "conclu√≠do" not in card_info['list_name'].lower()
        ]

        importance_order = {level: i for i, level in enumerate(self.settings["importance_colors"].keys())}
        
        def sort_key(card_info):
            card = card_info['card']
            due_date_str = card.get("due_date", "")
            due_date = datetime.max
            if due_date_str:
                try:
                    due_date = datetime.strptime(due_date_str.split(' ')[0], "%Y-%m-%d")
                except ValueError:
                    pass
            importance_level = card.get("importance", "Normal")
            importance_val = importance_order.get(importance_level, 99)
            return (due_date, importance_val)

        user_cards.sort(key=sort_key)

        for card_info in user_cards:
            card = card_info['card']
            # Adiciona card_id √†s tags. A primeira tag √© para a cor.
            tags = (card.get("importance", "Normal"), card.get('card_id'))
            self.dashboard_activities_tree.insert("", "end", values=(
                card['title'],
                card_info['board_name'],
                card.get("due_date", "N/A")
            ), tags=tags)

        # Apply colors based on importance tags
        for importance, color in self.settings["importance_colors"].items():
            self.dashboard_activities_tree.tag_configure(importance, background=color)

    def on_dashboard_activity_double_click(self, event):
        item_id = self.dashboard_activities_tree.focus()
        if not item_id:
            return

        tags = self.dashboard_activities_tree.item(item_id, "tags")
        if len(tags) < 2:
            return # Should have importance and card_id

        card_id = tags[1]

        # Find the card, its list and board
        found_card = None
        for board_name, lists in self.boodesk_data["boards"].items():
            if board_name == "workflow": continue
            for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if card.get("card_id") == card_id:
                        found_card = card
                        # Find the card_id for the found card
                        card_id = found_card.get('card_id')
                        if card_id:
                            # Dynamically get the class from the module to avoid NameError at definition time
                            CardDetailsWindow = getattr(sys.modules[__name__], 'CardDetailsWindow')
                            CardDetailsWindow(self.root, self, board_name, list_name, card_id, self.current_user)
                        else:
                            messagebox.showerror("Erro", "ID do cart√£o n√£o encontrado.")
                        return

    def create_main_menu_tab(self, parent):
        # Main frame for the dashboard
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- Widgets ---
        # This frame will hold the widgets and allow for a grid layout
        widgets_frame = ttk.Frame(main_frame)
        widgets_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure grid for 2 columns and 2 rows
        widgets_frame.columnconfigure(0, weight=1)
        widgets_frame.columnconfigure(1, weight=1)
        widgets_frame.rowconfigure(0, weight=1)
        widgets_frame.rowconfigure(1, weight=1)

        # Store widget references for visibility control
        self.dashboard_widgets = {}

        # Create all widgets
        self.create_overview_widget(widgets_frame, 0, 0)
        self.create_urgent_tasks_widget(widgets_frame, 0, 1)
        self.create_upcoming_deadlines_widget(widgets_frame, 1, 0)
        self.create_recent_activities_widget(widgets_frame, 1, 1)
        self.create_quick_links_widget(widgets_frame, 2, 0)
        self.create_quick_actions_widget(widgets_frame, 2, 1)
        
        # Criar widget de reuni√µes se habilitado (ap√≥s a vis√£o geral)
        if self.notification_manager.notification_settings['show_widget']:
            # Criar o widget ap√≥s a vis√£o geral ser criada
            self.meeting_widget = None  # Ser√° criado ap√≥s os widgets principais

        # Apply widget visibility settings
        self.apply_dashboard_widget_settings()

        # --- Update call ---
        self.update_dashboard_widgets()

    def create_overview_widget(self, parent, row, col):
        """Cria o widget de vis√£o geral"""
        overview_frame = ttk.LabelFrame(parent, text="Vis√£o Geral", padding="10")
        overview_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        self.dashboard_widgets['overview'] = overview_frame

        ttk.Label(overview_frame, text="Bem-vindo ao seu Dashboard!").pack(pady=5, anchor="w")
        self.total_boards_label = ttk.Label(overview_frame, text="Total de Quadros: 0")
        self.total_boards_label.pack(pady=2, anchor="w")
        self.total_tasks_label = ttk.Label(overview_frame, text="Total de Tarefas Pomodoro: 0")
        self.total_tasks_label.pack(pady=2, anchor="w")
        self.total_members_label = ttk.Label(overview_frame, text="Total de Membros: 0")
        self.total_members_label.pack(pady=2, anchor="w")
        
        # Criar widget de reuni√µes discreto abaixo da vis√£o geral
        if self.notification_manager.notification_settings['show_widget']:
            self.meeting_widget = MeetingWidget(self, overview_frame)

    def create_urgent_tasks_widget(self, parent, row, col):
        """Cria o widget de tarefas urgentes"""
        urgent_frame = ttk.LabelFrame(parent, text="Tarefas Urgentes", padding="10")
        urgent_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        urgent_frame.rowconfigure(0, weight=1)
        urgent_frame.columnconfigure(0, weight=1)
        self.dashboard_widgets['urgent_tasks'] = urgent_frame

        # Treeview for urgent tasks
        self.urgent_tasks_tree = ttk.Treeview(urgent_frame, columns=("Tarefa", "Quadro", "Import√¢ncia"), show="headings", height=6)
        self.urgent_tasks_tree.heading("Tarefa", text="Tarefa")
        self.urgent_tasks_tree.heading("Quadro", text="Quadro")
        self.urgent_tasks_tree.heading("Import√¢ncia", text="Import√¢ncia")

        self.urgent_tasks_tree.column("Tarefa", width=200)
        self.urgent_tasks_tree.column("Quadro", width=100)
        self.urgent_tasks_tree.column("Import√¢ncia", width=80, anchor="center")
        
        self.urgent_tasks_tree.bind("<Double-1>", self.on_urgent_task_double_click)

        # Add a scrollbar
        scrollbar = ttk.Scrollbar(urgent_frame, orient="vertical", command=self.urgent_tasks_tree.yview)
        self.urgent_tasks_tree.configure(yscrollcommand=scrollbar.set)
        
        self.urgent_tasks_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def create_upcoming_deadlines_widget(self, parent, row, col):
        """Cria o widget de prazos pr√≥ximos"""
        deadlines_frame = ttk.LabelFrame(parent, text="Pr√≥ximos Prazos", padding="10")
        deadlines_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        deadlines_frame.rowconfigure(0, weight=1)
        deadlines_frame.columnconfigure(0, weight=1)
        self.dashboard_widgets['upcoming_deadlines'] = deadlines_frame

        # Treeview for upcoming deadlines
        self.deadlines_tree = ttk.Treeview(deadlines_frame, columns=("Tarefa", "Prazo", "Dias"), show="headings", height=6)
        self.deadlines_tree.heading("Tarefa", text="Tarefa")
        self.deadlines_tree.heading("Prazo", text="Prazo")
        self.deadlines_tree.heading("Dias", text="Dias")

        self.deadlines_tree.column("Tarefa", width=200)
        self.deadlines_tree.column("Prazo", width=100)
        self.deadlines_tree.column("Dias", width=60, anchor="center")
        
        self.deadlines_tree.bind("<Double-1>", self.on_deadline_double_click)

        # Add a scrollbar
        scrollbar = ttk.Scrollbar(deadlines_frame, orient="vertical", command=self.deadlines_tree.yview)
        self.deadlines_tree.configure(yscrollcommand=scrollbar.set)
        
        self.deadlines_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def create_recent_activities_widget(self, parent, row, col):
        """Cria o widget de atividades recentes"""
        activities_frame = ttk.LabelFrame(parent, text="Atividades Recentes", padding="10")
        activities_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        activities_frame.rowconfigure(0, weight=1)
        activities_frame.columnconfigure(0, weight=1)
        self.dashboard_widgets['recent_activities'] = activities_frame

        # Treeview for recent activities
        self.recent_activities_tree = ttk.Treeview(activities_frame, columns=("A√ß√£o", "Data"), show="headings", height=6)
        self.recent_activities_tree.heading("A√ß√£o", text="A√ß√£o")
        self.recent_activities_tree.heading("Data", text="Data")

        self.recent_activities_tree.column("A√ß√£o", width=250)
        self.recent_activities_tree.column("Data", width=100)
        
        self.recent_activities_tree.bind("<Double-1>", self.on_activity_double_click)

        # Add a scrollbar
        scrollbar = ttk.Scrollbar(activities_frame, orient="vertical", command=self.recent_activities_tree.yview)
        self.recent_activities_tree.configure(yscrollcommand=scrollbar.set)
        
        self.recent_activities_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def create_quick_links_widget(self, parent, row, col):
        """Cria o widget de links r√°pidos"""
        links_frame = ttk.LabelFrame(parent, text="Links Frequentes", padding="10")
        links_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        self.dashboard_widgets['quick_links'] = links_frame

        ttk.Button(links_frame, text="Quadros", image=self.icons.get('folder_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Quadros')).pack(fill=tk.X, pady=2)
        ttk.Button(links_frame, text="Produtividade", image=self.icons.get('play_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Produtividade')).pack(fill=tk.X, pady=2)
        ttk.Button(links_frame, text="Finan√ßas", image=self.icons.get('money_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Finan√ßas')).pack(fill=tk.X, pady=2)
        ttk.Button(links_frame, text="Relat√≥rios", image=self.icons.get('pie_chart_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Relat√≥rios')).pack(fill=tk.X, pady=2)

    def create_quick_actions_widget(self, parent, row, col):
        """Cria o widget de a√ß√µes r√°pidas"""
        actions_frame = ttk.LabelFrame(parent, text="A√ß√µes R√°pidas", padding="10")
        actions_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        self.dashboard_widgets['quick_actions'] = actions_frame

        ttk.Button(actions_frame, text="Adicionar Quadro", image=self.icons.get('add_folder_icon'), compound=tk.LEFT, 
                  command=self.add_board).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Iniciar Pomodoro", image=self.icons.get('play_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Produtividade')).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Nova Transa√ß√£o", image=self.icons.get('add_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Finan√ßas')).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Gerenciar Usu√°rios", image=self.icons.get('key_icon'), compound=tk.LEFT, 
                  command=self.open_user_management).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Configurar Notifica√ß√µes", image=self.icons.get('settings_icon'), compound=tk.LEFT, 
                  command=self.open_notification_settings).pack(fill=tk.X, pady=2)
        
        # Bot√£o para alternar widget de reuni√µes ser√° movido para configura√ß√µes do dashboard
        
        # Widget de reuni√µes ser√° criado no m√©todo create_main_menu_tab
        ttk.Button(actions_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT, 
                  command=self.update_dashboard_widgets).pack(fill=tk.X, pady=2)

    def apply_dashboard_widget_settings(self):
        """Aplica as configura√ß√µes de visibilidade dos widgets"""
        widget_settings = self.settings.get('dashboard_widgets', {})
        
        # Converter string JSON para dicion√°rio se necess√°rio
        if isinstance(widget_settings, str):
            try:
                import json
                widget_settings = json.loads(widget_settings)
            except:
                widget_settings = {}
        
        for widget_name, frame in self.dashboard_widgets.items():
            if widget_settings.get(widget_name, True):
                frame.grid()
            else:
                frame.grid_remove()

    def on_urgent_task_double_click(self, event):
        """Handler para duplo clique em tarefa urgente"""
        selection = self.urgent_tasks_tree.selection()
        if selection:
            item = self.urgent_tasks_tree.item(selection[0])
            task_title = item['values'][0]
            # Aqui voc√™ pode implementar a navega√ß√£o para o cart√£o espec√≠fico
            self.select_tab_by_text('Quadros')
            messagebox.showinfo("Navega√ß√£o", f"Navegando para a tarefa: {task_title}")

    def on_deadline_double_click(self, event):
        """Handler para duplo clique em prazo"""
        selection = self.deadlines_tree.selection()
        if selection:
            item = self.deadlines_tree.item(selection[0])
            task_title = item['values'][0]
            # Aqui voc√™ pode implementar a navega√ß√£o para o cart√£o espec√≠fico
            self.select_tab_by_text('Quadros')
            messagebox.showinfo("Navega√ß√£o", f"Navegando para a tarefa: {task_title}")

    def on_activity_double_click(self, event):
        """Handler para duplo clique em atividade"""
        selection = self.recent_activities_tree.selection()
        if selection:
            item = self.recent_activities_tree.item(selection[0])
            activity = item['values'][0]
            messagebox.showinfo("Atividade", f"Detalhes da atividade: {activity}")

    def update_main_menu_overview(self):
        # Update the quick overview labels
        total_boards = len(self.boodesk_data["boards"])
        total_tasks = len(self.pomodoro_tasks_df)
        total_members = len(self.members_df)

        self.total_boards_label.config(text=f"Total de Quadros: {total_boards}")
        self.total_tasks_label.config(text=f"Total de Tarefas Pomodoro: {total_tasks}")
        self.total_members_label.config(text=f"Total de Membros: {total_members}")

    def update_urgent_tasks_widget(self):
        """Atualiza o widget de tarefas urgentes"""
        if not hasattr(self, 'urgent_tasks_tree'):
            return
            
        self.urgent_tasks_tree.delete(*self.urgent_tasks_tree.get_children())
        
        urgent_tasks = []
        for board_name, board_data in self.boodesk_data["boards"].items():
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                    if list_name != "workflow":
                        for card in cards:
                            if not card.get("is_archived", False):
                                importance = card.get("importance", "Normal")
                                if importance in ["Alta", "Cr√≠tica"]:
                                    urgent_tasks.append({
                                        "title": card.get("title", ""),
                                        "board": board_name,
                                        "importance": importance,
                                        "card": card
                                    })
        
        # Sort by importance (Cr√≠tica first, then Alta)
        importance_order = {"Cr√≠tica": 0, "Alta": 1}
        urgent_tasks.sort(key=lambda x: importance_order.get(x["importance"], 2))
        
        # Add to treeview (top 5)
        for i, task in enumerate(urgent_tasks[:5]):
            item = self.urgent_tasks_tree.insert("", "end", values=(
                task["title"],
                task["board"],
                task["importance"]
            ))
            
            # Apply background color based on importance
            if task["importance"] == "Cr√≠tica":
                self.urgent_tasks_tree.tag_configure("critical", background="#FFCCCC")
                self.urgent_tasks_tree.item(item, tags=("critical",))
            elif task["importance"] == "Alta":
                self.urgent_tasks_tree.tag_configure("high", background="#FFE5CC")
                self.urgent_tasks_tree.item(item, tags=("high",))

    def update_upcoming_deadlines_widget(self):
        """Atualiza o widget de prazos pr√≥ximos"""
        if not hasattr(self, 'deadlines_tree'):
            return
            
        self.deadlines_tree.delete(*self.deadlines_tree.get_children())
        
        deadline_tasks = []
        today = datetime.now()
        
        for board_name, board_data in self.boodesk_data["boards"].items():
            # Verificar se board_data √© um dicion√°rio ou lista
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                    if list_name != "workflow":
                        for card in cards:
                            if not card.get("is_archived", False):
                                due_date_str = card.get("due_date", "")
                                if due_date_str:
                                    try:
                                        due_date = datetime.strptime(due_date_str, '%Y-%m-%d %H:%M')
                                        if due_date > today:
                                            days_until = (due_date - today).days
                                            deadline_tasks.append({
                                                "title": card.get("title", ""),
                                                "due_date": due_date_str,
                                                "days": days_until,
                                                "card": card
                                            })
                                    except ValueError:
                                        continue
        
        # Sort by days until deadline
        deadline_tasks.sort(key=lambda x: x["days"])
        
        # Add to treeview (top 5)
        for i, task in enumerate(deadline_tasks[:5]):
            item = self.deadlines_tree.insert("", "end", values=(
                task["title"],
                task["due_date"],
                f"{task['days']} dias"
            ))
            
            # Aplicar cor baseada no quadro da tarefa
            card = task["card"]
            board_name = None
            
            # Encontrar o quadro da tarefa
            for board_name_iter, board_data in self.boodesk_data["boards"].items():
                for list_name, cards in board_data.items():
                    if list_name != "workflow":
                        for card_iter in cards:
                            if card_iter.get("id") == card.get("id"):
                                board_name = board_name_iter
                                break
                        if board_name:
                            break
                    if board_name:
                        break
                if board_name:
                    break
            
            # Aplicar cor do quadro se encontrado
            if board_name and board_name in self.settings.get('board_colors', {}):
                board_color = self.settings['board_colors'][board_name]
                tag_name = f"board_{board_name}"
                self.deadlines_tree.tag_configure(tag_name, background=board_color)
                self.deadlines_tree.item(item, tags=(tag_name,))
            else:
                # Fallback para cores baseadas na urg√™ncia
                if task["days"] <= 1:
                    self.deadlines_tree.tag_configure("urgent", background="#FFCCCC")
                    self.deadlines_tree.item(item, tags=("urgent",))
                elif task["days"] <= 3:
                    self.deadlines_tree.tag_configure("soon", background="#FFE5CC")
                    self.deadlines_tree.item(item, tags=("soon",))

    def update_recent_activities_widget(self):
        """Atualiza o widget de atividades recentes"""
        if not hasattr(self, 'recent_activities_tree'):
            return
            
        self.recent_activities_tree.delete(*self.recent_activities_tree.get_children())
        
        activities = []
        
        # Collect activities from card history
        for board_name, board_data in self.boodesk_data["boards"].items():
            # Verificar se board_data √© um dicion√°rio ou lista
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                    if list_name != "workflow":
                        for card in cards:
                            history = card.get("history", [])
                            for entry in history[-3:]:  # Last 3 entries per card
                                activities.append({
                                    "action": entry.get("action", ""),
                                    "timestamp": entry.get("timestamp", ""),
                                    "user": entry.get("user", "")
                                })
        
        # Sort by timestamp (most recent first)
        activities.sort(key=lambda x: x["timestamp"], reverse=True)
        
        # Add to treeview (top 10)
        for activity in activities[:10]:
            self.recent_activities_tree.insert("", "end", values=(
                activity["action"],
                activity["timestamp"]
            ))

    def open_user_management_window(self):
        """Abre a janela de gerenciamento de usu√°rios (alias para open_user_management)"""
        # Usar a fun√ß√£o principal que j√° est√° implementada e funcionando
        self.open_user_management()

    def open_management_reports(self):
        # Placeholder for Management Reports
        messagebox.showinfo("Relat√≥rios Gerenciais", "Funcionalidade de Relat√≥rios Gerenciais em desenvolvimento!")

    def create_accounts_registration_tab(self, parent):
        # Accounts Section
        accounts_frame = ttk.Frame(parent, padding="10")
        accounts_frame.pack(fill=tk.BOTH, expand=True)
        accounts_frame.columnconfigure(1, weight=1)

        ttk.Label(accounts_frame, text="Nome da Conta:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.account_name_entry = ttk.Entry(accounts_frame, width=40)
        self.account_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        button_frame_acc = ttk.Frame(accounts_frame)
        button_frame_acc.grid(row=1, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame_acc, text="Adicionar Conta", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_account).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_acc, text="Remover Selecionada", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_account).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_acc, text="Atualizar Saldo", image=self.icons.get('refresh_icon'), compound=tk.LEFT, command=self.update_selected_account_balance).pack(side=tk.LEFT, padx=5)

        accounts_list_frame = ttk.LabelFrame(accounts_frame, text="Contas Existentes", padding="10")
        accounts_list_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=10)
        accounts_list_frame.columnconfigure(0, weight=1)
        accounts_list_frame.rowconfigure(0, weight=1)

        self.accounts_listbox = tk.Listbox(accounts_list_frame, selectmode=tk.SINGLE, height=5)
        self.accounts_listbox.grid(row=0, column=0, sticky="nsew", pady=5)
        self.accounts_listbox.bind("<<ListboxSelect>>", self.on_account_select)
        acc_scrollbar = ttk.Scrollbar(accounts_list_frame, orient="vertical", command=self.accounts_listbox.yview)
        acc_scrollbar.grid(row=0, column=1, sticky="ns")
        self.accounts_listbox.config(yscrollcommand=acc_scrollbar.set)

    def create_categories_registration_tab(self, parent):
        # Categories Section
        categories_frame = ttk.Frame(parent, padding="10")
        categories_frame.pack(fill=tk.BOTH, expand=True)
        categories_frame.columnconfigure(1, weight=1)

        ttk.Label(categories_frame, text="Nome da Categoria:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.category_name_entry = ttk.Entry(categories_frame, width=40)
        self.category_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        button_frame_cat = ttk.Frame(categories_frame)
        button_frame_cat.grid(row=1, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame_cat, text="Adicionar Categoria", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_cat, text="Remover Selecionada", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_category).pack(side=tk.LEFT, padx=5)

        categories_list_frame = ttk.LabelFrame(categories_frame, text="Categorias Existentes", padding="10")
        categories_list_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=10)
        categories_list_frame.columnconfigure(0, weight=1)
        categories_list_frame.rowconfigure(0, weight=1)

        self.categories_listbox = tk.Listbox(categories_list_frame, selectmode=tk.SINGLE, height=5)
        self.categories_listbox.grid(row=0, column=0, sticky="nsew", pady=5)
        cat_scrollbar = ttk.Scrollbar(categories_list_frame, orient="vertical", command=self.categories_listbox.yview)
        cat_scrollbar.grid(row=0, column=1, sticky="ns")
        self.categories_listbox.config(yscrollcommand=cat_scrollbar.set)

    def create_payment_methods_registration_tab(self, parent):
        # Payment Methods Section
        payment_methods_frame = ttk.Frame(parent, padding="10")
        payment_methods_frame.pack(fill=tk.BOTH, expand=True)
        payment_methods_frame.columnconfigure(1, weight=1)

        ttk.Label(payment_methods_frame, text="Nome do Meio de Pagamento:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.payment_method_name_entry = ttk.Entry(payment_methods_frame, width=40)
        self.payment_method_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        button_frame_pm = ttk.Frame(payment_methods_frame)
        button_frame_pm.grid(row=1, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame_pm, text="Adicionar Meio de Pagamento", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_payment_method).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_pm, text="Remover Selecionado", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_payment_method).pack(side=tk.LEFT, padx=5)

        payment_methods_list_frame = ttk.LabelFrame(payment_methods_frame, text="Meios de Pagamento Existentes", padding="10")
        payment_methods_list_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=10)
        payment_methods_list_frame.columnconfigure(0, weight=1)
        payment_methods_list_frame.rowconfigure(0, weight=1)

        self.payment_methods_listbox = tk.Listbox(payment_methods_list_frame, selectmode=tk.SINGLE, height=5)
        self.payment_methods_listbox.grid(row=0, column=0, sticky="nsew", pady=5)
        pm_scrollbar = ttk.Scrollbar(payment_methods_list_frame, orient="vertical", command=self.payment_methods_listbox.yview)
        pm_scrollbar.grid(row=0, column=1, sticky="ns")
        self.payment_methods_listbox.config(yscrollcommand=pm_scrollbar.set)

    def create_incomes_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Input fields for new income transaction
        input_frame = ttk.LabelFrame(main_frame, text="Registrar Nova Entrada", padding="10")
        input_frame.pack(fill=tk.X, pady=10)

        input_frame.columnconfigure(1, weight=1)

        ttk.Label(input_frame, text="Descri√ß√£o:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.income_description_entry = ttk.Entry(input_frame, width=40)
        self.income_description_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(input_frame, text="Valor:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.income_amount_entry = NumericEntryWithButtons(input_frame, self.icons)
        self.income_amount_entry.grid(row=1, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Data:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        income_date_frame = ttk.Frame(input_frame)
        income_date_frame.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        self.income_date_entry = ttk.Entry(income_date_frame, width=15, state="readonly")
        self.income_date_entry.pack(side=tk.LEFT)
        ttk.Button(income_date_frame, image=self.icons.get('time_icon'), width=3, command=partial(self._open_finance_date_picker, self.income_date_entry)).pack(side=tk.LEFT, padx=2)
        self.income_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d")) # Default to today

        ttk.Label(input_frame, text="Categoria:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.income_category_combo = ttk.Combobox(input_frame, state="readonly")
        self.income_category_combo.grid(row=3, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Meio de Pagamento:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.income_payment_method_combo = ttk.Combobox(input_frame, state="readonly")
        self.income_payment_method_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Conta Banc√°ria:").grid(row=5, column=0, sticky="w", padx=5, pady=2)
        self.income_account_combo = ttk.Combobox(input_frame, state="readonly")
        self.income_account_combo.grid(row=5, column=1, sticky="w", padx=5, pady=2)

        ttk.Button(input_frame, text="Registrar Entrada", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.register_income).grid(row=6, column=0, columnspan=2, pady=10)

        # Treeview for displaying income transactions
        incomes_treeview_frame = ttk.LabelFrame(main_frame, text="Entradas Registradas", padding="10")
        incomes_treeview_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.incomes_treeview = ttk.Treeview(incomes_treeview_frame, columns=("Data", "Descri√ß√£o", "Valor", "Categoria", "Meio de Pagamento", "Conta"), show="headings")
        self.incomes_treeview.heading("Data", text="Data")
        self.incomes_treeview.heading("Descri√ß√£o", text="Descri√ß√£o")
        self.incomes_treeview.heading("Valor", text="Valor")
        self.incomes_treeview.heading("Categoria", text="Categoria")
        self.incomes_treeview.heading("Meio de Pagamento", text="Meio de Pagamento")
        self.incomes_treeview.heading("Conta", text="Conta")

        self.incomes_treeview.column("Data", width=100, anchor="center")
        self.incomes_treeview.column("Descri√ß√£o", width=200, anchor="w")
        self.incomes_treeview.column("Valor", width=100, anchor="e")
        self.incomes_treeview.column("Categoria", width=120, anchor="w")
        self.incomes_treeview.column("Meio de Pagamento", width=120, anchor="w")
        self.incomes_treeview.column("Conta", width=120, anchor="w")

        self.incomes_treeview.pack(fill=tk.BOTH, expand=True)

    def register_income(self):
        description = self.income_description_entry.get().strip()
        amount = self.income_amount_entry.get()
        date = self.income_date_entry.get()
        category = self.income_category_combo.get()
        payment_method = self.income_payment_method_combo.get()
        account = self.income_account_combo.get()

        if not description or amount <= 0 or not date or not category or not payment_method or not account:
            messagebox.showwarning("Campos Obrigat√≥rios", "Por favor, preencha todos os campos da entrada e o valor deve ser positivo.")
            return

        new_transaction = {
            "descricao": description,
            "valor": amount,
            "tipo": "Entrada",
            "data": date,
            "categoria": category,
            "meio_pagamento": payment_method,
            "conta_bancaria": account,
            "timestamp": datetime.now().isoformat()
        }

        self.boodesk_data["finances"]["transacoes"].append(new_transaction)
        
        for acc in self.boodesk_data['finances']['contas_bancarias']:
            if acc['name'] == account:
                acc['balance'] += amount
                break
        
        self.save_trello_data()
        self.update_transactions_treeview()
        self.update_incomes_treeview()
        self.update_accounts_listbox()
        self.update_total_balance_display()

        self.income_description_entry.delete(0, tk.END)
        self.income_amount_entry.set(0.00)
        self.income_date_entry.delete(0, tk.END)
        self.income_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.income_category_combo.set("")
        self.income_payment_method_combo.set("")
        self.income_account_combo.set("")
        messagebox.showinfo("Sucesso", "Entrada registrada com sucesso!")
        self._show_chart(self.current_chart_type)

    def update_incomes_treeview(self):
        for i in self.incomes_treeview.get_children():
            self.incomes_treeview.delete(i)
        for transaction in self.boodesk_data["finances"]["transacoes"]:
            if transaction["tipo"] == "Entrada":
                self.incomes_treeview.insert("", "end", values=(
                    transaction["data"],
                    transaction["descricao"],
                    f"{transaction["valor"]:.2f}",
                    transaction["categoria"],
                    transaction["meio_pagamento"],
                    transaction["conta_bancaria"]
                ))

    def create_expenses_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Input fields for new expense transaction
        input_frame = ttk.LabelFrame(main_frame, text="Registrar Nova Sa√≠da", padding="10")
        input_frame.pack(fill=tk.X, pady=10)

        input_frame.columnconfigure(1, weight=1)

        ttk.Label(input_frame, text="Descri√ß√£o:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.expense_description_entry = ttk.Entry(input_frame, width=40)
        self.expense_description_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(input_frame, text="Valor:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.expense_amount_entry = NumericEntryWithButtons(input_frame, self.icons)
        self.expense_amount_entry.grid(row=1, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Data:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        expense_date_frame = ttk.Frame(input_frame)
        expense_date_frame.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        self.expense_date_entry = ttk.Entry(expense_date_frame, width=15, state="readonly")
        self.expense_date_entry.pack(side=tk.LEFT)
        ttk.Button(expense_date_frame, image=self.icons.get('time_icon'), width=3, command=partial(self._open_finance_date_picker, self.expense_date_entry)).pack(side=tk.LEFT, padx=2)
        self.expense_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d")) # Default to today

        ttk.Label(input_frame, text="Categoria:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.expense_category_combo = ttk.Combobox(input_frame, state="readonly")
        self.expense_category_combo.grid(row=3, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Meio de Pagamento:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.expense_payment_method_combo = ttk.Combobox(input_frame, state="readonly")
        self.expense_payment_method_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Conta Banc√°ria:").grid(row=5, column=0, sticky="w", padx=5, pady=2)
        self.expense_account_combo = ttk.Combobox(input_frame, state="readonly")
        self.expense_account_combo.grid(row=5, column=1, sticky="w", padx=5, pady=2)

        ttk.Button(input_frame, text="Registrar Sa√≠da", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.register_expense).grid(row=6, column=0, columnspan=2, pady=10)

        # Treeview for displaying expense transactions
        expenses_treeview_frame = ttk.LabelFrame(main_frame, text="Sa√≠das Registradas", padding="10")
        expenses_treeview_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.expenses_treeview = ttk.Treeview(expenses_treeview_frame, columns=("Data", "Descri√ß√£o", "Valor", "Categoria", "Meio de Pagamento", "Conta"), show="headings")
        self.expenses_treeview.heading("Data", text="Data")
        self.expenses_treeview.heading("Descri√ß√£o", text="Descri√ß√£o")
        self.expenses_treeview.heading("Valor", text="Valor")
        self.expenses_treeview.heading("Categoria", text="Categoria")
        self.expenses_treeview.heading("Meio de Pagamento", text="Meio de Pagamento")
        self.expenses_treeview.heading("Conta", text="Conta")

        self.expenses_treeview.column("Data", width=100, anchor="center")
        self.expenses_treeview.column("Descri√ß√£o", width=200, anchor="w")
        self.expenses_treeview.column("Valor", width=100, anchor="e")
        self.expenses_treeview.column("Categoria", width=120, anchor="w")
        self.expenses_treeview.column("Meio de Pagamento", width=120, anchor="w")
        self.expenses_treeview.column("Conta", width=120, anchor="w")

        self.expenses_treeview.pack(fill=tk.BOTH, expand=True)

    def register_expense(self):
        description = self.expense_description_entry.get().strip()
        amount = self.expense_amount_entry.get()
        date = self.expense_date_entry.get()
        category = self.expense_category_combo.get()
        payment_method = self.expense_payment_method_combo.get()
        account = self.expense_account_combo.get()

        if not description or amount <= 0 or not date or not category or not payment_method or not account:
            messagebox.showwarning("Campos Obrigat√≥rios", "Por favor, preencha todos os campos da sa√≠da e o valor deve ser positivo.")
            return

        new_transaction = {
            "descricao": description,
            "valor": amount,
            "tipo": "Sa√≠da",
            "data": date,
            "categoria": category,
            "meio_pagamento": payment_method,
            "conta_bancaria": account,
            "timestamp": datetime.now().isoformat()
        }

        self.boodesk_data["finances"]["transacoes"].append(new_transaction)
        
        for acc in self.boodesk_data['finances']['contas_bancarias']:
            if acc['name'] == account:
                acc['balance'] -= amount
                break
        
        self.save_trello_data()
        self.update_transactions_treeview()
        self.update_expenses_treeview()
        self.update_accounts_listbox()
        self.update_total_balance_display()

        self.expense_description_entry.delete(0, tk.END)
        self.expense_amount_entry.set(0.00)
        self.expense_date_entry.delete(0, tk.END)
        self.expense_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.expense_category_combo.set("")
        self.expense_payment_method_combo.set("")
        self.expense_account_combo.set("")
        messagebox.showinfo("Sucesso", "Sa√≠da registrada com sucesso!")
        self._show_chart(self.current_chart_type)

    def update_expenses_treeview(self):
        for i in self.expenses_treeview.get_children():
            self.expenses_treeview.delete(i)
        for transaction in self.boodesk_data["finances"]["transacoes"]:
            if transaction["tipo"] == "Sa√≠da":
                self.expenses_treeview.insert("", "end", values=(
                    transaction["data"],
                    transaction["descricao"],
                    f"{transaction["valor"]:.2f}",
                    transaction["categoria"],
                    transaction["meio_pagamento"],
                    transaction["conta_bancaria"]
                ))

    def create_transactions_history_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Treeview for displaying all transactions
        transactions_frame = ttk.LabelFrame(main_frame, text="Hist√≥rico de Transa√ß√µes", padding="10")
        transactions_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.transactions_treeview = ttk.Treeview(transactions_frame, columns=("Data", "Descri√ß√£o", "Tipo", "Valor", "Categoria", "Meio de Pagamento", "Conta"), show="headings")
        self.transactions_treeview.heading("Data", text="Data")
        self.transactions_treeview.heading("Descri√ß√£o", text="Descri√ß√£o")
        self.transactions_treeview.heading("Tipo", text="Tipo")
        self.transactions_treeview.heading("Valor", text="Valor")
        self.transactions_treeview.heading("Categoria", text="Categoria")
        self.transactions_treeview.heading("Meio de Pagamento", text="Meio de Pagamento")
        self.transactions_treeview.heading("Conta", text="Conta")

        self.transactions_treeview.column("Data", width=100, anchor="center")
        self.transactions_treeview.column("Descri√ß√£o", width=200, anchor="w")
        self.transactions_treeview.column("Tipo", width=80, anchor="center")
        self.transactions_treeview.column("Valor", width=100, anchor="e")
        self.transactions_treeview.column("Categoria", width=120, anchor="w")
        self.transactions_treeview.column("Meio de Pagamento", width=120, anchor="w")
        self.transactions_treeview.column("Conta", width=120, anchor="w")

        self.transactions_treeview.pack(fill=tk.BOTH, expand=True)

    def _open_finance_date_picker(self, entry_widget):
        current_date_str = entry_widget.get()
        dialog = DatePickerDialog(self.root, current_date=current_date_str, icons=self.icons)
        self.root.wait_window(dialog)
        if dialog.result_date:
            entry_widget.config(state="normal")
            entry_widget.delete(0, tk.END)
            entry_widget.insert(0, dialog.result_date.strftime("%Y-%m-%d"))
            entry_widget.config(state="readonly")

    def update_transactions_treeview(self):
        for i in self.transactions_treeview.get_children():
            self.transactions_treeview.delete(i)
        for transaction in self.boodesk_data["finances"]["transacoes"]:
            self.transactions_treeview.insert("", "end", values=(
                transaction["data"],
                transaction["descricao"],
                transaction["tipo"],
                transaction["valor"], # No f-string here, it's already a float
                transaction["categoria"],
                transaction["meio_pagamento"],
                transaction["conta_bancaria"]
            ))

    def populate_finance_comboboxes(self):
        self.income_category_combo['values'] = self.boodesk_data["finances"]["categorias_gasto"]
        self.expense_category_combo['values'] = self.boodesk_data["finances"]["categorias_gasto"]
        self.income_payment_method_combo['values'] = self.boodesk_data["finances"]["meios_pagamento"]
        self.expense_payment_method_combo['values'] = self.boodesk_data["finances"]["meios_pagamento"]
        self.income_account_combo['values'] = [acc['name'] for acc in self.boodesk_data["finances"]["contas_bancarias"]]
        self.expense_account_combo['values'] = [acc['name'] for acc in self.boodesk_data["finances"]["contas_bancarias"]]

    def create_registration_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Frame para os bot√µes de navega√ß√£o
        button_nav_frame = ttk.Frame(main_frame)
        button_nav_frame.pack(pady=10)

        ttk.Button(button_nav_frame, text="Cadastrar Contas", image=self.icons.get('add_folder_icon'), compound=tk.LEFT, command=lambda: self.registration_notebook.select(0)).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_nav_frame, text="Cadastrar Categorias", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.registration_notebook.select(1)).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_nav_frame, text="Cadastrar Meios de Pagamento", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.registration_notebook.select(2)).pack(side=tk.LEFT, padx=5)

        self.registration_notebook = ttk.Notebook(main_frame)
        self.registration_notebook.pack(fill=tk.BOTH, expand=True)

        accounts_frame = ttk.Frame(self.registration_notebook)
        categories_frame = ttk.Frame(self.registration_notebook)
        payment_methods_frame = ttk.Frame(self.registration_notebook)

        self.registration_notebook.add(accounts_frame, text='Contas Banc√°rias')
        self.registration_notebook.add(categories_frame, text='Categorias de Gasto')
        self.registration_notebook.add(payment_methods_frame, text='Meios de Pagamento')

        self.create_accounts_registration_tab(accounts_frame)
        self.create_categories_registration_tab(categories_frame)
        self.create_payment_methods_registration_tab(payment_methods_frame)

    def add_account(self):
        name = self.account_name_entry.get().strip()

        if not name:
            messagebox.showwarning("Campo Obrigat√≥rio", "Por favor, insira o nome da conta.")
            return

        if any(acc['name'] == name for acc in self.boodesk_data['finances']['contas_bancarias']):
            messagebox.showwarning("Conta Existente", f"Uma conta com o nome '{name}' j√° existe.")
            return

        self.boodesk_data['finances']['contas_bancarias'].append({"name": name, "balance": 0.00})
        self.save_trello_data()
        self.update_accounts_listbox()
        self.populate_finance_comboboxes()
        self.update_total_balance_display()
        self.account_name_entry.delete(0, tk.END)
        messagebox.showinfo("Sucesso", f"Conta '{name}' adicionada com sucesso!")
        self._show_chart(self.current_chart_type)

    def remove_account(self):
        selected_index = self.accounts_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione uma conta para remover.")
            return

        account_name_display = self.accounts_listbox.get(selected_index[0])
        account_name = account_name_display.split(" (R$")[0]

        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover a conta '{account_name}'?"):
            self.boodesk_data['finances']['contas_bancarias'] = [
                acc for acc in self.boodesk_data['finances']['contas_bancarias'] if acc['name'] != account_name
            ]
            self.save_trello_data()
            self.update_accounts_listbox()
            self.populate_finance_comboboxes()
            self.update_total_balance_display()
            messagebox.showinfo("Sucesso", f"Conta '{account_name}' removida com sucesso!")
            self._show_chart(self.current_chart_type)

    def update_selected_account_balance(self):
        selected_index = self.accounts_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione uma conta para atualizar o saldo.")
            return

        account_name_display = self.accounts_listbox.get(selected_index[0])
        account_name = account_name_display.split(" (R$")[0]

        new_balance_str = simpledialog.askstring("Atualizar Saldo", f"Digite o novo saldo para '{account_name}':", parent=self.root)
        if new_balance_str is None:
            return

        try:
            new_balance = float(new_balance_str.replace(",", "."))
        except ValueError:
            messagebox.showwarning("Entrada Inv√°lida", "O saldo deve ser um n√∫mero v√°lido.")
            return

        found = False
        for account in self.boodesk_data['finances']['contas_bancarias']:
            if acc['name'] == account_name: # Bug in original code: 'acc' instead of 'account'
                account['balance'] = new_balance
                found = True
                break
        
        if found:
            self.save_trello_data()
            self.update_accounts_listbox()
            self.update_total_balance_display()
            messagebox.showinfo("Sucesso", f"Saldo da conta '{account_name}' atualizado para R$ {new_balance:.2f}.")
        else:
            messagebox.showerror("Erro", "Conta n√£o encontrada. Por favor, selecione uma conta v√°lida.")

    def update_accounts_listbox(self):
        self.accounts_listbox.delete(0, tk.END)
        for account in self.boodesk_data['finances']['contas_bancarias']:
            self.accounts_listbox.insert(tk.END, f"{account['name']} (R$ {account['balance']:.2f})")

    def on_account_select(self, event):
        selected_index = self.accounts_listbox.curselection()
        if selected_index:
            account_name_display = self.accounts_listbox.get(selected_index[0])
            account_name = account_name_display.split(" (R$")[0]
            
            for account in self.boodesk_data['finances']['contas_bancarias']:
                if account['name'] == account_name:
                    self.account_name_entry.delete(0, tk.END)
                    self.account_name_entry.insert(0, account['name'])
                    break

    def add_category(self):
        name = self.category_name_entry.get().strip()
        if not name:
            messagebox.showwarning("Campo Obrigat√≥rio", "Por favor, insira o nome da categoria.")
            return

        if name in self.boodesk_data['finances']['categorias_gasto']:
            messagebox.showwarning("Categoria Existente", f"A categoria '{name}' j√° existe.")
            return

        self.boodesk_data['finances']['categorias_gasto'].append(name)
        self.save_trello_data()
        self.update_categories_listbox()
        self.populate_finance_comboboxes()
        self.category_name_entry.delete(0, tk.END)
        messagebox.showinfo("Sucesso", f"Categoria '{name}' adicionada com sucesso!")

    def remove_category(self):
        selected_index = self.categories_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione uma categoria para remover.")
            return

        category_name = self.categories_listbox.get(selected_index[0])

        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover a categoria '{category_name}'?"):
            self.boodesk_data['finances']['categorias_gasto'].remove(category_name)
            self.save_trello_data()
            self.update_categories_listbox()
            self.populate_finance_comboboxes()
            messagebox.showinfo("Sucesso", f"Categoria '{category_name}' removida com sucesso!")

    def update_categories_listbox(self):
        self.categories_listbox.delete(0, tk.END)
        for category in self.boodesk_data['finances']['categorias_gasto']:
            self.categories_listbox.insert(tk.END, category)

    def add_payment_method(self):
        name = self.payment_method_name_entry.get().strip()
        if not name:
            messagebox.showwarning("Campo Obrigat√≥rio", "Por favor, insira o nome do meio de pagamento.")
            return

        if name in self.boodesk_data['finances']['meios_pagamento']:
            messagebox.showwarning("Meio de Pagamento Existente", f"O meio de pagamento '{name}' j√° existe.")
            return

        self.boodesk_data['finances']['meios_pagamento'].append(name)
        self.save_trello_data()
        self.update_payment_methods_listbox()
        self.populate_finance_comboboxes()
        self.payment_method_name_entry.delete(0, tk.END)
        messagebox.showinfo("Sucesso", f"Meio de pagamento '{name}' adicionado com sucesso!")

    def remove_payment_method(self):
        selected_index = self.payment_methods_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um meio de pagamento para remover.")
            return

        payment_method_name = self.payment_methods_listbox.get(selected_index[0])

        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover o meio de pagamento '{payment_method_name}'?"):
            self.boodesk_data['finances']['meios_pagamento'].remove(payment_method_name)
            self.save_trello_data()
            self.update_payment_methods_listbox()
            self.populate_finance_comboboxes()
            messagebox.showinfo("Sucesso", f"Meio de pagamento '{payment_method_name}' removido com sucesso!")

    def update_payment_methods_listbox(self):
        self.payment_methods_listbox.delete(0, tk.END)
        for method in self.boodesk_data['finances']['meios_pagamento']:
            self.payment_methods_listbox.insert(tk.END, method)

    def create_overview_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        overview_label_frame = ttk.LabelFrame(main_frame, text="Vis√£o Geral Financeira", padding="10")
        overview_label_frame.pack(fill=tk.X, pady=10)

        self.total_balance_label = ttk.Label(overview_label_frame, text="Saldo Total: R$ 0.00", font=("Helvetica", 16, "bold"))
        self.total_balance_label.pack(pady=10)

        # Menu de Relat√≥rios
        reports_menu_frame = ttk.Frame(main_frame)
        reports_menu_frame.pack(pady=5)

        reports_menubutton = ttk.Menubutton(reports_menu_frame, text="Relat√≥rios Financeiros", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT, direction="below")
        reports_menubutton.pack()

        reports_menu = tk.Menu(reports_menubutton, tearoff=0)
        reports_menubutton["menu"] = reports_menu

        reports_menu.add_command(label="Relat√≥rio de Entradas (Em Breve)", command=lambda: messagebox.showinfo("Relat√≥rio", "Funcionalidade de Relat√≥rio de Entradas em desenvolvimento!"))
        reports_menu.add_command(label="Relat√≥rio de Sa√≠das (Em Breve)", command=lambda: messagebox.showinfo("Relat√≥rio", "Funcionalidade de Relat√≥rio de Sa√≠das em desenvolvimento!"))
        reports_menu.add_command(label="Relat√≥rio por Categoria (Em Breve)", command=lambda: messagebox.showinfo("Relat√≥rio", "Funcionalidade de Relat√≥rio por Categoria em desenvolvimento!"))
        reports_menu.add_command(label="Relat√≥rio de Contas (Em Breve)", command=lambda: messagebox.showinfo("Relat√≥rio", "Funcionalidade de Relat√≥rio de Contas em desenvolvimento!"))

        # Chart display area
        self.chart_frame = ttk.Frame(main_frame)
        self.chart_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        # Chart selection buttons
        chart_buttons_frame = ttk.Frame(main_frame)
        chart_buttons_frame.pack(pady=5)

        ttk.Button(chart_buttons_frame, text="Entradas vs Sa√≠das", image=self.icons.get('pie_chart_icon'), compound=tk.LEFT, command=lambda: self._show_chart("income_vs_expense")).pack(side=tk.LEFT, padx=5)
        ttk.Button(chart_buttons_frame, text="Entradas por Categoria", image=self.icons.get('bar_chart_icon'), compound=tk.LEFT, command=lambda: self._show_chart("income_by_category")).pack(side=tk.LEFT, padx=5)
        ttk.Button(chart_buttons_frame, text="Sa√≠das por Categoria", image=self.icons.get('bar_chart_icon'), compound=tk.LEFT, command=lambda: self._show_chart("expense_by_category")).pack(side=tk.LEFT, padx=5)

        self.current_chart_canvas = None
        self.current_chart_toolbar = None

        # Initial chart display
        self._show_chart("income_vs_expense")

    def update_total_balance_display(self):
        total_balance = sum(account['balance'] for account in self.boodesk_data['finances']['contas_bancarias'])
        self.total_balance_label.config(text=f"Saldo Total: R$ {total_balance:.2f}")

    def _show_chart(self, chart_type):
        # Clear previous chart
        if self.current_chart_canvas:
            self.current_chart_canvas.get_tk_widget().destroy()
        if self.current_chart_toolbar:
            self.current_chart_toolbar.destroy()

        fig = None
        if chart_type == "income_vs_expense":
            fig = self._create_income_vs_expense_pie_chart()
        elif chart_type == "income_by_category":
            fig = self._create_income_by_category_bar_chart()
        elif chart_type == "expense_by_category":
            fig = self._create_expense_by_category_bar_chart()

        if fig:
            canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
            canvas_widget = canvas.get_tk_widget()
            canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
            self.current_chart_canvas = canvas

            toolbar = NavigationToolbar2Tk(canvas, self.chart_frame)
            toolbar.update()
            toolbar.pack(side=tk.BOTTOM, fill=tk.X)
            self.current_chart_toolbar = toolbar
            canvas.draw()

    def _create_income_vs_expense_pie_chart(self):
        incomes = sum(t['valor'] for t in self.boodesk_data['finances']['transacoes'] if t['tipo'] == 'Entrada')
        expenses = sum(t['valor'] for t in self.boodesk_data['finances']['transacoes'] if t['tipo'] == 'Sa√≠da')

        labels = ['Entradas', 'Sa√≠das']
        sizes = [incomes, expenses]
        colors = ['#4CAF50', '#F44336'] # Green for income, Red for expenses
        explode = (0.1, 0)  # explode 1st slice

        fig, ax = plt.subplots(figsize=(5, 4))

        if sum(sizes) == 0:
            ax.text(0.5, 0.5, "Sem dados para exibir", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=14, color='gray')
            ax.set_title('Entradas vs Sa√≠das')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            # Ensure sizes are not zero to prevent RuntimeWarning: invalid value encountered in divide
            # if sum(sizes) is 0.0, the warning occurs. Already handled by `if sum(sizes) == 0:`
            ax.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%',
                   shadow=True, startangle=140)
            ax.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
            ax.set_title('Entradas vs Sa√≠das')
        return fig

    def _create_income_by_category_bar_chart(self):
        income_by_category = {}
        for t in self.boodesk_data['finances']['transacoes']:
            if t['tipo'] == 'Entrada':
                category = t.get('categoria', 'Outros')
                income_by_category[category] = income_by_category.get(category, 0) + t['valor']

        categories = list(income_by_category.keys())
        values = list(income_by_category.values())

        fig, ax = plt.subplots(figsize=(7, 5))
        if not categories:
            ax.text(0.5, 0.5, "Sem dados de entrada por categoria", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=12, color='gray')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            ax.bar(categories, values, color='#4CAF50')
            ax.set_ylabel('Valor (R$)')
            ax.set_title('Entradas por Categoria')
            ax.tick_params(axis='x', rotation=45)
        plt.tight_layout()
        return fig

    def _create_expense_by_category_bar_chart(self):
        expense_by_category = {}
        for t in self.boodesk_data['finances']['transacoes']:
            if t['tipo'] == 'Sa√≠da':
                category = t.get('categoria', 'Outros')
                expense_by_category[category] = expense_by_category.get(category, 0) + t['valor']

        categories = list(expense_by_category.keys())
        values = list(expense_by_category.values())

        fig, ax = plt.subplots(figsize=(7, 5))
        if not categories:
            ax.text(0.5, 0.5, "Sem dados de sa√≠da por categoria", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=12, color='gray')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            ax.bar(categories, values, color='#F44336')
            ax.set_ylabel('Valor (R$)')
            ax.set_title('Sa√≠das por Categoria')
            ax.tick_params(axis='x', rotation=45)
        plt.tight_layout()
        return fig

    def create_pomodoro_timer_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        top_frame = ttk.Frame(main_frame)
        top_frame.pack(fill=tk.X, pady=10)

        timer_frame = ttk.Frame(top_frame)
        timer_frame.pack(side=tk.LEFT, expand=True, fill=tk.X)
        self.pomodoro_timer_label = ttk.Label(timer_frame, text="", font=("Helvetica", 48))
        self.pomodoro_timer_label.pack()
        self.pomodoro_cycle_label = ttk.Label(timer_frame, text="", font=("Helvetica", 14))
        self.pomodoro_cycle_label.pack()

        stats_frame = ttk.LabelFrame(top_frame, text="Estat√≠sticas do Pomodoro")
        stats_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
        self.pomodoro_completed_label = ttk.Label(stats_frame, text="", font=("Helvetica", 12))
        self.pomodoro_completed_label.pack(padx=10, pady=5)
        self.pomodoro_pending_label = ttk.Label(stats_frame, text="", font=("Helvetica", 12))
        self.pomodoro_pending_label.pack(padx=10, pady=5)

        self.message_label = ttk.Label(main_frame, text="", font=("Helvetica", 12, "italic"))
        self.message_label.pack(pady=10)

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=10)
        self.start_button = ttk.Button(button_frame, text="Iniciar", image=self.icons.get('play_icon'), compound=tk.LEFT, command=self.start_timer)
        self.start_button.pack(side=tk.LEFT, padx=5)
        self.pause_button = ttk.Button(button_frame, text="Pausar", image=self.icons.get('stop_icon'), compound=tk.LEFT, command=self.pause_timer, state=tk.DISABLED)
        self.pause_button.pack(side=tk.LEFT, padx=5)
        self.reset_button = ttk.Button(button_frame, text="Reiniciar", image=self.icons.get('refresh_icon'), compound=tk.LEFT, command=self.reset_timer)
        self.reset_button.pack(side=tk.LEFT, padx=5)
        self.skip_button = ttk.Button(button_frame, text="Pular", image=self.icons.get('forward_icon'), compound=tk.LEFT, command=self.skip_cycle)
        self.skip_button.pack(side=tk.LEFT, padx=5)

        task_frame = ttk.LabelFrame(main_frame, text="Tarefas do Pomodoro")
        task_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        self.pomodoro_task_list = ttk.Treeview(task_frame, columns=("Tarefa", "Status", "Assunto", "Objetivo"), show="headings")
        self.pomodoro_task_list.heading("Tarefa", text="Tarefa")
        self.pomodoro_task_list.heading("Status", text="Status")
        self.pomodoro_task_list.heading("Assunto", text="Assunto")
        self.pomodoro_task_list.heading("Objetivo", text="Objetivo")
        self.pomodoro_task_list.column("Tarefa", width=250, anchor="w")
        self.pomodoro_task_list.column("Status", width=100, anchor="center")
        self.pomodoro_task_list.column("Assunto", width=150, anchor="w")
        self.pomodoro_task_list.column("Objetivo", width=150, anchor="w")
        self.pomodoro_task_list.pack(fill=tk.BOTH, expand=True)
        self.pomodoro_task_list.bind("<<TreeviewSelect>>", self.on_pomodoro_task_select)

        task_button_frame = ttk.Frame(task_frame)
        task_button_frame.pack(pady=5)
        self.add_task_entry = ttk.Entry(task_button_frame, width=40)
        self.add_task_entry.pack(side=tk.LEFT, padx=5)
        ttk.Button(task_button_frame, text="Adicionar Tarefa", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_pomodoro_task).pack(side=tk.LEFT, padx=5)
        ttk.Button(task_button_frame, text="Remover Selecionada", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_pomodoro_task).pack(side=tk.LEFT, padx=5)
        ttk.Button(task_button_frame, text="Concluir Selecionada", image=self.icons.get('ok_icon'), compound=tk.LEFT, command=self.complete_pomodoro_task).pack(side=tk.LEFT, padx=5)

    def create_my_activities_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # PanedWindow para dividir a tela
        paned_window = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        paned_window.pack(fill=tk.BOTH, expand=True)

        # Frame da esquerda para a tabela
        left_frame = ttk.Frame(paned_window, padding="5")
        paned_window.add(left_frame, weight=1)

        # Frame da direita para as informa√ß√µes
        right_frame = ttk.LabelFrame(paned_window, text="Detalhes da Atividade", padding="10")
        paned_window.add(right_frame, weight=1)

        # Tabela de atividades (esquerda)
        self.activities_tree = ttk.Treeview(left_frame, columns=("Tipo", "T√≠tulo", "Sub"), show="headings")
        self.activities_tree.heading("Tipo", text="Tipo")
        self.activities_tree.heading("T√≠tulo", text="T√≠tulo")
        self.activities_tree.heading("Sub", text="Sub")
        self.activities_tree.column("Tipo", width=80, anchor="w")
        self.activities_tree.column("T√≠tulo", width=250, anchor="w")
        self.activities_tree.column("Sub", width=40, anchor="center")

        # Configurar tags de cor para import√¢ncia
        for importance, color in self.settings.get("importance_colors", {}).items():
            self.activities_tree.tag_configure(importance, background=color)

        self.activities_tree.pack(fill=tk.BOTH, expand=True)
        self.activities_tree.bind("<<TreeviewSelect>>", self.on_activity_select)
        self.activities_tree.bind("<Double-1>", self.on_activity_double_click)

        bold_font = ("Helvetica", 9, "bold")

        # Labels para informa√ß√µes (direita)
        ttk.Label(right_frame, text="Descri√ß√£o:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_desc_text = tk.Text(right_frame, height=5, wrap=tk.WORD, state="disabled")
        self.activity_desc_text.pack(fill=tk.X, pady=2)

        ttk.Label(right_frame, text="Prazo:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_due_date_label = ttk.Label(right_frame, text="-")
        self.activity_due_date_label.pack(anchor="w", pady=2)

        # Adicionar mais labels conforme necess√°rio (ex: membros, assunto, etc.)
        ttk.Label(right_frame, text="Membros:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_members_label = ttk.Label(right_frame, text="-")
        self.activity_members_label.pack(anchor="w", pady=2)

        ttk.Label(right_frame, text="Depend√™ncias:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_dependencies_label = ttk.Label(right_frame, text="-")
        self.activity_dependencies_label.pack(anchor="w", pady=2)

        ttk.Label(right_frame, text="Subtarefas:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_subtasks_text = tk.Text(right_frame, height=5, wrap=tk.WORD, state="disabled")
        self.activity_subtasks_text.pack(fill=tk.X, pady=2)

        # Bot√µes de A√ß√£o
        action_frame = ttk.Frame(right_frame)
        action_frame.pack(fill=tk.X, pady=10)
        ttk.Button(action_frame, text="Ir para o Quadro", image=self.icons.get('forward_icon_32'), compound=tk.LEFT, command=self.go_to_board_from_activity).pack(side=tk.LEFT, padx=5)
        ttk.Button(action_frame, text="Abrir Card", image=self.icons.get('open_file_icon_32'), compound=tk.LEFT, command=self.open_card_from_activity).pack(side=tk.LEFT, padx=5)

        # Bot√£o para atualizar
        ttk.Button(main_frame, text="Atualizar", image=self.icons.get('refresh_icon_32'), compound=tk.LEFT, command=self.update_my_activities_tab).pack(pady=5)

        # Legenda de Cores
        legend_frame = ttk.Frame(main_frame)
        legend_frame.pack(fill=tk.X, pady=5, side=tk.BOTTOM)
        ttk.Label(legend_frame, text="Legenda:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=5)
        for imp, color in self.settings.get("importance_colors", {}).items():
            ttk.Label(legend_frame, text=imp, background=color, font=("Helvetica", 8)).pack(side=tk.LEFT, padx=2)

        self.update_my_activities_tab()

    def update_my_activities_tab(self):
        for i in self.activities_tree.get_children():
            self.activities_tree.delete(i)

        if not self.current_user:
            return

        user_name = self.current_user.username
        all_cards = self.get_all_cards()

        # Filter for cards assigned to the current user or show all for admin
        if self.current_user.role == 'admin':
            user_cards = all_cards
        else:
            user_cards = [
                card_info for card_info in all_cards
                if user_name in card_info['card'].get('members', []) and
                not card_info['card'].get("is_archived", False)
            ]

        for card_info in user_cards:
            card = card_info['card']
            card_id = card.get('card_id')
            if not card_id:
                continue

            importance_tag = card.get("importance", "Normal")
            has_subtasks_indicator = "*" if card.get("subtasks") else ""

            # Insert the parent card, using its card_id as the iid and in the tags
            self.activities_tree.insert(
                "", "end",
                iid=card_id,
                values=("Tarefa", card['title'], has_subtasks_indicator),
                tags=(card_id, importance_tag)
            )

            # Add subtasks, also tagging them with the parent card_id
            if 'subtasks' in card:
                for subtask in card['subtasks']:
                    subtask_id = subtask.get('id')
                    if subtask_id:
                        self.activities_tree.insert(
                            card_id, "end",
                            iid=subtask_id,
                            values=("Subtarefa", subtask['text'], ""),
                            tags=(card_id,)
                        )

    def on_activity_double_click(self, event):
        item_id = self.activities_tree.identify_row(event.y)
        if not item_id:
            return

        item_type = self.activities_tree.item(item_id, "values")[0]
        if item_type == "Subtarefa":
            parent_id = self.activities_tree.parent(item_id)
            card = self.find_card_by_id(parent_id)
            subtask = self.find_subtask_by_id(card, item_id)
            if card and subtask:
                SubtaskEditorWindow(self.root, self, card, subtask)

    def on_activity_select(self, event):
        selected_item = self.activities_tree.selection()
        if not selected_item:
            return

        item_id = selected_item[0]
        card_id = self.activities_tree.item(item_id, "tags")[0]
        card_info = self.find_card_and_board_by_id(card_id)

        if not card_info:
            return

        card = card_info['card']

        # --- Clear and prepare the details view ---
        self.activity_desc_text.config(state="normal")
        self.activity_desc_text.delete("1.0", tk.END)
        self.activity_subtasks_text.config(state="normal")
        self.activity_subtasks_text.delete("1.0", tk.END)

        # --- Configure fonts ---
        bold_font = ("Helvetica", 9, "bold")
        normal_font = ("Helvetica", 9)

        # --- Populate details ---
        self.activity_due_date_label.config(text=card.get("due_date", "-"))
        self.activity_members_label.config(text=", ".join(card.get("members", [])) or "-")
        self.activity_dependencies_label.config(text=", ".join(card.get("dependencies", [])) or "-")

        self.activity_desc_text.insert("1.0", card.get("desc", "Sem descri√ß√£o."))

        # --- Populate Subtasks with formatting ---
        self.activity_subtasks_text.tag_configure("bold", font=bold_font)
        subtasks = card.get("subtasks", [])
        if not subtasks:
            self.activity_subtasks_text.insert("1.0", "Nenhuma subtarefa.")
        else:
            for subtask in subtasks:
                status = "[X]" if subtask.get('completed') else "[ ]"
                self.activity_subtasks_text.insert(tk.END, f"{status} ")
                self.activity_subtasks_text.insert(tk.END, f"{subtask.get('text', '')}\n", "bold")
                if subtask.get('desc'):
                    self.activity_subtasks_text.insert(tk.END, f"  - {subtask.get('desc')}\n")

        # --- Set text widgets to disabled ---
        self.activity_desc_text.config(state="disabled")
        self.activity_subtasks_text.config(state="disabled")

    def find_card_by_id(self, card_id):
        for board_name, lists in self.boodesk_data["boards"].items():
            if board_name == "workflow": continue
            for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if card.get('card_id') == card_id:
                        return card
        return None

    def find_subtask_by_id(self, card, subtask_id):
        if card and "subtasks" in card:
            for subtask in card["subtasks"]:
                if subtask.get("id") == subtask_id:
                    return subtask
        return None

    def go_to_board_from_activity(self):
        selected_item_id = self.activities_tree.selection()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione uma atividade para navegar.", parent=self.root)
            return

        item_id = selected_item_id[0]
        
        # If it's a subtask, get the parent card's ID
        parent_id = self.activities_tree.parent(item_id)
        if parent_id:
            item_id = parent_id

        card_info = self.find_card_and_board_by_id(item_id)
        if card_info:
            board_name = card_info["board_name"]
            
            # Find the index of the 'Quadros' tab in the main notebook
            boards_tab_index = -1
            for i, tab in enumerate(self.main_notebook.tabs()):
                if self.main_notebook.tab(i, "text") == 'Quadros':
                    boards_tab_index = i
                    break
            
            if boards_tab_index != -1:
                self.main_notebook.select(boards_tab_index)
                
                # Now find and select the specific board's tab
                for i, tab in enumerate(self.board_notebook.tabs()):
                    if self.board_notebook.tab(i, "text") == board_name:
                        self.board_notebook.select(i)
                        break

    def open_card_from_activity(self, event=None):
        selected_item_id = self.activities_tree.selection()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione uma atividade para abrir.", parent=self.root)
            return

        item_id = selected_item_id[0]
        tags = self.activities_tree.item(item_id, "tags")

        if not tags:
            messagebox.showerror("Erro", "O item selecionado n√£o tem um ID de cart√£o associado.", parent=self.root)
            return

        card_id = tags[0]  # The card_id is the first tag
        card_info = self.find_card_and_board_by_id(card_id)

        if card_info:
            CardWindow(self.root, self, card_info["board_name"], card_info["list_name"], card_info["card"], self.current_user)
        else:
            messagebox.showerror("Erro", f"Cart√£o com ID '{card_id}' n√£o encontrado. Pode ter sido movido ou removido.", parent=self.root)

    def find_card_and_board_by_id(self, card_id):
        for board_name, board_content in self.boodesk_data.get("boards", {}).items():
            if isinstance(board_content, dict):
                for list_name, cards in board_content.items():
                    if isinstance(cards, list):
                        for card in cards:
                            if card.get("card_id") == card_id:
                                return {"board_name": board_name, "list_name": list_name, "card": card}
        return None

    def create_history_tab(self, parent):
        history_frame = ttk.LabelFrame(parent, text="Hist√≥rico de Estudos")
        history_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.log_list = ttk.Treeview(history_frame, columns=("Data e Hora", "Assunto", "Dura√ß√£o (min)"), show="headings")
        self.log_list.heading("Data e Hora", text="Data e Hora")
        self.log_list.heading("Assunto", text="Assunto")
        self.log_list.heading("Dura√ß√£o (min)", text="Dura√ß√£o (min)")
        self.log_list.column("Data e Hora", width=200, anchor="center")
        self.log_list.column("Assunto", width=200, anchor="w")
        self.log_list.column("Dura√ß√£o (min)", width=150, anchor="center")
        scrollbar = ttk.Scrollbar(history_frame, orient="vertical", command=self.log_list.yview)
        self.log_list.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        self.log_list.pack(fill=tk.BOTH, expand=True)

    def on_card_select_treeview(self, board_name, list_name, event):
        """Handler para sele√ß√£o de cart√£o no treeview"""
        treeview = event.widget
        selection = treeview.selection()
        
        if selection:
            item = treeview.item(selection[0])
            card_id = item['tags'][0] if item['tags'] else None
            
            if card_id:
                # Find the card data
                for card in self.boodesk_data["boards"][board_name][list_name]:
                    if card.get('card_id') == card_id:
                        self.show_card_details(card)
                        break

    def get_boards_for_member(self, member_name):
        """Retorna apenas os quadros onde o membro participa de cards"""
        boards = []
        for board_name, board_data in self.boodesk_data['boards'].items():
            for list_name, cards in board_data.items():
                if list_name == 'workflow':  # Ignorar metadados
                    continue
                for card in cards:
                    if member_name in card.get('members', []):
                        boards.append(board_name)
                        break  # Uma vez encontrado, n√£o precisa verificar mais cards
        return list(set(boards))  # Remove duplicatas

    def _should_show_board_for_user(self, board_name, current_user_member):
        """Vers√£o melhorada do filtro de quadros - mostra apenas quadros relevantes ao membro"""
        try:
            # Administradores veem todos os quadros
            if hasattr(self, 'current_user') and getattr(self.current_user, 'role', None) == 'admin':
                return True
            
            # Se n√£o h√° membro associado, mostrar apenas quadros principais
            if not current_user_member:
                return board_name in ["Quadro Principal", "Quadro Geral"]
            
            # Verificar se o membro participa de algum card no quadro
            board_data = self.boodesk_data.get("boards", {}).get(board_name, {})
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                    if list_name == 'workflow':
                        continue
                    for card in cards:
                        if current_user_member in card.get('members', []):
                            return True
            
            # Quadros especiais sempre vis√≠veis
            if board_name in ["Quadro Principal", "Quadro Geral"]:
                return True
            
            return False
        except Exception as e:
            print(f"DEBUG: _should_show_board_for_user - Erro: {e}")
            # Em caso de erro, manter comportamento permissivo para n√£o ocultar quadros indevidamente
            return True

    # --- UI Population and Updates ---
    def populate_boards(self):
        print(f"DEBUG: populate_boards iniciado")
        print(f"DEBUG: boodesk_data['boards'] = {self.boodesk_data['boards']}")
        print(f"DEBUG: N√∫mero de quadros: {len(self.boodesk_data['boards'])}")
        
        try:
            selected_tab_index = self.board_notebook.index(self.board_notebook.select())
        except tk.TclError:
            selected_tab_index = 0

        for i in self.board_notebook.tabs():
            self.board_notebook.forget(i)

        self.listbox_refs = {} # Clear existing references

        # Garantir que pelo menos o Quadro Principal existe
        if not self.boodesk_data["boards"] or "Quadro Principal" not in self.boodesk_data["boards"]:
            print("DEBUG: Criando Quadro Principal padr√£o")
            self.boodesk_data["boards"]["Quadro Principal"] = {
                "A Fazer": [],
                "Em Progresso": [],
                "Conclu√≠do": []
            }

        importance_colors = self.settings["importance_colors"]
        
        # Obter o membro do usu√°rio atual (se m√©todo estiver dispon√≠vel)
        current_user_member = None
        try:
            if hasattr(self, '_get_current_user_member'):
                current_user_member = self._get_current_user_member()
            else:
                # Se o m√©todo n√£o existe, definir como None
                current_user_member = None
        except Exception as e:
            print(f"DEBUG: populate_boards - erro ao obter membro do usu√°rio: {e}")
            current_user_member = None
        print(f"DEBUG: populate_boards - Usu√°rio atual: {current_user_member}")

        print("DEBUG: Criando quadros na interface...")
        for board_name, lists in self.boodesk_data["boards"].items():
            print(f"DEBUG: Processando quadro: {board_name}")
            print(f"DEBUG: Tipo de lists: {type(lists)}")
            print(f"DEBUG: Conte√∫do de lists: {lists}")
            
            # Verificar se o quadro deve ser exibido para o usu√°rio atual
            should_show_board = self._should_show_board_for_user(board_name, current_user_member)
            print(f"DEBUG: populate_boards - Quadro '{board_name}' deve ser exibido: {should_show_board}")
            
            if not should_show_board:
                print(f"DEBUG: Quadro '{board_name}' n√£o ser√° exibido")
                continue
                
            print(f"DEBUG: Criando frame para quadro: {board_name}")
            board_frame = ttk.Frame(self.board_notebook, padding=5)
            self.board_notebook.add(board_frame, text=board_name)
            
            # Verificar se o quadro foi adicionado corretamente
            print(f"DEBUG: N√∫mero de abas ap√≥s adicionar '{board_name}': {len(self.board_notebook.tabs())}")

            list_management_frame = ttk.Frame(board_frame)
            list_management_frame.pack(fill=tk.X, pady=5)
            ttk.Button(list_management_frame, text="Adicionar Nova Lista", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_list, board_name)).pack(side=tk.LEFT)

            list_container = ttk.Frame(board_frame)
            list_container.pack(fill=tk.BOTH, expand=True)

            # Verificar se lists √© um dicion√°rio ou lista
            if isinstance(lists, dict):
                print(f"DEBUG: Lists √© um dicion√°rio com {len(lists)} listas")
                for list_name, cards in lists.items():
                    print(f"DEBUG: Processando lista: {list_name} com {len(cards)} cards")
                    list_frame = ttk.LabelFrame(list_container, text=list_name, padding=5)
                    list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)

                    # Context menu for list management
                    list_context_menu = tk.Menu(self.root, tearoff=0)
                    list_context_menu.add_command(label="Renomear Lista", image=self.icons.get('pencil_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.rename_list(b, l))
                    list_context_menu.add_command(label="Excluir Lista", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.delete_list(b, l))
                    list_context_menu.add_separator()
                    list_context_menu.add_command(label="Mover para Esquerda", image=self.icons.get('left_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.move_list(b, l, -1))
                    list_context_menu.add_command(label="Mover para Direita", image=self.icons.get('right_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.move_list(b, l, 1))
                    
                    # Bind right-click to the LabelFrame (list header)
                    list_frame.bind("<Button-3>", lambda event, menu=list_context_menu: menu.post(event.x_root, event.y_root))

                    treeview = ttk.Treeview(list_frame, columns=("Title", "Subject", "Due Date", "Importance"), show="headings")
                    treeview.heading("Title", text="T√≠tulo")
                    treeview.heading("Subject", text="Assunto")
                    treeview.heading("Due Date", text="Prazo")
                    treeview.heading("Importance", text="Import√¢ncia")

                    treeview.column("Title", width=150, anchor="w")
                    treeview.column("Subject", width=100, anchor="w")
                    treeview.column("Due Date", width=100, anchor="center")
                    treeview.column("Importance", width=80, anchor="center")

                    treeview.pack(fill=tk.BOTH, expand=True, pady=5)
                    DraggableTreeview(treeview, self, board_name, list_name) # Enable drag-and-drop for Treeview
                    treeview.bind("<Double-1>", self.open_card_details) # Double-click to open card details
                    treeview.bind("<Button-3>", partial(self.show_card_context_menu, board_name, list_name)) # Right-click for card context menu
                    treeview.bind("<Key>", partial(self.handle_card_key_press, board_name, list_name)) # Keyboard shortcuts
                    treeview.bind("<<TreeviewSelect>>", partial(self.on_card_select_treeview, board_name, list_name)) # New binding for click-to-expand

                    # Store reference to treeview for target identification
                    self.listbox_refs[(board_name, list_name)] = treeview

                    # Apply filters
                    filtered_cards = []
                    filter_subject = self.filter_subject_var.get()
                    filter_goal = self.filter_goal_var.get()
                    filter_member = self.filter_member_var.get()
                    filter_due_date = self.filter_due_date_var.get()
                    filter_importance = self.filter_importance_var.get()
                    filter_recurrence = self.filter_recurrence_var.get()
                    filter_keyword = self.filter_keyword_var.get().lower()

                    # Get current user's member name for filtering
                    try:
                        if hasattr(self, '_get_current_user_member'):
                            current_user_member = self._get_current_user_member()
                        else:
                            current_user_member = None
                    except Exception as e:
                        print(f"DEBUG: Erro ao obter membro do usu√°rio para filtro: {e}")
                        current_user_member = None

                    for card in cards:
                        match = True

                        # User-Member filter - show only cards where current user is a member
                        # MODIFICA√á√ÉO: Tornar o filtro menos restritivo para evitar tela em branco
                        if current_user_member and getattr(self.current_user, 'role', None) != 'admin':
                            card_members = card.get('members', [])
                            # Se o cart√£o n√£o tem membros, mostrar para todos
                            if card_members and current_user_member not in card_members:
                                match = False

                        # Keyword filter
                        if match and filter_keyword:
                            card_title_lower = card.get('title', '').lower()
                            card_desc_lower = card.get('desc', '').lower()
                            if filter_keyword not in card_title_lower and filter_keyword not in card_desc_lower:
                                match = False

                        # Subject filter - only apply if filter is not empty
                        if match and filter_subject and filter_subject != "Todos" and card.get('subject') != filter_subject:
                            match = False
                        
                        # Goal filter - only apply if filter is not empty
                        if match and filter_goal and filter_goal != "Todos" and card.get('goal') != filter_goal:
                            match = False

                        # Member filter - only apply if filter is not empty
                        if match and filter_member and filter_member.lower() != "todos":
                            card_members = [m.lower() for m in card.get('members', [])]
                            if filter_member.lower() not in card_members:
                                match = False

                        # Due Date filter - only apply if filter is not empty
                        if match and filter_due_date and filter_due_date != "Todos":
                            if not self._filter_due_date(card.get('due_date', ''), filter_due_date):
                                match = False

                        # Importance filter - only apply if filter is not empty
                        if match and filter_importance and filter_importance != "Todos" and card.get('importance') != filter_importance:
                            match = False

                        # Recurrence filter - only apply if filter is not empty
                        if match and filter_recurrence and filter_recurrence != "Todos" and card.get('recurrence', 'Nenhuma') != filter_recurrence:
                            match = False

                        if match:
                            filtered_cards.append(card)

                    for card in filtered_cards: # Iterate directly over filtered_cards
                        if card.get('is_archived', False): # Skip archived cards
                            continue

                        title = card['title']
                        subject = card.get('subject', '-')
                        due_date = card.get('due_date', '')
                        importance = card.get('importance', 'Normal')
                        card_id = card.get('card_id') # Get the unique card ID for tagging

                        # Insert main card row
                        item_id = treeview.insert("", "end", values=(title, subject, due_date, importance), tags=(card_id,))
                        
                        # Apply background color based on importance
                        bg_color = importance_colors.get(importance, "white")
                        dependencies = card.get('dependencies', [])
                        if dependencies and not self.can_start_card(card):
                            # Adjust color for cards with unfulfilled dependencies
                            if bg_color == "white": bg_color = "#f0f0f0"
                            elif bg_color == "#ffcccc": bg_color = "#ffb3b3"
                            elif bg_color == "#ffffcc": bg_color = "#ffffb3"
                            elif bg_color == "#ccffcc": bg_color = "#b3ffb3"
                        
                        treeview.tag_configure(card_id, background=bg_color)
                        treeview.item(item_id, tags=(card_id,)) # Apply the tag to the item

                    treeview.filtered_cards = filtered_cards

                    card_management_frame = ttk.Frame(list_frame)
                    card_management_frame.pack(fill=tk.X, pady=5)
                    ttk.Button(card_management_frame, text="Adicionar Cart√£o", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_card, board_name, list_name)).pack(side=tk.LEFT, expand=True, fill=tk.X, padx=2)
            elif isinstance(lists, list):
                print(f"DEBUG: Lists √© uma lista (workflow) com {len(lists)} itens: {lists}")
                # Pular quadros que s√£o listas (como workflow)
                continue
            else:
                print(f"DEBUG: Tipo inesperado para lists: {type(lists)}")
                continue

        # Verificar se h√° quadros vis√≠veis
        if not self.board_notebook.tabs():
            print("DEBUG: Nenhum quadro vis√≠vel - criando quadro padr√£o")
            # Criar um quadro padr√£o se nenhum estiver vis√≠vel
            default_board_frame = ttk.Frame(self.board_notebook, padding=5)
            self.board_notebook.add(default_board_frame, text="Quadro Principal")
            
            list_management_frame = ttk.Frame(default_board_frame)
            list_management_frame.pack(fill=tk.X, pady=5)
            ttk.Button(list_management_frame, text="Adicionar Nova Lista", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_list, "Quadro Principal")).pack(side=tk.LEFT)
            
            # Criar as listas padr√£o no quadro
            list_container = ttk.Frame(default_board_frame)
            list_container.pack(fill=tk.BOTH, expand=True)
            
            # Criar as tr√™s listas padr√£o
            for list_name in ["A Fazer", "Em Progresso", "Conclu√≠do"]:
                list_frame = ttk.LabelFrame(list_container, text=list_name, padding=5)
                list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
                
                treeview = ttk.Treeview(list_frame, columns=("Title", "Subject", "Due Date", "Importance"), show="headings")
                treeview.heading("Title", text="T√≠tulo")
                treeview.heading("Subject", text="Assunto")
                treeview.heading("Due Date", text="Prazo")
                treeview.heading("Importance", text="Import√¢ncia")
                
                treeview.column("Title", width=150, anchor="w")
                treeview.column("Subject", width=100, anchor="w")
                treeview.column("Due Date", width=100, anchor="center")
                treeview.column("Importance", width=80, anchor="center")
                
                treeview.pack(fill=tk.BOTH, expand=True, pady=5)
                self.listbox_refs[("Quadro Principal", list_name)] = treeview
                
                card_management_frame = ttk.Frame(list_frame)
                card_management_frame.pack(fill=tk.X, pady=5)
                ttk.Button(card_management_frame, text="Adicionar Cart√£o", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_card, "Quadro Principal", list_name)).pack(side=tk.LEFT, expand=True, fill=tk.X, padx=2)
            
            # Garantir que o Quadro Principal existe nos dados
            if "Quadro Principal" not in self.boodesk_data['boards']:
                self.boodesk_data['boards']["Quadro Principal"] = {
                    "A Fazer": [],
                    "Em Progresso": [],
                    "Conclu√≠do": []
                }
        
        if self.board_notebook.tabs():
            if selected_tab_index < len(self.board_notebook.tabs()):
                self.board_notebook.select(selected_tab_index)
            else:
                self.board_notebook.select(0)
        self.update_gantt_chart()

    def show_card_context_menu(self, board_name, list_name, event):
        treeview = event.widget
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return

        # Get the card_id from the tags of the selected item
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object and its index in the boodesk_data structure
        card_index = -1
        for i, card in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if card.get('card_id') == card_id:
                card_index = i
                break

        if card_index == -1:
            return

        card_context_menu = tk.Menu(self.root, tearoff=0)
        card_context_menu.add_command(label="Abrir Detalhes do Cart√£o", image=self.icons.get('info_icon'), compound=tk.LEFT, command=partial(self.open_card_details_from_context, board_name, list_name, card_index))
        card_context_menu.add_command(label="Arquivar Cart√£o", image=self.icons.get('folder_icon'), compound=tk.LEFT, command=partial(self.archive_card_from_context, board_name, list_name, treeview, card_index))
        card_context_menu.add_command(label="Excluir Cart√£o (Permanente)", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=partial(self.delete_card_permanently_from_context, board_name, list_name, treeview, card_index))
        card_context_menu.post(event.x_root, event.y_root)

    def handle_card_key_press(self, board_name, list_name, event):
        """Handle keyboard shortcuts for cards"""
        treeview = event.widget
        selected_item_id = treeview.focus()
        
        if not selected_item_id:
            return

        card_id = treeview.item(selected_item_id, "tags")[0]
        card_index = -1
        for i, card in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if card.get('card_id') == card_id:
                card_index = i
                break

        if card_index == -1:
            return
            
        if event.keysym == 'Delete':
            # Delete key pressed - delete the selected card
            self.delete_card_permanently_from_context(board_name, list_name, treeview, card_index)
        elif event.keysym == 'Return':
            # Enter key pressed - open card details
            self.open_card_details_from_context(board_name, list_name, card_index)

    def open_card_details_from_context(self, board_name, list_name, card_index):
        # Get the card_id from the actual card object
        card_to_open = self.boodesk_data["boards"][board_name][list_name][card_index]
        card_id = card_to_open.get('card_id')
        if card_id:
            CardWindow(self.root, self, board_name, list_name, card_id, self.current_user)
        else:
            messagebox.showerror("Erro", "N√£o foi poss√≠vel abrir os detalhes do cart√£o: ID do cart√£o n√£o encontrado.")

    def open_archived_cards_window(self):
        ArchivedCardsWindow(self.root, self)

    def archive_card_from_context(self, board_name, list_name, treeview, card_index):
        # Get the card_id from the tags of the selected item
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object using its card_id
        card_to_archive = None
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card.get('card_id') == card_id:
                card_to_archive = card
                break
        
        if not card_to_archive:
            messagebox.showerror("Erro", "Cart√£o n√£o encontrado.")
            return

        card_title = card_to_archive['title']
        if messagebox.askyesno("Confirmar Arquivamento", f"Tem certeza que deseja arquivar o cart√£o '{card_title}'?", parent=self.root):
            card_to_archive['is_archived'] = True
            self.save_trello_data()
            self.populate_boards()
            messagebox.showinfo("Cart√£o Arquivado", f"O cart√£o '{card_title}' foi arquivado.")

    def delete_card_permanently_from_context(self, board_name, list_name, treeview, card_index):
        # Get the card_id from the tags of the selected item
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object using its card_id
        card_to_delete = None
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card.get('card_id') == card_id:
                card_to_delete = card
                break
        
        if not card_to_delete:
            messagebox.showerror("Erro", "Cart√£o n√£o encontrado.")
            return

        card_title = card_to_delete['title']
        if messagebox.askyesno("Confirmar Exclus√£o Permanente", f"Tem certeza que deseja EXCLUIR PERMANENTEMENTE o cart√£o '{card_title}'? Esta a√ß√£o n√£o pode ser desfeita.", parent=self.root):
            # Remove the card from the data structure by card_id
            self.boodesk_data["boards"][board_name][list_name] = [
                card for card in self.boodesk_data["boards"][board_name][list_name] if card.get('card_id') != card_id
            ]
            self.save_trello_data()
            self.populate_boards()

    def update_pomodoro_task_list(self):
        for i in self.pomodoro_task_list.get_children():
            self.pomodoro_task_list.delete(i)
        for index, row in self.pomodoro_tasks_df.iterrows():
            self.pomodoro_task_list.insert("", "end", values=(row["Tarefa"], row["Status"], row["Assunto"], row["Objetivo"]))
        self.update_pomodoro_stats()

    def update_pomodoro_stats(self):
        completed = len(self.pomodoro_tasks_df[self.pomodoro_tasks_df['Status'] == 'Conclu√≠do'])
        pending = len(self.pomodoro_tasks_df[self.pomodoro_tasks_df['Status'] == 'Pendente'])
        self.pomodoro_completed_label.config(text=f"Conclu√≠das: {completed}")
        self.pomodoro_pending_label.config(text=f"Pendentes: {pending}")

    def update_timer_display(self):
        display_seconds = self.time_left if self.time_left > 0 else self.get_current_time_setting() * 60
        # Garantir que display_seconds seja um n√∫mero
        if isinstance(display_seconds, str):
            try:
                display_seconds = int(display_seconds)
            except:
                display_seconds = 0
        minutes, secs = divmod(display_seconds, 60)
        text = f"{minutes:02d}:{secs:02d}"
        self.pomodoro_timer_label.config(text=text)
        self.pomodoro_cycle_label.config(text=f"Ciclo: {self.current_cycle}/{self.settings['cycles']}")

    def get_current_time_setting(self):
        if self.on_break:
            return self.settings['short_break'] if self.current_cycle % self.settings['cycles'] != 0 else self.settings['long_break']
        return self.settings['pomodoro']

    def on_pomodoro_task_select(self, event):
        selected_item = self.pomodoro_task_list.selection()
        if not selected_item:
            return
        
        task_name = self.pomodoro_task_list.item(selected_item, "values")[0]
        task_details = self.pomodoro_tasks_df[self.pomodoro_tasks_df['Tarefa'] == task_name].iloc[0].to_dict()
        self.active_pomodoro_task = {"source": "pomodoro_list", "details": task_details}

    def open_card_details(self, event):
        """Abre a janela de detalhes do cart√£o quando o usu√°rio faz duplo clique"""
        treeview = event.widget
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return

        board_name = self.board_notebook.tab(self.board_notebook.select(), "text")
        list_name = treeview.master.cget("text")
        
        # Get the card_id from the tags of the selected item
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object and its index in the boodesk_data structure
        card_index = -1
        for i, card in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if card.get('card_id') == card_id:
                card_index = i
                break

        if card_index != -1:
            CardWindow(self.root, self, board_name, list_name, card_id, self.current_user)

    def start_pomodoro_from_card(self, board_name, list_name, card_id):
        card = None
        for c in self.boodesk_data["boards"][board_name][list_name]:
            if c.get('card_id') == card_id:
                card = c
                break
        
        if not card:
            messagebox.showerror("Erro", "Cart√£o n√£o encontrado para iniciar Pomodoro.")
            return

        self.active_pomodoro_task = {"source": "boodesk", "details": card}
        messagebox.showinfo("Pomodoro Iniciado", f"Timer iniciado para a tarefa: {card['title']}")
        self.main_notebook.select(1) # Seleciona a aba Pomodoro
        self.pomodoro_notebook.select(0) # Seleciona a sub-aba Timer Pomodoro
        self.start_timer()

    def start_timer(self):
        if not self.active_pomodoro_task:
            messagebox.showwarning("Nenhuma Tarefa", "Selecione uma tarefa na lista de Pomodoro ou inicie a partir de um cart√£o Trello.")
            return
        if self.timer_running:
            return
        self.timer_running = True
        self.start_button.config(state=tk.DISABLED)
        self.pause_button.config(state=tk.NORMAL)
        self.reset_button.config(state=tk.NORMAL)
        self.skip_button.config(state=tk.NORMAL)
        if self.time_left == 0:
            self.time_left = self.get_current_time_setting() * 60
        self.countdown(self.time_left)

    def pause_timer(self):
        if not self.timer_running:
            return
        self.timer_running = False
        self.start_button.config(state=tk.NORMAL)
        self.pause_button.config(state=tk.DISABLED)
        if self.timer_id:
            self.root.after_cancel(self.timer_id)

    def reset_timer(self):
        if self.timer_id:
            self.root.after_cancel(self.timer_id)
        self.timer_running = False
        self.current_cycle = 0
        self.on_break = False
        self.time_left = 0
        self.update_timer_display()
        self.start_button.config(state=tk.NORMAL)
        self.pause_button.config(state=tk.DISABLED)
        self.reset_button.config(state=tk.DISABLED)
        self.skip_button.config(state=tk.DISABLED)

    def skip_cycle(self):
        if self.timer_id:
            self.root.after_cancel(self.timer_id)
        self.timer_running = False
        self.time_left = 0
        self.handle_cycle_completion()

    def countdown(self, seconds):
        if not self.timer_running:
            return
        self.time_left = seconds
        if seconds >= 0:
            minutes, secs = divmod(seconds, 60)
            self.pomodoro_timer_label.config(text=f"{minutes:02d}:{secs:02d}")
            self.timer_id = self.root.after(1000, self.countdown, seconds - 1)
        else:
            winsound.Beep(1000, 500)
            self.handle_cycle_completion()

    def handle_cycle_completion(self):
        if not self.on_break:
            self.current_cycle += 1
            self.log_pomodoro()
            if self.current_cycle % self.settings['cycles'] == 0:
                self.on_break = True
                messagebox.showinfo("Pausa Longa", "Pausa longa! Bom descanso.")
            else:
                self.on_break = True
                messagebox.showinfo("Pausa Curta", "Pausa curta! Respire fundo.")
        else:
            self.on_break = False
            messagebox.showinfo("Fim da Pausa", "Fim da pausa. Hora de voltar ao foco!")

        self.time_left = 0
        self.update_timer_display()
        self.start_timer()

    def log_pomodoro(self):
        if not self.active_pomodoro_task:
            return
        
        task_details = self.active_pomodoro_task['details']
        new_log = pd.DataFrame({
            'Data e Hora': [datetime.now().strftime('%Y-%m-%d %H:%M:%S')],
            'Assunto': [task_details.get('subject', task_details.get('Assunto', '-'))],
            'Dura√ß√£o (min)': [self.settings['pomodoro']]
        })
        self.log_df = pd.concat([self.log_df, new_log], ignore_index=True)
        self.save_log()
        self.update_log()

    def update_log(self):
        for i in self.log_list.get_children():
            self.log_list.delete(i)
        for index, row in self.log_df.iterrows():
            self.log_list.insert("", "end", values=(row["Data e Hora"], row["Assunto"], row["Dura√ß√£o (min)"]))

    # --- Board, List, and Card Management Logic ---
    def add_board(self):
        new_board_name = simpledialog.askstring("Novo Quadro", "Digite o nome do novo quadro:", parent=self.root)
        if new_board_name:
            try:
                # Get current user ID
                user_id = self.get_current_user_id()
                if not user_id:
                    messagebox.showerror("Erro", "Usu√°rio n√£o identificado. Fa√ßa login novamente.", parent=self.root)
                    return
                
                # Check if board already exists for this user
                existing_boards = self.db.get_boards(user_id)
                board_names = [board['name'] for board in existing_boards]
                
                if new_board_name in board_names:
                    messagebox.showwarning("Erro", "Um quadro com este nome j√° existe.", parent=self.root)
                    return
                
                # Create board in database
                board_id = self.db.create_board(new_board_name, owner_id=user_id)
                
                if board_id:
                    # Reload data and update display
                    self.load_trello_data()
                    self.populate_boards()
                    
                    # Select the new board
                    try:
                        self.board_notebook.select(len(self.board_notebook.tabs()) - 1)
                    except:
                        pass
                    
                    messagebox.showinfo("Sucesso", f"Quadro '{new_board_name}' criado com sucesso!", parent=self.root)
                else:
                    messagebox.showerror("Erro", "N√£o foi poss√≠vel criar o quadro.", parent=self.root)
                    
            except Exception as e:
                print(f"Erro ao criar quadro: {e}")
                messagebox.showerror("Erro", f"N√£o foi poss√≠vel criar o quadro: {e}", parent=self.root)

    def rename_board(self, old_name):
        new_name = simpledialog.askstring("Renomear Quadro", f"Digite o novo nome para '{old_name}':", parent=self.root)
        
        if new_name and new_name != old_name:
            try:
                # Get current user ID
                user_id = self.get_current_user_id()
                if not user_id:
                    messagebox.showerror("Erro", "Usu√°rio n√£o identificado. Fa√ßa login novamente.", parent=self.root)
                    return
                
                # Check if new name already exists for this user
                existing_boards = self.db.get_boards(user_id)
                board_names = [board['name'] for board in existing_boards]
                
                if new_name in board_names:
                    messagebox.showwarning("Erro", "Um quadro com este nome j√° existe.", parent=self.root)
                    return
                
                # Get board ID
                board_id = self.get_board_id_by_name(old_name)
                if not board_id:
                    messagebox.showerror("Erro", f"Quadro '{old_name}' n√£o encontrado.", parent=self.root)
                    return
                
                # Update board name in database
                self.db.update_board(board_id, new_name, "", "")
                success = True
                
                if success:
                    # Reload data and update display
                    self.load_trello_data()
                    self.populate_boards()
                    messagebox.showinfo("Sucesso", f"Quadro renomeado para '{new_name}'!", parent=self.root)
                else:
                    messagebox.showerror("Erro", "N√£o foi poss√≠vel renomear o quadro.", parent=self.root)
                    
            except Exception as e:
                print(f"Erro ao renomear quadro: {e}")
                messagebox.showerror("Erro", f"N√£o foi poss√≠vel renomear o quadro: {e}", parent=self.root)
        elif new_name:
            messagebox.showwarning("Erro", "N√£o foi poss√≠vel renomear. Verifique se o nome j√° existe ou √© inv√°lido.", parent=self.root)

    def delete_board(self, board_name):
        if messagebox.askyesno("Confirmar Exclus√£o", f"Tem certeza que deseja excluir o quadro '{board_name}' e todos os seus conte√∫dos?", parent=self.root):
            try:
                # Get board ID
                board_id = self.get_board_id_by_name(board_name)
                if not board_id:
                    messagebox.showerror("Erro", f"Quadro '{board_name}' n√£o encontrado.", parent=self.root)
                    return
                
                # Delete board from database (this will also delete all cards)
                self.db.delete_board(board_id)
                success = True
                
                if success:
                    # Reload data and update display
                    self.load_trello_data()
                    self.populate_boards()
                    messagebox.showinfo("Sucesso", f"Quadro '{board_name}' exclu√≠do com sucesso!", parent=self.root)
                else:
                    messagebox.showerror("Erro", "N√£o foi poss√≠vel excluir o quadro.", parent=self.root)
                    
            except Exception as e:
                print(f"Erro ao excluir quadro: {e}")
                messagebox.showerror("Erro", f"N√£o foi poss√≠vel excluir o quadro: {e}", parent=self.root)

    def add_list(self, board_name):
        new_list_name = simpledialog.askstring("Nova Lista", "Digite o nome da nova lista:", parent=self.root)
        if new_list_name and new_list_name not in self.boodesk_data["boards"][board_name]:
            self.boodesk_data["boards"][board_name][new_list_name] = []
            self.save_trello_data()
            self.populate_boards()
        elif new_list_name:
            messagebox.showwarning("Erro", "Uma lista com este nome j√° existe neste quadro.", parent=self.root)

    def rename_list(self, board_name, old_list_name):
        new_list_name = simpledialog.askstring("Renomear Lista", f"Digite o novo nome para '{old_list_name}':", parent=self.root)
        if new_list_name and new_list_name != old_list_name and new_list_name not in self.boodesk_data["boards"][board_name]:
            # Recreate the dictionary with the new key in the same position
            new_lists = {}
            for name, cards in self.boodesk_data["boards"][board_name].items():
                if name == old_list_name:
                    new_lists[new_list_name] = cards
                else:
                    new_lists[name] = cards
            self.boodesk_data["boards"][board_name] = new_lists
            self.save_trello_data()
            self.populate_boards()
        elif new_list_name:
            messagebox.showwarning("Erro", "N√£o foi poss√≠vel renomear. Verifique se o nome j√° existe ou √© inv√°lido.", parent=self.root)

    def delete_list(self, board_name, list_name):
        if messagebox.askyesno("Confirmar Exclus√£o", f"Tem certeza que deseja excluir a lista '{list_name}' e todos os seus cart√µes?", parent=self.root):
            del self.boodesk_data["boards"][board_name][list_name]
            self.save_trello_data()
            self.populate_boards()

    def move_list(self, board_name, list_name, direction):
        lists = list(self.boodesk_data["boards"][board_name].keys())
        try:
            current_index = lists.index(list_name)
        except ValueError:
            return

        new_index = current_index + direction
        if 0 <= new_index < len(lists):
            lists.insert(new_index, lists.pop(current_index))
            reordered_lists = {name: self.boodesk_data["boards"][board_name][name] for name in lists}
            self.boodesk_data["boards"][board_name] = reordered_lists
            self.save_trello_data()
            self.populate_boards()

    def add_card(self, board_name, list_name):
        card_title = simpledialog.askstring("Novo Cart√£o", "Digite o t√≠tulo do novo cart√£o:", parent=self.root)
        if card_title and card_title.strip(): # Ensure title is not empty or just whitespace
            try:
                # Get current user ID
                user_id = self.get_current_user_id()
                if not user_id:
                    messagebox.showerror("Erro", "Usu√°rio n√£o identificado. Fa√ßa login novamente.", parent=self.root)
                    return
                
                # Get board ID
                board_id = self.get_board_id_by_name(board_name)
                if not board_id:
                    messagebox.showerror("Erro", f"Quadro '{board_name}' n√£o encontrado.", parent=self.root)
                    return
                
                # Create card in database
                card_id = self.db.create_card(
                    board_id=board_id,
                    list_name=list_name,
                    title=card_title,
                    description="",
                    status='to_do',
                    importance='Normal',
                    due_date="",
                    subject="-",
                    goal="-",
                    members=[],
                    git_branch="",
                    git_commit="",
                    recurrence="Nenhuma",
                    dependencies=[],
                    user_id=user_id
                )
                
                if card_id:
                    # Reload data and update display
                    self.load_trello_data()
                    self.populate_boards()
                    
                    # Email notification for card creation
                    if hasattr(self, 'email_integration'):
                        card_data = {
                            "title": card_title,
                            "board": board_name,
                            "column": list_name,
                            "created_by": self.current_user.username,
                            "created_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                            "importance": "Normal",
                            "due_date": ""
                        }
                        self.email_integration.notify_card_created(card_data)
                    
                    # Open card window - the CardWindow will handle finding the card
                    CardWindow(self.root, self, board_name, list_name, card_id, self.current_user,
                               callback_on_close=partial(self.handle_card_window_closed, board_name, list_name, card_id))
                else:
                    messagebox.showerror("Erro", "N√£o foi poss√≠vel criar o cart√£o.", parent=self.root)
                    
            except Exception as e:
                print(f"Erro ao criar cart√£o: {e}")
                # Fallback para board_id se o m√©todo n√£o funcionar
                try:
                    board_id = 1  # Fallback padr√£o
                    print(f"DEBUG: Usando board_id fallback: {board_id}")
                    
                    # Create card in database with fallback
                    card_id = self.db.create_card(
                        board_id=board_id,
                        list_name=list_name,
                        title=card_title,
                        description="",
                        status='to_do',
                        importance='Normal',
                        due_date="",
                        subject="-",
                        goal="-",
                        members=[],
                        git_branch="",
                        git_commit="",
                        recurrence="Nenhuma",
                        dependencies=[],
                        user_id=user_id
                    )
                    
                    if card_id:
                        # Reload data and update display
                        self.load_trello_data()
                        self.populate_boards()
                        
                        # Open card window
                        CardWindow(self.root, self, board_name, list_name, card_id, self.current_user,
                                   callback_on_close=partial(self.handle_card_window_closed, board_name, list_name, card_id))
                    else:
                        messagebox.showerror("Erro", "N√£o foi poss√≠vel criar o cart√£o.", parent=self.root)
                        
                except Exception as fallback_error:
                    print(f"Erro no fallback: {fallback_error}")
                    messagebox.showerror("Erro", f"N√£o foi poss√≠vel criar o cart√£o: {e}", parent=self.root)

    def delete_card(self, board_name, list_name, treeview):
        selected_item_id = treeview.focus()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um cart√£o para excluir.", parent=self.root)
            return
        
        card_id = treeview.item(selected_item_id, "tags")[0]
        card_title = treeview.item(selected_item_id, "values")[0]

        if messagebox.askyesno("Confirmar Exclus√£o", f"Tem certeza que deseja excluir o cart√£o '{card_title}'?", parent=self.root):
            # Remove the card from the data structure by card_id
            self.boodesk_data["boards"][board_name][list_name] = [
                card for card in self.boodesk_data["boards"][board_name][list_name] if card.get('card_id') != card_id
            ]
            self.save_trello_data()
            self.populate_boards()

    def move_card_data(self, source_board, source_list, card_id, target_board, target_list):
        # Find the card to move using its card_id
        card_to_move = None
        source_list_data = self.boodesk_data["boards"][source_board][source_list]
        for i, card in enumerate(source_list_data):
            if card.get('card_id') == card_id:
                card_to_move = source_list_data.pop(i)
                break

        if not card_to_move:
            messagebox.showerror("Erro", "Cart√£o n√£o encontrado para mover.")
            return

        # Verificar se est√° tentando mover para "Conclu√≠do" e se h√° subtarefas pendentes
        if target_list == "Conclu√≠do":
            subtasks = card_to_move.get('subtasks', [])
            if subtasks:
                uncompleted_subtasks = [subtask for subtask in subtasks if not subtask['completed']]
                if uncompleted_subtasks:
                    uncompleted_text = "\n".join([f"‚Ä¢ {subtask['text']}" for subtask in uncompleted_subtasks])
                    messagebox.showwarning(
                        "Subtarefas Pendentes", 
                        f"N√£o √© poss√≠vel mover o cart√£o '{card_to_move['title']}' para 'Conclu√≠do' porque ainda existem subtarefas pendentes:\n\n{uncompleted_text}\n\nConclua todas as subtarefas antes de mover o cart√£o para 'Conclu√≠do'."
                    )
                    # If not moved, put the card back in the source list
                    source_list_data.insert(i, card_to_move) 
                    return
        
        # Add card to target
        self.boodesk_data["boards"][target_board][target_list].append(card_to_move)

        # Log the move in card history
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        user_name = self.current_user.username if self.current_user else "Sistema"
        card_to_move.setdefault('history', []).append({
            "timestamp": current_time,
            "action": f"Cart√£o movido de '{source_list}' para '{target_list}' no quadro '{source_board}' por {user_name}.",
            "user": user_name
        })

        # Email notification for card movement
        if hasattr(self, 'email_integration'):
            card_data = {
                "title": card_to_move.get("title", "Sem t√≠tulo"),
                "board": target_board,
                "column": target_list,
                "modified_by": user_name,
                "modified_date": current_time
            }
            changes = [f"Cart√£o movido de '{source_list}' para '{target_list}'"]
            self.email_integration.notify_card_modified(card_data, changes)

        self.save_trello_data()
        self.populate_boards()

    def handle_card_window_closed(self, board_name, list_name, card_id, saved=False):
        if not saved:
            # If the card window was closed without saving, and it was a new card,
            # remove the card that was just added to the data model.
            # This prevents empty cards from appearing if the user cancels creation.
            current_list_cards = self.boodesk_data["boards"][board_name][list_name]
            card_to_remove_index = -1
            for i, card in enumerate(current_list_cards):
                if card.get('card_id') == card_id:
                    card_to_remove_index = i
                    break

            if card_to_remove_index != -1:
                # Only remove if it's a newly added card that wasn't saved
                # and still has the default/empty title.
                if current_list_cards[card_to_remove_index].get('title') == "" or \
                   current_list_cards[card_to_remove_index].get('title') == "Sua primeira tarefa Trello":
                    self.boodesk_data["boards"][board_name][list_name].pop(card_to_remove_index)
                    self.save_trello_data()
        else:
            # Se o card foi salvo, verificar se precisa sincronizar com Google Calendar
            if self.settings.get('google_calendar_enabled', False):
                # Encontrar o card salvo
                for card in self.boodesk_data["boards"][board_name][list_name]:
                    if card.get('card_id') == card_id:
                        # Verificar se tem data de vencimento
                        if card.get('due_date'):
                            # Sincronizar com Google Calendar
                            self._sync_new_card_to_calendar(card, board_name, list_name)
                        break
        
        self.populate_boards() # Always repopulate to reflect changes or removals

    def _sync_new_card_to_calendar(self, card, board_name, list_name):
        """Sincroniza um card rec√©m-criado com o Google Calendar"""
        try:
            # Verificar se o Google Calendar est√° configurado
            if not hasattr(self, 'google_calendar') or not self.google_calendar.is_authenticated:
                print("Google Calendar n√£o est√° autenticado")
                return
            
            # Verificar se h√° data de vencimento
            if not card.get('due_date'):
                print("Card n√£o possui data de vencimento")
                return
            
            # Usar fun√ß√£o auxiliar para processar data brasileira
            event_datetime = self.parse_brazilian_date(card['due_date'])
            
            if not event_datetime:
                print(f"Formato de data inv√°lido: {card['due_date']}")
                return
            
            # Criar evento no Google Calendar
            event_title = f"üìã {card['title']}"
            event_description = f"""
Card: {card['title']}
Descri√ß√£o: {card.get('desc', 'Sem descri√ß√£o')}
Import√¢ncia: {card.get('importance', 'Normal')}
Assunto: {card.get('subject', '-')}
Objetivo: {card.get('goal', '-')}
Membros: {', '.join(card.get('members', []))}
Board: {board_name}
Lista: {list_name}
Card ID: {card.get('card_id', '')}
            """.strip()
            
            # Definir dura√ß√£o do evento (1 hora por padr√£o)
            event_duration = timedelta(hours=1)
            
            # Coletar emails para o evento
            attendees = []
            
            # Adicionar emails padr√£o se habilitado
            calendar_settings = self.settings.get('calendar_integration', {})
            if calendar_settings.get('include_default_emails', True):
                default_emails = calendar_settings.get('default_emails', [])
                attendees.extend(default_emails)
            
            # Adicionar membros do card se habilitado
            if calendar_settings.get('include_card_members', True):
                card_members = card.get('members', [])
                for member in card_members:
                    # Buscar email do membro no arquivo de membros
                    member_email = self._get_member_email(member)
                    if member_email:
                        attendees.append(member_email)
            
            # Remover duplicatas
            attendees = list(set(attendees))
            
            # Criar evento
            success = self.google_calendar.create_event(
                title=event_title,
                description=event_description,
                start_datetime=event_datetime,
                duration=event_duration,
                card_id=card.get('card_id', ''),
                attendees=attendees if attendees else None
            )
            
            if success:
                print(f"‚úÖ Evento criado no Google Calendar para o card rec√©m-criado: {card['title']}")
                # Adicionar ao hist√≥rico do card
                card.setdefault('history', []).append({
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "action": f"Evento criado no Google Calendar",
                    "user": self.current_user.username if self.current_user else "Sistema"
                })
                # Salvar dados atualizados
                self.save_trello_data()
            else:
                print(f"‚ùå Erro ao criar evento no Google Calendar para o card: {card['title']}")
                
        except Exception as e:
            print(f"‚ùå Erro na sincroniza√ß√£o com Google Calendar: {e}")
            import traceback
            traceback.print_exc()

    def _get_member_email(self, member_name):
        """Busca o email de um membro no arquivo de membros"""
        try:
            if hasattr(self, 'members') and self.members:
                print(f"DEBUG: Buscando email para membro '{member_name}'")
                print(f"DEBUG: Total de membros carregados: {len(self.members)}")
                for member in self.members:
                    print(f"DEBUG: Verificando membro: {member}")
                    if member.get('Membro') == member_name:
                        email = member.get('email', '')
                        print(f"DEBUG: Email encontrado para '{member_name}': {email}")
                        return email
                print(f"DEBUG: Membro '{member_name}' n√£o encontrado")
            else:
                print(f"DEBUG: Lista de membros n√£o dispon√≠vel ou vazia")
            return None
        except Exception as e:
            print(f"Erro ao buscar email do membro {member_name}: {e}")
            return None

    def _is_card_completed(self, card_full_title):
        # card_full_title format: "Board Name > List Name > Card Title"
        parts = card_full_title.split(' > ')
        if len(parts) != 3:
            return False # Invalid format
        
        board_name, list_name, card_title = parts

        if board_name not in self.boodesk_data["boards"]:
            return False
        if list_name not in self.boodesk_data["boards"][board_name]:
            return False
        
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card['title'] == card_title:
                # A card is considered completed if it's in the "Conclu√≠do" list
                return list_name == "Conclu√≠do"
        return False

    def _get_next_recurrence_date(self, current_date_str, recurrence_type):
        if not current_date_str:
            return ""
        
        try:
            current_date = datetime.strptime(current_date_str.split(' ')[0], "%Y-%m-%d")
        except ValueError:
            return "" # Invalid date format

        if recurrence_type == "Diariamente":
            next_date = current_date + timedelta(days=1)
        elif recurrence_type == "Semanalmente":
            next_date = current_date + timedelta(weeks=1)
        elif recurrence_type == "Mensalmente":
            # Advance by one month, handling end-of-month correctly
            year = current_date.year
            month = current_date.month + 1
            if month > 12:
                month = 1
                year += 1
            day = min(current_date.day, (datetime(year, month, 1) - timedelta(days=1)).day)
            next_date = datetime(year, month, day)
        elif recurrence_type == "Anualmente":
            next_date = current_date.replace(year=current_date.year + 1)
        else:
            return "" # No recurrence or invalid type

        return next_date.strftime("%Y-%m-%d")

    def complete_boodesk_card(self, board_name, list_name, card_id):
        card = None
        card_index = -1
        for i, c in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if c.get('card_id') == card_id:
                card = c
                card_index = i
                break
        
        if not card:
            messagebox.showerror("Erro", "Cart√£o n√£o encontrado para concluir.")
            return

        recurrence = card.get('recurrence', 'Nenhuma')

        # Verificar se todas as subtarefas est√£o conclu√≠das
        subtasks = card.get('subtasks', [])
        if subtasks:
            uncompleted_subtasks = [subtask for subtask in subtasks if not subtask['completed']]
            if uncompleted_subtasks:
                uncompleted_text = "\n".join([f"‚Ä¢ {subtask['text']}" for subtask in uncompleted_subtasks])
                messagebox.showwarning(
                    "Subtarefas Pendentes", 
                    f"N√£o √© poss√≠vel concluir o cart√£o '{card['title']}' porque ainda existem subtarefas pendentes:\n\n{uncompleted_text}\n\nConclua todas as subtarefas antes de marcar o cart√£o como conclu√≠do."
                )
                return

        # Handle dependencies first
        completed_card_full_title = f"{board_name} > {list_name} > {card['title']}"
        for b_name, lists in self.boodesk_data["boards"].items():
            for l_name, cards_in_list in lists.items():
                for c in cards_in_list:
                    if completed_card_full_title in c.get('dependencies', []):
                        messagebox.showinfo("Depend√™ncia Conclu√≠da", f"O cart√£o '{c['title']}' agora est√° desbloqueado, pois sua depend√™ncia '{card['title']}' foi conclu√≠da.")

        if recurrence == "Nenhuma":
            # Move to "Conclu√≠do" list if not recurring
            if list_name != "Conclu√≠do":
                if "Conclu√≠do" in self.boodesk_data["boards"][board_name]:
                    self.boodesk_data["boards"][board_name][list_name].pop(card_index)
                    self.boodesk_data["boards"][board_name]["Conclu√≠do"].append(card)
                    self.save_trello_data()
                else:
                    messagebox.showwarning("Lista N√£o Encontrada", "A lista 'Conclu√≠do' n√£o existe neste quadro.")
            else:
                messagebox.showinfo("Cart√£o J√° Conclu√≠do", "Este cart√£o j√° est√° na lista 'Conclu√≠do'.")
        else:
            # Handle recurrence: Create a new instance and move the original to "Conclu√≠do"
            original_card_id = card.get('card_id')
            
            # Move original card to "Conclu√≠do"
            if list_name != "Conclu√≠do":
                if "Conclu√≠do" in self.boodesk_data["boards"][board_name]:
                    self.boodesk_data["boards"][board_name][list_name].pop(card_index)
                    self.boodesk_data["boards"][board_name]["Conclu√≠do"].append(card)
                    messagebox.showinfo("Cart√£o Conclu√≠do", f"Cart√£o '{card['title']}' conclu√≠do e movido para 'Conclu√≠do'.")
                else:
                    messagebox.showwarning("Lista N√£o Encontrada", "A lista 'Conclu√≠do' n√£o existe neste quadro. O cart√£o original n√£o foi movido.")
            else:
                messagebox.showinfo("Cart√£o Conclu√≠do", "Este cart√£o j√° est√° na lista 'Conclu√≠do'.")

            # Create a new recurring instance
            new_card = card.copy()
            new_card['card_id'] = str(uuid.uuid4()) # New unique ID
            new_card['parent_card_id'] = original_card_id # Link to original
            new_card['creation_date'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S") # New creation date for the instance
            new_card['is_archived'] = False # Ensure new instance is not archived

            # Calculate next due date
            original_due_date = card.get('due_date', '')
            new_card['due_date'] = self._get_next_recurrence_date(original_due_date, recurrence)

            # Place the new instance in "A Fazer"
            if "A Fazer" in self.boodesk_data["boards"][board_name]:
                self.boodesk_data["boards"][board_name]["A Fazer"].append(new_card)
                messagebox.showinfo("Cart√£o Recorrente Criado", f"Nova inst√¢ncia de '{new_card['title']}' criada e adicionada a 'A Fazer'.")
            else:
                messagebox.showwarning("Lista N√£o Encontrada", "A lista 'A Fazer' n√£o existe neste quadro. A nova inst√¢ncia do cart√£o recorrente n√£o foi adicionada.")
            self.save_trello_data()
        self.populate_boards()

    def can_start_card(self, card):
        """Check if a card can be started based on its dependencies"""
        dependencies = card.get('dependencies', [])
        if not dependencies:
            return True
        
        return all(self._is_card_completed(dep) for dep in dependencies)

    def get_card_dependency_status(self, card):
        """Get detailed dependency status for a card"""
        dependencies = card.get('dependencies', [])
        if not dependencies:
            return {"can_start": True, "completed": 0, "total": 0, "pending": []}
        
        completed = [dep for dep in dependencies if self._is_card_completed(dep)]
        pending = [dep for dep in dependencies if not self._is_card_completed(dep)]
        
        return {
            "can_start": len(pending) == 0,
            "completed": len(completed),
            "total": len(dependencies),
            "pending": pending
        }

    def add_subject_dialog(self, subject_type):
        # This method now opens the management window instead of a simple dialog
        if self.settings['unify_subjects']:
            # If subjects are unified, always manage the pomodoro list which is the master list
            SubjectManagerWindow(self.root, self, 'pomodoro')
        else:
            SubjectManagerWindow(self.root, self, subject_type)

    def add_goal(self):
        new_goal = simpledialog.askstring("Novo Objetivo", "Digite o novo objetivo:").strip()
        if new_goal and new_goal not in self.goals:
            new_goal_df = pd.DataFrame({'Objetivo': [new_goal]})
            self.goals_df = pd.concat([self.goals_df, new_goal_df], ignore_index=True)
            self.goals = self.goals_df['Objetivo'].tolist()
            self.goals_df.to_excel(self.goals_file, index=False, engine='openpyxl')
            messagebox.showinfo("Sucesso", f"Objetivo '{new_goal}' adicionado.")

    def add_pomodoro_task(self):
        task = self.add_task_entry.get().strip()
        if not task:
            messagebox.showwarning("Entrada Inv√°lida", "Por favor, insira o nome da tarefa.")
            return

        subject = simpledialog.askstring("Assunto", "Digite o assunto da tarefa:")
        goal = simpledialog.askstring("Objetivo", "Digite o objetivo da tarefa:")

        new_task = pd.DataFrame({
            'Tarefa': [task],
            'Status': ['Pendente'],
            'Assunto': [subject if subject else '-'],
            'Objetivo': [goal if goal else '-']
        })
        self.pomodoro_tasks_df = pd.concat([self.pomodoro_tasks_df, new_task], ignore_index=True)
        self.save_pomodoro_tasks()
        self.update_pomodoro_task_list()
        self.add_task_entry.delete(0, tk.END)

    def remove_pomodoro_task(self):
        selected_item = self.pomodoro_task_list.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione uma tarefa para remover.")
            return

        task_name = self.pomodoro_task_list.item(selected_item, "values")[0]
        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover a tarefa '{task_name}'?"):
            self.pomodoro_tasks_df = self.pomodoro_tasks_df[self.pomodoro_tasks_df['Tarefa'] == task_name]
            self.save_pomodoro_tasks()
            self.update_pomodoro_task_list()

    def complete_pomodoro_task(self):
        selected_item = self.pomodoro_task_list.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione uma tarefa para concluir.")
            return

        task_name = self.pomodoro_task_list.item(selected_item, "values")[0]
        self.pomodoro_tasks_df.loc[self.pomodoro_tasks_df['Tarefa'] == task_name, 'Status'] = 'Conclu√≠do'
        self.save_pomodoro_tasks()
        self.update_pomodoro_task_list()

    def open_members_manager(self):
        MembersWindow(self.root, self)

    def open_categories_manager(self):
        """Abre o gerenciador de categorias"""
        CategoriesManagerWindow(self.root, self)

    def open_settings(self):
        SettingsWindow(self.root, self)

class SubjectManagerWindow(tk.Toplevel):
    def __init__(self, parent, app, subject_type):
        super().__init__(parent)
        self.app = app
        self.subject_type = subject_type
        
        if self.subject_type == 'pomodoro':
            self.title("Gerenciar Assuntos do Pomodoro")
            self.subjects_df = self.app.pomodoro_subjects_df
            self.subjects_list = self.app.pomodoro_subjects
            self.file_path = self.app.pomodoro_subjects_file
        else: # boodesk
            self.title("Gerenciar Assuntos do Boodesk")
            self.subjects_df = self.app.boodesk_subjects_df
            self.subjects_list = self.app.boodesk_subjects
            self.file_path = self.app.boodesk_subjects_file

        self.geometry("450x350")
        self.transient(parent)
        self.grab_set()

        self.create_widgets()
        self._populate_subjects_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Listbox Frame
        list_frame = ttk.LabelFrame(main_frame, text="Assuntos Cadastrados")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        self.subjects_listbox = tk.Listbox(list_frame, selectmode=tk.SINGLE)
        self.subjects_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.subjects_listbox.bind("<<ListboxSelect>>", self._on_subject_select)
        
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.subjects_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.subjects_listbox.config(yscrollcommand=scrollbar.set)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Assunto")
        entry_frame.pack(fill=tk.X, pady=5)
        entry_frame.columnconfigure(0, weight=1)

        self.subject_entry = ttk.Entry(entry_frame)
        self.subject_entry.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        
        self.add_edit_button = ttk.Button(entry_frame, text="Adicionar", command=self._add_subject)
        self.add_edit_button.grid(row=0, column=1, padx=5, pady=5)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Remover Selecionado", command=self._remove_subject).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", command=self.destroy).pack(side=tk.RIGHT, padx=5)

    def _populate_subjects_list(self):
        self.subjects_listbox.delete(0, tk.END)
        # Sort the list for better UX
        for subject in sorted(self.subjects_list):
            if subject != '-': # Don't show the default '-'
                self.subjects_listbox.insert(tk.END, subject)

    def _on_subject_select(self, event):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            self.subject_entry.delete(0, tk.END)
            self.add_edit_button.config(text="Adicionar", command=self._add_subject)
            return
        
        selected_subject = self.subjects_listbox.get(selected_indices[0])
        self.subject_entry.delete(0, tk.END)
        self.subject_entry.insert(0, selected_subject)
        self.add_edit_button.config(text="Salvar Edi√ß√£o", command=self._edit_subject)

    def _clear_selection(self):
        self.subjects_listbox.selection_clear(0, tk.END)
        self.subject_entry.delete(0, tk.END)
        self.add_edit_button.config(text="Adicionar", command=self._add_subject)
        # Manually trigger the event handler to reset the button state
        self._on_subject_select(None)


    def _add_subject(self):
        new_subject = self.subject_entry.get().strip()
        if not new_subject:
            messagebox.showwarning("Entrada Inv√°lida", "O nome do assunto n√£o pode estar vazio.", parent=self)
            return
        
        if new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' j√° existe.", parent=self)
            return

        # Update DataFrame and list
        new_subject_df = pd.DataFrame({'Assunto': [new_subject]})
        self.subjects_df = pd.concat([self.subjects_df, new_subject_df], ignore_index=True)
        self.subjects_list.append(new_subject)
        
        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{new_subject}' adicionado.", parent=self)

    def _edit_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um assunto para editar.", parent=self)
            return
            
        old_subject = self.subjects_listbox.get(selected_indices[0])
        new_subject = self.subject_entry.get().strip()

        if not new_subject:
            messagebox.showwarning("Entrada Inv√°lida", "O nome do assunto n√£o pode estar vazio.", parent=self)
            return

        if new_subject != old_subject and new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' j√° existe.", parent=self)
            return

        # Update DataFrame and list
        self.subjects_df.loc[self.subjects_df['Assunto'] == old_subject, 'Assunto'] = new_subject
        self.subjects_list[self.subjects_list.index(old_subject)] = new_subject

        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{old_subject}' atualizado para '{new_subject}'.", parent=self)

    def _remove_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um assunto para remover.", parent=self)
            return

        subject_to_remove = self.subjects_listbox.get(selected_indices[0])
        
        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover o assunto '{subject_to_remove}'?\nIsso n√£o pode ser desfeito e n√£o alterar√° os cart√µes existentes.", parent=self):
            # Update DataFrame and list
            self.subjects_df = self.subjects_df[self.subjects_df['Assunto'] != subject_to_remove]
            self.subjects_list.remove(subject_to_remove)
            
            # Save and refresh
            self._save_and_refresh()
            self._clear_selection()
            messagebox.showinfo("Sucesso", f"Assunto '{subject_to_remove}' removido.", parent=self)

    def _save_and_refresh(self):
        # Save the DataFrame to the Excel file
        self.subjects_df.to_excel(self.file_path, index=False)
        
        # Update the main app's data
        if self.subject_type == 'pomodoro':
            self.app.pomodoro_subjects_df = self.subjects_df
            self.app.pomodoro_subjects = self.subjects_list
        else: # boodesk
            self.app.boodesk_subjects_df = self.subjects_df
            self.app.boodesk_subjects = self.subjects_list
            
        # Reload all auxiliary data in the main app to update all UI components
        self.app.load_aux_data()
        self.app.update_all_displays() # A comprehensive update
        
        # Refresh the listbox in this window
        self._populate_subjects_list()

    def destroy(self):
        # Ensure the main app window gets focus back
        self.app.root.focus_set()
        super().destroy()

class ArchivedCardsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Cart√µes Arquivados")
        self.geometry("600x400")
        self.transient(parent)
        self.grab_set()

        if self.app.settings.get('open_on_current_screen', False):
            self.update_idletasks()
            parent_x = parent.winfo_x()
            parent_y = parent.winfo_y()
            parent_width = parent.winfo_width()
            parent_height = parent.winfo_height()

            x = parent_x + (parent_width // 2) - (self.winfo_width() // 2)
            y = parent_y + (parent_height // 2) - (self.winfo_height() // 2)
            self.geometry(f"+{x}+{y}")

        self.create_widgets()
        self._populate_archived_cards_listbox()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Cart√µes Arquivados:").pack(anchor="w", pady=5)

        self.archived_listbox = tk.Listbox(main_frame, selectmode=tk.SINGLE)
        self.archived_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        self.archived_listbox.bind("<Double-1>", self._restore_card_from_double_click)

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=5)

        ttk.Button(button_frame, text="Restaurar Cart√£o", command=self._restore_card).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Excluir Permanentemente", command=self._delete_card_permanently).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", command=self.destroy).pack(side=tk.LEFT, padx=5)

    def _populate_archived_cards_listbox(self):
        self.archived_listbox.delete(0, tk.END)
        self.archived_cards_data = [] # Store references to actual card objects

        for board_name, lists in self.app.trello_data["boards"].items():
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    if isinstance(cards, list):
                        for card in cards:
                    if card.get("is_archived", False):
                        display_text = f"{board_name} > {list_name} > {card['title']}"
                        self.archived_listbox.insert(tk.END, display_text)
                        self.archived_cards_data.append({"board": board_name, "list": list_name, "card": card})

    def _restore_card_from_double_click(self, event):
        self._restore_card()

    def _restore_card(self):
        selected_index = self.archived_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um cart√£o para restaurar.")
            return

        card_info = self.archived_cards_data[selected_index[0]]
        card = card_info["card"]
        board_name = card_info["board"]
        list_name = card_info["list"] # This is the original list name

        if messagebox.askyesno("Confirmar Restaura√ß√£o", f"Tem certeza que deseja restaurar o cart√£o '{card['title']}' para o quadro '{board_name}' na lista '{list_name}'?"):
            card["is_archived"] = False

            # Remove the card from its current list (where it was archived)
            # We need to find the card by its card_id and remove it from the list it's currently in.
            # This assumes the card is still in the list it was in when it was archived.
            found_and_removed = False
            if board_name in self.app.trello_data["boards"] and list_name in self.app.trello_data["boards"][board_name]:
                original_list = self.app.trello_data["boards"][board_name][list_name]
                for i, c in enumerate(original_list):
                    if c.get("card_id") == card.get("card_id"):
                        original_list.pop(i)
                        found_and_removed = True
                        break
            
            if not found_and_removed:
                messagebox.showerror("Erro de Restaura√ß√£o", "N√£o foi poss√≠vel encontrar o cart√£o em sua lista original para remo√ß√£o.")
                return

            # Add the card to the target list
            target_list_name = list_name # Default to original list
            if list_name not in self.app.trello_data["boards"][board_name]:
                # Fallback to "A Fazer" if original list was deleted
                if "A Fazer" in self.app.trello_data["boards"][board_name]:
                    target_list_name = "A Fazer"
                    messagebox.showinfo("Restaura√ß√£o", f"Lista original '{list_name}' n√£o encontrada. Cart√£o restaurado para 'A Fazer'.")
                else:
                    messagebox.showerror("Erro de Restaura√ß√£o", "N√£o foi poss√≠vel restaurar o cart√£o. A lista original e 'A Fazer' n√£o existem.")
                    return
            
            self.app.trello_data["boards"][board_name][target_list_name].append(card)
            
            self.app.save_trello_data()
            self.app.populate_boards() # Refresh main board view
            self._populate_archived_cards_listbox() # Refresh archived list
            messagebox.showinfo("Sucesso", f"Cart√£o '{card['title']}' restaurado com sucesso!")

    def _delete_card_permanently(self):
        selected_index = self.archived_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um cart√£o para excluir permanentemente.")
            return

        card_info = self.archived_cards_data[selected_index[0]]
        card = card_info["card"]
        board_name = card_info["board"]
        list_name = card_info["list"]

        if messagebox.askyesno("Confirmar Exclus√£o Permanente", f"Tem certeza que deseja EXCLUIR PERMANENTEMENTE o cart√£o '{card['title']}'? Esta a√ß√£o n√£o pode ser desfeita."):
            # Find the card in the actual data structure and remove it
            if board_name in self.app.trello_data["boards"] and list_name in self.app.trello_data["boards"][board_name]:
                # Filter out the card by its unique card_id
                self.app.trello_data["boards"][board_name][list_name] = [
                    c for c in self.app.trello_data["boards"][board_name][list_name] if c.get("card_id") != card.get("card_id")
                ]
                self.app.save_trello_data()
                self.app.populate_boards() # Refresh main board view
                self._populate_archived_cards_listbox() # Refresh archived list
                messagebox.showinfo("Sucesso", f"Cart√£o '{card['title']}' exclu√≠do permanentemente.")
            else:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel encontrar o cart√£o na estrutura de dados para exclus√£o.")

class CardWindow(tk.Toplevel):
    def __init__(self, parent, app, board_name, list_name, card_id, current_user, callback_on_close=None):
        super().__init__(parent)
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self.card_id = card_id # Now using card_id instead of card_index
        self.current_user = current_user # Store the current user
        self.callback_on_close = callback_on_close
        
        # Find the card using its card_id - try both in-memory data and database
        self.card = None
        
        # First, try to find in the in-memory data structure
        if (self.board_name in self.app.boodesk_data["boards"] and 
            self.list_name in self.app.boodesk_data["boards"][self.board_name]):
            for card_data in self.app.boodesk_data["boards"][self.board_name][self.list_name]:
                if card_data.get('card_id') == self.card_id:
                    self.card = card_data
                    break
        
        # If not found in memory, try to get from database
        if not self.card and hasattr(self.app, 'db') and self.app.db:
            try:
                card_data = self.app.db.get_card_by_id(self.card_id)
                if card_data:
                    # Convert to dictionary if needed
                    if not isinstance(card_data, dict):
                        card_data = dict(card_data)
                    
                    # Add board and list information
                    card_data['board_name'] = self.board_name
                    card_data['list_name'] = self.list_name
                    self.card = card_data
                    print(f"DEBUG: Card encontrado no banco de dados: {self.card.get('title', 'Sem t√≠tulo')}")
            except Exception as e:
                print(f"Erro ao buscar card no banco: {e}")

        if not self.card:
            messagebox.showerror("Erro", "Cart√£o n√£o encontrado. Pode ter sido exclu√≠do ou movido.")
            self.destroy()
            return

        self.title(f"Editar Tarefa: {self.card['title']}")
        self.geometry("1000x700")  # Tamanho fixo que funciona bem
        self.resizable(False, False)  # Impedir redimensionamento para evitar deforma√ß√£o
        
        # Centralizar a janela na tela
        self.center_window()
        
        # Tornar esta janela modal (usu√°rio deve interagir com ela antes de voltar √† janela principal)
        self.transient(parent)
        self.grab_set()

        # Initialize StringVars for Git integration
        self.git_branch_var = tk.StringVar(value=self.card.get('git_branch', ''))
        self.git_commit_var = tk.StringVar(value=self.card.get('git_commit', ''))
        self.git_pr_var = tk.StringVar(value=self.card.get('git_pr', ''))

        self.create_widgets()

    def center_window(self):
        """Centraliza a janela na tela"""
        self.update_idletasks()
        
        # Obter dimens√µes da tela
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Obter dimens√µes da janela
        window_width = self.winfo_width()
        window_height = self.winfo_height()
        
        # Calcular posi√ß√£o central
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        
        # Aplicar posi√ß√£o
        self.geometry(f"+{x}+{y}")

    def create_widgets(self):
        # Main container with proper layout
        main_container = ttk.Frame(self)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Configure main container for proper layout
        main_container.columnconfigure(0, weight=1)
        main_container.rowconfigure(0, weight=1)
        
        # Create a frame for the scrollable content
        content_frame = ttk.Frame(main_container)
        content_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 10))
        content_frame.columnconfigure(0, weight=1)
        content_frame.rowconfigure(0, weight=1)
        
        # Create canvas and scrollbar
        canvas = tk.Canvas(content_frame)
        scrollbar = ttk.Scrollbar(content_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # Main frame inside scrollable area
        main_frame = ttk.Frame(scrollable_frame, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure grid for 2 columns with proper weights
        main_frame.columnconfigure(0, weight=1)  # Left column
        main_frame.columnconfigure(1, weight=1)  # Right column
        main_frame.rowconfigure(0, weight=1)  # Allow vertical expansion

        # === LEFT COLUMN ===
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
        left_frame.columnconfigure(1, weight=1)
        left_frame.rowconfigure(0, weight=1)  # Allow expansion

        # --- Card Details Section ---
        details_frame = ttk.LabelFrame(left_frame, text="Detalhes do Cart√£o", padding="10")
        details_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        details_frame.columnconfigure(1, weight=1)

        ttk.Label(details_frame, text="T√≠tulo:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
        self.title_entry = ttk.Entry(details_frame)
        self.title_entry.grid(row=0, column=1, sticky="ew", pady=3, padx=5)
        self.title_entry.insert(0, self.card['title'])

        ttk.Label(details_frame, text="Descri√ß√£o:", font=("Arial", 9, "bold")).grid(row=1, column=0, sticky="nw", pady=3, padx=5)
        self.desc_text = tk.Text(details_frame, height=4, width=35, wrap=tk.WORD)
        self.desc_text.grid(row=1, column=1, sticky="ew", pady=3, padx=5)
        self.desc_text.insert("1.0", self.card.get('desc', ''))

        # --- Dates and Recurrence Section ---
        dates_frame = ttk.LabelFrame(left_frame, text="Datas e Recorr√™ncia", padding="10")
        dates_frame.pack(fill=tk.X, pady=(0, 10))
        dates_frame.columnconfigure(1, weight=1)

        ttk.Label(dates_frame, text="Prazo:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
        date_frame = ttk.Frame(dates_frame)
        date_frame.grid(row=0, column=1, sticky="ew", pady=3, padx=5)
        self.due_date_entry = ttk.Entry(date_frame, width=15, state="readonly")
        self.due_date_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(date_frame, image=self.app.icons.get('time_icon'), width=3, command=self.open_date_picker).pack(side=tk.LEFT, padx=2)

        self.include_time_var = tk.BooleanVar()
        self.include_time_var.set(False)
        self.include_time_check = ttk.Checkbutton(dates_frame, text="Incluir Hor√°rio", 
                                                variable=self.include_time_var, 
                                                command=self.toggle_time_fields)
        self.include_time_check.grid(row=1, column=0, sticky="w", pady=3, padx=5)

        time_frame = ttk.Frame(dates_frame)
        time_frame.grid(row=1, column=1, sticky="ew", pady=3, padx=5)
        self.hour_entry = tk.Spinbox(time_frame, from_=0, to=23, width=3, state="disabled", wrap=True)
        self.hour_entry.pack(side=tk.LEFT)
        ttk.Label(time_frame, text=":").pack(side=tk.LEFT)
        self.minute_entry = tk.Spinbox(time_frame, from_=0, to=59, width=3, state="disabled", wrap=True)
        self.minute_entry.pack(side=tk.LEFT)

        ttk.Label(dates_frame, text="Recorr√™ncia:", font=("Arial", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3, padx=5)
        self.recurrence_options = ["Nenhuma", "Diariamente", "Semanalmente", "Mensalmente", "Anualmente"]
        self.recurrence_combo = ttk.Combobox(dates_frame, values=self.recurrence_options, state="readonly")
        self.recurrence_combo.grid(row=2, column=1, sticky="ew", pady=3, padx=5)
        self.recurrence_combo.set(self.card.get('recurrence', 'Nenhuma'))

        # Git Integration Section (visible only in dev mode)
        if self.app.settings.get('dev_mode', False):
            git_frame = ttk.LabelFrame(left_frame, text="Integra√ß√£o Git", padding="10")
            git_frame.pack(fill=tk.X, pady=(0, 10))
            git_frame.columnconfigure(1, weight=1)

            # Git Status and Actions
            git_status_frame = ttk.Frame(git_frame)
            git_status_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 10))
            git_status_frame.columnconfigure(1, weight=1)

            ttk.Label(git_status_frame, text="Status Git:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
            self.git_status_label = ttk.Label(git_status_frame, text="N√£o configurado", foreground="gray")
            self.git_status_label.grid(row=0, column=1, sticky="w", pady=3, padx=5)

            # Git Actions Buttons
            git_actions_frame = ttk.Frame(git_frame)
            git_actions_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(0, 10))

            ttk.Button(git_actions_frame, text="Inicializar Repo", 
                      image=self.app.icons.get('add_icon'), compound=tk.LEFT,
                      command=self.init_git_repo).pack(side=tk.LEFT, padx=2)
            
            ttk.Button(git_actions_frame, text="Criar Branch", 
                      image=self.app.icons.get('add_folder_icon'), compound=tk.LEFT,
                      command=self.create_git_branch).pack(side=tk.LEFT, padx=2)
            
            ttk.Button(git_actions_frame, text="Commit", 
                      image=self.app.icons.get('save_icon'), compound=tk.LEFT,
                      command=self.make_git_commit).pack(side=tk.LEFT, padx=2)

            # Git Information Fields
            ttk.Label(git_frame, text="Branch Atual:", font=("Arial", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3, padx=5)
            self.git_branch_entry = ttk.Entry(git_frame, textvariable=self.git_branch_var)
            self.git_branch_entry.grid(row=2, column=1, sticky="ew", pady=3, padx=5)

            ttk.Label(git_frame, text="√öltimo Commit:", font=("Arial", 9, "bold")).grid(row=3, column=0, sticky="w", pady=3, padx=5)
            self.git_commit_entry = ttk.Entry(git_frame, textvariable=self.git_commit_var)
            self.git_commit_entry.grid(row=3, column=1, sticky="ew", pady=3, padx=5)

            ttk.Label(git_frame, text="Pull Request:", font=("Arial", 9, "bold")).grid(row=4, column=0, sticky="w", pady=3, padx=5)
            self.git_pr_entry = ttk.Entry(git_frame, textvariable=self.git_pr_var)
            self.git_pr_entry.grid(row=4, column=1, sticky="ew", pady=3, padx=5)

            # Git History Section
            git_history_frame = ttk.LabelFrame(git_frame, text="Hist√≥rico Git", padding="5")
            git_history_frame.grid(row=5, column=0, columnspan=2, sticky="ew", pady=(10, 0))
            git_history_frame.columnconfigure(0, weight=1)

            self.git_history_text = tk.Text(git_history_frame, height=4, width=40, wrap=tk.WORD, state="disabled")
            self.git_history_text.pack(fill=tk.BOTH, expand=True, pady=5)
            
            # Update Git status
            self.update_git_status()

        # Populate due date and time if available
        if self.card.get('due_date'):
            try:
                # Tentar diferentes formatos de data
                due_date_str = self.card['due_date']
                dt_obj = None
                
                # Formato com data e hora: "2025-08-12 14:30"
                if ' ' in due_date_str:
                    try:
                        dt_obj = datetime.strptime(due_date_str, "%Y-%m-%d %H:%M")
                        self.include_time_var.set(True)
                        self.toggle_time_fields()
                    except ValueError:
                        try:
                            dt_obj = datetime.strptime(due_date_str, "%Y-%m-%d %H:%M:%S")
                            self.include_time_var.set(True)
                            self.toggle_time_fields()
                        except ValueError:
                            pass
                
                # Formato apenas data: "2025-08-12"
                if not dt_obj:
                    try:
                        dt_obj = datetime.strptime(due_date_str, "%Y-%m-%d")
                        self.include_time_var.set(False)
                        self.toggle_time_fields()
                    except ValueError:
                        # Formato brasileiro: "12/08/2025"
                        try:
                            dt_obj = datetime.strptime(due_date_str, "%d/%m/%Y")
                            self.include_time_var.set(False)
                            self.toggle_time_fields()
                        except ValueError:
                            pass
                
                if dt_obj:
                    self.due_date_entry.config(state="normal")
                    self.due_date_entry.delete(0, tk.END)
                    self.due_date_entry.insert(0, dt_obj.strftime("%Y-%m-%d"))
                    self.due_date_entry.config(state="readonly")
                    
                    if self.include_time_var.get():
                        self.hour_entry.config(state="normal")
                        self.minute_entry.config(state="normal")
                        self.hour_entry.delete(0, tk.END)
                        self.minute_entry.delete(0, tk.END)
                        self.hour_entry.insert(0, dt_obj.strftime("%H"))
                        self.minute_entry.insert(0, dt_obj.strftime("%M"))
                        
            except Exception as e:
                print(f"Erro ao processar data do card: {e}")
                # Se n√£o conseguir processar, limpar os campos
                self.due_date_entry.config(state="normal")
                self.due_date_entry.delete(0, tk.END)
                self.due_date_entry.config(state="readonly")
                self.include_time_var.set(True)
            except ValueError:  # Only date available
                self.due_date_entry.config(state="normal")
                self.due_date_entry.delete(0, tk.END)
                self.due_date_entry.insert(0, self.card['due_date'])
                self.due_date_entry.config(state="readonly")
                self.include_time_var.set(False)
        self.toggle_time_fields()

        # --- Attributes Section ---
        attributes_frame = ttk.LabelFrame(left_frame, text="Atributos", padding="10")
        attributes_frame.pack(fill=tk.X, pady=(0, 10))
        attributes_frame.columnconfigure(1, weight=1)

        ttk.Label(attributes_frame, text="Import√¢ncia:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
        self.importance_options = list(self.app.settings["importance_colors"].keys())
        self.importance_combo = ttk.Combobox(attributes_frame, values=self.importance_options, state="readonly")
        self.importance_combo.grid(row=0, column=1, sticky="ew", pady=3, padx=5)
        self.importance_combo.set(self.card.get('importance', 'Normal'))

        ttk.Label(attributes_frame, text="Categoria:", font=("Arial", 9, "bold")).grid(row=1, column=0, sticky="w", pady=3, padx=5)
        category_options = [cat['name'] for cat in self.app.categories]
        self.category_combo = ttk.Combobox(attributes_frame, values=category_options, state="readonly")
        self.category_combo.grid(row=1, column=1, sticky="ew", pady=3, padx=5)
        self.category_combo.set(self.card.get('category', '-'))

        ttk.Label(attributes_frame, text="Objetivo:", font=("Arial", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3, padx=5)
        self.goal_combo = ttk.Combobox(attributes_frame, values=self.app.goals, state="readonly")
        self.goal_combo.grid(row=2, column=1, sticky="ew", pady=3, padx=5)
        self.goal_combo.set(self.card.get('goal', '-'))

        # --- Members Section ---
        members_frame = ttk.LabelFrame(left_frame, text="Membros Respons√°veis", padding="10")
        members_frame.pack(fill=tk.X, pady=(0, 10))
        members_frame.columnconfigure(0, weight=1)

        # Frame for the combobox and add button
        add_member_frame = ttk.Frame(members_frame)
        add_member_frame.pack(fill=tk.X, pady=2)
        add_member_frame.columnconfigure(0, weight=1)

        self.member_suggestions_combo = ttk.Combobox(add_member_frame, values=[member['Membro'] for member in self.app.members], state="readonly")
        self.member_suggestions_combo.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        self.member_suggestions_combo.set("Selecionar Membro para Adicionar")
        
        add_member_btn = ttk.Button(add_member_frame, text="Adicionar", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_member_from_combo)
        add_member_btn.grid(row=0, column=1)

        # Listbox for assigned members
        self.assigned_members_listbox = tk.Listbox(members_frame, selectmode=tk.SINGLE, height=3)
        self.assigned_members_listbox.pack(fill=tk.BOTH, expand=True, pady=2)
        for member in self.card.get('members', []):
            self.assigned_members_listbox.insert(tk.END, member)

        # Remove button
        remove_member_btn = ttk.Button(members_frame, text="Remover Selecionado", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_assigned_member)
        remove_member_btn.pack(pady=2)

        # --- Creation Date Section ---
        creation_frame = ttk.LabelFrame(left_frame, text="Informa√ß√µes do Sistema", padding="10")
        creation_frame.pack(fill=tk.X)
        
        ttk.Label(creation_frame, text="Data de Cria√ß√£o:", font=("Arial", 9, "bold")).pack(anchor="w", padx=5, pady=2)
        self.creation_date_label = ttk.Label(creation_frame, text=self.card.get('creation_date', 'N/A'))
        self.creation_date_label.pack(anchor="w", padx=5, pady=2)

        # === RIGHT COLUMN ===
        right_frame = ttk.Frame(main_frame)
        right_frame.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
        right_frame.columnconfigure(0, weight=1)
        right_frame.rowconfigure(0, weight=1)  # Allow expansion

        # --- Dependencies Section ---
        dependencies_frame = ttk.LabelFrame(right_frame, text="Depend√™ncias", padding="10")
        dependencies_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        dependencies_frame.columnconfigure(0, weight=1)
        
        # Configure the frame to expand properly
        dependencies_frame.pack_configure(fill=tk.BOTH, expand=True)

        # Dependency input area
        dependency_input_frame = ttk.Frame(dependencies_frame)
        dependency_input_frame.pack(fill=tk.X, pady=(0, 5))
        dependency_input_frame.columnconfigure(0, weight=1)
        
        self.dependency_combo = ttk.Combobox(dependency_input_frame, state="readonly")
        self.dependency_combo.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        add_dep_btn = ttk.Button(dependency_input_frame, text="Adicionar", 
                               image=self.app.icons.get('add_icon'), compound=tk.LEFT,
                               command=self._add_dependency)
        add_dep_btn.grid(row=0, column=1)

        # Dependencies list
        self.dependencies_listbox = tk.Listbox(dependencies_frame, selectmode=tk.SINGLE, height=6)
        self.dependencies_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        
        dep_scrollbar = ttk.Scrollbar(dependencies_frame, orient="vertical", command=self.dependencies_listbox.yview)
        dep_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.dependencies_listbox.config(yscrollcommand=dep_scrollbar.set)

        # Remove dependency button
        remove_dep_btn = ttk.Button(dependencies_frame, text="Remover Depend√™ncia", 
                                  image=self.app.icons.get('delete_icon'), compound=tk.LEFT,
                                  command=self._remove_dependency)
        remove_dep_btn.pack(pady=5)

        # --- Subtasks Section ---
        subtasks_frame = ttk.LabelFrame(right_frame, text="Subtarefas/Checklist", padding="10")
        subtasks_frame.pack(fill=tk.BOTH, expand=True)
        subtasks_frame.columnconfigure(0, weight=1)
        
        # Configure the frame to expand properly
        subtasks_frame.pack_configure(fill=tk.BOTH, expand=True)

        # Subtask input area
        subtask_input_frame = ttk.Frame(subtasks_frame)
        subtask_input_frame.pack(fill=tk.X, pady=(0, 5))
        subtask_input_frame.columnconfigure(0, weight=1)
        subtask_input_frame.columnconfigure(1, weight=1)
        
        # Subtask entry
        self.subtask_entry = ttk.Entry(subtask_input_frame)
        self.subtask_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        self.subtask_entry.bind('<Return>', lambda e: self._add_subtask())
        
        # Member assignment for subtask
        member_options = [member['Membro'] for member in self.app.members]
        self.subtask_member_combo = ttk.Combobox(subtask_input_frame, values=member_options, state="readonly")
        self.subtask_member_combo.grid(row=0, column=1, sticky="ew", padx=(0, 5))
        self.subtask_member_combo.set("Delegar para...")
        
        add_subtask_btn = ttk.Button(subtask_input_frame, text="Adicionar", 
                                   image=self.app.icons.get('add_icon'), compound=tk.LEFT,
                                   command=self._add_subtask)
        add_subtask_btn.grid(row=0, column=2)

        # Subtasks list
        self.subtasks_listbox = tk.Listbox(subtasks_frame, selectmode=tk.SINGLE, height=8)
        self.subtasks_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        self.subtasks_listbox.bind("<Double-1>", self._toggle_subtask_completion)
        
        subtask_scrollbar = ttk.Scrollbar(subtasks_frame, orient="vertical", command=self.subtasks_listbox.yview)
        subtask_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.subtasks_listbox.config(yscrollcommand=subtask_scrollbar.set)

        # Remove subtask button
        remove_subtask_btn = ttk.Button(subtasks_frame, text="Remover Subtarefa", 
                                      image=self.app.icons.get('delete_icon'), compound=tk.LEFT,
                                      command=self._remove_subtask)
        remove_subtask_btn.pack(pady=5)

        # --- Activity History Section ---
        history_frame = ttk.LabelFrame(right_frame, text="Hist√≥rico de Atividade", padding="10")
        history_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        history_frame.columnconfigure(0, weight=1)
        history_frame.rowconfigure(0, weight=1) # Allow treeview to expand

        self.history_treeview = ttk.Treeview(history_frame, columns=("Timestamp", "User", "Details"), show="headings")
        self.history_treeview.heading("Timestamp", text="Data/Hora")
        self.history_treeview.heading("User", text="Usu√°rio")
        self.history_treeview.heading("Details", text="Detalhes")

        self.history_treeview.column("Timestamp", width=150, anchor="w")
        self.history_treeview.column("User", width=80, anchor="w")
        self.history_treeview.column("Details", width=300, anchor="w")

        self.history_treeview.grid(row=0, column=0, sticky="nsew", pady=5)

        history_scrollbar = ttk.Scrollbar(history_frame, orient="vertical", command=self.history_treeview.yview)
        history_scrollbar.grid(row=0, column=1, sticky="ns")
        self.history_treeview.config(yscrollcommand=history_scrollbar.set)

        # Pack canvas and scrollbar
        canvas.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")
        
        # Configure canvas to expand properly
        content_frame.columnconfigure(0, weight=1)
        content_frame.rowconfigure(0, weight=1)
        
        # === BOTTOM ACTION BUTTONS (FIXED AT BOTTOM) ===
        button_frame = ttk.LabelFrame(main_container, text="A√ß√µes", padding="10")
        button_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(10, 0))
        
        # Configure button frame for proper layout
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)
        
        # Create buttons with better spacing
        save_btn = ttk.Button(button_frame, text="Salvar", 
                            image=self.app.icons.get('save_icon'), compound=tk.LEFT,
                            command=self.save_card)
        save_btn.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        cancel_btn = ttk.Button(button_frame, text="Cancelar", 
                              image=self.app.icons.get('cancel_icon'), compound=tk.LEFT,
                              command=self.destroy)
        cancel_btn.grid(row=0, column=1, sticky="ew", padx=(0, 5))
        
        pomodoro_btn = ttk.Button(button_frame, text="Iniciar Pomodoro", 
                                image=self.app.icons.get('coffee_icon'), compound=tk.LEFT,
                                command=self.start_pomodoro_action)
        pomodoro_btn.grid(row=0, column=2, sticky="ew", padx=(0, 5))
        
        complete_btn = ttk.Button(button_frame, text="Concluir Cart√£o", 
                                image=self.app.icons.get('ok_icon'), compound=tk.LEFT,
                                command=self.complete_card_action)
        complete_btn.grid(row=0, column=3, sticky="ew")
        
        # Add keyboard shortcuts
        self.bind('<Control-s>', lambda e: self.save_card())
        self.bind('<Escape>', lambda e: self.destroy())
        self.bind('<Return>', lambda e: self.save_card())
        
        # Initialize data
        self._populate_dependency_combobox()
        self._populate_dependencies_listbox()
        self._populate_subtasks_listbox()
        self._populate_history_treeview()
        
        # Focus on title entry
        self.title_entry.focus_set()

    def _populate_history_treeview(self):
        self.history_treeview.delete(*self.history_treeview.get_children())
        history = self.card.get('history', [])
        for entry in history:
            timestamp = entry.get('timestamp', 'N/A')
            user = entry.get('user', 'Sistema')
            action = entry.get('action', 'A√ß√£o desconhecida')
            self.history_treeview.insert("", "end", values=(timestamp, user, action))

    def _add_member_from_combo(self):
        selected_member = self.member_suggestions_combo.get()
        if selected_member and selected_member != "Selecionar Membro para Adicionar":
            current_members = self.assigned_members_listbox.get(0, tk.END)
            if selected_member not in current_members:
                self.assigned_members_listbox.insert(tk.END, selected_member)
            self.member_suggestions_combo.set("Selecionar Membro para Adicionar")

    def _remove_assigned_member(self):
        selected_index = self.assigned_members_listbox.curselection()
        if selected_index:
            self.assigned_members_listbox.delete(selected_index)

    def _add_suggested_member(self, event):
        selected_member = self.member_suggestions_combo.get()
        current_members = [m.strip() for m in self.members_entry.get().split(',') if m.strip()]
        if selected_member and selected_member != "Selecionar Membro" and selected_member not in current_members:
            current_members.append(selected_member)
            self.members_entry.delete(0, tk.END)
            self.members_entry.insert(0, ", ".join(current_members))
        self.member_suggestions_combo.set("Selecionar Membro")

    def open_date_picker(self):
        current_date_str = self.due_date_entry.get()
        dialog = DatePickerDialog(self, current_date=current_date_str, icons=self.app.icons)
        self.wait_window(dialog)
        if dialog.result_date:
            self.due_date_entry.config(state="normal")
            self.due_date_entry.delete(0, tk.END)
            self.due_date_entry.insert(0, dialog.result_date.strftime("%Y-%m-%d"))
            self.due_date_entry.config(state="readonly")

    def toggle_time_fields(self):
        state = "normal" if self.include_time_var.get() else "disabled"
        self.hour_entry.config(state=state)
        self.minute_entry.config(state=state)

    def _add_subtask(self):
        subtask_text = self.subtask_entry.get().strip()
        if subtask_text:
            # Obter membro delegado
            assigned_member = self.subtask_member_combo.get()
            if assigned_member == "Delegar para...":
                assigned_member = None
            
            # Converter subtarefa para caixa alta
            subtask_data = {
                'text': subtask_text.upper(), 
                'completed': False,
                'assigned_member': assigned_member
            }
            self.card.setdefault('subtasks', []).append(subtask_data)
            self.subtask_entry.delete(0, tk.END)
            self.subtask_member_combo.set("Delegar para...")
            self._populate_subtasks_listbox()

    def _remove_subtask(self):
        selected_index = self.subtasks_listbox.curselection()
        if selected_index:
            # Adjust index to account for header and separator
            actual_index = selected_index[0] - 2
            if actual_index >= 0 and actual_index < len(self.card.get('subtasks', [])):
                del self.card['subtasks'][actual_index]
                self._populate_subtasks_listbox()

    def _toggle_subtask_completion(self, event):
        selected_index = self.subtasks_listbox.nearest(event.y)
        if selected_index != -1:
            # Adjust index to account for header and separator
            actual_index = selected_index - 2
            if actual_index >= 0 and actual_index < len(self.card.get('subtasks', [])):
                self.card['subtasks'][actual_index]['completed'] = not self.card['subtasks'][actual_index]['completed']
                self._populate_subtasks_listbox()

    def _populate_subtasks_listbox(self):
        self.subtasks_listbox.delete(0, tk.END)
        subtasks = self.card.get('subtasks', [])
        
        if not subtasks:
            self.subtasks_listbox.insert(tk.END, "Nenhuma subtarefa adicionada")
            return
            
        completed_count = sum(1 for subtask in subtasks if subtask['completed'])
        total_count = len(subtasks)
        
        # Add progress header
        progress_text = f"Progresso: {completed_count}/{total_count} ({completed_count/total_count*100:.0f}%)"
        self.subtasks_listbox.insert(tk.END, progress_text)
        self.subtasks_listbox.itemconfig(0, foreground='blue')
        
        # Add separator
        self.subtasks_listbox.insert(tk.END, "‚îÄ" * 50)
        self.subtasks_listbox.itemconfig(1, foreground='gray')
        
        # Add subtasks
        for i, subtask in enumerate(subtasks):
            checkbox = "" if subtask['completed'] else ""
            display_text = f"{checkbox} {subtask['text']}"
            
            # Adicionar informa√ß√£o do membro delegado
            if subtask.get('assigned_member'):
                display_text += f" ‚Üí {subtask['assigned_member']}"
            
            self.subtasks_listbox.insert(tk.END, display_text)
            listbox_index = i + 2  # +2 because of progress header and separator
            if subtask['completed']:
                self.subtasks_listbox.itemconfig(listbox_index, foreground='gray', selectforeground='gray')
            else:
                self.subtasks_listbox.itemconfig(listbox_index, foreground='black', selectforeground='black')

    def _populate_dependency_combobox(self):
        all_cards = []
        for board_name, lists in self.app.boodesk_data["boards"].items():
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                for i, card_data in enumerate(cards):
                    # Don't allow a card to be a dependency of itself or an archived card
                    if card_data.get("card_id") != self.card.get("card_id") and not card_data.get("is_archived", False):
                        all_cards.append(f"{board_name} > {list_name} > {card_data['title']}")
        self.dependency_combo['values'] = sorted(list(set(all_cards)))

    def _add_dependency(self):
        selected_dependency_str = self.dependency_combo.get()
        if selected_dependency_str and selected_dependency_str not in self.card.get('dependencies', []):
            self.card.setdefault('dependencies', []).append(selected_dependency_str)
            self._populate_dependencies_listbox()
            self.dependency_combo.set("")

    def _remove_dependency(self):
        selected_index = self.dependencies_listbox.curselection()
        if selected_index:
            # Adjust index to account for header and separator
            actual_index = selected_index[0] - 2
            if actual_index >= 0 and actual_index < len(self.card.get('dependencies', [])):
                del self.card['dependencies'][actual_index]
                self._populate_dependencies_listbox()

    def _populate_dependencies_listbox(self):
        self.dependencies_listbox.delete(0, tk.END)
        dependencies = self.card.get('dependencies', [])
        
        if not dependencies:
            self.dependencies_listbox.insert(tk.END, "Nenhuma depend√™ncia adicionada")
            return
            
        # Add header with dependency status
        completed_deps = sum(1 for dep in dependencies if self.app._is_card_completed(dep))
        total_deps = len(dependencies)
        status_text = f"Depend√™ncias: {completed_deps}/{total_deps} Conclu√≠das"
        self.dependencies_listbox.insert(tk.END, status_text)
        self.dependencies_listbox.itemconfig(0, foreground='blue')
        
        # Add separator
        self.dependencies_listbox.insert(tk.END, "‚îÄ" * 50)
        self.dependencies_listbox.itemconfig(1, foreground='gray')
        
        # Add dependencies with detailed status
        for i, dep in enumerate(dependencies):
            is_completed = self.app._is_card_completed(dep)
            status = "Conclu√≠da" if is_completed else "Pendente"
            
            # Get card details for better display
            dep_parts = dep.split(" > ")
            if len(dep_parts) >= 3:
                board_name, list_name, card_title = dep_parts[0], dep_parts[1], dep_parts[2]
                # Check if card is in "Conclu√≠do" list
                if list_name == "Conclu√≠do":
                    status = "Conclu√≠da"
                else:
                    status = "Pendente"
                    
                display_text = f"{status} | {card_title} ({list_name})"
            else:
                display_text = f"{status} | {dep}"
                
            self.dependencies_listbox.insert(tk.END, display_text)
            listbox_index = i + 2  # +2 because of header and separator
            
            if is_completed:
                self.dependencies_listbox.itemconfig(listbox_index, foreground='green')
            else:
                self.dependencies_listbox.itemconfig(listbox_index, foreground='orange')
                
        # Add footer with card status
        if dependencies:
            can_start = all(self.app._is_card_completed(dep) for dep in dependencies)
            if can_start:
                self.dependencies_listbox.insert(tk.END, "Status: Card pode ser iniciado!")
                self.dependencies_listbox.itemconfig(len(dependencies) + 2, foreground='green')
            else:
                pending_count = total_deps - completed_deps
                self.dependencies_listbox.insert(tk.END, f"Status: Aguardando {pending_count} depend√™ncia(s)")
                self.dependencies_listbox.itemconfig(len(dependencies) + 2, foreground='orange')

    def save_card(self):
        # Capture original card state for history logging
        original_card = self.card.copy()
        original_card['subtasks'] = [st.copy() for st in self.card.get('subtasks', [])]
        original_card['dependencies'] = self.card.get('dependencies', []).copy()
        original_card['members'] = self.card.get('members', []).copy()

        title = self.title_entry.get()
        desc = self.desc_text.get("1.0", tk.END).strip()
        due_date_str = self.due_date_entry.get()
        importance = self.importance_combo.get()
        category = self.category_combo.get()
        goal = self.goal_combo.get()
        members = list(self.assigned_members_listbox.get(0, tk.END)) # Convert tuple to list

        if not title:
            messagebox.showwarning("Campo Obrigat√≥rio", "O t√≠tulo da tarefa √© obrigat√≥rio.")
            return

        full_due_date = due_date_str
        if self.include_time_var.get():
            hour = self.hour_entry.get().strip()
            minute = self.minute_entry.get().strip()
            if hour and minute:
                try:
                    h = int(hour)
                    m = int(minute)
                    if 0 <= h <= 23 and 0 <= m <= 59:
                        full_due_date = f"{due_date_str} {h:02d}:{m:02d}"
                    else:
                        messagebox.showwarning("Entrada Inv√°lida", "Hora ou minuto inv√°lidos.")
                        return
                except ValueError:
                    messagebox.showwarning("Entrada Inv√°lida", "Hora e minuto devem ser n√∫meros.")
                    return
            else:
                messagebox.showwarning("Entrada Inv√°lida", "Preencha a hora e o minuto ou desmarque 'Incluir Hor√°rio'.")
                return
        
        # Update card data
        self.card['title'] = title.upper()
        self.card['desc'] = desc
        self.card['due_date'] = full_due_date
        self.card['importance'] = importance
        self.card['category'] = category
        self.card['goal'] = goal
        self.card['members'] = members
        if self.app.settings.get('dev_mode', False):
            self.card['git_branch'] = self.git_branch_var.get()
            self.card['git_commit'] = self.git_commit_var.get()
            self.card['git_pr'] = self.git_pr_var.get()
        # Subtasks and dependencies are already updated directly in self.card by their respective methods

        # Log changes to history
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        user_name = self.current_user.username

        def add_history_entry(action_desc):
            self.card.setdefault('history', []).append({"timestamp": current_time, "action": action_desc, "user": user_name})

        # Title
        if self.card['title'] != original_card['title']:
            add_history_entry(f"T√≠tulo alterado de '{original_card['title']}' para '{self.card['title']}'.")

        # Description
        if self.card['desc'] != original_card['desc']:
            add_history_entry(f"Descri√ß√£o alterada.")

        # Due Date
        if self.card['due_date'] != original_card['due_date']:
            add_history_entry(f"Prazo alterado de '{original_card['due_date']}' para '{self.card['due_date']}'.")

        # Importance
        if self.card['importance'] != original_card['importance']:
            add_history_entry(f"Import√¢ncia alterada de '{original_card['importance']}' para '{self.card['importance']}'.")

        # Category
        if self.card['category'] != original_card.get('category', '-'):
            add_history_entry(f"Categoria alterada de '{original_card.get('category', '-')}' para '{self.card['category']}'.")

        # Goal
        if self.card['goal'] != original_card['goal']:
            add_history_entry(f"Objetivo alterado de '{original_card['goal']}' para '{self.card['goal']}'.")

        # Members
        added_members = [m for m in self.card['members'] if m not in original_card['members']]
        removed_members = [m for m in original_card['members'] if m not in self.card['members']]
        for member in added_members:
            add_history_entry(f"Membro '{member}' adicionado.")
        for member in removed_members:
            add_history_entry(f"Membro '{member}' removido.")

        # Subtasks (more complex, check for additions, removals, and completion changes)
        original_subtasks_map = {st['text']: st['completed'] for st in original_card.get('subtasks', [])}
        current_subtasks_map = {st['text']: st['completed'] for st in self.card.get('subtasks', [])}

        for subtask_text, completed_status in current_subtasks_map.items():
            if subtask_text not in original_subtasks_map:
                add_history_entry(f"Subtarefa '{subtask_text}' adicionada.")
            elif original_subtasks_map[subtask_text] != completed_status:
                status_change = "conclu√≠da" if completed_status else "reaberta"
                add_history_entry(f"Subtarefa '{subtask_text}' marcada como {status_change}.")
        
        for subtask_text in original_subtasks_map:
            if subtask_text not in current_subtasks_map:
                add_history_entry(f"Subtarefa '{subtask_text}' removida.")

        # Dependencies (check for additions and removals)
        added_dependencies = [d for d in self.card.get('dependencies', []) if d not in original_card.get('dependencies', [])]
        removed_dependencies = [d for d in original_card.get('dependencies', []) if d not in self.card.get('dependencies', [])]
        for dep in added_dependencies:
            add_history_entry(f"Depend√™ncia '{dep}' adicionada.")
        for dep in removed_dependencies:
            add_history_entry(f"Depend√™ncia '{dep}' removida.")

        # Find the card in the main data structure and update it
        found_card = False
        for i, card_data in enumerate(self.app.boodesk_data["boards"][self.board_name][self.list_name]):
            if card_data.get('card_id') == self.card_id:
                self.app.boodesk_data["boards"][self.board_name][self.list_name][i] = self.card
                found_card = True
                break
        
        if not found_card:
            messagebox.showerror("Erro", "N√£o foi poss√≠vel encontrar o cart√£o para salvar as altera√ß√µes.")
            return

        self.app.save_trello_data()
        
        # Sincronizar com Google Calendar se habilitado
        if self.app.settings.get('google_calendar_enabled', False):
            self._sync_card_to_calendar()
        
        if self.callback_on_close:
            self.callback_on_close(saved=True)
        self.destroy()

    def start_pomodoro_action(self):
        # Find the card index using card_id
        card_index = -1
        for i, card_data in enumerate(self.app.boodesk_data["boards"][self.board_name][self.list_name]):
            if card_data.get('card_id') == self.card_id:
                card_index = i
                break
        
        if card_index != -1:
            self.app.start_pomodoro_from_card(self.board_name, self.list_name, card_index)
        self.destroy()

    def complete_card_action(self):
        # Find the card index using card_id
        card_index = -1
        for i, card_data in enumerate(self.app.boodesk_data["boards"][self.board_name][self.list_name]):
            if card_data.get('card_id') == self.card_id:
                card_index = i
                break
        
        if card_index != -1:
            self.app.complete_trello_card(self.board_name, self.list_name, card_index)
        self.destroy()

    def _sync_card_to_calendar(self):
        """Sincroniza o card com o Google Calendar"""
        try:
            # Verificar se o Google Calendar est√° configurado
            if not hasattr(self.app, 'google_calendar') or not self.app.google_calendar.is_authenticated:
                print("Google Calendar n√£o est√° autenticado")
                return
            
            # Verificar se h√° data de vencimento
            if not self.card.get('due_date'):
                print("Card n√£o possui data de vencimento")
                return
            
            # Usar fun√ß√£o auxiliar para processar data brasileira
            event_datetime = self.app.parse_brazilian_date(self.card['due_date'])
            
            if not event_datetime:
                print(f"Formato de data inv√°lido: {self.card['due_date']}")
                return
            
            # Criar evento no Google Calendar
            event_title = f"üìã {self.card['title']}"
            event_description = f"""
Card: {self.card['title']}
Descri√ß√£o: {self.card.get('desc', 'Sem descri√ß√£o')}
Import√¢ncia: {self.card.get('importance', 'Normal')}
Assunto: {self.card.get('subject', '-')}
Objetivo: {self.card.get('goal', '-')}
Membros: {', '.join(self.card.get('members', []))}
Board: {self.board_name}
Lista: {self.list_name}
Card ID: {self.card_id}
            """.strip()
            
            # Definir dura√ß√£o do evento (1 hora por padr√£o)
            event_duration = timedelta(hours=1)
            
            # Coletar emails para o evento
            attendees = []
            
            # Adicionar emails padr√£o se habilitado
            calendar_settings = self.app.settings.get('calendar_integration', {})
            if calendar_settings.get('include_default_emails', True):
                default_emails = calendar_settings.get('default_emails', [])
                attendees.extend(default_emails)
            
            # Adicionar membros do card se habilitado
            if calendar_settings.get('include_card_members', True):
                card_members = self.card.get('members', [])
                for member in card_members:
                    # Buscar email do membro no arquivo de membros
                    member_email = self._get_member_email(member)
                    if member_email:
                        attendees.append(member_email)
            
            # Remover duplicatas
            attendees = list(set(attendees))
            
            # Criar evento
            success = self.app.google_calendar.create_event(
                title=event_title,
                description=event_description,
                start_datetime=event_datetime,
                duration=event_duration,
                card_id=self.card_id,
                attendees=attendees if attendees else None
            )
            
            if success:
                print(f"‚úÖ Evento criado no Google Calendar para o card: {self.card['title']}")
                # Adicionar ao hist√≥rico do card
                self.card.setdefault('history', []).append({
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "action": f"Evento criado no Google Calendar",
                    "user": self.current_user.username
                })
            else:
                print(f"‚ùå Erro ao criar evento no Google Calendar para o card: {self.card['title']}")
                
        except Exception as e:
            print(f"‚ùå Erro na sincroniza√ß√£o com Google Calendar: {e}")
            import traceback
            traceback.print_exc()

    def _get_member_email(self, member_name):
        """Busca o email de um membro no arquivo de membros"""
        try:
            if hasattr(self.app, 'members') and self.app.members:
                print(f"DEBUG: Buscando email para membro '{member_name}' (CardWindow)")
                print(f"DEBUG: Total de membros carregados: {len(self.app.members)}")
                for member in self.app.members:
                    print(f"DEBUG: Verificando membro: {member}")
                    if member.get('Membro') == member_name:
                        email = member.get('email', '')
                        print(f"DEBUG: Email encontrado para '{member_name}': {email}")
                        return email
                print(f"DEBUG: Membro '{member_name}' n√£o encontrado")
            else:
                print(f"DEBUG: Lista de membros n√£o dispon√≠vel ou vazia")
            return None
        except Exception as e:
            print(f"Erro ao buscar email do membro {member_name}: {e}")
            return None

    # Git Integration Methods
    def update_git_status(self):
        """Update the Git status display"""
        if hasattr(self, 'git_status_label'):
            if self.git_branch_var.get():
                self.git_status_label.config(text="Configurado", foreground="green")
            else:
                self.git_status_label.config(text="N√£o configurado", foreground="gray")
            
            # Update Git history
            if hasattr(self, 'git_history_text'):
                self.update_git_history()

    def update_git_history(self):
        """Update the Git history display"""
        if hasattr(self, 'git_history_text'):
            self.git_history_text.config(state="normal")
            self.git_history_text.delete("1.0", tk.END)
            
            history_text = "Hist√≥rico Git:\n"
            if self.git_branch_var.get():
                history_text += f"Branch: {self.git_branch_var.get()}\n"
            if self.git_commit_var.get():
                history_text += f"Commit: {self.git_commit_var.get()}\n"
            if self.git_pr_var.get():
                history_text += f"PR: {self.git_pr_var.get()}\n"
            
            if not any([self.git_branch_var.get(), self.git_commit_var.get(), self.git_pr_var.get()]):
                history_text += "Nenhuma informa√ß√£o Git dispon√≠vel"
            
            self.git_history_text.insert("1.0", history_text)
            self.git_history_text.config(state="disabled")

    def init_git_repo(self):
        """Initialize Git repository for this card"""
        try:
            import subprocess
            import os
            
            # Create a directory for this card's Git repo
            repo_dir = os.path.join(self.app.base_dir, f"git_repos/{self.card_id}")
            os.makedirs(repo_dir, exist_ok=True)
            
            # Initialize Git repository
            result = subprocess.run(['git', 'init'], cwd=repo_dir, capture_output=True, text=True)
            
            if result.returncode == 0:
                messagebox.showinfo("Git", "Reposit√≥rio Git inicializado com sucesso!")
                self.git_branch_var.set("main")
                self.update_git_status()
            else:
                messagebox.showerror("Erro Git", f"Erro ao inicializar reposit√≥rio: {result.stderr}")
                
        except Exception as e:
            messagebox.showerror("Erro Git", f"Erro ao inicializar reposit√≥rio Git: {e}")

    def create_git_branch(self):
        """Create a new Git branch for this card"""
        branch_name = simpledialog.askstring("Criar Branch", "Nome da nova branch:", parent=self)
        if branch_name:
            try:
                import subprocess
                import os
                
                repo_dir = os.path.join(self.app.base_dir, f"git_repos/{self.card_id}")
                
                if not os.path.exists(os.path.join(repo_dir, '.git')):
                    messagebox.showerror("Erro Git", "Reposit√≥rio Git n√£o inicializado. Use 'Inicializar Repo' primeiro.")
                    return
                
                # Create and checkout new branch
                result = subprocess.run(['git', 'checkout', '-b', branch_name], cwd=repo_dir, capture_output=True, text=True)
                
                if result.returncode == 0:
                    self.git_branch_var.set(branch_name)
                    self.update_git_status()
                    messagebox.showinfo("Git", f"Branch '{branch_name}' criada e ativada!")
                else:
                    messagebox.showerror("Erro Git", f"Erro ao criar branch: {result.stderr}")
                    
            except Exception as e:
                messagebox.showerror("Erro Git", f"Erro ao criar branch Git: {e}")

    def make_git_commit(self):
        """Make a Git commit for this card"""
        commit_message = simpledialog.askstring("Commit", "Mensagem do commit:", parent=self)
        if commit_message:
            try:
                import subprocess
                import os
                
                repo_dir = os.path.join(self.app.base_dir, f"git_repos/{self.card_id}")
                
                if not os.path.exists(os.path.join(repo_dir, '.git')):
                    messagebox.showerror("Erro Git", "Reposit√≥rio Git n√£o inicializado. Use 'Inicializar Repo' primeiro.")
                    return
                
                # Add all files and commit
                subprocess.run(['git', 'add', '.'], cwd=repo_dir, capture_output=True)
                result = subprocess.run(['git', 'commit', '-m', commit_message], cwd=repo_dir, capture_output=True, text=True)
                
                if result.returncode == 0:
                    # Get the commit hash
                    commit_result = subprocess.run(['git', 'rev-parse', 'HEAD'], cwd=repo_dir, capture_output=True, text=True)
                    if commit_result.returncode == 0:
                        commit_hash = commit_result.stdout.strip()[:8]  # First 8 characters
                        self.git_commit_var.set(commit_hash)
                        self.update_git_status()
                        messagebox.showinfo("Git", f"Commit realizado com sucesso!\nHash: {commit_hash}")
                    else:
                        messagebox.showinfo("Git", "Commit realizado com sucesso!")
                else:
                    messagebox.showerror("Erro Git", f"Erro ao fazer commit: {result.stderr}")
                    
            except Exception as e:
                messagebox.showerror("Erro Git", f"Erro ao fazer commit Git: {e}")

    def destroy(self):
        if self.callback_on_close:
            self.callback_on_close(saved=False)
        super().destroy()

    def _get_current_user_member(self):
        """Retorna o nome do membro associado ao usu√°rio logado"""
        try:
            if not self.current_user:
                return None
            
            username = self.current_user.username
            
            # Buscar o membro associado ao usu√°rio no banco SQLite
            import sqlite3
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            cursor.execute("SELECT member_id FROM users WHERE username = ?", (username,))
            result = cursor.fetchone()
            conn.close()
            
            if result and result[0]:
                member_id = result[0]
                # Buscar o nome do membro usando o member_id
                conn = sqlite3.connect('boodesk_new.db')
                cursor = conn.cursor()
                cursor.execute("SELECT name FROM members WHERE id = ?", (member_id,))
                member_result = cursor.fetchone()
                conn.close()
                
                if member_result:
                    member_name = member_result[0]
                    print(f"DEBUG: Usu√°rio {username} associado ao membro {member_name}")
                    return member_name
            
            print(f"DEBUG: Usu√°rio {username} n√£o tem membro associado")
            return None
            
        except Exception as e:
            print(f"DEBUG: Erro ao buscar membro do usu√°rio: {e}")
            return None

    # Chamar update_all_displays ap√≥s todos os m√©todos serem definidos
    def initialize_displays(self):
        """Inicializa todos os displays ap√≥s a classe estar completamente definida"""
        print("DEBUG: Chamando update_all_displays")
        self.update_all_displays()
        print("DEBUG: update_all_displays conclu√≠do")

class MembersWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Gerenciar Membros")
        self.geometry("800x600") # Increased size to accommodate email column
        self.resizable(True, True)  # Allow resizing
        self.minsize(700, 550)  # Minimum size
        self.transient(parent)
        self.grab_set()
        
        # Variables for edit mode
        self.edit_mode = False
        self.selected_member = None

        # Center the window on screen
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 800
        window_height = 600
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

        self.create_widgets()
        self._populate_members_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure main frame for better layout
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)  # List frame should expand
        
        # Title
        title_label = ttk.Label(main_frame, text="Gerenciamento de Membros", font=("Arial", 12, "bold"))
        title_label.grid(row=0, column=0, pady=(0, 10), sticky="w")

        # Member List Frame
        list_frame = ttk.LabelFrame(main_frame, text="Lista de Membros", padding="5")
        list_frame.grid(row=1, column=0, sticky="nsew", pady=(0, 10))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        self.members_tree = ttk.Treeview(list_frame, columns=("Membro", "Cargo", "Email"), show="headings")
        self.members_tree.heading("Membro", text="Membro")
        self.members_tree.heading("Cargo", text="Cargo")
        self.members_tree.heading("Email", text="Email")
        self.members_tree.column("Membro", width=150, anchor="w")
        self.members_tree.column("Cargo", width=100, anchor="w")
        self.members_tree.column("Email", width=200, anchor="w")
        self.members_tree.grid(row=0, column=0, sticky="nsew", pady=5)
        self.members_tree.bind("<<TreeviewSelect>>", self._on_member_select)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Membro", padding="10")
        entry_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        entry_frame.columnconfigure(1, weight=1) # Make entry expandable

        ttk.Label(entry_frame, text="Nome do Membro:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.member_name_entry = ttk.Entry(entry_frame)
        self.member_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(entry_frame, text="Cargo:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.role_combo = ttk.Combobox(entry_frame, values=list(self.app.settings["roles"].keys()), state="readonly")
        self.role_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        self.role_combo.set("Usu√°rio") # Default role

        ttk.Label(entry_frame, text="Email:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        self.email_entry = ttk.Entry(entry_frame)
        self.email_entry.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        
        # Adicionar instru√ß√£o sobre o email
        email_info = ttk.Label(entry_frame, text="(Opcional - usado para convites do Google Calendar)", 
                              font=("Arial", 8), foreground="gray")
        email_info.grid(row=3, column=0, columnspan=2, sticky="w", padx=5, pady=(0, 5))

        button_row = ttk.Frame(entry_frame)
        button_row.grid(row=4, column=0, columnspan=2, pady=5)
        button_row.columnconfigure(0, weight=1)
        button_row.columnconfigure(1, weight=1)
        
        ttk.Button(button_row, text="Adicionar Membro", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_member).grid(row=0, column=0, padx=2)
        ttk.Button(button_row, text="Limpar", image=self.app.icons.get('clear_icon'), compound=tk.LEFT, command=self._clear_form).grid(row=0, column=1, padx=2)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=3, column=0, pady=5, sticky="ew")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)
        
        ttk.Button(button_frame, text="Editar Membro", image=self.app.icons.get('edit_icon'), compound=tk.LEFT, command=self._edit_member).grid(row=0, column=0, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Remover Membro", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_member).grid(row=0, column=1, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Cadastrar Cargo", image=self.app.icons.get('settings_icon'), compound=tk.LEFT, command=self._open_roles_settings).grid(row=0, column=2, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Cadastrar Usu√°rio", image=self.app.icons.get('registration_icon'), compound=tk.LEFT, command=self._open_user_registration_for_member).grid(row=0, column=3, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Fechar", image=self.app.icons.get('cancel_icon'), compound=tk.LEFT, command=self.destroy).grid(row=0, column=4, padx=5, sticky="ew")

    def _open_roles_settings(self):
        """Open SettingsWindow and navigate to the Roles tab"""
        settings_window = SettingsWindow(self.master, self.app)
        settings_window.notebook.select(settings_window.roles_tab) # Select the roles tab
        self.master.wait_window(settings_window)
        
        # Refresh the roles combo after settings window is closed
        self.role_combo['values'] = list(self.app.settings["roles"].keys())
        if self.role_combo.get() not in self.app.settings["roles"]:
            self.role_combo.set("Usu√°rio")  # Reset to default if current role was removed
        # Tamb√©m atualizar combo de cargo na janela de usu√°rios
        try:
            if hasattr(self, 'cargo_combo') and self.cargo_combo:
                self.cargo_combo['values'] = list(self.app.settings["roles"].keys())
                if self.cargo_combo.get() not in self.cargo_combo['values'] and self.cargo_combo['values']:
                    self.cargo_combo.set(self.cargo_combo['values'][0])
        except Exception:
            pass

    def _open_user_registration_for_member(self):
        """Abre a tela de usu√°rios j√° com o membro selecionado"""
        try:
            selected_item = self.members_tree.selection()
            pre_member_id = None
            if selected_item:
                values = self.members_tree.item(selected_item, "values")
                member_name = values[0]
                # Buscar ID do membro por nome
                import sqlite3
                conn = sqlite3.connect('boodesk_new.db')
                cursor = conn.cursor()
                cursor.execute("SELECT id FROM members WHERE name = ?", (member_name,))
                row = cursor.fetchone()
                conn.close()
                if row:
                    pre_member_id = row[0]
            # Abrir a janela de usu√°rios passando app e o member_id
            UserRegistrationWindow(self.master, self.app.user_management if hasattr(self.app, 'user_management') else None, self.app.icons, app=self.app, preselected_member_id=pre_member_id)
        except Exception as e:
            print(f"DEBUG: Erro ao abrir cadastro de usu√°rio a partir de membros: {e}")

    def _populate_members_list(self):
        self.members_tree.delete(*self.members_tree.get_children())
        for index, row in self.app.members_df.iterrows():
            # Verificar se a coluna email existe, sen√£o usar string vazia
            email = row.get('email', '') if 'email' in row else ''
            self.members_tree.insert("", "end", values=(row['Membro'], row['Cargo'], email))

    def _add_member(self):
        new_member_name = self.member_name_entry.get().strip()
        new_member_role = self.role_combo.get()
        new_member_email = self.email_entry.get().strip()

        if not new_member_name:
            messagebox.showwarning("Entrada Inv√°lida", "O nome do membro n√£o pode estar vazio.")
            return

        # Verificar se o membro j√° existe no banco SQLite
        try:
            import sqlite3
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM members WHERE name = ?", (new_member_name,))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este membro j√° existe.")
                conn.close()
                return
            conn.close()
        except Exception as e:
            print(f"Erro ao verificar membro existente: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel verificar se o membro existe: {e}")
            return

        # Validar email se fornecido
        if new_member_email:
            import re
            email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
            if not email_pattern.match(new_member_email):
                messagebox.showwarning("Email Inv√°lido", "Por favor, insira um email v√°lido ou deixe em branco.")
                return

        # Adicionar membro diretamente no banco SQLite
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            # Verificar se o membro j√° existe
            cursor.execute("SELECT id FROM members WHERE name = ?", (new_member_name,))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este nome de membro j√° existe.")
                conn.close()
                return
            
            # Inserir novo membro
            cursor.execute("""
                INSERT INTO members (name, email, role, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?)
            """, (new_member_name, new_member_email, new_member_role, datetime.now(), datetime.now()))
            
            conn.commit()
            conn.close()
            
            # Recarregar membros na aplica√ß√£o principal
            self.app.load_members()
            self._populate_members_list()
            
        except Exception as e:
            print(f"Erro ao adicionar membro: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel adicionar o membro: {e}")
            return
        
        # Clear form
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usu√°rio") # Reset to default
        self.email_entry.delete(0, tk.END)
        self.edit_mode = False
        self.selected_member = None
        
        messagebox.showinfo("Sucesso", f"Membro '{new_member_name}' adicionado com sucesso!")
        self.app.populate_boards() # Refresh boards to update member filter options

    def _on_member_select(self, event):
        """Handle member selection in treeview"""
        selected_item = self.members_tree.selection()
        if selected_item:
            values = self.members_tree.item(selected_item, "values")
            self.selected_member = values[0]  # Member name
            # Populate entry fields for editing
            self.member_name_entry.delete(0, tk.END)
            self.member_name_entry.insert(0, values[0])
            self.role_combo.set(values[1])
            # Preencher email se existir
            if len(values) > 2:
                self.email_entry.delete(0, tk.END)
                self.email_entry.insert(0, values[2])
            else:
                self.email_entry.delete(0, tk.END)
            self.edit_mode = True
        else:
            self.edit_mode = False
            self.selected_member = None

    def _edit_member(self):
        """Edit selected member"""
        if not self.selected_member:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um membro para editar.")
            return

        new_member_name = self.member_name_entry.get().strip()
        new_member_role = self.role_combo.get()
        new_member_email = self.email_entry.get().strip()

        if not new_member_name:
            messagebox.showwarning("Entrada Inv√°lida", "O nome do membro n√£o pode estar vazio.")
            return

        # Check if new name conflicts with existing members (excluding current member)
        try:
            import sqlite3
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM members WHERE name = ? AND name != ?", (new_member_name, self.selected_member))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este nome de membro j√° existe.")
                conn.close()
                return
            conn.close()
        except Exception as e:
            print(f"Erro ao verificar membro existente: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel verificar se o membro existe: {e}")
            return

        # Validar email se fornecido
        if new_member_email:
            import re
            email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
            if not email_pattern.match(new_member_email):
                messagebox.showwarning("Email Inv√°lido", "Por favor, insira um email v√°lido ou deixe em branco.")
                return

        # Atualizar membro no banco SQLite
        try:
            import sqlite3
            from datetime import datetime
            
            conn = sqlite3.connect('boodesk_new.db')
            cursor = conn.cursor()
            
            # Verificar se o novo nome j√° existe (excluindo o membro atual)
            cursor.execute("SELECT id FROM members WHERE name = ? AND name != ?", (new_member_name, self.selected_member))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este nome de membro j√° existe.")
                conn.close()
                return
            
            # Atualizar membro
            cursor.execute("""
                UPDATE members 
                SET name = ?, email = ?, role = ?, updated_at = ?
                WHERE name = ?
            """, (new_member_name, new_member_email, new_member_role, datetime.now(), self.selected_member))
            
            conn.commit()
            conn.close()
            
            # Recarregar membros na aplica√ß√£o principal
            self.app.load_members()
            self._populate_members_list()
            
        except Exception as e:
            print(f"Erro ao atualizar membro: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel atualizar o membro: {e}")
            return
        
        # Clear form
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usu√°rio")
        self.email_entry.delete(0, tk.END)
        self.edit_mode = False
        self.selected_member = None
        
        messagebox.showinfo("Sucesso", f"Membro '{new_member_name}' atualizado com sucesso!")
        self.app.populate_boards()

    def _remove_member(self):
        selected_item = self.members_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um membro para remover.")
            return

        member_name_to_remove = self.members_tree.item(selected_item, "values")[0]
        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover '{member_name_to_remove}'?"):
            try:
                import sqlite3
                
                conn = sqlite3.connect('boodesk_new.db')
                cursor = conn.cursor()
                
                # Remover membro do banco
                cursor.execute("DELETE FROM members WHERE name = ?", (member_name_to_remove,))
                
                conn.commit()
                conn.close()
                
                # Recarregar membros na aplica√ß√£o principal
                self.app.load_members()
                
            except Exception as e:
                print(f"Erro ao remover membro: {e}")
                messagebox.showerror("Erro", f"N√£o foi poss√≠vel remover o membro: {e}")
                return
            self._populate_members_list()
            
            # Clear form if the removed member was selected
            if self.selected_member == member_name_to_remove:
                self.member_name_entry.delete(0, tk.END)
                self.role_combo.set("Usu√°rio")
                self.edit_mode = False
                self.selected_member = None
            
            messagebox.showinfo("Sucesso", f"Membro '{member_name_to_remove}' removido com sucesso!")
            self.app.populate_boards() # Refresh boards to update member filter options

    def _clear_form(self):
        """Clear the form and reset to add mode"""
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usu√°rio")
        self.email_entry.delete(0, tk.END)
        self.edit_mode = False
        self.selected_member = None
        self.members_tree.selection_remove(*self.members_tree.selection())

    def toggle_always_on_top(self):
        self.app.root.attributes("-topmost", self.always_on_top_var.get())

class SubjectManagerWindow(tk.Toplevel):
    def __init__(self, parent, app, subject_type):
        super().__init__(parent)
        self.app = app
        self.subject_type = subject_type
        
        if self.subject_type == 'pomodoro':
            self.title("Gerenciar Assuntos do Pomodoro")
            self.subjects_df = self.app.pomodoro_subjects_df
            self.subjects_list = self.app.pomodoro_subjects
            self.file_path = self.app.pomodoro_subjects_file
        else: # boodesk
            self.title("Gerenciar Assuntos do Boodesk")
            self.subjects_df = self.app.boodesk_subjects_df
            self.subjects_list = self.app.boodesk_subjects
            self.file_path = self.app.boodesk_subjects_file

        self.geometry("450x350")
        self.transient(parent)
        self.grab_set()

        self.create_widgets()
        self._populate_subjects_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Listbox Frame
        list_frame = ttk.LabelFrame(main_frame, text="Assuntos Cadastrados")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        self.subjects_listbox = tk.Listbox(list_frame, selectmode=tk.SINGLE)
        self.subjects_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.subjects_listbox.bind("<<ListboxSelect>>", self._on_subject_select)
        
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.subjects_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.subjects_listbox.config(yscrollcommand=scrollbar.set)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Assunto")
        entry_frame.pack(fill=tk.X, pady=5)
        entry_frame.columnconfigure(0, weight=1)

        self.subject_entry = ttk.Entry(entry_frame)
        self.subject_entry.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        
        self.add_edit_button = ttk.Button(entry_frame, text="Adicionar", command=self._add_subject)
        self.add_edit_button.grid(row=0, column=1, padx=5, pady=5)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Remover Selecionado", command=self._remove_subject).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", command=self.destroy).pack(side=tk.RIGHT, padx=5)

    def _populate_subjects_list(self):
        self.subjects_listbox.delete(0, tk.END)
        # Sort the list for better UX
        for subject in sorted(self.subjects_list):
            if subject != '-': # Don't show the default '-'
                self.subjects_listbox.insert(tk.END, subject)

    def _on_subject_select(self, event):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            self.subject_entry.delete(0, tk.END)
            self.add_edit_button.config(text="Adicionar", command=self._add_subject)
            return
        
        selected_subject = self.subjects_listbox.get(selected_indices[0])
        self.subject_entry.delete(0, tk.END)
        self.subject_entry.insert(0, selected_subject)
        self.add_edit_button.config(text="Salvar Edi√ß√£o", command=self._edit_subject)

    def _clear_selection(self):
        self.subjects_listbox.selection_clear(0, tk.END)
        self.subject_entry.delete(0, tk.END)
        self.add_edit_button.config(text="Adicionar", command=self._add_subject)
        # Manually trigger the event handler to reset the button state
        self._on_subject_select(None)


    def _add_subject(self):
        new_subject = self.subject_entry.get().strip()
        if not new_subject:
            messagebox.showwarning("Entrada Inv√°lida", "O nome do assunto n√£o pode estar vazio.", parent=self)
            return
        
        if new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' j√° existe.", parent=self)
            return

        # Update DataFrame and list
        new_subject_df = pd.DataFrame({'Assunto': [new_subject]})
        self.subjects_df = pd.concat([self.subjects_df, new_subject_df], ignore_index=True)
        self.subjects_list.append(new_subject)
        
        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{new_subject}' adicionado.", parent=self)

    def _edit_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um assunto para editar.", parent=self)
            return
            
        old_subject = self.subjects_listbox.get(selected_indices[0])
        new_subject = self.subject_entry.get().strip()

        if not new_subject:
            messagebox.showwarning("Entrada Inv√°lida", "O nome do assunto n√£o pode estar vazio.", parent=self)
            return

        if new_subject != old_subject and new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' j√° existe.", parent=self)
            return

        # Update DataFrame and list
        self.subjects_df.loc[self.subjects_df['Assunto'] == old_subject, 'Assunto'] = new_subject
        self.subjects_list[self.subjects_list.index(old_subject)] = new_subject

        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{old_subject}' atualizado para '{new_subject}'.", parent=self)

    def _remove_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um assunto para remover.", parent=self)
            return

        subject_to_remove = self.subjects_listbox.get(selected_indices[0])
        
        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover o assunto '{subject_to_remove}'?\nIsso n√£o pode ser desfeito e n√£o alterar√° os cart√µes existentes.", parent=self):
            # Update DataFrame and list
            self.subjects_df = self.subjects_df[self.subjects_df['Assunto'] != subject_to_remove]
            self.subjects_list.remove(subject_to_remove)
            
            # Save and refresh
            self._save_and_refresh()
            self._clear_selection()
            messagebox.showinfo("Sucesso", f"Assunto '{subject_to_remove}' removido.", parent=self)

    def _save_and_refresh(self):
        # Save the DataFrame to the Excel file
        self.subjects_df.to_excel(self.file_path, index=False)
        
        # Update the main app's data
        if self.subject_type == 'pomodoro':
            self.app.pomodoro_subjects_df = self.subjects_df
            self.app.pomodoro_subjects = self.subjects_list
        else: # boodesk
            self.app.boodesk_subjects_df = self.subjects_df
            self.app.boodesk_subjects = self.subjects_list
            
        # Reload all auxiliary data in the main app to update all UI components
        self.app.load_aux_data()
        self.app.update_all_displays() # A comprehensive update
        
        # Refresh the listbox in this window
        self._populate_subjects_list()

    def destroy(self):
        # Ensure the main app window gets focus back
        self.app.root.focus_set()
        super().destroy()

class SettingsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Configura√ß√µes")
        self.geometry("1200x800")  # Tamanho maior para acomodar scrollbars
        self.resizable(True, True)  # Permitir redimensionamento
        self.transient(parent)
        self.grab_set()
        
        # Centralizar a janela na tela
        self.center_window()
        
        # Criar estilo vermelho para destacar a se√ß√£o de a√ß√µes
        style = ttk.Style()
        style.configure('Red.TFrame', background='#ffcccc')

        self.create_widgets()

    def center_window(self):
        """Centraliza a janela na tela - igual ao CardWindow"""
        self.update_idletasks()
        
        # Obter dimens√µes da tela
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Obter dimens√µes da janela
        window_width = self.winfo_width()
        window_height = self.winfo_height()
        
        # Calcular posi√ß√£o central
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        
        # Aplicar posi√ß√£o
        self.geometry(f"+{x}+{y}")

    def create_widgets(self):
        # Main container with proper layout - igual √† tela de cards
        main_container = ttk.Frame(self)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Configure main container for proper layout
        main_container.columnconfigure(0, weight=1)
        main_container.rowconfigure(0, weight=1)
        
        # === CONTENT FRAME (TOP) ===
        content_frame = ttk.Frame(main_container)
        content_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 10))
        content_frame.columnconfigure(0, weight=1)
        content_frame.rowconfigure(0, weight=1)
        
        # Configure grid for 2 columns
        content_frame.columnconfigure(0, weight=1)  # Left column
        content_frame.columnconfigure(1, weight=1)  # Right column
        content_frame.rowconfigure(0, weight=1)

        # === LEFT COLUMN ===
        left_frame = ttk.Frame(content_frame)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
        
        # Notebook principal
        self.notebook = ttk.Notebook(left_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)

        # Create tabs with scrollbars
        self.geral_tab = self.create_scrollable_tab("Geral")
        self.quadros_tab = self.create_scrollable_tab("Quadros")
        self.pomodoro_tab = self.create_scrollable_tab("Pomodoro")
        self.roles_tab = self.create_scrollable_tab("Cargos")
        self.dashboard_tab = self.create_scrollable_tab("Dashboard")
        self.calendar_tab = self.create_scrollable_tab("Calend√°rio")
        self.email_tab = self.create_scrollable_tab("Email")
        self.email_templates_tab = self.create_scrollable_tab("Templates de Email")

        # Create tab contents
        self.create_geral_tab()
        self.create_quadros_tab()
        self.create_pomodoro_tab()
        self.create_roles_tab()
        self.create_dashboard_tab()
        self.create_calendar_tab()
        self.create_email_tab()
        self.create_email_templates_tab()

        # === RIGHT COLUMN ===
        right_frame = ttk.Frame(content_frame)
        right_frame.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
        
        # Adicionar informa√ß√µes extras na coluna direita
        info_frame = ttk.LabelFrame(right_frame, text="Informa√ß√µes do Sistema", padding="10")
        info_frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(info_frame, text="Vers√£o do Sistema: 2.0", font=("Arial", 10, "bold")).pack(anchor="w", pady=5)
        ttk.Label(info_frame, text="Status: Ativo", font=("Arial", 9)).pack(anchor="w", pady=2)
        ttk.Label(info_frame, text="√öltima Atualiza√ß√£o: Hoje", font=("Arial", 9)).pack(anchor="w", pady=2)
        ttk.Label(info_frame, text="Configura√ß√µes Salvas: Sim", font=("Arial", 9)).pack(anchor="w", pady=2)
        
        # === BOTTOM ACTION BUTTONS (FIXED AT BOTTOM) ===
        # Bot√µes fixos na parte inferior - igual √† tela de cards
        button_frame = ttk.LabelFrame(main_container, text="A√ß√µes", padding="10")
        button_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(10, 0))
        
        # Configure button frame for proper layout
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        
        # Create buttons with better spacing and icons like in CardWindow
        restore_btn = ttk.Button(button_frame, text="üîÑ Restaurar Padr√µes", 
                                command=self.restore_defaults)
        restore_btn.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        cancel_btn = ttk.Button(button_frame, text="‚ùå Cancelar", 
                              command=self.destroy)
        cancel_btn.grid(row=0, column=1, sticky="ew", padx=(0, 5))
        
        save_btn = ttk.Button(button_frame, text="üíæ Salvar", 
                            command=self.save_settings)
        save_btn.grid(row=0, column=2, sticky="ew")
        
        # Add keyboard shortcuts
        self.bind('<Control-s>', lambda e: self.save_settings())
        self.bind('<Escape>', lambda e: self.destroy())
        self.bind('<Return>', lambda e: self.save_settings())
        
        # Focus on save button
        save_btn.focus_set()
        
        # For√ßar atualiza√ß√£o da interface
        self.update_idletasks()
        
        # Debug: verificar se os bot√µes foram criados
        print(f"DEBUG: Bot√µes criados - Restaurar: {restore_btn.winfo_exists()}, Cancelar: {cancel_btn.winfo_exists()}, Salvar: {save_btn.winfo_exists()}")
        print(f"DEBUG: Layout igual √† tela de cards - Bot√µes fixos na parte inferior")

    def create_scrollable_tab(self, tab_name):
        """Cria uma aba com scrollbar vertical e horizontal"""
        # Frame principal da aba
        tab_frame = ttk.Frame(self.notebook)
        
        # Canvas para scroll
        canvas = tk.Canvas(tab_frame, bg='white')
        scrollbar_y = ttk.Scrollbar(tab_frame, orient="vertical", command=canvas.yview)
        scrollbar_x = ttk.Scrollbar(tab_frame, orient="horizontal", command=canvas.xview)
        
        # Frame interno para o conte√∫do
        content_frame = ttk.Frame(canvas)
        
        # Configurar scroll
        canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        # Layout dos widgets
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar_y.pack(side="right", fill="y")
        scrollbar_x.pack(side="bottom", fill="x")
        
        # Criar janela no canvas
        canvas_window = canvas.create_window((0, 0), window=content_frame, anchor="nw")
        
        # Configurar redimensionamento
        def configure_scroll_region(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
        
        def configure_canvas_window(event):
            canvas.itemconfig(canvas_window, width=event.width)
        
        content_frame.bind("<Configure>", configure_scroll_region)
        canvas.bind("<Configure>", configure_canvas_window)
        
        # Adicionar aba ao notebook
        self.notebook.add(tab_frame, text=tab_name)
        
        # Retornar o frame de conte√∫do para ser usado pelas fun√ß√µes de cria√ß√£o
        return content_frame

    def create_geral_tab(self):
        frame = self.geral_tab
        frame.grid_columnconfigure(0, weight=1)

        ttk.Label(frame, text="Tema do Aplicativo:").pack(anchor="w", padx=10, pady=(10, 0))
        self.theme_combo = ttk.Combobox(frame, values=self.app.root.get_themes(), state="readonly")
        self.theme_combo.pack(fill="x", padx=10, pady=5)
        self.theme_combo.set(self.app.settings.get('theme', 'aquativo'))

        self.always_on_top_var = tk.BooleanVar()
        self.always_on_top_var.set(self.app.root.attributes("-topmost"))
        ttk.Checkbutton(frame, text="Sempre no topo", variable=self.always_on_top_var, command=self.toggle_always_on_top).pack(anchor="w", padx=10, pady=5)

        self.dev_mode_var = tk.BooleanVar()
        self.dev_mode_var.set(self.app.settings.get('dev_mode', False))
        ttk.Checkbutton(frame, text="Modo Desenvolvedor (Recursos √Ågeis)", variable=self.dev_mode_var).pack(anchor="w", padx=10, pady=5)

        self.git_integration_enabled_var = tk.BooleanVar()
        self.git_integration_enabled_var.set(self.app.settings.get('git_integration_enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integra√ß√£o Git (Modo Dev)", variable=self.git_integration_enabled_var).pack(anchor="w", padx=10, pady=5)

    def create_quadros_tab(self):
        frame = self.quadros_tab
        frame.grid_columnconfigure(1, weight=1)
        frame.grid_rowconfigure(2, weight=1)

        self.unify_subjects_var = tk.BooleanVar()
        self.unify_subjects_var.set(self.app.settings.get('unify_subjects', False))
        ttk.Checkbutton(frame, text="Unificar Assuntos (Boodesk e Pomodoro)", variable=self.unify_subjects_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)

        self.show_card_details_on_board_var = tk.BooleanVar()
        self.show_card_details_on_board_var.set(self.app.settings.get('show_card_details_on_board', False))
        ttk.Checkbutton(frame, text="Mostrar Detalhes do Cart√£o no Quadro (Respons√°vel, Cria√ß√£o)", variable=self.show_card_details_on_board_var).grid(row=1, column=0, columnspan=2, sticky="w", padx=10, pady=5)

        # Importance Levels Management
        importance_frame = ttk.LabelFrame(frame, text="Gerenciar N√≠veis de Import√¢ncia", padding=10)
        importance_frame.grid(row=2, column=0, columnspan=3, sticky="nsew", padx=10, pady=(15, 5))
        importance_frame.grid_columnconfigure(0, weight=1)

        self.importance_tree = ttk.Treeview(importance_frame, columns=("Nome", "Cor"), show="headings")
        self.importance_tree.heading("Nome", text="Nome")
        self.importance_tree.heading("Cor", text="Cor")
        self.importance_tree.column("Nome", width=150, anchor="w")
        self.importance_tree.column("Cor", width=100, anchor="center")
        self.importance_tree.pack(fill="both", expand=True, pady=5)
        self.importance_tree.bind("<Double-1>", self._edit_importance_color) # Double click to edit color

        importance_buttons_frame = ttk.Frame(importance_frame)
        importance_buttons_frame.pack(fill="x", pady=5)

        ttk.Button(importance_buttons_frame, text="Adicionar N√≠vel", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_importance_level).pack(side="left", padx=5)
        ttk.Button(importance_buttons_frame, text="‚ûñ Remover N√≠vel", command=self._remove_importance_level).pack(side="left", padx=5)

        self._populate_importance_treeview()

    def create_dashboard_tab(self):
        """Cria a aba de configura√ß√µes do dashboard"""
        frame = self.dashboard_tab
        frame.grid_columnconfigure(0, weight=1)
        
        # Widget settings
        widget_frame = ttk.LabelFrame(frame, text="Widgets do Dashboard", padding=10)
        widget_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Dashboard widget checkboxes
        self.dashboard_widget_vars = {}
        widget_settings = self.app.settings.get('dashboard_widgets', {})
        
        widgets = [
            ('overview', 'Vis√£o Geral'),
            ('urgent_tasks', 'Tarefas Urgentes'),
            ('upcoming_deadlines', 'Pr√≥ximos Prazos'),
            ('recent_activities', 'Atividades Recentes'),
            ('quick_links', 'Links Frequentes'),
            ('quick_actions', 'A√ß√µes R√°pidas'),
            ('meeting_widget', 'Widget de Reuni√µes')
        ]
        
        for i, (widget_key, widget_name) in enumerate(widgets):
            if widget_key == 'meeting_widget':
                var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['show_widget'])
            else:
                var = tk.BooleanVar(value=widget_settings.get(widget_key, True))
            self.dashboard_widget_vars[widget_key] = var
            ttk.Checkbutton(widget_frame, text=widget_name, variable=var).pack(anchor=tk.W, pady=2)
        
        # Preview button
        ttk.Button(frame, text="Visualizar Dashboard", 
                  command=self.preview_dashboard_settings).pack(pady=10)

    def create_calendar_tab(self):
        """Cria a aba de configura√ß√µes de calend√°rio"""
        frame = self.calendar_tab
        frame.grid_columnconfigure(1, weight=1)
        
        calendar_settings = self.app.settings.get('calendar_integration', {})
        
        # Enable calendar integration
        self.calendar_enabled_var = tk.BooleanVar(value=calendar_settings.get('enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integra√ß√£o com Google Calendar", 
                       variable=self.calendar_enabled_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)
        
        # Tipo de autentica√ß√£o
        ttk.Label(frame, text="Tipo de Autentica√ß√£o:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        auth_frame = ttk.Frame(frame)
        auth_frame.grid(row=1, column=1, sticky="w", padx=10, pady=5)
        
        self.auth_type_var = tk.StringVar(value=calendar_settings.get('auth_type', 'json'))
        print(f"DEBUG: auth_type_var inicializado com: {self.auth_type_var.get()}")
        
        json_radio = ttk.Radiobutton(auth_frame, text="Arquivo JSON", 
                       variable=self.auth_type_var, value="json", 
                       command=self.toggle_auth_methods)
        json_radio.pack(side=tk.LEFT, padx=5)
        print("DEBUG: Radio button JSON criado")
        
        key_radio = ttk.Radiobutton(auth_frame, text="ID e Chave Privada", 
                       variable=self.auth_type_var, value="key", 
                       command=self.toggle_auth_methods)
        key_radio.pack(side=tk.LEFT, padx=5)
        print("DEBUG: Radio button ID/Chave criado")
        
        # Frame para arquivo JSON
        self.json_frame = ttk.LabelFrame(frame, text="Arquivo JSON de Credenciais", padding=10)
        self.json_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        self.json_frame.columnconfigure(1, weight=1)
        
        ttk.Label(self.json_frame, text="Arquivo:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        json_credentials_frame = ttk.Frame(self.json_frame)
        json_credentials_frame.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        json_credentials_frame.columnconfigure(0, weight=1)
        
        self.credentials_file_var = tk.StringVar(value=calendar_settings.get('credentials_file', ''))
        self.credentials_entry = ttk.Entry(json_credentials_frame, textvariable=self.credentials_file_var, width=50)
        self.credentials_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        ttk.Button(json_credentials_frame, text="Procurar", 
                  command=self.browse_credentials_file).grid(row=0, column=1)
        
        # Frame para ID e chave privada
        self.key_frame = ttk.LabelFrame(frame, text="ID e Chave Privada", padding=10)
        self.key_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        self.key_frame.columnconfigure(1, weight=1)
        
        ttk.Label(self.key_frame, text="Client ID:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.client_id_var = tk.StringVar(value=calendar_settings.get('client_id', ''))
        self.client_id_entry = ttk.Entry(self.key_frame, textvariable=self.client_id_var, width=50)
        self.client_id_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.key_frame, text="Client Secret:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.client_secret_var = tk.StringVar(value=calendar_settings.get('client_secret', ''))
        self.client_secret_entry = ttk.Entry(self.key_frame, textvariable=self.client_secret_var, width=50, show="*")
        self.client_secret_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        
        # Bot√£o para mostrar/ocultar senha
        self.show_secret_var = tk.BooleanVar()
        ttk.Checkbutton(self.key_frame, text="Mostrar chave", 
                       variable=self.show_secret_var, 
                       command=self.toggle_secret_visibility).grid(row=1, column=2, padx=5, pady=2)
        
        # Instru√ß√µes
        instructions_frame = ttk.LabelFrame(frame, text="Instru√ß√µes Para configurar o Google Calendar:", padding=10)
        instructions_frame.grid(row=4, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        instructions = [
            "1. Acesse https://console.developers.google.com/",
            "2. Crie um novo projeto ou selecione um existente",
            "3. Ative a Google Calendar API",
            "4. Crie credenciais OAuth 2.0",
            "5. Baixe o arquivo JSON OU copie o Client ID e Secret",
            "6. Configure acima usando JSON ou ID/Chave"
        ]
        
        for instruction in instructions:
            ttk.Label(instructions_frame, text=instruction).pack(anchor="w", pady=1)
        
        # Sincroniza√ß√£o autom√°tica
        sync_frame = ttk.LabelFrame(frame, text="Sincroniza√ß√£o Autom√°tica", padding=10)
        sync_frame.grid(row=5, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        self.sync_auto_var = tk.BooleanVar(value=calendar_settings.get('sync_auto', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar automaticamente", 
                       variable=self.sync_auto_var).pack(anchor=tk.W, pady=2)
        
        self.sync_cards_deadline_var = tk.BooleanVar(value=calendar_settings.get('sync_cards_deadline', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar cart√µes com prazo", 
                       variable=self.sync_cards_deadline_var).pack(anchor=tk.W, pady=2)
        
        self.sync_calendar_events_var = tk.BooleanVar(value=calendar_settings.get('sync_calendar_events', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar eventos do calend√°rio", 
                       variable=self.sync_calendar_events_var).pack(anchor=tk.W, pady=2)
        
        # Bot√µes de valida√ß√£o e teste
        test_frame = ttk.LabelFrame(frame, text="Valida√ß√£o e Teste", padding=10)
        test_frame.grid(row=6, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        test_buttons_frame = ttk.Frame(test_frame)
        test_buttons_frame.pack(fill=tk.X)
        
        ttk.Button(test_buttons_frame, text="üîç Validar Credenciais", 
                  command=self.validate_credentials).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(test_buttons_frame, text="üîÑ Testar Conex√£o", 
                  command=self.test_calendar_connection).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(test_buttons_frame, text="üìÇ Configurar Credenciais", 
                  command=self.open_credentials_config).pack(side=tk.LEFT, padx=5)
        
        # Status da valida√ß√£o
        self.validation_status_var = tk.StringVar(value="Status: N√£o verificado")
        ttk.Label(test_frame, textvariable=self.validation_status_var, 
                 font=("Arial", 9)).pack(anchor="w", pady=(10, 0))
        
        # Configurar navega√ß√£o com Enter
        self.setup_enter_navigation()
        
        # Inicializar visibilidade dos m√©todos de autentica√ß√£o
        print("DEBUG: Inicializando visibilidade dos m√©todos de autentica√ß√£o")
        self.toggle_auth_methods()
        print("DEBUG: Aba de calend√°rio criada com sucesso")
        print("üéØ OP√á√ÉO 'ID E CHAVE PRIVADA' DEVE APARECER NA ABA CALEND√ÅRIO!")
    
    def setup_enter_navigation(self):
        """Configura navega√ß√£o com Enter entre campos"""
        # Configurar Enter para navegar entre campos
        self.credentials_entry.bind('<Return>', lambda e: self.client_id_entry.focus())
        self.client_id_entry.bind('<Return>', lambda e: self.client_secret_entry.focus())
        self.client_secret_entry.bind('<Return>', lambda e: self.credentials_entry.focus())
    
    def toggle_auth_methods(self):
        """Alterna entre m√©todos de autentica√ß√£o"""
        print(f"DEBUG: toggle_auth_methods chamado - auth_type: {self.auth_type_var.get()}")
        if self.auth_type_var.get() == 'json':
            print("DEBUG: Mostrando frame JSON, ocultando frame Key")
            self.json_frame.grid()
            self.key_frame.grid_remove()
        else:
            print("DEBUG: Mostrando frame Key, ocultando frame JSON")
            self.json_frame.grid_remove()
            self.key_frame.grid()
    
    def toggle_secret_visibility(self):
        """Alterna visibilidade da chave privada"""
        if self.show_secret_var.get():
            self.client_secret_entry.config(show="")
        else:
            self.client_secret_entry.config(show="*")
    
    def browse_credentials_file(self):
        """Abre di√°logo para selecionar arquivo de credenciais"""
        from tkinter import filedialog
        file_path = filedialog.askopenfilename(
            title="Selecionar arquivo de credenciais do Google Calendar",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if file_path:
            self.credentials_file_var.set(file_path)
    
    def validate_credentials(self):
        """Valida as credenciais (JSON ou ID/Chave)"""
        auth_type = self.auth_type_var.get()
        
        if auth_type == 'json':
            self.validate_json_credentials()
        else:
            self.validate_key_credentials()
    
    def validate_json_credentials(self):
        """Valida o arquivo de credenciais JSON"""
        import json
        import os
        
        file_path = self.credentials_file_var.get()
        
        if not file_path:
            self.validation_status_var.set("Status: ‚ùå Nenhum arquivo selecionado")
            return
        
        if not os.path.exists(file_path):
            self.validation_status_var.set("Status: ‚ùå Arquivo n√£o encontrado")
            return
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            if 'installed' in data:
                client_info = data['installed']
                project_id = client_info.get('project_id', 'N/A')
                client_id = client_info.get('client_id', 'N/A')
                
                self.validation_status_var.set(f"Status: ‚úÖ JSON V√°lido - Projeto: {project_id}")
                messagebox.showinfo("Valida√ß√£o", 
                                  f"‚úÖ Arquivo de credenciais v√°lido!\n\n"
                                  f"üìù Projeto: {project_id}\n"
                                  f"üÜî Client ID: {client_id[:30]}...\n"
                                  f"üìè Tamanho: {os.path.getsize(file_path)} bytes")
                
            elif 'web' in data:
                client_info = data['web']
                project_id = client_info.get('project_id', 'N/A')
                client_id = client_info.get('client_id', 'N/A')
                
                self.validation_status_var.set(f"Status: ‚úÖ JSON V√°lido (Web) - Projeto: {project_id}")
                messagebox.showinfo("Valida√ß√£o", 
                                  f"‚úÖ Arquivo de credenciais v√°lido!\n\n"
                                  f"üìù Projeto: {project_id}\n"
                                  f"üÜî Client ID: {client_id[:30]}...\n"
                                  f"üìè Tamanho: {os.path.getsize(file_path)} bytes")
                
            else:
                self.validation_status_var.set("Status: ‚ùå Formato inv√°lido")
                messagebox.showerror("Erro", "‚ùå Arquivo n√£o cont√©m credenciais v√°lidas!\n\nO arquivo deve conter 'installed' ou 'web'")
                
        except json.JSONDecodeError:
            self.validation_status_var.set("Status: ‚ùå JSON inv√°lido")
            messagebox.showerror("Erro", "‚ùå Arquivo JSON inv√°lido!")
        except Exception as e:
            self.validation_status_var.set("Status: ‚ùå Erro ao ler arquivo")
            messagebox.showerror("Erro", f"‚ùå Erro ao ler arquivo: {e}")
    
    def validate_key_credentials(self):
        """Valida o ID e chave privada"""
        client_id = self.client_id_var.get().strip()
        client_secret = self.client_secret_var.get().strip()
        
        if not client_id:
            self.validation_status_var.set("Status: ‚ùå Client ID n√£o informado")
            messagebox.showerror("Erro", "‚ùå Client ID √© obrigat√≥rio!")
            return
        
        if not client_secret:
            self.validation_status_var.set("Status: ‚ùå Client Secret n√£o informado")
            messagebox.showerror("Erro", "‚ùå Client Secret √© obrigat√≥rio!")
            return
        
        # Validar formato do Client ID
        if not client_id.endswith('.apps.googleusercontent.com'):
            self.validation_status_var.set("Status: ‚ö†Ô∏è Client ID pode estar incorreto")
            messagebox.showwarning("Aviso", "‚ö†Ô∏è Client ID deve terminar com '.apps.googleusercontent.com'")
            return
        
        # Validar formato do Client Secret
        if len(client_secret) < 10:
            self.validation_status_var.set("Status: ‚ö†Ô∏è Client Secret pode estar incorreto")
            messagebox.showwarning("Aviso", "‚ö†Ô∏è Client Secret parece muito curto")
            return
        
        self.validation_status_var.set("Status: ‚úÖ ID e Chave v√°lidos")
        messagebox.showinfo("Valida√ß√£o", 
                          f"‚úÖ Credenciais v√°lidas!\n\n"
                          f"üÜî Client ID: {client_id[:30]}...\n"
                          f"üîê Client Secret: {client_secret[:10]}...\n"
                          f"üìù Tipo: ID e Chave Privada")
    
    def test_calendar_connection(self):
        """Testa a conex√£o com Google Calendar"""
        auth_type = self.auth_type_var.get()
        
        if auth_type == 'json':
            self.test_json_connection()
        else:
            self.test_key_connection()
    
    def test_json_connection(self):
        """Testa conex√£o usando arquivo JSON"""
        try:
            # Verificar se as bibliotecas est√£o instaladas
            try:
                from google.oauth2.credentials import Credentials
                from google_auth_oauthlib.flow import InstalledAppFlow
                from google.auth.transport.requests import Request
                from googleapiclient.discovery import build
                from googleapiclient.errors import HttpError
                import pickle
            except ImportError as e:
                messagebox.showerror("Erro", 
                                   f"‚ùå Bibliotecas n√£o instaladas: {e}\n\n"
                                   f"üí° Execute:\n"
                                   f"pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
                return
            
            # Verificar arquivo de credenciais
            file_path = self.credentials_file_var.get()
            if not file_path or not os.path.exists(file_path):
                messagebox.showerror("Erro", "‚ùå Arquivo de credenciais n√£o encontrado!\n\nSelecione um arquivo v√°lido primeiro.")
                return
            
            # Validar formato do arquivo JSON
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    json_data = json.load(f)
                
                if 'installed' not in json_data:
                    messagebox.showerror("Erro", "‚ùå Formato de arquivo inv√°lido!\n\nO arquivo deve conter credenciais OAuth 2.0 para aplica√ß√£o instalada.")
                    return
                    
            except json.JSONDecodeError:
                messagebox.showerror("Erro", "‚ùå Arquivo JSON inv√°lido!")
                return
            
            # Tentar autentica√ß√£o
            SCOPES = ['https://www.googleapis.com/auth/calendar']
            
            creds = None
            token_file = os.path.join(self.app.base_dir, 'test_token.pickle')
            
            if os.path.exists(token_file):
                try:
                    with open(token_file, 'rb') as token:
                        creds = pickle.load(token)
                except Exception as e:
                    print(f"Erro ao carregar token de teste: {e}")
                    creds = None
            
            if not creds or not creds.valid:
                if creds and creds.expired and creds.refresh_token:
                    try:
                        creds.refresh(Request())
                    except Exception as e:
                        print(f"Erro ao renovar token: {e}")
                        creds = None
                
                if not creds:
                    try:
                        flow = InstalledAppFlow.from_client_secrets_file(file_path, SCOPES)
                        creds = flow.run_local_server(port=0)
                        
                        # Salvar token de teste
                        with open(token_file, 'wb') as token:
                            pickle.dump(creds, token)
                    except Exception as e:
                        messagebox.showerror("Erro", f"‚ùå Erro na autentica√ß√£o OAuth:\n\n{e}")
                        return
            
            # Testar API
            service = build('calendar', 'v3', credentials=creds)
            
            try:
                calendar_list = service.calendarList().list().execute()
                calendars = calendar_list.get('items', [])
                
                if calendars:
                    self.validation_status_var.set("Status: ‚úÖ Conectado (JSON) - Calend√°rios dispon√≠veis")
                    messagebox.showinfo("Sucesso", 
                                      f"üéâ Conex√£o bem-sucedida!\n\n"
                                      f"üìÖ Calend√°rios encontrados: {len(calendars)}\n"
                                      f"üìù Primeiro calend√°rio: {calendars[0]['summary']}\n"
                                      f"üîó Tipo: Arquivo JSON")
                else:
                    self.validation_status_var.set("Status: ‚ö†Ô∏è Conectado (JSON) - Nenhum calend√°rio")
                    messagebox.showwarning("Aviso", "‚ö†Ô∏è Conex√£o bem-sucedida, mas nenhum calend√°rio encontrado!")
                    
            except HttpError as e:
                error_details = f"Erro {e.resp.status}: {e.content.decode()}"
                self.validation_status_var.set("Status: ‚ùå Erro de API (JSON)")
                messagebox.showerror("Erro de API", f"‚ùå Erro na API do Google Calendar:\n\n{error_details}")
                
        except Exception as e:
            self.validation_status_var.set("Status: ‚ùå Erro de conex√£o (JSON)")
            messagebox.showerror("Erro de Conex√£o", f"‚ùå Erro ao conectar com Google Calendar:\n\n{e}")
    
    def test_key_connection(self):
        """Testa conex√£o usando ID e chave privada"""
        try:
            # Verificar se as bibliotecas est√£o instaladas
            try:
                from google.oauth2.credentials import Credentials
                from google_auth_oauthlib.flow import InstalledAppFlow
                from google.auth.transport.requests import Request
                from googleapiclient.discovery import build
                from googleapiclient.errors import HttpError
                import pickle
            except ImportError as e:
                messagebox.showerror("Erro", 
                                   f"‚ùå Bibliotecas n√£o instaladas: {e}\n\n"
                                   f"üí° Execute:\n"
                                   f"pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
                return
            
            # Verificar credenciais
            client_id = self.client_id_var.get().strip()
            client_secret = self.client_secret_var.get().strip()
            
            if not client_id or not client_secret:
                messagebox.showerror("Erro", "‚ùå Client ID e Client Secret s√£o obrigat√≥rios!")
                return
            
            # Validar formato do Client ID
            if not client_id.endswith('.apps.googleusercontent.com'):
                messagebox.showwarning("Aviso", "‚ö†Ô∏è Client ID deve terminar com '.apps.googleusercontent.com'")
            
            # Validar formato do Client Secret
            if len(client_secret) < 10:
                messagebox.showwarning("Aviso", "‚ö†Ô∏è Client Secret parece muito curto")
            
            # Criar arquivo tempor√°rio de credenciais
            import tempfile
            import json
            
            temp_creds = {
                "installed": {
                    "client_id": client_id,
                    "client_secret": client_secret,
                    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                    "token_uri": "https://oauth2.googleapis.com/token",
                    "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                    "redirect_uris": ["http://localhost"]
                }
            }
            
            # Criar arquivo tempor√°rio
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                json.dump(temp_creds, f)
                temp_file = f.name
            
            try:
                # Tentar autentica√ß√£o
                SCOPES = ['https://www.googleapis.com/auth/calendar']
                
                creds = None
                token_file = os.path.join(self.app.base_dir, 'test_token.pickle')
                
                if os.path.exists(token_file):
                    try:
                        with open(token_file, 'rb') as token:
                            creds = pickle.load(token)
                    except Exception as e:
                        print(f"Erro ao carregar token de teste: {e}")
                        creds = None
                
                if not creds or not creds.valid:
                    if creds and creds.expired and creds.refresh_token:
                        try:
                            creds.refresh(Request())
                        except Exception as e:
                            print(f"Erro ao renovar token: {e}")
                            creds = None
                    
                    if not creds:
                        try:
                            flow = InstalledAppFlow.from_client_secrets_file(temp_file, SCOPES)
                            creds = flow.run_local_server(port=0)
                            
                            # Salvar token de teste
                            with open(token_file, 'wb') as token:
                                pickle.dump(creds, token)
                        except Exception as e:
                            messagebox.showerror("Erro", f"‚ùå Erro na autentica√ß√£o OAuth:\n\n{e}")
                            return
                
                # Testar API
                service = build('calendar', 'v3', credentials=creds)
                
                try:
                    calendar_list = service.calendarList().list().execute()
                    calendars = calendar_list.get('items', [])
                    
                    if calendars:
                        self.validation_status_var.set("Status: ‚úÖ Conectado (ID/Chave) - Calend√°rios dispon√≠veis")
                        messagebox.showinfo("Sucesso", 
                                          f"üéâ Conex√£o bem-sucedida!\n\n"
                                          f"üìÖ Calend√°rios encontrados: {len(calendars)}\n"
                                          f"üìù Primeiro calend√°rio: {calendars[0]['summary']}\n"
                                          f"üîó Tipo: ID e Chave Privada")
                    else:
                        self.validation_status_var.set("Status: ‚ö†Ô∏è Conectado (ID/Chave) - Nenhum calend√°rio")
                        messagebox.showwarning("Aviso", "‚ö†Ô∏è Conex√£o bem-sucedida, mas nenhum calend√°rio encontrado!")
                        
                except HttpError as e:
                    error_details = f"Erro {e.resp.status}: {e.content.decode()}"
                    self.validation_status_var.set("Status: ‚ùå Erro de API (ID/Chave)")
                    messagebox.showerror("Erro de API", f"‚ùå Erro na API do Google Calendar:\n\n{error_details}")
                    
            finally:
                # Limpar arquivo tempor√°rio
                try:
                    os.unlink(temp_file)
                except:
                    pass
                    
        except Exception as e:
            self.validation_status_var.set("Status: ‚ùå Erro de conex√£o (ID/Chave)")
            messagebox.showerror("Erro de Conex√£o", f"‚ùå Erro ao conectar com Google Calendar:\n\n{e}")
    
    def open_credentials_config(self):
        """Abre o configurador de credenciais"""
        try:
            import subprocess
            import sys
            
            # Tentar executar o configurador
            subprocess.Popen([sys.executable, "config_google_calendar.py"])
            
        except Exception as e:
            messagebox.showerror("Erro", 
                               f"‚ùå Erro ao abrir configurador: {e}\n\n"
                               f"üí° Execute manualmente:\n"
                               f"python config_google_calendar.py")

    def create_email_tab(self):
        """Cria a aba de configura√ß√µes de email"""
        frame = self.email_tab
        frame.grid_columnconfigure(1, weight=1)
        
        email_settings = self.app.settings.get('email_integration', {})
        
        # Enable email integration
        self.email_enabled_var = tk.BooleanVar(value=email_settings.get('enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integra√ß√£o de Email", 
                       variable=self.email_enabled_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)
        
        # Provider selection
        ttk.Label(frame, text="Provedor:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        self.email_provider_var = tk.StringVar(value=email_settings.get('provider', 'gmail'))
        provider_frame = ttk.Frame(frame)
        provider_frame.grid(row=1, column=1, sticky="w", padx=10, pady=5)
        
        ttk.Radiobutton(provider_frame, text="Gmail", 
                       variable=self.email_provider_var, value="gmail").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(provider_frame, text="Outlook", 
                       variable=self.email_provider_var, value="outlook").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(provider_frame, text="SMTP Personalizado", 
                       variable=self.email_provider_var, value="smtp").pack(side=tk.LEFT, padx=5)
        
        # Email credentials
        ttk.Label(frame, text="Email:").grid(row=2, column=0, sticky="w", padx=10, pady=5)
        self.email_address_entry = ttk.Entry(frame, width=50)
        self.email_address_entry.grid(row=2, column=1, sticky="ew", padx=10, pady=5)
        self.email_address_entry.insert(0, email_settings.get('email_address', ''))
        
        ttk.Label(frame, text="Senha:").grid(row=3, column=0, sticky="w", padx=10, pady=5)
        self.email_password_entry = ttk.Entry(frame, width=50, show="*")
        self.email_password_entry.grid(row=3, column=1, sticky="ew", padx=10, pady=5)
        self.email_password_entry.insert(0, email_settings.get('email_password', ''))
        
        ttk.Label(frame, text="Senha do App (Gmail):").grid(row=4, column=0, sticky="w", padx=10, pady=5)
        self.app_password_entry = ttk.Entry(frame, width=50, show="*")
        self.app_password_entry.grid(row=4, column=1, sticky="ew", padx=10, pady=5)
        self.app_password_entry.insert(0, email_settings.get('app_password', ''))
        
        # SMTP settings
        ttk.Label(frame, text="Servidor SMTP:").grid(row=5, column=0, sticky="w", padx=10, pady=5)
        self.smtp_server_entry = ttk.Entry(frame, width=50)
        self.smtp_server_entry.grid(row=5, column=1, sticky="ew", padx=10, pady=5)
        self.smtp_server_entry.insert(0, email_settings.get('smtp_server', 'smtp.gmail.com'))
        
        ttk.Label(frame, text="Porta SMTP:").grid(row=6, column=0, sticky="w", padx=10, pady=5)
        self.smtp_port_entry = ttk.Entry(frame, width=50)
        self.smtp_port_entry.grid(row=6, column=1, sticky="ew", padx=10, pady=5)
        self.smtp_port_entry.insert(0, str(email_settings.get('smtp_port', 587)))
        
        # Auto notifications
        notif_frame = ttk.LabelFrame(frame, text="Notifica√ß√µes Autom√°ticas", padding=10)
        notif_frame.grid(row=7, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        auto_notifications = email_settings.get('auto_notifications', {})
        
        self.notify_card_created_var = tk.BooleanVar(value=auto_notifications.get('card_created', True))
        ttk.Checkbutton(notif_frame, text="Cart√£o Criado", 
                       variable=self.notify_card_created_var).pack(anchor=tk.W, pady=2)
        
        self.notify_card_modified_var = tk.BooleanVar(value=auto_notifications.get('card_modified', True))
        ttk.Checkbutton(notif_frame, text="Cart√£o Modificado", 
                       variable=self.notify_card_modified_var).pack(anchor=tk.W, pady=2)
        
        self.notify_card_moved_var = tk.BooleanVar(value=auto_notifications.get('card_moved', True))
        ttk.Checkbutton(notif_frame, text="Cart√£o Movido", 
                       variable=self.notify_card_moved_var).pack(anchor=tk.W, pady=2)
        
        self.notify_deadline_reminder_var = tk.BooleanVar(value=auto_notifications.get('deadline_reminder', True))
        ttk.Checkbutton(notif_frame, text="Lembrete de Prazo", 
                       variable=self.notify_deadline_reminder_var).pack(anchor=tk.W, pady=2)
        
        self.notify_weekly_report_var = tk.BooleanVar(value=auto_notifications.get('weekly_report', True))
        ttk.Checkbutton(notif_frame, text="Relat√≥rio Semanal", 
                       variable=self.notify_weekly_report_var).pack(anchor=tk.W, pady=2)
        
        # Recipients
        ttk.Label(frame, text="Destinat√°rios (separados por v√≠rgula):").grid(row=8, column=0, sticky="w", padx=10, pady=5)
        self.recipients_entry = ttk.Entry(frame, width=50)
        self.recipients_entry.grid(row=8, column=1, sticky="ew", padx=10, pady=5)
        recipients = email_settings.get('notification_recipients', [])
        self.recipients_entry.insert(0, ', '.join(recipients))
        
        # Reminder settings
        reminder_frame = ttk.LabelFrame(frame, text="Configura√ß√µes de Lembrete", padding=10)
        reminder_frame.grid(row=9, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        ttk.Label(reminder_frame, text="Horas antes do prazo:").pack(anchor=tk.W, pady=2)
        self.reminder_hours_var = tk.StringVar(value=str(email_settings.get('deadline_reminder_hours', 24)))
        reminder_hours_spinbox = ttk.Spinbox(reminder_frame, from_=1, to=168, textvariable=self.reminder_hours_var, width=10)
        reminder_hours_spinbox.pack(anchor=tk.W, pady=2)
        
        # Weekly report settings
        report_frame = ttk.LabelFrame(frame, text="Relat√≥rio Semanal", padding=10)
        report_frame.grid(row=10, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        ttk.Label(report_frame, text="Dia da semana:").pack(anchor=tk.W, pady=2)

    def create_calendar_tab(self):
        """Cria a aba de configura√ß√µes do Google Calendar"""
        frame = self.calendar_tab
        frame.grid_columnconfigure(1, weight=1)
        
        calendar_settings = self.app.settings.get('google_calendar', {})
        
        # Enable Google Calendar integration
        self.calendar_enabled_var = tk.BooleanVar(value=calendar_settings.get('enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integra√ß√£o com Google Calendar", 
                       variable=self.calendar_enabled_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)
        
        # Credentials file
        ttk.Label(frame, text="Arquivo de Credenciais:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        self.credentials_file_var = tk.StringVar(value=calendar_settings.get('credentials_file', ''))
        credentials_frame = ttk.Frame(frame)
        credentials_frame.grid(row=1, column=1, sticky="ew", padx=10, pady=5)
        
        self.credentials_entry = ttk.Entry(credentials_frame, textvariable=self.credentials_file_var, width=40)
        self.credentials_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(credentials_frame, text="Procurar", command=self.browse_credentials_file).pack(side=tk.RIGHT, padx=(5, 0))
        
        # Instructions
        instructions_frame = ttk.LabelFrame(frame, text="Instru√ß√µes", padding=10)
        instructions_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        instructions_text = """
Para configurar o Google Calendar:

1. Acesse https://console.developers.google.com/
2. Crie um novo projeto ou selecione um existente
3. Ative a Google Calendar API
4. Crie credenciais OAuth 2.0
5. Baixe o arquivo JSON de credenciais
6. Selecione o arquivo acima
        """.strip()
        
        ttk.Label(instructions_frame, text=instructions_text, justify=tk.LEFT).pack(anchor=tk.W)
        
        # Auto sync settings
        sync_frame = ttk.LabelFrame(frame, text="Sincroniza√ß√£o Autom√°tica", padding=10)
        sync_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        self.auto_sync_var = tk.BooleanVar(value=calendar_settings.get('auto_sync', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar automaticamente", 
                       variable=self.auto_sync_var).pack(anchor=tk.W, pady=2)
        
        self.sync_cards_var = tk.BooleanVar(value=calendar_settings.get('sync_cards', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar cart√µes com prazo", 
                       variable=self.sync_cards_var).pack(anchor=tk.W, pady=2)
        
        self.sync_events_var = tk.BooleanVar(value=calendar_settings.get('sync_events', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar eventos do calend√°rio", 
                       variable=self.sync_events_var).pack(anchor=tk.W, pady=2)
        
        # Email management settings
        email_frame = ttk.LabelFrame(frame, text="Gerenciamento de Emails", padding=10)
        email_frame.grid(row=4, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        # Add default emails
        ttk.Label(email_frame, text="Emails Padr√£o (um por linha):").pack(anchor=tk.W, pady=(0, 5))
        
        email_text_frame = ttk.Frame(email_frame)
        email_text_frame.pack(fill=tk.X, pady=(0, 5))
        
        self.default_emails_text = tk.Text(email_text_frame, height=4, width=50)
        email_scrollbar = ttk.Scrollbar(email_text_frame, orient="vertical", command=self.default_emails_text.yview)
        self.default_emails_text.configure(yscrollcommand=email_scrollbar.set)
        
        self.default_emails_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        email_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Load existing emails
        default_emails = calendar_settings.get('default_emails', [])
        self.default_emails_text.insert("1.0", "\n".join(default_emails))
        
        # Email options
        email_options_frame = ttk.Frame(email_frame)
        email_options_frame.pack(fill=tk.X, pady=(5, 0))
        
        self.include_default_emails_var = tk.BooleanVar(value=calendar_settings.get('include_default_emails', True))
        ttk.Checkbutton(email_options_frame, text="Incluir emails padr√£o em todos os eventos", 
                       variable=self.include_default_emails_var).pack(side=tk.LEFT, padx=(0, 10))
        
        self.include_card_members_var = tk.BooleanVar(value=calendar_settings.get('include_card_members', True))
        ttk.Checkbutton(email_options_frame, text="Incluir membros do card automaticamente", 
                       variable=self.include_card_members_var).pack(side=tk.LEFT)
        
        # Instructions for emails
        email_instructions = ttk.LabelFrame(email_frame, text="Instru√ß√µes para Emails", padding=5)
        email_instructions.pack(fill=tk.X, pady=(10, 0))
        
        instructions_text = """
* Emails padr√£o: Ser√£o inclu√≠dos em todos os eventos criados
* Membros do card: Ser√£o adicionados automaticamente se tiverem email configurado
* Formato: um email por linha (exemplo@email.com)
* Os emails receber√£o convites autom√°ticos do Google Calendar
        """.strip()
        
        ttk.Label(email_instructions, text=instructions_text, justify=tk.LEFT, font=("TkDefaultFont", 8)).pack(anchor=tk.W)

    def create_email_templates_tab(self):
        """Cria a aba de gerenciamento de templates de email"""
        frame = self.email_templates_tab
        frame.grid_columnconfigure(1, weight=1)
        frame.grid_rowconfigure(2, weight=1)
        
        # Template selection
        ttk.Label(frame, text="Template:").grid(row=0, column=0, sticky="w", padx=10, pady=5)
        self.template_var = tk.StringVar()
        self.template_combo = ttk.Combobox(frame, textvariable=self.template_var, state="readonly", width=30)
        self.template_combo.grid(row=0, column=1, sticky="w", padx=10, pady=5)
        self.template_combo['values'] = self.app.email_template_manager.get_available_templates()
        self.template_combo.bind("<<ComboboxSelected>>", self.on_template_selected)
        
        # Template actions
        template_actions = ttk.Frame(frame)
        template_actions.grid(row=1, column=0, columnspan=2, sticky="w", padx=10, pady=5)
        
        ttk.Button(template_actions, text="Novo Template", command=self.create_new_template).pack(side=tk.LEFT, padx=2)
        ttk.Button(template_actions, text="Duplicar", command=self.duplicate_template).pack(side=tk.LEFT, padx=2)
        ttk.Button(template_actions, text="Excluir", command=self.delete_template).pack(side=tk.LEFT, padx=2)
        
        # Template editor
        editor_frame = ttk.LabelFrame(frame, text="Editor de Template", padding=10)
        editor_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", padx=10, pady=10)
        editor_frame.grid_columnconfigure(0, weight=1)
        editor_frame.grid_rowconfigure(1, weight=1)
        
        # Subject
        ttk.Label(editor_frame, text="Assunto:").grid(row=0, column=0, sticky="w", pady=(0, 5))
        self.subject_var = tk.StringVar()
        self.subject_entry = ttk.Entry(editor_frame, textvariable=self.subject_var, width=60)
        self.subject_entry.grid(row=0, column=1, sticky="ew", pady=(0, 5), padx=(10, 0))
        
        # Body
        ttk.Label(editor_frame, text="Corpo do Email:").grid(row=1, column=0, sticky="nw", pady=(0, 5))
        body_frame = ttk.Frame(editor_frame)
        body_frame.grid(row=1, column=1, sticky="nsew", padx=(10, 0))
        body_frame.grid_columnconfigure(0, weight=1)
        body_frame.grid_rowconfigure(0, weight=1)
        
        self.body_text = tk.Text(body_frame, height=15, width=60)
        body_scrollbar = ttk.Scrollbar(body_frame, orient="vertical", command=self.body_text.yview)
        self.body_text.configure(yscrollcommand=body_scrollbar.set)
        
        self.body_text.grid(row=0, column=0, sticky="nsew")
        body_scrollbar.grid(row=0, column=1, sticky="ns")
        
        # Variables help
        variables_frame = ttk.LabelFrame(frame, text="Vari√°veis Dispon√≠veis", padding=10)
        variables_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        variables_text = """
Vari√°veis que podem ser usadas nos templates:
{card_title} - T√≠tulo do cart√£o
{board_name} - Nome do quadro
{list_name} - Nome da lista
{card_description} - Descri√ß√£o do cart√£o
{due_date} - Data de vencimento
{importance} - N√≠vel de import√¢ncia
{member_name} - Nome do membro
{changes} - Lista de altera√ß√µes
{week_period} - Per√≠odo do relat√≥rio
{completed_tasks} - Tarefas conclu√≠das
{pending_tasks} - Tarefas pendentes
{total_pomodoro_time} - Tempo total de pomodoro
{productivity_score} - Score de produtividade
{important_completed_tasks} - Tarefas importantes conclu√≠das
{upcoming_deadlines} - Pr√≥ximos prazos
        """.strip()
        
        ttk.Label(variables_frame, text=variables_text, justify=tk.LEFT, font=("TkDefaultFont", 9)).pack(anchor=tk.W)
        
        # Save button
        save_frame = ttk.Frame(frame)
        save_frame.grid(row=4, column=0, columnspan=2, pady=10)
        
        ttk.Button(save_frame, text="Salvar Template", command=self.save_template).pack(side=tk.LEFT, padx=5)
        ttk.Button(save_frame, text="Testar Template", command=self.test_template).pack(side=tk.LEFT, padx=5)
        ttk.Button(save_frame, text="Restaurar Padr√£o", command=self.restore_default_template).pack(side=tk.LEFT, padx=5)

    def browse_credentials_file(self):
        """Abre di√°logo para selecionar arquivo de credenciais"""
        from tkinter import filedialog
        filename = filedialog.askopenfilename(
            title="Selecionar arquivo de credenciais",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if filename:
            self.credentials_file_var.set(filename)

    def on_template_selected(self, event=None):
        """Chamado quando um template √© selecionado"""
        template_name = self.template_var.get()
        if template_name:
            template = self.app.email_template_manager.get_template(template_name)
            if template:
                self.subject_var.set(template.get('subject', ''))
                self.body_text.delete("1.0", tk.END)
                self.body_text.insert("1.0", template.get('body', ''))

    def create_new_template(self):
        """Cria um novo template"""
        template_name = simpledialog.askstring("Novo Template", "Nome do template:")
        if template_name:
            if template_name in self.app.email_template_manager.get_available_templates():
                messagebox.showwarning("Aviso", "Template com este nome j√° existe!")
                return
            
            # Adicionar ao combo
            current_values = list(self.template_combo['values'])
            current_values.append(template_name)
            self.template_combo['values'] = current_values
            self.template_combo.set(template_name)
            
            # Limpar campos
            self.subject_var.set("")
            self.body_text.delete("1.0", tk.END)
            
            # Focar no campo de assunto
            self.subject_entry.focus()

    def duplicate_template(self):
        """Duplica o template selecionado"""
        current_template = self.template_var.get()
        if not current_template:
            messagebox.showwarning("Aviso", "Selecione um template para duplicar!")
            return
        
        new_name = simpledialog.askstring("Duplicar Template", f"Nome do novo template (baseado em {current_template}):")
        if new_name:
            if new_name in self.app.email_template_manager.get_available_templates():
                messagebox.showwarning("Aviso", "Template com este nome j√° existe!")
                return
            
            # Copiar template
            original_template = self.app.email_template_manager.get_template(current_template)
            self.app.email_template_manager.update_template(
                new_name, 
                original_template.get('subject', ''),
                original_template.get('body', '')
            )
            
            # Atualizar combo
            current_values = list(self.template_combo['values'])
            current_values.append(new_name)
            self.template_combo['values'] = current_values
            self.template_combo.set(new_name)

    def delete_template(self):
        """Exclui o template selecionado"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para excluir!")
            return
        
        if messagebox.askyesno("Confirmar", f"Tem certeza que deseja excluir o template '{template_name}'?"):
            # Remover template
            templates = self.app.email_template_manager.templates
            if template_name in templates:
                del templates[template_name]
                self.app.email_template_manager.save_templates()
            
            # Atualizar combo
            current_values = list(self.template_combo['values'])
            current_values.remove(template_name)
            self.template_combo['values'] = current_values
            self.template_combo.set("")
            
            # Limpar campos
            self.subject_var.set("")
            self.body_text.delete("1.0", tk.END)

    def save_template(self):
        """Salva o template atual"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para salvar!")
            return
        
        subject = self.subject_var.get().strip()
        body = self.body_text.get("1.0", tk.END).strip()
        
        if not subject:
            messagebox.showwarning("Aviso", "O assunto √© obrigat√≥rio!")
            return
        
        # Salvar template
        self.app.email_template_manager.update_template(template_name, subject, body)
        messagebox.showinfo("Sucesso", "Template salvo com sucesso!")

    def test_template(self):
        """Testa o template atual com dados de exemplo"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para testar!")
            return
        
        # Dados de exemplo
        test_variables = {
            'card_title': 'Tarefa de Exemplo',
            'board_name': 'Quadro de Teste',
            'list_name': 'Em Progresso',
            'card_description': 'Esta √© uma descri√ß√£o de exemplo',
            'due_date': '2024-01-15',
            'importance': 'Alta',
            'member_name': 'Jo√£o Silva',
            'changes': '- T√≠tulo alterado\n- Prazo atualizado',
            'week_period': '01/01/2024 - 07/01/2024',
            'completed_tasks': '5',
            'pending_tasks': '3',
            'total_pomodoro_time': '12h 30m',
            'productivity_score': '85',
            'important_completed_tasks': '- Tarefa importante 1\n- Tarefa importante 2',
            'upcoming_deadlines': '- Reuni√£o de equipe (15/01)\n- Relat√≥rio mensal (20/01)'
        }
        
        # Formatar template
        subject, body = self.app.email_template_manager.format_template(template_name, test_variables)
        
        # Mostrar preview
        preview_window = tk.Toplevel(self)
        preview_window.title("Preview do Template")
        preview_window.geometry("600x500")
        preview_window.transient(self)
        preview_window.grab_set()
        
        # Assunto
        ttk.Label(preview_window, text="Assunto:", font=("TkDefaultFont", 10, "bold")).pack(anchor="w", padx=10, pady=(10, 5))
        subject_text = tk.Text(preview_window, height=2, width=70)
        subject_text.pack(fill=tk.X, padx=10, pady=(0, 10))
        subject_text.insert("1.0", subject)
        subject_text.config(state="disabled")
        
        # Corpo
        ttk.Label(preview_window, text="Corpo:", font=("TkDefaultFont", 10, "bold")).pack(anchor="w", padx=10, pady=(10, 5))
        body_text = tk.Text(preview_window, height=20, width=70)
        body_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
        body_text.insert("1.0", body)
        body_text.config(state="disabled")
        
        # Bot√£o fechar
        ttk.Button(preview_window, text="Fechar", command=preview_window.destroy).pack(pady=10)

    def restore_default_template(self):
        """Restaura o template padr√£o"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para restaurar!")
            return
        
        if messagebox.askyesno("Confirmar", f"Tem certeza que deseja restaurar o template '{template_name}' para o padr√£o?"):
            # Recarregar templates padr√£o
            self.app.email_template_manager.load_templates()
            
            # Atualizar campos
            self.on_template_selected()
            
            messagebox.showinfo("Sucesso", "Template restaurado para o padr√£o!")

    def toggle_config_frames(self):
        self.report_day_var = tk.StringVar(value=email_settings.get('weekly_report_day', 'monday'))
        report_day_combo = ttk.Combobox(report_frame, textvariable=self.report_day_var, 
                                       values=['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
                                       state="readonly")
        report_day_combo.pack(anchor=tk.W, pady=2)
        
        ttk.Label(report_frame, text="Hor√°rio (HH:MM):").pack(anchor=tk.W, pady=2)
        self.report_time_var = tk.StringVar(value=email_settings.get('weekly_report_time', '09:00'))
        report_time_entry = ttk.Entry(report_frame, textvariable=self.report_time_var, width=10)
        report_time_entry.pack(anchor=tk.W, pady=2)
        
        # Test connection button
        ttk.Button(frame, text="Testar Conex√£o", 
                  command=self.test_email_connection).grid(row=11, column=0, columnspan=2, pady=10)

    def toggle_config_frames(self):
        """Alterna a visibilidade dos frames de configura√ß√£o"""
        if self.config_type_var.get() == "individual":
            self.individual_frame.grid()
            self.centralized_frame.grid_remove()
        else:
            self.individual_frame.grid_remove()
            self.centralized_frame.grid()

    def preview_dashboard_settings(self):
        """Mostra preview das configura√ß√µes do dashboard"""
        enabled_widgets = [name for key, var in self.dashboard_widget_vars.items() if var.get()]
        messagebox.showinfo("Preview Dashboard", 
                          f"Widgets habilitados:\n" + "\n".join([f"‚Ä¢ {name}" for name in enabled_widgets]))

    # Fun√ß√µes de teste e reautentica√ß√£o do Google Calendar removidas - integra√ß√£o desabilitada

    def test_email_connection(self):
        """Testa a conex√£o de email"""
        try:
            # Create temporary email integration for testing
            temp_email = EmailIntegration(self.app)
            temp_email.settings = {
                'enabled': True,
                'provider': self.email_provider_var.get(),
                'email_address': self.email_address_entry.get(),
                'email_password': self.email_password_entry.get(),
                'app_password': self.app_password_entry.get(),
                'smtp_server': self.smtp_server_entry.get(),
                'smtp_port': int(self.smtp_port_entry.get()),
                'demo_mode': True  # Use demo mode for testing
            }
            
            # Test with demo mode
            if temp_email.send_email("test@example.com", "Teste de Conex√£o", "Este √© um teste de conex√£o."):
                messagebox.showinfo("Teste de Conex√£o", "Conex√£o de email testada com sucesso (modo demo)!")
            else:
                messagebox.showerror("Erro de Conex√£o", "Falha ao testar conex√£o de email.")
                
        except Exception as e:
            messagebox.showerror("Erro de Conex√£o", f"Erro ao testar conex√£o: {e}")

    def create_pomodoro_tab(self):
        frame = self.pomodoro_tab
        frame.grid_columnconfigure(1, weight=1)

        ttk.Label(frame, text="Tempo do Pomodoro (minutos):").grid(row=0, column=0, sticky="w", padx=10, pady=(10, 2))
        self.pomodoro_entry = ttk.Spinbox(frame, from_=1, to=120, increment=1)
        self.pomodoro_entry.grid(row=0, column=1, sticky="ew", padx=10, pady=(10, 2))
        self.pomodoro_entry.set(self.app.settings['pomodoro'])

        ttk.Label(frame, text="Pausa Curta (minutos):").grid(row=1, column=0, sticky="w", padx=10, pady=2)
        self.short_break_entry = ttk.Spinbox(frame, from_=1, to=60, increment=1)
        self.short_break_entry.grid(row=1, column=1, sticky="ew", padx=10, pady=2)
        self.short_break_entry.set(self.app.settings['short_break'])

        ttk.Label(frame, text="Pausa Longa (minutos):").grid(row=2, column=0, sticky="w", padx=10, pady=2)
        self.long_break_entry = ttk.Spinbox(frame, from_=1, to=120, increment=1)
        self.long_break_entry.grid(row=2, column=1, sticky="ew", padx=10, pady=2)
        self.long_break_entry.set(self.app.settings['long_break'])

        ttk.Label(frame, text="Ciclos at√© a Pausa Longa:").grid(row=3, column=0, sticky="w", padx=10, pady=2)
        self.cycles_entry = ttk.Spinbox(frame, from_=1, to=10, increment=1)
        self.cycles_entry.grid(row=3, column=1, sticky="ew", padx=10, pady=2)
        self.cycles_entry.set(self.app.settings['cycles'])

    def _populate_importance_treeview(self):
        for i in self.importance_tree.get_children():
            self.importance_tree.delete(i)
        for name, color in self.app.settings["importance_colors"].items():
            self.importance_tree.insert("", "end", values=(name, color), tags=(name,))
            self.importance_tree.tag_configure(name, background=color)

    def _add_importance_level(self):
        new_name = simpledialog.askstring("Novo N√≠vel de Import√¢ncia", "Digite o nome para o novo n√≠vel de import√¢ncia:", parent=self)
        if new_name:
            new_name = new_name.strip()
            if new_name in self.app.settings["importance_colors"]:
                messagebox.showwarning("Nome Duplicado", f"O n√≠vel de import√¢ncia '{new_name}' j√° existe.", parent=self)
                return
            color_code = colorchooser.askcolor(title=f"Escolha a cor para {new_name}")
            if color_code[1]:
                self.app.settings["importance_colors"][new_name] = color_code[1]
                self._populate_importance_treeview()
            else:
                messagebox.showwarning("Cor N√£o Selecionada", "Nenhuma cor foi selecionada para o novo n√≠vel.", parent=self)

    def _remove_importance_level(self):
        selected_item = self.importance_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um n√≠vel de import√¢ncia para remover.", parent=self)
            return
        
        importance_name = self.importance_tree.item(selected_item, "values")[0]
        
        # Prevent removal of default importance levels
        default_importance_levels = self.app.get_default_settings()["importance_colors"].keys()
        if importance_name in default_importance_levels:
            messagebox.showwarning("N√≠vel Padr√£o", f"O n√≠vel de import√¢ncia '{importance_name}' √© padr√£o e n√£o pode ser removido.", parent=self)
            return

        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover o n√≠vel de import√¢ncia '{importance_name}'? Isso pode afetar cart√µes existentes.", parent=self):
            del self.app.settings["importance_colors"][importance_name]
            self._populate_importance_treeview()

    def _edit_importance_color(self, event):
        selected_item = self.importance_tree.selection()
        if not selected_item:
            return
        
        importance_name = self.importance_tree.item(selected_item, "values")[0]
        current_color = self.app.settings["importance_colors"][importance_name]

        color_code = colorchooser.askcolor(title=f"Escolha a nova cor para {importance_name}", initialcolor=current_color)
        if color_code[1]:
            self.app.settings["importance_colors"][importance_name] = color_code[1]
            self._populate_importance_treeview()

    def choose_color(self, importance, color_label):
        # This method is now deprecated but kept for compatibility if needed elsewhere
        color_code = colorchooser.askcolor(title=f"Escolha a cor para {importance}")
        if color_code[1]:
            color_label.config(bg=color_code[1], text=color_code[1])

    def create_roles_tab(self):
        frame = self.roles_tab
        frame.grid_columnconfigure(0, weight=1)
        frame.grid_rowconfigure(0, weight=1)

        roles_frame = ttk.LabelFrame(frame, text="Gerenciar Cargos", padding=10)
        roles_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        roles_frame.grid_columnconfigure(0, weight=1)

        self.roles_tree = ttk.Treeview(roles_frame, columns=("Nome", "Descri√ß√£o"), show="headings")
        self.roles_tree.heading("Nome", text="Nome")
        self.roles_tree.heading("Descri√ß√£o", text="Descri√ß√£o")
        self.roles_tree.column("Nome", width=150, anchor="w")
        self.roles_tree.column("Descri√ß√£o", width=300, anchor="w")
        self.roles_tree.pack(fill="both", expand=True, pady=5)
        self.roles_tree.bind("<Double-1>", self._edit_role_level) # Double click to edit

        roles_buttons_frame = ttk.Frame(roles_frame)
        roles_buttons_frame.pack(fill="x", pady=5)

        ttk.Button(roles_buttons_frame, text="Adicionar Cargo", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_role_level).pack(side="left", padx=5)
        ttk.Button(roles_buttons_frame, text="Remover Cargo", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_role_level).pack(side="left", padx=5)

        self.app.load_settings() # Ensure settings are up-to-date
        self._populate_roles_treeview()

    def _populate_roles_treeview(self):
        for i in self.roles_tree.get_children():
            self.roles_tree.delete(i)
        for name, desc in self.app.settings["roles"].items():
            self.roles_tree.insert("", "end", values=(name, desc), tags=(name,))

    def _add_role_level(self):
        new_name = simpledialog.askstring("Novo Cargo", "Digite o nome para o novo cargo:", parent=self)
        if new_name:
            new_name = new_name.strip()
            if new_name in self.app.settings["roles"]:
                messagebox.showwarning("Nome Duplicado", f"O cargo '{new_name}' j√° existe.", parent=self)
                return
            new_desc = simpledialog.askstring("Descri√ß√£o do Cargo", f"Digite a descri√ß√£o para o cargo '{new_name}':", parent=self)
            if new_desc is not None:
                self.app.settings["roles"][new_name] = new_desc.strip()
                self.app.save_settings_file()
                self._populate_roles_treeview()
            else:
                messagebox.showwarning("Descri√ß√£o Necess√°ria", "A descri√ß√£o do cargo √© necess√°ria.", parent=self)

    def _edit_role_level(self, event):
        selected_item = self.roles_tree.selection()
        if not selected_item:
            return
        
        role_name = self.roles_tree.item(selected_item, "values")[0]
        current_desc = self.app.settings["roles"][role_name]

        new_desc = simpledialog.askstring("Editar Cargo", f"Editar descri√ß√£o para '{role_name}':", initialvalue=current_desc, parent=self)
        if new_desc is not None:
            self.app.settings["roles"][role_name] = new_desc.strip()
            self.app.save_settings_file()
            self._populate_roles_treeview()

    def _remove_role_level(self):
        selected_item = self.roles_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um cargo para remover.", parent=self)
            return
        
        role_name = self.roles_tree.item(selected_item, "values")[0]
        
        # Prevent removal of default roles
        default_roles = self.app.get_default_settings()["roles"].keys()
        if role_name in default_roles:
            messagebox.showwarning("Cargo Padr√£o", f"O cargo '{role_name}' √© padr√£o e n√£o pode ser removido.", parent=self)
            return

        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover o cargo '{role_name}'?", parent=self):
            del self.app.settings["roles"][role_name]
            self.app.save_settings_file()
            self._populate_roles_treeview()

    def restore_defaults(self):
        if messagebox.askyesno("Restaurar Padr√µes", "Tem certeza que deseja restaurar todas as configura√ß√µes para os valores de f√°brica?"):
            self.app.settings = self.app.get_default_settings()
            self.app.save_settings_file()
            self.destroy()
            self.app.open_settings()

    def save_settings(self):
        try:
            # Verificar se as vari√°veis existem antes de acess√°-las
            if hasattr(self, 'pomodoro_entry'):
                pomodoro = int(self.pomodoro_entry.get())
                short_break = int(self.short_break_entry.get())
                long_break = int(self.long_break_entry.get())
                cycles = int(self.cycles_entry.get())

                if not all(x > 0 for x in [pomodoro, short_break, long_break, cycles]):
                    raise ValueError("Todos os valores devem ser maiores que zero.")

                self.app.settings['pomodoro'] = pomodoro
                self.app.settings['short_break'] = short_break
                self.app.settings['long_break'] = long_break
                self.app.settings['cycles'] = cycles

            # Configura√ß√µes gerais
            if hasattr(self, 'theme_combo'):
                self.app.settings['theme'] = self.theme_combo.get()
            if hasattr(self, 'unify_subjects_var'):
                self.app.settings['unify_subjects'] = self.unify_subjects_var.get()
            if hasattr(self, 'show_card_details_on_board_var'):
                self.app.settings['show_card_details_on_board'] = self.show_card_details_on_board_var.get()
            if hasattr(self, 'dev_mode_var'):
                self.app.settings['dev_mode'] = self.dev_mode_var.get()
            if hasattr(self, 'git_integration_enabled_var'):
                self.app.settings['git_integration_enabled'] = self.git_integration_enabled_var.get()

            # Save dashboard widget settings
            if hasattr(self, 'dashboard_widget_vars'):
                dashboard_widgets = {}
                for key, var in self.dashboard_widget_vars.items():
                    if key == 'meeting_widget':
                        # Salvar configura√ß√£o do widget de reuni√µes
                        self.app.notification_manager.notification_settings['show_widget'] = var.get()
                        self.app.notification_manager.save_notification_settings()
                    else:
                        dashboard_widgets[key] = var.get()
                
                self.app.settings['dashboard_widgets'] = dashboard_widgets

            # Save Google Calendar settings
            if hasattr(self, 'calendar_enabled_var'):
                calendar_settings = {
                    'enabled': self.calendar_enabled_var.get(),
                    'auth_type': self.auth_type_var.get() if hasattr(self, 'auth_type_var') else 'json',
                    'credentials_file': self.credentials_file_var.get() if hasattr(self, 'credentials_file_var') else '',
                    'client_id': self.client_id_var.get() if hasattr(self, 'client_id_var') else '',
                    'client_secret': self.client_secret_var.get() if hasattr(self, 'client_secret_var') else '',
                    'sync_auto': self.sync_auto_var.get() if hasattr(self, 'sync_auto_var') else True,
                    'sync_cards_deadline': self.sync_cards_deadline_var.get() if hasattr(self, 'sync_cards_deadline_var') else True,
                    'sync_calendar_events': self.sync_calendar_events_var.get() if hasattr(self, 'sync_calendar_events_var') else True
                }
                
                # Validar configura√ß√µes do Google Calendar antes de salvar
                if calendar_settings['enabled']:
                    if calendar_settings['auth_type'] == 'json':
                        if not calendar_settings['credentials_file'] or not os.path.exists(calendar_settings['credentials_file']):
                            messagebox.showerror("Erro", "‚ùå Arquivo de credenciais JSON n√£o encontrado!\n\nConfigure um arquivo v√°lido primeiro.")
                            return
                    elif calendar_settings['auth_type'] == 'key':
                        if not calendar_settings['client_id'].strip() or not calendar_settings['client_secret'].strip():
                            messagebox.showerror("Erro", "‚ùå Client ID e Client Secret s√£o obrigat√≥rios!\n\nConfigure as credenciais primeiro.")
                            return
                    else:
                        messagebox.showerror("Erro", "‚ùå Tipo de autentica√ß√£o inv√°lido!")
                        return
                
                self.app.settings['calendar_integration'] = calendar_settings

            # Save Google Calendar email settings
            if hasattr(self, 'default_emails_text'):
                # Get emails from text widget
                emails_text = self.default_emails_text.get("1.0", tk.END).strip()
                default_emails = [email.strip() for email in emails_text.split('\n') if email.strip()]
                
                # Validate email format
                import re
                email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
                valid_emails = []
                invalid_emails = []
                
                for email in default_emails:
                    if email_pattern.match(email):
                        valid_emails.append(email)
                    else:
                        invalid_emails.append(email)
                
                if invalid_emails:
                    messagebox.showwarning("Emails Inv√°lidos", 
                                         f"Os seguintes emails n√£o s√£o v√°lidos e ser√£o ignorados:\n{', '.join(invalid_emails)}")
                
                # Update calendar settings with email configuration
                calendar_settings.update({
                    'default_emails': valid_emails,
                    'include_default_emails': self.include_default_emails_var.get() if hasattr(self, 'include_default_emails_var') else True,
                    'include_card_members': self.include_card_members_var.get() if hasattr(self, 'include_card_members_var') else True
                })
                
                self.app.settings['calendar_integration'] = calendar_settings

            # Save email integration settings
            if hasattr(self, 'email_enabled_var'):
                recipients = [email.strip() for email in self.recipients_entry.get().split(',') if email.strip()]
                self.app.settings['email_integration'] = {
                                    'enabled': self.email_enabled_var.get() if hasattr(self, 'email_enabled_var') else False,
                'provider': self.email_provider_var.get() if hasattr(self, 'email_provider_var') else 'gmail',
                    'email_address': self.email_address_entry.get() if hasattr(self, 'email_address_entry') else '',
                    'email_password': self.email_password_entry.get() if hasattr(self, 'email_password_entry') else '',
                    'app_password': self.app_password_entry.get() if hasattr(self, 'app_password_entry') else '',
                    'smtp_server': self.smtp_server_entry.get() if hasattr(self, 'smtp_server_entry') else 'smtp.gmail.com',
                    'smtp_port': int(self.smtp_port_entry.get()) if hasattr(self, 'smtp_port_entry') else 587,
                                    'auto_notifications': {
                    'card_created': self.notify_card_created_var.get() if hasattr(self, 'notify_card_created_var') else True,
                    'card_modified': self.notify_card_modified_var.get() if hasattr(self, 'notify_card_modified_var') else True,
                    'card_moved': self.notify_card_moved_var.get() if hasattr(self, 'notify_card_moved_var') else True,
                    'deadline_reminder': self.notify_deadline_reminder_var.get() if hasattr(self, 'notify_deadline_reminder_var') else True,
                    'weekly_report': self.notify_weekly_report_var.get() if hasattr(self, 'notify_weekly_report_var') else True
                },
                    'notification_recipients': recipients,
                    'deadline_reminder_hours': int(self.reminder_hours_var.get()) if hasattr(self, 'reminder_hours_var') else 24,
                    'weekly_report_day': self.report_day_var.get() if hasattr(self, 'report_day_var') else 'monday',
                    'weekly_report_time': self.report_time_var.get() if hasattr(self, 'report_time_var') else '09:00'
                }

            # Roles are already updated directly by _add_role_level, _edit_role_level, _remove_role_level
            # No need to iterate self.color_labels anymore

            self.app.save_settings_file()
            
            # Apply dashboard widget settings
            self.app.apply_dashboard_widget_settings()
            self.app.change_theme(self.app.settings['theme'])
            self.app.load_aux_data()
            self.app.update_timer_display()
            
            # Preservar o estado do calend√°rio ANTES de atualizar os quadros
            calendar_state = None
            if hasattr(self.app, 'calendar_widget') and self.app.calendar_widget:
                try:
                    # Capturar estado atual do calend√°rio
                    calendar_state = {
                        'selected_date': self.app.calendar_widget.get_date(),
                        'current_month': datetime.now().strftime("%Y-%m-%d"),  # Usar data atual em vez de calevent_date
                        'events': [],
                        'calendar_width': self.app.calendar_widget.winfo_width(),
                        'calendar_height': self.app.calendar_widget.winfo_height(),
                        'calendar_geometry': self.app.calendar_widget.winfo_geometry()
                    }
                    
                    # Capturar eventos se existirem
                    if hasattr(self.app, 'events_tree') and self.app.events_tree:
                        events = []
                        for item in self.app.events_tree.get_children():
                            values = self.app.events_tree.item(item)['values']
                            events.append(values)
                        calendar_state['events'] = events
                        
                    # Capturar estado do painel de eventos
                    if hasattr(self.app, 'events_tree') and self.app.events_tree:
                        calendar_state['events_tree_width'] = self.app.events_tree.winfo_width()
                        calendar_state['events_tree_height'] = self.app.events_tree.winfo_height()
                        
                except Exception as e:
                    print(f"Erro ao capturar estado do calend√°rio: {e}")
                    calendar_state = None
            
            # Atualizar apenas os quadros sem recriar o calend√°rio
            self.app.populate_boards()
            self.app.update_legend()
            self.app.update_pomodoro_task_list()
            
            # Restaurar o estado do calend√°rio AP√ìS atualizar os quadros
            if calendar_state and hasattr(self.app, 'calendar_widget') and self.app.calendar_widget:
                try:
                    # Restaurar data selecionada
                    if calendar_state['selected_date']:
                        self.app.calendar_widget.selection_set(calendar_state['selected_date'])
                    
                    # Restaurar tamanho do calend√°rio se necess√°rio
                    if calendar_state.get('calendar_width') and calendar_state.get('calendar_height'):
                        try:
                            # For√ßar redimensionamento do calend√°rio
                            self.app.calendar_widget.configure(width=calendar_state['calendar_width'])
                            self.app.calendar_widget.update_idletasks()
                        except:
                            pass
                    
                    # Recarregar eventos do calend√°rio se necess√°rio
                    if hasattr(self.app, 'load_calendar_events'):
                        self.app.load_calendar_events()
                        
                    # For√ßar atualiza√ß√£o do layout
                    self.app.calendar_widget.update_idletasks()
                    if hasattr(self.app, 'events_tree') and self.app.events_tree:
                        self.app.events_tree.update_idletasks()
                        
                except Exception as e:
                    print(f"Erro ao restaurar estado do calend√°rio: {e}")
            
            self.destroy()
            messagebox.showinfo("Configura√ß√µes Salvas", "As configura√ß√µes foram salvas com sucesso!")

        except ValueError as e:
            messagebox.showerror("Erro", f"Por favor, insira valores num√©ricos v√°lidos e maiores que zero: {e}")

    def toggle_always_on_top(self):
        self.app.root.attributes("-topmost", self.always_on_top_var.get())

# Define CardDetailsWindow as an alias for CardWindow
CardDetailsWindow = CardWindow

class CategoriesManagerWindow:
    def __init__(self, parent, app):
        self.parent = parent
        self.app = app
        self.window = tk.Toplevel(parent)
        self.window.title("Gerenciar Categorias")
        self.window.geometry("600x500")
        self.window.transient(parent)
        self.window.grab_set()
        
        self.create_widgets()
    
    def create_widgets(self):
        """Cria widgets da janela de gerenciamento de categorias"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_label = ttk.Label(main_frame, text="Gerenciar Categorias", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Frame para lista de categorias
        list_frame = ttk.LabelFrame(main_frame, text="Categorias Cadastradas", padding="10")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Treeview para categorias
        columns = ("ID", "Nome", "Cor")
        self.categories_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=10)
        
        self.categories_tree.heading("ID", text="ID")
        self.categories_tree.heading("Nome", text="Nome")
        self.categories_tree.heading("Cor", text="Cor")
        
        self.categories_tree.column("ID", width=50, anchor="center")
        self.categories_tree.column("Nome", width=200, anchor="w")
        self.categories_tree.column("Cor", width=100, anchor="center")
        
        self.categories_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.categories_tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.categories_tree.configure(yscrollcommand=scrollbar.set)
        
        # Frame para adicionar/editar categoria
        edit_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Categoria", padding="10")
        edit_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Grid para campos
        edit_frame.columnconfigure(1, weight=1)
        
        # Nome da categoria
        ttk.Label(edit_frame, text="Nome:").grid(row=0, column=0, sticky="w", padx=(0, 10), pady=5)
        self.name_var = tk.StringVar()
        self.name_entry = ttk.Entry(edit_frame, textvariable=self.name_var, width=30)
        self.name_entry.grid(row=0, column=1, sticky="ew", padx=(0, 10), pady=5)
        
        # Cor da categoria
        ttk.Label(edit_frame, text="Cor:").grid(row=0, column=2, sticky="w", padx=(0, 10), pady=5)
        self.color_var = tk.StringVar(value="#3498db")
        self.color_entry = ttk.Entry(edit_frame, textvariable=self.color_var, width=10)
        self.color_entry.grid(row=0, column=3, sticky="w", padx=(0, 10), pady=5)
        
        # Bot√£o para escolher cor
        self.color_button = tk.Button(edit_frame, text="Escolher", 
                                     command=self.choose_color, bg=self.color_var.get())
        self.color_button.grid(row=0, column=4, padx=(0, 10), pady=5)
        
        # Bot√µes de a√ß√£o
        button_frame = ttk.Frame(edit_frame)
        button_frame.grid(row=1, column=0, columnspan=5, pady=10)
        
        ttk.Button(button_frame, text="Adicionar", 
                  command=self.add_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Editar", 
                  command=self.edit_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Remover", 
                  command=self.remove_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Limpar", 
                  command=self.clear_form).pack(side=tk.LEFT, padx=5)
        
        # Bot√µes principais
        main_button_frame = ttk.Frame(main_frame)
        main_button_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(main_button_frame, text="Fechar", 
                  command=self.window.destroy).pack(side=tk.RIGHT, padx=5)
        
        # Carregar categorias
        self.load_categories()
        
        # Bind para sele√ß√£o
        self.categories_tree.bind("<<TreeviewSelect>>", self.on_category_select)
    
    def load_categories(self):
        """Carrega as categorias na treeview"""
        # Limpar treeview
        for item in self.categories_tree.get_children():
            self.categories_tree.delete(item)
        
        # Adicionar categorias
        for category in self.app.categories:
            self.categories_tree.insert("", "end", values=(
                category['id'],
                category['name'],
                category['color']
            ))
    
    def choose_color(self):
        """Abre o seletor de cores"""
        try:
            from tkinter import colorchooser
            color = colorchooser.askcolor(title="Escolher Cor da Categoria")[1]
            if color:
                self.color_var.set(color)
                self.color_button.config(bg=color)
        except ImportError:
            messagebox.showwarning("Aviso", "Seletor de cores n√£o dispon√≠vel")
    
    def add_category(self):
        """Adiciona uma nova categoria"""
        name = self.name_var.get().strip()
        color = self.color_var.get().strip()
        
        if not name:
            messagebox.showwarning("Aviso", "Nome da categoria √© obrigat√≥rio!")
            return
        
        if not color:
            messagebox.showwarning("Aviso", "Cor da categoria √© obrigat√≥ria!")
            return
        
        # Verificar se j√° existe
        for category in self.app.categories:
            if category['name'].lower() == name.lower():
                messagebox.showwarning("Aviso", f"Categoria '{name}' j√° existe!")
                return
        
        # Gerar novo ID
        new_id = max([cat['id'] for cat in self.app.categories], default=0) + 1
        
        # Adicionar categoria
        new_category = {
            'id': new_id,
            'name': name,
            'color': color
        }
        
        self.app.categories.append(new_category)
        self.app.save_categories()
        self.load_categories()
        self.clear_form()
        
        messagebox.showinfo("Sucesso", f"Categoria '{name}' adicionada com sucesso!")
    
    def edit_category(self):
        """Edita a categoria selecionada"""
        selected = self.categories_tree.selection()
        if not selected:
            messagebox.showwarning("Aviso", "Selecione uma categoria para editar!")
            return
        
        name = self.name_var.get().strip()
        color = self.color_var.get().strip()
        
        if not name:
            messagebox.showwarning("Aviso", "Nome da categoria √© obrigat√≥rio!")
            return
        
        if not color:
            messagebox.showwarning("Aviso", "Cor da categoria √© obrigat√≥ria!")
            return
        
        # Obter categoria selecionada
        item = self.categories_tree.item(selected[0])
        category_id = item['values'][0]
        
        # Verificar se nome j√° existe (exceto para a categoria atual)
        for category in self.app.categories:
            if category['id'] != category_id and category['name'].lower() == name.lower():
                messagebox.showwarning("Aviso", f"Categoria '{name}' j√° existe!")
                return
        
        # Atualizar categoria
        for category in self.app.categories:
            if category['id'] == category_id:
                category['name'] = name
                category['color'] = color
                break
        
        self.app.save_categories()
        self.load_categories()
        self.clear_form()
        
        messagebox.showinfo("Sucesso", f"Categoria '{name}' atualizada com sucesso!")
    
    def remove_category(self):
        """Remove a categoria selecionada"""
        selected = self.categories_tree.selection()
        if not selected:
            messagebox.showwarning("Aviso", "Selecione uma categoria para remover!")
            return
        
        item = self.categories_tree.item(selected[0])
        category_id = item['values'][0]
        category_name = item['values'][1]
        
        if messagebox.askyesno("Confirmar", f"Tem certeza que deseja remover a categoria '{category_name}'?"):
            # Remover categoria
            self.app.categories = [cat for cat in self.app.categories if cat['id'] != category_id]
            self.app.save_categories()
            self.load_categories()
            self.clear_form()
            
            messagebox.showinfo("Sucesso", f"Categoria '{category_name}' removida com sucesso!")
    
    def clear_form(self):
        """Limpa o formul√°rio"""
        self.name_var.set("")
        self.color_var.set("#3498db")
        self.color_button.config(bg="#3498db")
        self.categories_tree.selection_remove(*self.categories_tree.selection())
    
    def on_category_select(self, event):
        """Chamado quando uma categoria √© selecionada"""
        selected = self.categories_tree.selection()
        if selected:
            item = self.categories_tree.item(selected[0])
            values = item['values']
            
            self.name_var.set(values[1])
            self.color_var.set(values[2])
            self.color_button.config(bg=values[2])

if __name__ == "__main__":
    try:
        # Sistema de controle de concorr√™ncia para o banco de dados
        print("üîí Iniciando controle de concorr√™ncia do banco de dados...")
        db_control = DatabaseConcurrencyControl('boodesk_new.db')
        
        # Tentar adquirir lock do banco
        if not db_control.acquire_lock(timeout=30):
            print("‚ùå N√£o foi poss√≠vel adquirir lock do banco de dados")
            print("üí° Verifique se h√° outras inst√¢ncias do app rodando")
            messagebox.showerror("Erro", "N√£o foi poss√≠vel acessar o banco de dados.\nVerifique se h√° outras inst√¢ncias do app rodando.")
            sys.exit(1)
        
        print("‚úÖ Lock do banco adquirido com sucesso")
        
        # Determine base_dir for icons
        if getattr(sys, 'frozen', False):
            base_dir = sys._MEIPASS
        else:
            base_dir = os.path.dirname(os.path.abspath(__file__))

        root = ThemedTk(theme="aquativo")
        
        # Configure main window to start maximized
        try:
            root.state('zoomed')  # Maximize the window on Windows
        except:
            try:
                root.attributes('-zoomed', True)  # Alternative for some Linux systems
            except:
                # Fallback: maximize using geometry
                root.update_idletasks()
                screen_width = root.winfo_screenwidth()
                screen_height = root.winfo_screenheight()
                root.geometry(f"{screen_width}x{screen_height}+0+0")
        
        root.resizable(True, True)  # Permitir redimensionamento
        
        # Load icons AFTER the root window is created
        app_icons = load_app_icons(base_dir)

        # Criar aplica√ß√£o sem usu√°rio inicial
        print("DEBUG: Criando aplica√ß√£o...")
        app = BoodeskApp(root, None, app_icons)
        root.app = app
        
        # Configurar protocolo de fechamento
        def on_closing_with_lock():
            """Handler de fechamento que libera o lock do banco"""
            try:
                print("üîì Liberando lock do banco de dados (fechamento)...")
                db_control.release_lock()
            except:
                pass
            app.on_closing()
        
        root.protocol("WM_DELETE_WINDOW", on_closing_with_lock)
        
        print("DEBUG: Aplica√ß√£o criada com sucesso")
        
        # Configurar sistema de login
        root.login_successful = False
        root.current_user = None
        print("DEBUG: Sistema de login configurado")
        
        # Criar janela de login de forma mais direta
        print("DEBUG: Criando janela de login...")
        
        # Criar uma janela de login simples e robusta
        login_window = tk.Toplevel()
        login_window.title("Login - Sistema Boodesk")
        login_window.geometry("400x300")
        login_window.resizable(False, False)
        
        # Centralizar na tela
        login_window.update_idletasks()
        x = (login_window.winfo_screenwidth() - 400) // 2
        y = (login_window.winfo_screenheight() - 300) // 2
        login_window.geometry(f"400x300+{x}+{y}")
        
        # For√ßar exibi√ß√£o
        login_window.lift()
        login_window.focus_force()
        login_window.deiconify()
        login_window.update()
        
        # Ocultar janela principal ap√≥s criar a janela de login
        root.withdraw()
        print("DEBUG: Janela principal ocultada")
        
        # Criar widgets b√°sicos
        frame = ttk.Frame(login_window, padding="20")
        frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(frame, text="Login - Sistema Boodesk", font=("Arial", 16, "bold")).pack(pady=20)
        ttk.Label(frame, text="Usu√°rio:").pack(pady=5)
        user_entry = ttk.Entry(frame, width=30)
        user_entry.pack(pady=5)
        ttk.Label(frame, text="Senha:").pack(pady=5)
        pass_entry = ttk.Entry(frame, show="*", width=30)
        pass_entry.pack(pady=5)
        
        def do_login():
            username = user_entry.get().strip()
            password = pass_entry.get()
            print(f"DEBUG: Tentativa de login - Usu√°rio: '{username}', Senha: '{password}'")
            
            if username and password:
                # Verificar se o usu√°rio existe no banco de dados
                try:
                    # Usar o banco de dados em vez do arquivo XLSX
                    user_data = app.db.get_user_by_username(username)
                    print(f"DEBUG: Usu√°rio encontrado no banco: {user_data is not None}")
                    
                    if user_data and user_data['password_hash'] == password:
                        # Verificar se o usu√°rio tem membro associado
                        if 'member_id' in user_data and user_data['member_id']:
                            # Criar usu√°rio manualmente
                            user = User(
                                username=user_data['username'],
                                role=user_data['role'],
                                cargo=user_data.get('cargo', 'Usu√°rio') if hasattr(user_data, 'get') else user_data['cargo'],
                                user_id=user_data.get('id', 1) if hasattr(user_data, 'get') else user_data['id']
                            )
                            user.is_authenticated = True
                            user.login_time = pd.Timestamp.now()
                            
                            root.login_successful = True
                            root.current_user = user
                            print(f"DEBUG: Login bem-sucedido para {username}")
                            login_window.destroy()
                        else:
                            print(f"DEBUG: Usu√°rio {username} n√£o tem membro associado")
                            messagebox.showerror("Erro", "Usu√°rio n√£o tem membro associado. Contate o administrador.")
                    else:
                        print(f"DEBUG: Usu√°rio n√£o encontrado ou senha incorreta")
                        messagebox.showerror("Erro", "Usu√°rio ou senha incorretos!")
                except Exception as e:
                    print(f"DEBUG: Erro no login: {e}")
                    messagebox.showerror("Erro", f"Erro no sistema de login: {e}")
            else:
                messagebox.showerror("Erro", "Preencha todos os campos!")
        
        def cancel():
            root.login_successful = False
            login_window.destroy()
        
        ttk.Button(frame, text="Entrar", command=do_login).pack(pady=10)
        ttk.Button(frame, text="Cancelar", command=cancel).pack(pady=5)
        
        # Focar no campo de usu√°rio
        user_entry.focus()
        
        # For√ßar exibi√ß√£o novamente ap√≥s criar widgets
        login_window.after(100, lambda: login_window.lift())
        login_window.after(200, lambda: login_window.focus_force())
        login_window.after(300, lambda: login_window.deiconify())
        
        print("DEBUG: Aguardando fechamento da janela de login...")
        try:
            root.wait_window(login_window)
            print("DEBUG: Janela de login fechada")
        except Exception as e:
            print(f"DEBUG: Erro ao aguardar janela de login: {e}")
            root.destroy()
        
        # Verificar se o login foi bem-sucedido
        print(f"DEBUG: login_successful = {root.login_successful}")
        print(f"DEBUG: current_user = {root.current_user}")
        
        if root.login_successful and root.current_user:
            print("DEBUG: Login bem-sucedido, configurando usu√°rio...")
            # Configurar usu√°rio na aplica√ß√£o
            app.current_user = root.current_user
            app.apply_role_permissions()
            
            # Adicionar m√©todo _get_current_user_member √† inst√¢ncia
            def _get_current_user_member(self):
                """Retorna o nome do membro associado ao usuario logado"""
                try:
                    if not self.current_user:
                        return None
                    
                    username = self.current_user.username
                    
                    # Buscar o membro associado ao usu√°rio no banco SQLite
                    import sqlite3
                    conn = sqlite3.connect('boodesk_new.db')
                    cursor = conn.cursor()
                    
                    cursor.execute("SELECT member_id FROM users WHERE username = ?", (username,))
                    result = cursor.fetchone()
                    conn.close()
                    
                    if result and result[0]:
                        member_id = result[0]
                        # Buscar o nome do membro usando o member_id
                        conn = sqlite3.connect('boodesk_new.db')
                        cursor = conn.cursor()
                        cursor.execute("SELECT name FROM members WHERE id = ?", (member_id,))
                        member_result = cursor.fetchone()
                        conn.close()
                        
                        if member_result:
                            member_name = member_result[0]
                            print(f"DEBUG: Usuario {username} associado ao membro {member_name}")
                            return member_name
                    
                    print(f"DEBUG: Usu√°rio {username} n√£o tem membro associado")
                    return None
                    
                except Exception as e:
                    print(f"DEBUG: Erro ao buscar membro do usu√°rio: {e}")
                    return None
            
            # Adicionar o m√©todo √† inst√¢ncia
            import types
            app._get_current_user_member = types.MethodType(_get_current_user_member, app)
            
            # Inicializar displays ap√≥s todos os m√©todos serem definidos
            print("DEBUG: Chamando update_all_displays")
            app.update_all_displays()
            print("DEBUG: update_all_displays conclu√≠do")
            
            # Aplicar tema salvo nas configura√ß√µes
            try:
                saved_theme = app.settings.get('theme', 'aquativo')
                print(f"DEBUG: Aplicando tema: {saved_theme}")
                app.root.set_theme(saved_theme)
                print("DEBUG: Tema aplicado com sucesso")
            except Exception as e:
                print(f"DEBUG: Erro ao aplicar tema: {e}")
            
            # Mostrar/ocultar aba do dashboard baseado no tipo de usu√°rio
            app.show_dashboard_for_admin()
            
            # Mostrar aplica√ß√£o principal
            print("DEBUG: Mostrando aplica√ß√£o principal...")
            root.deiconify()
            
            # Maximizar a janela principal
            try:
                root.state('zoomed')  # Windows
                print("DEBUG: Janela maximizada (Windows)")
            except:
                try:
                    root.attributes('-zoomed', True)  # Linux
                    print("DEBUG: Janela maximizada (Linux)")
                except:
                    # Fallback: maximizar usando geometry
                    root.update_idletasks()
                    screen_width = root.winfo_screenwidth()
                    screen_height = root.winfo_screenheight()
                    root.geometry(f"{screen_width}x{screen_height}+0+0")
                    print("DEBUG: Janela maximizada (Fallback)")
            
            # Mostrar notifica√ß√µes AP√ìS o login
            root.after(1000, app.show_deadline_notifications)
            
            root.mainloop()
        else:
            print("DEBUG: Login cancelado ou falhou, fechando aplica√ß√£o...")
            # Login cancelado ou falhou
            root.destroy()
        
        # Liberar lock do banco ao sair
        print("üîì Liberando lock do banco de dados...")
        db_control.release_lock()
            
    except Exception as e:
        import traceback
        error_msg = f"Ocorreu um erro inesperado: {e}\n\nDetalhes t√©cnicos:\n{traceback.format_exc()}"
        print(f"DEBUG: Erro completo: {error_msg}")
        messagebox.showerror("Erro Inesperado", f"Ocorreu um erro inesperado: {e}")
        
        # Liberar lock do banco em caso de erro
        try:
            print("üîì Liberando lock do banco de dados (erro)...")
            db_control.release_lock()
        except:
            pass
        
        # Tentar fechar a aplica√ß√£o de forma limpa
        try:
            root.destroy()
        except:
            pass

# ============================================================================
# MELHORIAS IMPLEMENTADAS - SISTEMA DE FILTRO INTELIGENTE E NOTIFICA√á√ïES
# ============================================================================

def get_boards_for_member(self, member_name):
    """Retorna apenas os quadros onde o membro participa de cards"""
    boards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards in board_data.items():
            if list_name == 'workflow':  # Ignorar metadados
                continue
            for card in cards:
                if member_name in card.get('members', []):
                    boards.append(board_name)
                    break  # Uma vez encontrado, n√£o precisa verificar mais cards
    return list(set(boards))  # Remove duplicatas

def _should_show_board_for_user_improved(self, board_name, current_user_member):
    """Vers√£o melhorada do filtro de quadros"""
    # Administradores veem todos os quadros
    if hasattr(self, 'current_user') and getattr(self.current_user, 'role', None) == 'admin':
        return True
    
    # Se n√£o h√° membro associado, mostrar apenas quadros principais
    if not current_user_member:
        return board_name in ["Quadro Principal", "Quadro Geral"]
    
    # Verificar se o membro participa de algum card no quadro
    board_data = self.boodesk_data.get("boards", {}).get(board_name, {})
    if isinstance(board_data, dict):
        for list_name, cards in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards:
                if current_user_member in card.get('members', []):
                    return True
    
    # Quadros especiais sempre vis√≠veis
    if board_name in ["Quadro Principal", "Quadro Geral"]:
        return True
    
    return False

def notify_member_added_to_card(self, card_id, member_name, added_by):
    """Notifica membro quando adicionado a um card"""
    card = self.get_card_by_id(card_id)
    if not card:
        return
    
    notification = {
        'type': 'member_added',
        'card_title': card['title'],
        'card_id': card_id,
        'member': member_name,
        'added_by': added_by,
        'board': card.get('board_name', ''),
        'list': card.get('list_name', ''),
        'timestamp': datetime.now().isoformat(),
        'read': False
    }
    
    # Salvar notifica√ß√£o no banco
    self.save_notification(notification)
    
    # Mostrar notifica√ß√£o na interface
    self.show_notification_popup(notification)

def show_notification_popup(self, notification):
    """Mostra popup de notifica√ß√£o"""
    popup = tk.Toplevel(self.root)
    popup.title("Nova Notifica√ß√£o")
    popup.geometry("400x200")
    
    message = f"Voc√™ foi adicionado ao card:\n'{notification['card_title']}'\n\nQuadro: {notification['board']}\nLista: {notification['list']}"
    
    ttk.Label(popup, text=message, wraplength=350).pack(pady=20)
    ttk.Button(popup, text="Ver Card", command=lambda: self.open_card(notification['card_id'])).pack(pady=10)
    ttk.Button(popup, text="Fechar", command=popup.destroy).pack(pady=5)

def save_notification(self, notification):
    """Salva notifica√ß√£o no banco de dados"""
    try:
        conn = sqlite3.connect('boodesk_new.db')
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO notifications (type, card_title, card_id, member, added_by, board, list_name, timestamp, read_status)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            notification['type'],
            notification['card_title'],
            notification['card_id'],
            notification['member'],
            notification['added_by'],
            notification['board'],
            notification['list'],
            notification['timestamp'],
            notification['read']
        ))
        
        conn.commit()
        conn.close()
        print(f"‚úÖ Notifica√ß√£o salva para {notification['member']}")
    except Exception as e:
        print(f"‚ùå Erro ao salvar notifica√ß√£o: {e}")

def create_member_dashboard(self, member_name):
    """Cria dashboard personalizado para o membro"""
    dashboard = {
        'my_cards': self.get_cards_by_member(member_name),
        'my_boards': self.get_boards_for_member(member_name),
        'pending_tasks': self.get_pending_tasks(member_name),
        'completed_tasks': self.get_completed_tasks(member_name),
        'recent_activities': self.get_recent_activities(member_name),
        'upcoming_deadlines': self.get_upcoming_deadlines(member_name)
    }
    return dashboard

def get_cards_by_member(self, member_name):
    """Retorna todos os cards onde o membro participa"""
    cards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards_list in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards_list:
                if member_name in card.get('members', []):
                    card['board_name'] = board_name
                    card['list_name'] = list_name
                    cards.append(card)
    return cards

def get_pending_tasks(self, member_name):
    """Retorna tarefas pendentes do membro"""
    return [card for card in self.get_cards_by_member(member_name) 
            if card.get('status') != 'done']

def get_completed_tasks(self, member_name, days=30):
    """Retorna tarefas completadas nos √∫ltimos X dias"""
    cutoff_date = datetime.now() - timedelta(days=days)
    completed = []
    for card in self.get_cards_by_member(member_name):
        if card.get('status') == 'done':
            completed_date = card.get('completed_at')
            if completed_date and completed_date > cutoff_date:
                completed.append(card)
    return completed

def get_upcoming_deadlines(self, member_name, days=7):
    """Retorna prazos pr√≥ximos do membro"""
    cutoff_date = datetime.now() + timedelta(days=days)
    upcoming = []
    for card in self.get_cards_by_member(member_name):
        deadline = card.get('deadline')
        if deadline and deadline <= cutoff_date and card.get('status') != 'done':
            upcoming.append(card)
    return upcoming

def log_activity(self, action, user, card_id=None, details=None):
    """Registra atividade no sistema"""
    activity = {
        'id': str(uuid.uuid4()),
        'action': action,
        'user': user,
        'card_id': card_id,
        'details': details,
        'timestamp': datetime.now().isoformat()
    }
    
    # Salvar no banco
    self.save_activity(activity)
    
    # Atualizar interface se necess√°rio
    self.update_activity_display()

def save_activity(self, activity):
    """Salva atividade no banco de dados"""
    try:
        conn = sqlite3.connect('boodesk_new.db')
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO activities (id, action, user, card_id, details, timestamp)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (
            activity['id'],
            activity['action'],
            activity['user'],
            activity['card_id'],
            activity['details'],
            activity['timestamp']
        ))
        
        conn.commit()
        conn.close()
        print(f"‚úÖ Atividade registrada: {activity['action']}")
    except Exception as e:
        print(f"‚ùå Erro ao salvar atividade: {e}")

def get_recent_activities(self, member_name, limit=10):
    """Retorna atividades recentes relacionadas ao membro"""
    try:
        conn = sqlite3.connect('boodesk_new.db')
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT action, details, timestamp FROM activities 
            WHERE user = ? OR details LIKE ?
            ORDER BY timestamp DESC LIMIT ?
        """, (member_name, f"%{member_name}%", limit))
        
        activities = cursor.fetchall()
        conn.close()
        
        return [{'action': a[0], 'details': a[1], 'timestamp': a[2]} for a in activities]
    except Exception as e:
        print(f"‚ùå Erro ao buscar atividades: {e}")
        return []

def update_activity_display(self):
    """Atualiza display de atividades na interface"""
    if hasattr(self, 'activity_frame'):
        # Limpar frame atual
        for widget in self.activity_frame.winfo_children():
            widget.destroy()
        
        # Obter atividades do usu√°rio atual
        current_user_member = self._get_current_user_member()
        activities = self.get_recent_activities(current_user_member, 5)
        
        # Criar lista de atividades
        for activity in activities:
            activity_text = f"{activity['action']} - {activity['timestamp']}"
            ttk.Label(self.activity_frame, text=activity_text).pack(anchor='w')

def get_member_metrics(self, member_name, period='month'):
    """Calcula m√©tricas de produtividade do membro"""
    start_date = self.get_period_start_date(period)
    
    metrics = {
        'cards_created': len(self.get_cards_created_by(member_name, start_date)),
        'cards_completed': len(self.get_cards_completed_by(member_name, start_date)),
        'average_completion_time': self.get_avg_completion_time(member_name, start_date),
        'productivity_score': self.calculate_productivity_score(member_name, start_date),
        'on_time_completion_rate': self.get_on_time_completion_rate(member_name, start_date),
        'active_boards': len(self.get_boards_for_member(member_name))
    }
    return metrics

def get_period_start_date(self, period):
    """Retorna data de in√≠cio do per√≠odo"""
    now = datetime.now()
    if period == 'week':
        return now - timedelta(days=7)
    elif period == 'month':
        return now - timedelta(days=30)
    elif period == 'quarter':
        return now - timedelta(days=90)
    else:
        return now - timedelta(days=365)

def get_cards_created_by(self, member_name, start_date):
    """Retorna cards criados pelo membro desde uma data"""
    cards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards_list in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards_list:
                if card.get('created_by') == member_name:
                    created_date = card.get('created_at')
                    if created_date and created_date >= start_date:
                        cards.append(card)
    return cards

def get_cards_completed_by(self, member_name, start_date):
    """Retorna cards completados pelo membro desde uma data"""
    cards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards_list in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards_list:
                if member_name in card.get('members', []) and card.get('status') == 'done':
                    completed_date = card.get('completed_at')
                    if completed_date and completed_date >= start_date:
                        cards.append(card)
    return cards

def get_avg_completion_time(self, member_name, start_date):
    """Calcula tempo m√©dio de conclus√£o"""
    completed_cards = self.get_cards_completed_by(member_name, start_date)
    if not completed_cards:
        return 0
    
    total_time = 0
    for card in completed_cards:
        created = card.get('created_at')
        completed = card.get('completed_at')
        if created and completed:
            try:
                created_dt = datetime.fromisoformat(created)
                completed_dt = datetime.fromisoformat(completed)
                total_time += (completed_dt - created_dt).total_seconds() / 3600  # em horas
            except:
                pass
    
    return total_time / len(completed_cards) if completed_cards else 0

def get_on_time_completion_rate(self, member_name, start_date):
    """Calcula taxa de conclus√£o no prazo"""
    completed_cards = self.get_cards_completed_by(member_name, start_date)
    if not completed_cards:
        return 0
    
    on_time_count = 0
    for card in completed_cards:
        deadline = card.get('deadline')
        completed = card.get('completed_at')
        if deadline and completed:
            try:
                deadline_dt = datetime.fromisoformat(deadline)
                completed_dt = datetime.fromisoformat(completed)
                if completed_dt <= deadline_dt:
                    on_time_count += 1
            except:
                pass
    
    return on_time_count / len(completed_cards) if completed_cards else 0

def calculate_productivity_score(self, member_name, start_date):
    """Calcula score de produtividade (0-100)"""
    completed = len(self.get_cards_completed_by(member_name, start_date))
    total_assigned = len(self.get_cards_by_member(member_name))
    
    if total_assigned == 0:
        return 0
    
    on_time_rate = self.get_on_time_completion_rate(member_name, start_date)
    completion_rate = completed / total_assigned
    
    # Score baseado em conclus√£o e pontualidade
    score = (completion_rate * 0.7 + on_time_rate * 0.3) * 100
    return min(100, max(0, score))

def generate_member_report(self, member_name, period='month'):
    """Gera relat√≥rio completo do membro"""
    metrics = self.get_member_metrics(member_name, period)
    cards = self.get_cards_by_member(member_name)
    
    report = {
        'member': member_name,
        'period': period,
        'metrics': metrics,
        'cards_summary': {
            'total': len(cards),
            'pending': len([c for c in cards if c.get('status') != 'done']),
            'completed': len([c for c in cards if c.get('status') == 'done']),
            'overdue': len([c for c in cards if self.is_card_overdue(c)])
        },
        'boards_participation': self.get_boards_for_member(member_name),
        'recent_activities': self.get_recent_activities(member_name, 10)
    }
    
    return report

def is_card_overdue(self, card):
    """Verifica se um card est√° atrasado"""
    deadline = card.get('deadline')
    if not deadline or card.get('status') == 'done':
        return False
    
    try:
        deadline_dt = datetime.fromisoformat(deadline)
        return datetime.now() > deadline_dt
    except:
        return False

def create_progress_indicators(self, board_frame, member_name):
    """Cria indicadores visuais de progresso"""
    progress_frame = ttk.LabelFrame(board_frame, text="Meu Progresso")
    progress_frame.pack(fill=tk.X, pady=5)
    
    # Cards pendentes
    pending = len(self.get_pending_tasks(member_name))
    ttk.Label(progress_frame, text=f"üìã Pendentes: {pending}").pack(side=tk.LEFT, padx=10)
    
    # Cards completados hoje
    completed_today = len(self.get_completed_tasks(member_name, 1))
    ttk.Label(progress_frame, text=f"‚úÖ Completados Hoje: {completed_today}").pack(side=tk.LEFT, padx=10)
    
    # Cards atrasados
    overdue = len([c for c in self.get_cards_by_member(member_name) if self.is_card_overdue(c)])
    ttk.Label(progress_frame, text=f"‚ö†Ô∏è Atrasados: {overdue}").pack(side=tk.LEFT, padx=10)

def create_advanced_filters(self, board_frame):
    """Cria filtros avan√ßados para cards"""
    filter_frame = ttk.LabelFrame(board_frame, text="Filtros")
    filter_frame.pack(fill=tk.X, pady=5)
    
    # Filtro por status
    status_var = tk.StringVar(value="Todos")
    ttk.Label(filter_frame, text="Status:").pack(side=tk.LEFT, padx=5)
    status_combo = ttk.Combobox(filter_frame, textvariable=status_var, 
                               values=["Todos", "Pendentes", "Em Progresso", "Conclu√≠dos"])
    status_combo.pack(side=tk.LEFT, padx=5)
    
    # Filtro por prazo
    deadline_var = tk.StringVar(value="Todos")
    ttk.Label(filter_frame, text="Prazo:").pack(side=tk.LEFT, padx=5)
    deadline_combo = ttk.Combobox(filter_frame, textvariable=deadline_var,
                                 values=["Todos", "Hoje", "Esta Semana", "Atrasados"])
    deadline_combo.pack(side=tk.LEFT, padx=5)
    
    # Bot√£o aplicar filtros
    ttk.Button(filter_frame, text="Aplicar", 
               command=lambda: self.apply_filters(status_var.get(), deadline_var.get())).pack(side=tk.LEFT, padx=10)

def apply_filters(self, status_filter, deadline_filter):
    """Aplica filtros aos cards"""
    # Implementar l√≥gica de filtros aqui
    print(f"Aplicando filtros: Status={status_filter}, Prazo={deadline_filter}")
    # Atualizar display dos cards com base nos filtros

def open_personal_dashboard(self):
    """Abre dashboard personalizado do usu√°rio"""
    current_user_member = self._get_current_user_member()
    if not current_user_member:
        messagebox.showwarning("Aviso", "Voc√™ precisa estar logado para acessar o dashboard pessoal.")
        return
    
    dashboard_data = self.create_member_dashboard(current_user_member)
    self.show_personal_dashboard_window(dashboard_data)

def show_personal_dashboard_window(self, dashboard_data):
    """Mostra janela do dashboard pessoal"""
    dashboard_window = tk.Toplevel(self.root)
    dashboard_window.title(f"Dashboard Pessoal - {dashboard_data['my_cards'][0]['members'][0] if dashboard_data['my_cards'] else 'Usu√°rio'}")
    dashboard_window.geometry("800x600")
    
    # Criar notebook para organizar as se√ß√µes
    notebook = ttk.Notebook(dashboard_window)
    notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    # Aba de Cards
    cards_frame = ttk.Frame(notebook)
    notebook.add(cards_frame, text="Meus Cards")
    
    # Lista de cards
    cards_text = tk.Text(cards_frame, wrap=tk.WORD, height=20)
    cards_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    for card in dashboard_data['my_cards']:
        status_icon = "‚úÖ" if card.get('status') == 'done' else "üìã"
        card_text = f"{status_icon} {card['title']} - {card['board_name']} > {card['list_name']}\n"
        cards_text.insert(tk.END, card_text)
    
    # Aba de M√©tricas
    metrics_frame = ttk.Frame(notebook)
    notebook.add(metrics_frame, text="M√©tricas")
    
    metrics = self.get_member_metrics(dashboard_data['my_cards'][0]['members'][0] if dashboard_data['my_cards'] else 'Usu√°rio')
    
    metrics_text = tk.Text(metrics_frame, wrap=tk.WORD, height=20)
    metrics_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    metrics_text.insert(tk.END, f"üìä M√âTRICAS DE PRODUTIVIDADE\n\n")
    metrics_text.insert(tk.END, f"Cards Criados: {metrics['cards_created']}\n")
    metrics_text.insert(tk.END, f"Cards Completados: {metrics['cards_completed']}\n")
    metrics_text.insert(tk.END, f"Tempo M√©dio de Conclus√£o: {metrics['average_completion_time']:.1f} horas\n")
    metrics_text.insert(tk.END, f"Score de Produtividade: {metrics['productivity_score']:.1f}%\n")
    metrics_text.insert(tk.END, f"Taxa de Conclus√£o no Prazo: {metrics['on_time_completion_rate']*100:.1f}%\n")
    metrics_text.insert(tk.END, f"Quadros Ativos: {metrics['active_boards']}\n")
    
    # Aba de Atividades
    activities_frame = ttk.Frame(notebook)
    notebook.add(activities_frame, text="Atividades Recentes")
    
    activities_text = tk.Text(activities_frame, wrap=tk.WORD, height=20)
    activities_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    for activity in dashboard_data['recent_activities']:
        activity_text = f"üïí {activity['action']} - {activity['timestamp']}\n"
        activities_text.insert(tk.END, activity_text)

# ============================================================================
# FIM DAS MELHORIAS IMPLEMENTADAS
# ============================================================================