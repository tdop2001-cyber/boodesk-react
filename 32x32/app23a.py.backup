import tkinter as tk
from supabase_setup import supabase_config
# Kanban Performance Optimizer
try:
    from kanban_performance_optimizer import KanbanPerformanceOptimizer
    KANBAN_OPTIMIZER_AVAILABLE = True
    print("✅ Kanban Performance Optimizer disponível")
except ImportError as e:
    KANBAN_OPTIMIZER_AVAILABLE = False
    print(f"⚠️ Kanban Performance Optimizer não disponível: {e}")
from tkinter import ttk, messagebox, simpledialog, colorchooser, filedialog
from ttkthemes import ThemedTk
import pandas as pd
import json
import os
import requests
import json
from datetime import datetime
from os.path import sep
import random
import winsound # Apenas para Windows
from datetime import datetime, timedelta, timezone
from functools import partial
from PIL import Image, ImageTk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import sys
import uuid
from tkcalendar import Calendar, DateEntry
import calendar
import threading
import time
import psutil
import signal
import subprocess
import shutil
import base64
import platform

# Sistema de upload completo (Supabase + Cloudflare R2)
try:
    from sistema_upload_completo import SistemaUploadCompleto
    SISTEMA_UPLOAD_DISPONIVEL = True
except ImportError:
    SISTEMA_UPLOAD_DISPONIVEL = False
    print("⚠️ Sistema de upload completo não disponível. Usando upload local.")

# Carregar variáveis de ambiente do arquivo .env
try:
    from dotenv import load_dotenv
    load_dotenv()
    print("✅ Variáveis de ambiente carregadas do arquivo .env")
except ImportError:
    print("⚠️ python-dotenv não instalado. Usando variáveis de ambiente do sistema.")
except Exception as e:
    print(f"⚠️ Erro ao carregar .env: {e}")

class ImageUploadManager:
    """Gerencia uploads e manipulação de imagens de perfil"""
    
    def __init__(self, upload_dir="uploads"):
        self.upload_dir = upload_dir
        self.allowed_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp'}

        self.max_file_size = 5 * 1024 * 1024  # 5MB
        self.profile_size = (150, 150)  # Tamanho padrão para foto de perfil
        
        # Criar diretório de uploads se não existir
        if not os.path.exists(upload_dir):
            os.makedirs(upload_dir)
    
    def select_image(self, parent_window):
        """Abre diálogo para selecionar imagem"""
        file_path = filedialog.askopenfilename(
            parent=parent_window,
            title="Selecionar Foto de Perfil",
            filetypes=[
                ("Imagens", "*.jpg *.jpeg *.png *.gif *.bmp"),
                ("JPEG", "*.jpg *.jpeg"),
                ("PNG", "*.png"),
                ("GIF", "*.gif"),
                ("BMP", "*.bmp"),
                ("Todos os arquivos", "*.*")
            ]
        )
        
        if file_path:
            return self.process_image(file_path)
        return None
    
    def process_image(self, file_path):
        """Processa e redimensiona a imagem"""
        try:
            # Verificar extensão
            file_ext = os.path.splitext(file_path)[1].lower()
            if file_ext not in self.allowed_extensions:
                raise ValueError(f"Formato não suportado: {file_ext}")
            
            # Verificar tamanho
            file_size = os.path.getsize(file_path)
            if file_size > self.max_file_size:
                raise ValueError(f"Arquivo muito grande: {file_size / 1024 / 1024:.1f}MB (máx: 5MB)")
            
            # Abrir e redimensionar imagem
            with Image.open(file_path) as img:
                # Converter para RGB se necessário
                if img.mode != 'RGB':
                    img = img.convert('RGB')
                
                # Redimensionar mantendo proporção
                img.thumbnail(self.profile_size, Image.Resampling.LANCZOS)
                
                # Salvar imagem processada
                filename = f"profile_{uuid.uuid4().hex[:8]}.jpg"
                save_path = os.path.join(self.upload_dir, filename)
                img.save(save_path, 'JPEG', quality=85, optimize=True)
                
                return {
                    'original_path': file_path,
                    'processed_path': save_path,
                    'filename': filename,
                    'size': img.size
                }
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao processar imagem:\n{str(e)}")
            return None
    
    def get_image_preview(self, image_path, size=(100, 100)):
        """Cria preview da imagem para exibição"""
        try:
            with Image.open(image_path) as img:
                img.thumbnail(size, Image.Resampling.LANCZOS)
                return ImageTk.PhotoImage(img)
        except Exception as e:
            print(f"Erro ao criar preview: {e}")
            return None
    
    def delete_image(self, filename):
        """Remove imagem do sistema"""
        try:
            file_path = os.path.join(self.upload_dir, filename)
            if os.path.exists(file_path):
                os.remove(file_path)
                return True
        except Exception as e:
            print(f"Erro ao deletar imagem: {e}")
        return False
    
    def image_to_base64(self, image_path):
        """Converte imagem para base64"""
        try:
            with open(image_path, 'rb') as img_file:
                return base64.b64encode(img_file.read()).decode('utf-8')
        except Exception as e:
            print(f"Erro ao converter para base64: {e}")
            return None
    
    def base64_to_image(self, base64_data, filename):
        """Converte base64 para imagem"""
        try:
            image_data = base64.b64decode(base64_data)
            file_path = os.path.join(self.upload_dir, filename)
            with open(file_path, 'wb') as img_file:
                img_file.write(image_data)
            return file_path
        except Exception as e:
            print(f"Erro ao converter base64 para imagem: {e}")
            return None

class DatabaseConcurrencyControl:
    """Sistema de controle de concorrência para o banco de dados"""
    
    def __init__(self, db_file='boodesk_new.db'):
        self.db_file = db_file
        self.lock_file = f"{db_file}.lock"
        self.pid_file = f"{db_file}.pid"
        self.current_pid = os.getpid()
        self.lock_acquired = False
        
    def acquire_lock(self, timeout=30):
        """Tenta adquirir o lock do banco de dados"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                # Verificar se já temos o lock
                if self.lock_acquired:
                    print(f"✅ Lock já adquirido (PID: {self.current_pid})")
                    return True
                
                # Verificar se já existe um lock para este processo
                if os.path.exists(self.lock_file):
                    try:
                        with open(self.lock_file, 'r') as f:
                            pid_str = f.read().strip()
                            if pid_str == str(self.current_pid):
                                self.lock_acquired = True
                                print(f"✅ Lock já adquirido por este processo (PID: {self.current_pid})")
                                return True
                    except:
                        pass
                
                # Verificar se há outro processo usando o banco
                if self._is_other_process_using_db():
                    print(f"⚠️ Outro processo está usando o banco. Tentando interromper...")
                    if self._terminate_other_processes():
                        time.sleep(2)  # Aguardar processo terminar
                        continue
                    else:
                        print(f"❌ Não foi possível interromper outros processos")
                        return False
                
                # Verificar se há outro processo usando o lock
                if os.path.exists(self.lock_file):
                    try:
                        with open(self.lock_file, 'r') as f:
                            pid_str = f.read().strip()
                            if pid_str:
                                try:
                                    pid = int(pid_str)
                                    if psutil.pid_exists(pid) and pid != self.current_pid:
                                        print(f"⚠️ Lock já existe para PID {pid}")
                                        return False
                                except:
                                    pass
                    except:
                        pass
                
                # Tentar criar arquivo de lock
                with open(self.lock_file, 'w') as f:
                    f.write(str(self.current_pid))
                
                # Verificar se conseguiu criar o lock
                if os.path.exists(self.lock_file):
                    with open(self.lock_file, 'r') as f:
                        pid_in_file = f.read().strip()
                        if pid_in_file == str(self.current_pid):
                            self.lock_acquired = True
                            print(f"✅ Lock adquirido com sucesso (PID: {self.current_pid})")
                            return True
                
                time.sleep(0.5)
                
            except Exception as e:
                print(f"⚠️ Erro ao tentar adquirir lock: {e}")
                time.sleep(0.5)
        
        print(f"❌ Timeout ao tentar adquirir lock do banco")
        return False
    
    def release_lock(self):
        """Libera o lock do banco de dados"""
        try:
            if self.lock_acquired and os.path.exists(self.lock_file):
                try:
                    with open(self.lock_file, 'r') as f:
                        pid_in_file = f.read().strip()
                        if pid_in_file == str(self.current_pid):
                            try:
                                os.remove(self.lock_file)
                                self.lock_acquired = False
                                print(f"✅ Lock liberado (PID: {self.current_pid})")
                            except Exception as e:
                                print(f"⚠️ Erro ao remover arquivo de lock: {e}")
                                # Tentar novamente após um pequeno delay
                                time.sleep(0.1)
                                try:
                                    os.remove(self.lock_file)
                                    self.lock_acquired = False
                                    print(f"✅ Lock liberado na segunda tentativa (PID: {self.current_pid})")
                                except:
                                    pass
                except Exception as e:
                    print(f"⚠️ Erro ao ler arquivo de lock: {e}")
        except Exception as e:
            print(f"⚠️ Erro ao liberar lock: {e}")
    
    def _is_other_process_using_db(self):
        """Verifica se há outro processo usando o banco"""
        try:
            # Verificar arquivo de lock
            if os.path.exists(self.lock_file):
                with open(self.lock_file, 'r') as f:
                    pid_str = f.read().strip()
                    if pid_str and pid_str != str(self.current_pid):
                        try:
                            pid = int(pid_str)
                            if psutil.pid_exists(pid):
                                return True
                        except:
                            pass
            
            # Verificar processos Python que podem estar usando o banco
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    if proc.info['name'] and 'python' in proc.info['name'].lower():
                        if proc.info['cmdline']:
                            cmdline = ' '.join(proc.info['cmdline'])
                            if 'app23a.py' in cmdline and proc.info['pid'] != self.current_pid:
                                return True
                except:
                    continue
            
            return False
            
        except Exception as e:
            print(f"⚠️ Erro ao verificar outros processos: {e}")
            return False
    
    def _terminate_other_processes(self):
        """Tenta terminar outros processos Python que estejam usando o banco"""
        try:
            terminated_count = 0
            
            # Terminar processos Python que executam app23a.py
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    if proc.info['name'] and 'python' in proc.info['name'].lower():
                        if proc.info['cmdline']:
                            cmdline = ' '.join(proc.info['cmdline'])
                            if 'app23a.py' in cmdline and proc.info['pid'] != self.current_pid:
                                print(f"🔄 Terminando processo Python (PID: {proc.info['pid']})")
                                proc.terminate()
                                proc.wait(timeout=5)
                                terminated_count += 1
                except:
                    continue
            
            # Limpar arquivos de lock órfãos
            if os.path.exists(self.lock_file):
                try:
                    with open(self.lock_file, 'r') as f:
                        pid_str = f.read().strip()
                        if pid_str:
                            try:
                                pid = int(pid_str)
                                if not psutil.pid_exists(pid):
                                    os.remove(self.lock_file)
                                    print(f"🗑️ Removido lock órfão (PID: {pid})")
                            except:
                                os.remove(self.lock_file)
                except:
                    pass
            
            # Limpar arquivos WAL/SHM se existirem
            wal_file = f"{self.db_file}-wal"
            shm_file = f"{self.db_file}-shm"
            
            for file_path in [wal_file, shm_file]:
                if os.path.exists(file_path):
                    try:
                        os.remove(file_path)
                        print(f"🗑️ Removido arquivo: {file_path}")
                    except:
                        pass
            
            print(f"✅ {terminated_count} processos terminados")
            return True
            
        except Exception as e:
            print(f"❌ Erro ao terminar outros processos: {e}")
            return False
    
    def __enter__(self):
        """Context manager para adquirir lock automaticamente"""
        if not self.acquire_lock():
            raise RuntimeError("Não foi possível adquirir lock do banco de dados")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager para liberar lock automaticamente"""
        self.release_lock()

class UserManagement:
    def __init__(self):
        """Inicializa o gerenciamento de usuários usando banco SQLite"""
        self.load_users()
    
    def load_users(self):
        """Carrega usuários do banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, username, email, password_hash, role, cargo, created_at, updated_at, member_id
                FROM users ORDER BY username
            """)
            users_data = cursor.fetchall()
            conn.close()
            
            # Converter para DataFrame
            if users_data:
                self.users_df = pd.DataFrame(users_data, columns=[
                    'user_id', 'username', 'email', 'password', 'role', 'Cargo', 
                    'created_at', 'last_login', 'member_id'
                ])
            else:
                # Criar DataFrame vazio com estrutura correta
                self.users_df = pd.DataFrame(columns=[
                    'user_id', 'username', 'email', 'password', 'role', 'Cargo', 
                    'created_at', 'last_login', 'member_id'
                ])
            
            print(f"DEBUG: {len(self.users_df)} usuários carregados do SQLite")
            
        except Exception as e:
            print(f"Erro ao carregar usuários do SQLite: {e}")
            # Criar DataFrame vazio em caso de erro
            self.users_df = pd.DataFrame(columns=[
                'user_id', 'username', 'email', 'password', 'role', 'Cargo', 
                'created_at', 'last_login', 'member_id'
            ])
    
    def save_users(self):
        """Salva usuários no banco SQLite"""
        try:
            print("DEBUG: Usuários salvos no SQLite")
        except Exception as e:
            print(f"Erro ao salvar usuários: {e}")
    
    def login(self, username, password):
        """Autentica um usuário usando banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, username, email, password_hash, role, cargo, member_id
                FROM users WHERE username = %s AND password_hash = %s
            """, (username, password))
            
            user_data = cursor.fetchone()
            conn.close()
            
            if user_data:
                user_id, username, email, password_hash, role, cargo, member_id = user_data
                
                user = User(
                    username=username,
                    role=role,
                    cargo=cargo,
                    user_id=user_id
                )
                user.is_authenticated = True
                user.login_time = pd.Timestamp.now()
                user.member_id = member_id
                
                # Atualizar último login no banco
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                cursor.execute("""
                    UPDATE users SET updated_at = %s WHERE id = %s
                """, (datetime.now(), user_id))
                conn.commit()
                conn.close()
                
                return user
            return None
            
        except Exception as e:
            print(f"Erro no login: {e}")
            return None
    
    def register_user(self, username, password, role, cargo):
        """Registra um novo usuário no banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            # Verificar se o usuário já existe
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("SELECT id FROM users WHERE username = %s", (username,))
            if cursor.fetchone():
                conn.close()
                return False, "Usuário já existe"
            
            # Validar dados
            if not username or not password:
                return False, "Usuário e senha são obrigatórios"
            
            if len(password) < 6:
                return False, "Senha deve ter pelo menos 6 caracteres"
            
            if role not in ['admin', 'user', 'manager']:
                return False, "Role inválido"
            
            # Inserir novo usuário
            cursor.execute("""
                INSERT INTO users (username, email, password_hash, role, cargo, created_at, updated_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """, (username, '', password, role, cargo, datetime.now(), datetime.now()))
            
            conn.commit()
            conn.close()
            
            # Recarregar usuários
            self.load_users()
            
            return True, "Usuário registrado com sucesso"
            
        except Exception as e:
            print(f"Erro ao registrar usuário: {e}")
            return False, f"Erro ao registrar usuário: {e}"
    
    def update_user(self, user_id, username, password, role, cargo):
        """Atualiza dados de um usuário"""
        user_idx = self.users_df[self.users_df['user_id'] == user_id].index
        if len(user_idx) == 0:
            return False, "Usuário não encontrado"
        
        idx = user_idx[0]
        
        # Verificar se o novo username já existe (exceto para o próprio usuário)
        existing_user = self.users_df[
            (self.users_df['username'] == username) & 
            (self.users_df['user_id'] != user_id)
        ]
        if not existing_user.empty:
            return False, "Username já existe"
        
        # Atualizar dados
        self.users_df.loc[idx, 'username'] = username
        if password:  # Só atualizar senha se fornecida
            self.users_df.loc[idx, 'password'] = password
        self.users_df.loc[idx, 'role'] = role
        self.users_df.loc[idx, 'Cargo'] = cargo
        
        self.save_users()
        return True, "Usuário atualizado com sucesso"
    
    def delete_user(self, user_id):
        """Remove um usuário"""
        user_idx = self.users_df[self.users_df['user_id'] == user_id].index
        if len(user_idx) == 0:
            return False, "Usuário não encontrado"
        
        # Não permitir deletar o último admin
        user_role = self.users_df.loc[user_idx[0], 'role']
        if user_role == 'admin':
            admin_count = len(self.users_df[self.users_df['role'] == 'admin'])
            if admin_count <= 1:
                return False, "Não é possível deletar o último administrador"
        
        self.users_df = self.users_df[self.users_df['user_id'] != user_id]
        self.save_users()
        return True, "Usuário removido com sucesso"
    
    def get_all_users(self):
        """Retorna todos os usuários do banco SQLite"""
        try:
            import sqlite3
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, username, email, role, cargo, created_at, updated_at, member_id
                FROM users ORDER BY username
            """)
            users_data = cursor.fetchall()
            conn.close()
            
            users = []
            for user_data in users_data:
                user_id, username, email, role, cargo, created_at, updated_at, member_id = user_data
                users.append({
                    'user_id': user_id,
                    'username': username,
                    'email': email,
                    'role': role,
                    'cargo': cargo,
                    'created_at': created_at,
                    'last_login': updated_at,
                    'member_id': member_id
                })
            
            return users
            
        except Exception as e:
            print(f"Erro ao buscar usuários: {e}")
            return []
    
    def get_user_by_id(self, user_id):
        """Retorna um usuário específico por ID"""
        user_data = self.users_df[self.users_df['user_id'] == user_id]
        if not user_data.empty:
            user_row = user_data.iloc[0]
            return User(
                username=user_row['username'],
                role=user_row['role'],
                cargo=user_row['Cargo'],
                user_id=user_row['user_id']
            )
        return None

class EmailIntegration:
    def __init__(self, app):
        self.app = app
        self.settings = app.settings.get('email_integration', {})
        self.email_thread = None
        self.running = False
        
    def start_email_service(self):
        if not self.settings.get('enabled', False):
            return
            
        self.running = True
        self.email_thread = threading.Thread(target=self._email_loop, daemon=True)
        self.email_thread.start()
    
    def stop_email_service(self):
        self.running = False
        if self.email_thread:
            self.email_thread.join(timeout=1)
    
    def _email_loop(self):
        while self.running:
            try:
                if self.settings.get('auto_notifications', {}).get('deadline_reminder', True):
                    self._check_deadline_reminders()
                
                if self.settings.get('auto_notifications', {}).get('weekly_report', True):
                    self._check_weekly_report()
                
                time.sleep(3600)  # Check every hour
            except Exception as e:
                print(f"Erro no loop de email: {e}")
                time.sleep(300)
    
    def send_email(self, to_email, subject, body, attachments=None):
        try:
            if self.settings.get('demo_mode', False):
                return self._demo_send_email(to_email, subject, body)
            
            provider = self.settings.get('provider', 'gmail')
            
            if provider == 'gmail':
                return self._send_gmail(to_email, subject, body, attachments)
            elif provider == 'outlook':
                return self._send_outlook(to_email, subject, body, attachments)
            else:
                return self._send_smtp(to_email, subject, body, attachments)
                
        except Exception as e:
            print(f"Erro ao enviar email: {e}")
            return False
    
    def _demo_send_email(self, to_email, subject, body):
        """Simula envio de email em modo demo"""
        print(f"DEMO EMAIL - Para: {to_email}")
        print(f"Assunto: {subject}")
        print(f"Corpo: {body}")
        print("--- Email simulado com sucesso ---")
        return True
    
    def _send_gmail(self, to_email, subject, body, attachments=None):
        try:
            email_address = self.settings.get('email_address', '')
            app_password = self.settings.get('app_password', '')
            
            if not email_address or not app_password:
                print("Credenciais de email não configuradas")
                return False
            
            msg = MIMEMultipart()
            msg['From'] = email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            if attachments:
                for attachment in attachments:
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                        msg.attach(part)
            
            server = smtplib.SMTP('smtp.gmail.com', 587)
            server.starttls()
            server.login(email_address, app_password)
            text = msg.as_string()
            server.sendmail(email_address, to_email, text)
            server.quit()
            
            print(f"Email enviado com sucesso para {to_email}")
            return True
            
        except Exception as e:
            print(f"Erro ao enviar email via Gmail: {e}")
            return False
    
    def _send_outlook(self, to_email, subject, body, attachments=None):
        try:
            email_address = self.settings.get('email_address', '')
            email_password = self.settings.get('email_password', '')
            smtp_server = self.settings.get('smtp_server', 'smtp-mail.outlook.com')
            smtp_port = self.settings.get('smtp_port', 587)
            
            if not email_address or not email_password:
                print("Credenciais de email não configuradas")
                return False
            
            msg = MIMEMultipart()
            msg['From'] = email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            if attachments:
                for attachment in attachments:
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                        msg.attach(part)
            
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(email_address, email_password)
            text = msg.as_string()
            server.sendmail(email_address, to_email, text)
            server.quit()
            
            print(f"Email enviado com sucesso para {to_email}")
            return True
            
        except Exception as e:
            print(f"Erro ao enviar email via Outlook: {e}")
            return False
    
    def _send_smtp(self, to_email, subject, body, attachments=None):
        try:
            email_address = self.settings.get('email_address', '')
            email_password = self.settings.get('email_password', '')
            smtp_server = self.settings.get('smtp_server', '')
            smtp_port = self.settings.get('smtp_port', 587)
            
            if not all([email_address, email_password, smtp_server]):
                print("Configurações SMTP incompletas")
                return False
            
            msg = MIMEMultipart()
            msg['From'] = email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            if attachments:
                for attachment in attachments:
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                        msg.attach(part)
            
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(email_address, email_password)
            text = msg.as_string()
            server.sendmail(email_address, to_email, text)
            server.quit()
            
            print(f"Email enviado com sucesso para {to_email}")
            return True
            
        except Exception as e:
            print(f"Erro ao enviar email via SMTP: {e}")
            return False
    
    def notify_card_created(self, card_data):
        """Notifica criação de novo cartão"""
        try:
            # Verificar se card_data é um dicionário
            if not isinstance(card_data, dict):
                print(f"DEBUG: card_data não é um dicionário: {type(card_data)} - {card_data}")
                return
            
            # Verificar se as configurações estão disponíveis
            if not hasattr(self, 'settings') or not isinstance(self.settings, dict):
                print("DEBUG: settings não disponível ou não é um dicionário")
                return
            
            # Verificar se auto_notifications existe e é um dicionário
            auto_notifications = self.settings.get('auto_notifications', {})
            if not isinstance(auto_notifications, dict):
                print("DEBUG: auto_notifications não é um dicionário, usando padrão")
                auto_notifications = {}
            
            if not auto_notifications.get('card_created', True):
                return
            
            # Verificar se email_templates existe e é um dicionário
            email_templates = self.settings.get('email_templates', {})
            if not isinstance(email_templates, dict):
                print("DEBUG: email_templates não é um dicionário, usando padrão")
                email_templates = {}
            
            template = email_templates.get('card_created', 'Novo cartão criado: {title}')
            
            # Garantir que todos os campos necessários estejam presentes
            safe_card_data = {
                'title': card_data.get('title', ''),
                'board': card_data.get('board', ''),
                'column': card_data.get('column', ''),
                'created_by': card_data.get('created_by', ''),
                'created_date': card_data.get('created_date', ''),
                'importance': card_data.get('importance', ''),
                'due_date': card_data.get('due_date', '')
            }
            
            try:
                subject = template.format(**safe_card_data)
            except Exception as format_error:
                print(f"Erro ao formatar template: {format_error}")
                subject = f"Novo cartão criado: {safe_card_data.get('title', '')}"
            
            body = f"""
Novo cartão criado no Boodesk:

Título: {safe_card_data.get('title', '')}
Quadro: {safe_card_data.get('board', '')}
Lista: {safe_card_data.get('column', '')}
Criado por: {safe_card_data.get('created_by', '')}
Data de criação: {safe_card_data.get('created_date', '')}
Importância: {safe_card_data.get('importance', '')}
Prazo: {safe_card_data.get('due_date', '')}
"""
            
            # Verificar se notification_recipients existe e é uma lista
            notification_recipients = self.settings.get('notification_recipients', [])
            if not isinstance(notification_recipients, list):
                print("DEBUG: notification_recipients não é uma lista, usando lista vazia")
                notification_recipients = []
            
            for recipient in notification_recipients:
                if hasattr(self, 'send_email'):
                    self.send_email(recipient, subject, body)
                
        except Exception as e:
            print(f"Erro ao notificar criação de cartão: {e}")

    def notify_card_modified(self, card_data, changes):
        """Notifica modificação de cartão"""
        try:
            # Verificar se card_data é um dicionário
            if not isinstance(card_data, dict):
                print(f"DEBUG: card_data não é um dicionário: {type(card_data)} - {card_data}")
                return
            
            # Verificar se as configurações estão disponíveis
            if not hasattr(self, 'settings') or not isinstance(self.settings, dict):
                print("DEBUG: settings não disponível ou não é um dicionário")
                return
            
            # Verificar se auto_notifications existe e é um dicionário
            auto_notifications = self.settings.get('auto_notifications', {})
            if not isinstance(auto_notifications, dict):
                print("DEBUG: auto_notifications não é um dicionário, usando padrão")
                auto_notifications = {}
            
            if not auto_notifications.get('card_modified', True):
                return
            
            # Verificar se email_templates existe e é um dicionário
            email_templates = self.settings.get('email_templates', {})
            if not isinstance(email_templates, dict):
                print("DEBUG: email_templates não é um dicionário, usando padrão")
                email_templates = {}
            
            template = email_templates.get('card_modified', 'Cartão modificado: {title}')
            
            # Garantir que todos os campos necessários estejam presentes
            safe_card_data = {
                'title': card_data.get('title', ''),
                'board': card_data.get('board', ''),
                'column': card_data.get('column', ''),
                'modified_by': card_data.get('modified_by', ''),
                'modified_date': card_data.get('modified_date', '')
            }
            
            try:
                subject = template.format(**safe_card_data)
            except Exception as format_error:
                print(f"Erro ao formatar template: {format_error}")
                subject = f"Cartão modificado: {safe_card_data.get('title', '')}"
            
            # Criar lista de mudanças
            changes_text = "\n".join([f"• {change}" for change in changes]) if isinstance(changes, list) else str(changes)
            
            body = f"""
Cartão modificado no Boodesk:

Título: {safe_card_data.get('title', '')}
Quadro: {safe_card_data.get('board', '')}
Lista: {safe_card_data.get('column', '')}
Modificado por: {safe_card_data.get('modified_by', '')}
Data de modificação: {safe_card_data.get('modified_date', '')}

Mudanças realizadas:
{changes_text}
"""
            
            # Verificar se notification_recipients existe e é uma lista
            notification_recipients = self.settings.get('notification_recipients', [])
            if not isinstance(notification_recipients, list):
                print("DEBUG: notification_recipients não é uma lista, usando lista vazia")
                notification_recipients = []
            
            for recipient in notification_recipients:
                if hasattr(self, 'send_email'):
                    self.send_email(recipient, subject, body)
                
        except Exception as e:
            print(f"Erro ao notificar modificação de cartão: {e}")


import requests
import base64
import urllib.parse
import threading
import time
# Importações para Google Calendar e templates de email
import threading
import time
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
import ssl
import pickle
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import webbrowser
from database_postgres import DatabasePostgres as Database
# Sistema de atualizações automáticas
from auto_updater import AutoUpdater, UpdateDialog, check_for_updates_in_background
import threading
import time


# Configurações da API Google Calendar
SCOPES = ['https://www.googleapis.com/auth/calendar']
CREDENTIALS_FILE = 'credentials.json'
TOKEN_FILE = 'token.pickle'

class User:
    def __init__(self, username, role, cargo=None, user_id=None):
        self.username = username
        self.role = role
        self.cargo = cargo or "Usuário"
        self.user_id = user_id
        self.is_authenticated = False
        self.login_time = None
        
    def has_permission(self, permission):
        """Verifica se o usuário tem uma determinada permissão"""
        # Verificar se o role é válido
        if not hasattr(self, 'role') or not self.role:
            print("DEBUG: Usuário sem role, usando role padrão 'user'")
            self.role = "user"
        
        # Mapear roles em português para inglês
        role_mapping = {
            "Administrador": "admin",
            "admin": "admin",
            "Manager": "manager", 
            "manager": "manager",
            "Usuário": "user",
            "user": "user"
        }
        
        # Normalizar o role
        normalized_role = role_mapping.get(self.role, self.role)
        
        if normalized_role == "admin":
            return True  # Admin tem todas as permissões
        
        # Permissões específicas por role
        permissions = {
            "user": [
                "view_boards", "view_cards", "edit_own_cards", 
                "move_cards", "add_comments", "view_reports"
            ],
            "manager": [
                "view_boards", "view_cards", "edit_cards", 
                "move_cards", "add_comments", "view_reports",
                "manage_members", "create_cards", "delete_cards",
                "manage_users"
            ]
        }
        
        return permission in permissions.get(normalized_role, [])
    
    def can_manage_users(self):
        """Verifica se o usuário pode gerenciar outros usuários"""
        if not hasattr(self, 'role') or not self.role:
            return False
        
        # Mapear roles em português para inglês
        role_mapping = {
            "Administrador": "admin",
            "admin": "admin",
            "Manager": "manager", 
            "manager": "manager",
            "Usuário": "user",
            "user": "user"
        }
        
        # Normalizar o role
        normalized_role = role_mapping.get(self.role, self.role)
        return normalized_role in ["admin", "manager"]
    
    def can_manage_settings(self):
        """Verifica se o usuário pode gerenciar configurações"""
        if not hasattr(self, 'role') or not self.role:
            return False
        return self.role == "admin"
    
    def can_delete_cards(self):
        """Verifica se o usuário pode deletar cartões"""
        if not hasattr(self, 'role') or not self.role:
            return False
        return self.role in ["admin", "manager"]
    
    def can_edit_all_cards(self):
        """Verifica se o usuário pode editar todos os cartões"""
        if not hasattr(self, 'role') or not self.role:
            return False
        return self.role in ["admin", "manager"]
    
    def __str__(self):
        cargo = getattr(self, 'cargo', 'Usuário')
        return f"{self.username} ({cargo})"

class NotificationManager:
    def __init__(self, app):
        self.app = app
        self.notification_settings = self.load_notification_settings()
        self.notification_thread = None
        self.running = False
        
    def load_notification_settings(self):
        """Carrega configurações de notificação"""
        default_settings = {
            'enabled': True,
            'sound_enabled': True,
            'popup_enabled': True,
            'advance_notification_minutes': 15,
            'show_widget': True,
            'widget_position': 'top_right',
            'notification_duration': 10
        }
        
        try:
            if os.path.exists('notification_settings.json'):
                with open('notification_settings.json', 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                    # Mesclar com configurações padrão
                    for key, value in default_settings.items():
                        if key not in settings:
                            settings[key] = value
                    return settings
            else:
                return default_settings
        except Exception as e:
            print(f"Erro ao carregar configurações de notificação: {e}")
            return default_settings
    
    def save_notification_settings(self):
        """Salva configurações de notificação"""
        try:
            with open('notification_settings.json', 'w', encoding='utf-8') as f:
                json.dump(self.notification_settings, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"Erro ao salvar configurações de notificação: {e}")
    
    def start_notification_monitor(self):
        """Inicia o monitor de notificações"""
        if not self.notification_settings['enabled']:
            return
            
        self.running = True
        self.notification_thread = threading.Thread(target=self._monitor_meetings, daemon=True)
        self.notification_thread.start()
    
    def stop_notification_monitor(self):
        """Para o monitor de notificações"""
        self.running = False
        if self.notification_thread:
            self.notification_thread.join(timeout=1)
    
    def _monitor_meetings(self):
        """Monitora reuniões para notificações"""
        while self.running:
            try:
                current_time = datetime.now()
                
                # Verificar reuniões próximas
                for meeting_id, meeting in self.app.meeting_integration.meeting_data.items():
                    if meeting.get('notified', False):
                        continue
                    
                    # Verificar se date e time não estão vazios
                    if not meeting.get('date') or not meeting.get('time'):
                        print(f"Reunião com data/hora vazia ignorada: {meeting}")
                        continue
                    
                    try:
                        meeting_datetime = datetime.strptime(f"{meeting['date']} {meeting['time']}", "%Y-%m-%d %H:%M")
                        time_diff = meeting_datetime - current_time
                    except ValueError as e:
                        print(f"Erro ao fazer parse da data/hora da reunião: {e}")
                        continue
                    
                    # Notificar X minutos antes
                    if 0 <= time_diff.total_seconds() <= self.notification_settings['advance_notification_minutes'] * 60:
                        self._show_meeting_notification(meeting)
                        meeting['notified'] = True
                        self.app.meeting_integration.save_meeting_data()
                
                time.sleep(30)  # Verificar a cada 30 segundos
                
            except Exception as e:
                print(f"Erro no monitor de notificações: {e}")
                time.sleep(60)
    
    def _show_meeting_notification(self, meeting):
        """Mostra notificação de reunião"""
        if self.notification_settings['sound_enabled']:
            self._play_notification_sound()
        
        if self.notification_settings['popup_enabled']:
            self._show_popup_notification(meeting)
    
    def _play_notification_sound(self):
        """Toca som de notificação"""
        try:
            winsound.MessageBeep(winsound.MB_ICONEXCLAMATION)
        except:
            pass  # Ignorar se não conseguir tocar som
    
    def _show_popup_notification(self, meeting):
        """Mostra popup de notificação simples"""
        def show_popup():
            popup = tk.Toplevel()
            popup.title("Reunião")
            popup.geometry("300x120")
            
            # Centralizar na tela
            popup.update_idletasks()
            x = (popup.winfo_screenwidth() // 2) - (300 // 2)
            y = (popup.winfo_screenheight() // 2) - (120 // 2)
            popup.geometry(f"300x120+{x}+{y}")
            
            # Sempre no topo
            popup.attributes('-topmost', True)
            
            # Conteúdo simples
            title_label = tk.Label(popup, text="Reunião Próxima", 
                                 font=("Arial", 12, "bold"))
            title_label.pack(pady=5)
            
            meeting_label = tk.Label(popup, text=meeting['title'], 
                                   font=("Arial", 10))
            meeting_label.pack(pady=2)
            
            time_label = tk.Label(popup, text=f"{meeting['time']} - {meeting['platform'].upper()}", 
                                font=("Arial", 9))
            time_label.pack(pady=2)
            
            # Botões simples
            button_frame = tk.Frame(popup)
            button_frame.pack(pady=10)
            
            tk.Button(button_frame, text="Entrar", 
                     command=lambda: [webbrowser.open(meeting['link']), popup.destroy()]).pack(side=tk.LEFT, padx=5)
            
            tk.Button(button_frame, text="Fechar", 
                     command=popup.destroy).pack(side=tk.LEFT, padx=5)
            
            # Auto-fechar após X segundos
            popup.after(self.notification_settings['notification_duration'] * 1000, popup.destroy)
        
        # Executar na thread principal
        self.app.root.after(0, show_popup)

class MeetingWidget:
    def __init__(self, app, parent_frame):
        self.app = app
        self.parent_frame = parent_frame
        self.widget_frame = None
        self.create_widget()
    
    def create_widget(self):
        """Cria o widget de reuniões discreto no menu principal"""
        if not self.app.notification_manager.notification_settings['show_widget']:
            return
            
        # Criar frame discreto para o widget
        self.widget_frame = ttk.Frame(self.parent_frame)
        self.widget_frame.pack(fill=tk.X, padx=10, pady=2)
        
        # Título discreto com ícone
        title_frame = ttk.Frame(self.widget_frame)
        title_frame.pack(anchor=tk.W, pady=(0, 2))
        
        if hasattr(self.app, 'icons') and self.app.icons.get('reuniao_icon'):
            title_label = ttk.Label(title_frame, text="Próxima Reunião:", image=self.app.icons['reuniao_icon'], compound=tk.LEFT, font=("Arial", 9))
        else:
            title_label = ttk.Label(title_frame, text="Próxima Reunião:", font=("Arial", 9))
        title_label.pack(side=tk.LEFT)
        
        # Lista de reuniões
        self.meetings_frame = tk.Frame(self.widget_frame)
        self.meetings_frame.pack(fill=tk.X)
        
        # Atualizar reuniões
        self.refresh_meetings()
        
        # Atualizar periodicamente
        self._schedule_refresh()
    
    def refresh_meetings(self):
        """Atualiza a lista de reuniões"""
        # Limpar frame
        for widget in self.meetings_frame.winfo_children():
            widget.destroy()
        
        # Buscar reuniões próximas e em andamento
        current_time = datetime.now()
        upcoming_meetings = []
        ongoing_meetings = []
        
        for meeting_id, meeting in self.app.meeting_integration.meeting_data.items():
            try:
                # Verificar se date e time não estão vazios
                date_str = meeting.get('date', '').strip()
                time_str = meeting.get('time', '').strip()
                
                if not date_str or not time_str:
                    print(f"Reunião com data/hora vazia ignorada: {meeting}")
                    continue
                
                meeting_datetime = datetime.strptime(f"{date_str} {time_str}", "%Y-%m-%d %H:%M")
                duration_minutes = int(meeting.get('duration', 60))  # Duração padrão 60 min
                end_datetime = meeting_datetime + timedelta(minutes=duration_minutes)
            except (ValueError, KeyError) as e:
                print(f"Erro ao processar reunião: {meeting} - {e}")
                continue
            
            # Verificar se a reunião está em andamento
            if meeting_datetime <= current_time <= end_datetime:
                ongoing_meetings.append((meeting_datetime, meeting, end_datetime))
            # Verificar se a reunião está próxima (próximas 24 horas)
            elif 0 <= (meeting_datetime - current_time).total_seconds() <= 24 * 60 * 60:
                upcoming_meetings.append((meeting_datetime, meeting))
        
        # Ordenar por data/hora (primeiro elemento da tupla é o datetime)
        ongoing_meetings.sort(key=lambda x: x[0])
        upcoming_meetings.sort(key=lambda x: x[0])
        
        # Mostrar reunião em andamento primeiro, depois a próxima
        if ongoing_meetings:
            meeting_datetime, meeting, end_datetime = ongoing_meetings[0]
            self._display_meeting(meeting, meeting_datetime, is_ongoing=True, end_datetime=end_datetime)
        elif upcoming_meetings:
            meeting_datetime, meeting = upcoming_meetings[0]
            self._display_meeting(meeting, meeting_datetime, is_ongoing=False)
        else:
            # Se não há reuniões, mostrar mensagem discreta
            no_meetings_label = ttk.Label(self.meetings_frame, text="Nenhuma reunião nas próximas 24h", 
                                        font=("Arial", 8), 
                                        foreground='#7f8c8d')
            no_meetings_label.pack(pady=2)
    
    def _display_meeting(self, meeting, meeting_datetime, is_ongoing=False, end_datetime=None):
        """Exibe uma reunião no widget"""
        current_time = datetime.now()
        
        # Frame principal da reunião
        meeting_frame = tk.Frame(self.meetings_frame, relief=tk.SUNKEN, bd=1)
        meeting_frame.pack(fill=tk.X, pady=1)
        
        if is_ongoing:
            # Reunião em andamento
            time_remaining = end_datetime - current_time
            minutes_remaining = int(time_remaining.total_seconds() // 60)
            time_text = f"EM ANDAMENTO ({minutes_remaining}m restantes)"
            time_color = '#e74c3c'  # Vermelho para reunião em andamento
        else:
            # Reunião próxima
            time_diff = meeting_datetime - current_time
            hours = int(time_diff.total_seconds() // 3600)
            minutes = int((time_diff.total_seconds() % 3600) // 60)
            
            if hours > 0:
                time_text = f"em {hours}h {minutes}m"
            else:
                time_text = f"em {minutes}m"
            time_color = '#e67e22'  # Laranja para reunião próxima
        
        # Frame para informações da reunião
        info_frame = tk.Frame(meeting_frame)
        info_frame.pack(fill=tk.X, padx=5, pady=3)
        
        # Título da reunião (clicável)
        title_label = tk.Label(info_frame, text=meeting['title'][:30] + "..." if len(meeting['title']) > 30 else meeting['title'], 
                             font=("Arial", 9), 
                             fg='#2c3e50', cursor="hand2")
        title_label.pack(side=tk.LEFT, anchor=tk.W)
        
        # Bind duplo clique para abrir link
        title_label.bind("<Double-1>", lambda e, m=meeting: webbrowser.open(m['link']))
        
        # Tempo restante
        time_label = tk.Label(info_frame, text=time_text, 
                            font=("Arial", 8), 
                            fg=time_color)
        time_label.pack(side=tk.LEFT, padx=(10, 0))
        
        # Hora e plataforma
        time_info = tk.Label(info_frame, text=f"{meeting['time']} - {meeting['platform'].upper()}", 
                           font=("Arial", 8), 
                           fg='#7f8c8d')
        time_info.pack(side=tk.LEFT, padx=(10, 0))
        
        # Botão discreto para copiar link
        copy_button = tk.Button(info_frame, 
                              image=self.app.icons.get('copy_icon'),
                              relief=tk.FLAT, 
                              bd=0,
                              command=lambda m=meeting: self.copy_meeting_link(m))
        copy_button.pack(side=tk.RIGHT, padx=(5, 0))
        
        # Tooltip para o botão
        copy_button.bind("<Enter>", lambda e, btn=copy_button: btn.config(bg='#e0e0e0'))
        copy_button.bind("<Leave>", lambda e, btn=copy_button: btn.config(bg='SystemButtonFace'))
    
    def copy_meeting_link(self, meeting):
        """Copia o link da reunião para a área de transferência"""
        try:
            self.app.root.clipboard_clear()
            self.app.root.clipboard_append(meeting['link'])
            # Mostrar feedback discreto
            messagebox.showinfo("Link Copiado", f"Link da reunião '{meeting['title']}' copiado para a área de transferência!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao copiar link: {e}")
    
    def _schedule_refresh(self):
        """Agenda atualização automática"""
        self.refresh_meetings()
        self.widget_frame.after(60000, self._schedule_refresh)  # Atualizar a cada minuto
    
    def open_notification_settings(self):
        """Abre configurações de notificação"""
        NotificationSettingsWindow(self.app)

class NotificationSettingsWindow:
    def __init__(self, app):
        self.app = app
        self.window = tk.Toplevel(app.root)
        self.window.title("Configurações de Notificação")
        self.window.geometry("500x400")
        self.window.transient(app.root)
        self.window.grab_set()
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
    
    def create_widgets(self):
        """Cria widgets da janela de configurações"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_label = ttk.Label(main_frame, text="Configurações de Notificação", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Configurações
        settings_frame = ttk.LabelFrame(main_frame, text="Notificações", padding="10")
        settings_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Habilitar notificações
        self.enabled_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['enabled'])
        ttk.Checkbutton(settings_frame, text="Habilitar notificações", 
                       variable=self.enabled_var).pack(anchor=tk.W, pady=2)
        
        # Som
        self.sound_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['sound_enabled'])
        ttk.Checkbutton(settings_frame, text="Tocar som", 
                       variable=self.sound_var).pack(anchor=tk.W, pady=2)
        
        # Popup
        self.popup_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['popup_enabled'])
        ttk.Checkbutton(settings_frame, text="Mostrar popup", 
                       variable=self.popup_var).pack(anchor=tk.W, pady=2)
        
        # Widget
        self.widget_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['show_widget'])
        ttk.Checkbutton(settings_frame, text="Mostrar widget na tela", 
                       variable=self.widget_var).pack(anchor=tk.W, pady=2)
        
        # Configurações avançadas
        advanced_frame = ttk.LabelFrame(main_frame, text="Configurações Avançadas", padding="10")
        advanced_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Antecedência da notificação
        ttk.Label(advanced_frame, text="Notificar (minutos antes):").pack(anchor=tk.W, pady=2)
        self.advance_var = tk.StringVar(value=str(self.app.notification_manager.notification_settings['advance_notification_minutes']))
        advance_entry = ttk.Entry(advanced_frame, textvariable=self.advance_var, width=10)
        advance_entry.pack(anchor=tk.W, pady=2)
        
        # Duração da notificação
        ttk.Label(advanced_frame, text="Duração do popup (segundos):").pack(anchor=tk.W, pady=2)
        self.duration_var = tk.StringVar(value=str(self.app.notification_manager.notification_settings['notification_duration']))
        duration_entry = ttk.Entry(advanced_frame, textvariable=self.duration_var, width=10)
        duration_entry.pack(anchor=tk.W, pady=2)
        
        # Posição do widget
        ttk.Label(advanced_frame, text="Posição do widget:").pack(anchor=tk.W, pady=2)
        self.position_var = tk.StringVar(value=self.app.notification_manager.notification_settings['widget_position'])
        position_combo = ttk.Combobox(advanced_frame, textvariable=self.position_var, 
                                     values=['top_right', 'top_left', 'bottom_right', 'bottom_left'], 
                                     state="readonly", width=15)
        position_combo.pack(anchor=tk.W, pady=2)
        
        # Botões
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=20)
        
        ttk.Button(button_frame, text="Salvar", 
                  command=self.save_settings).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Testar Notificação", 
                  command=self.test_notification).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancelar", 
                  command=self.window.destroy).pack(side=tk.RIGHT, padx=5)
    
    def save_settings(self):
        """Salva as configurações"""
        try:
            self.app.notification_manager.notification_settings.update({
                'enabled': self.enabled_var.get(),
                'sound_enabled': self.sound_var.get(),
                'popup_enabled': self.popup_var.get(),
                'show_widget': self.widget_var.get(),
                'advance_notification_minutes': int(self.advance_var.get()),
                'notification_duration': int(self.duration_var.get()),
                'widget_position': self.position_var.get()
            })
            
            self.app.notification_manager.save_notification_settings()
            
            # Reiniciar monitor se necessário
            if self.app.notification_manager.notification_settings['enabled']:
                self.app.notification_manager.stop_notification_monitor()
                self.app.notification_manager.start_notification_monitor()
            
            messagebox.showinfo("Sucesso", "Configurações salvas com sucesso!")
            self.window.destroy()
            
        except ValueError:
            messagebox.showerror("Erro", "Por favor, insira valores numéricos válidos.")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar configurações: {e}")
    
    def test_notification(self):
        """Testa a notificação"""
        test_meeting = {
            'title': 'Reunião de Teste',
            'date': datetime.now().strftime('%Y-%m-%d'),
            'time': datetime.now().strftime('%H:%M'),
            'platform': 'test',
            'link': '#'
        }
        
        self.app.notification_manager._show_meeting_notification(test_meeting)

class GoogleCalendarManager:
    def __init__(self):
        self.service = None
        self.credentials = None
        
    def authenticate(self):
        """Autentica com a API do Google Calendar"""
        try:
            # Verificar se já temos credenciais salvas
            if os.path.exists(TOKEN_FILE):
                with open(TOKEN_FILE, 'rb') as token:
                    self.credentials = pickle.load(token)
            
            # Se não há credenciais válidas, fazer login
            if not self.credentials or not self.credentials.valid:
                if self.credentials and self.credentials.expired and self.credentials.refresh_token:
                    self.credentials.refresh(Request())
                else:
                    if not os.path.exists(CREDENTIALS_FILE):
                        messagebox.showerror("Erro", 
                                           "Arquivo credentials.json não encontrado!\n\n"
                                           "Para usar o Google Meet:\n"
                                           "1. Acesse https://console.cloud.google.com\n"
                                           "2. Crie um projeto e ative a Google Calendar API\n"
                                           "3. Crie credenciais OAuth 2.0\n"
                                           "4. Baixe o arquivo como 'credentials.json'\n"
                                           "5. Coloque na pasta do aplicativo")
                        return False
                    
                    flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_FILE, SCOPES)
                    self.credentials = flow.run_local_server(port=0)
                
                # Salvar credenciais para uso futuro
                with open(TOKEN_FILE, 'wb') as token:
                    pickle.dump(self.credentials, token)
            
            # Construir o serviço
            self.service = build('calendar', 'v3', credentials=self.credentials)
            return True
            
        except Exception as e:
            messagebox.showerror("Erro de Autenticação", f"Erro ao autenticar com Google Calendar:\n{str(e)}")
            return False
    
    def create_meeting(self, title, date, time_str, duration=60, description="", timezone="America/Sao_Paulo"):
        """Cria uma reunião real no Google Calendar com Google Meet"""
        try:
            if not self.service:
                if not self.authenticate():
                    return None
            
            # Converter data e hora para datetime
            datetime_str = f"{date} {time_str}"
            start_time = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M")
            end_time = start_time + timedelta(minutes=duration)
            
            # Formatar para RFC3339 com fuso horário (sem 'Z' no final)
            start_rfc = start_time.isoformat()
            end_rfc = end_time.isoformat()
            
            # Criar evento no Google Calendar
            event = {
                'summary': title,
                'description': description,
                'start': {
                    'dateTime': start_rfc,
                    'timeZone': timezone,
                },
                'end': {
                    'dateTime': end_rfc,
                    'timeZone': timezone,
                },
                'conferenceData': {
                    'createRequest': {
                        'requestId': f"meet_{int(time.time())}",
                        'conferenceSolutionKey': {
                            'type': 'hangoutsMeet'
                        }
                    }
                }
            }
            
            # Inserir evento
            event = self.service.events().insert(
                calendarId='primary',
                body=event,
                conferenceDataVersion=1
            ).execute()
            
            # Extrair link do Google Meet
            meet_link = event.get('conferenceData', {}).get('entryPoints', [{}])[0].get('uri', '')
            
            return {
                'id': event['id'],
                'title': title,
                'date': date,
                'time': time_str,
                'duration': duration,
                'link': meet_link,
                'platform': 'google_meet',
                'created_by': 'Sistema',
                'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'status': 'scheduled',
                'google_event_id': event['id']
            }
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao criar reunião no Google Meet:\n{str(e)}")
            return None
    
    def cancel_meeting(self, event_id):
        """Cancela uma reunião no Google Calendar"""
        try:
            if not self.service:
                if not self.authenticate():
                    return False
            
            # Deletar evento do Google Calendar
            self.service.events().delete(
                calendarId='primary',
                eventId=event_id
            ).execute()
            
            print(f"✅ Reunião cancelada no Google Calendar: {event_id}")
            return True
            
        except Exception as e:
            print(f"❌ Erro ao cancelar reunião no Google Calendar: {e}")
            return False

# New function to load all icons
def load_app_icons(base_dir):
    print("DEBUG: Iniciando load_app_icons")
    icons = {}
    # Helper function to load images safely within this scope
    def _load_image(filename, size):
        try:
            path = os.path.join(base_dir, filename)
            img = Image.open(path)
            return ImageTk.PhotoImage(img.resize(size))
        except FileNotFoundError:
            print(f"Erro: Arquivo de imagem não encontrado: {filename}")
            return None # Return None or a placeholder image
        except Exception as e:
            print(f"Erro ao carregar imagem {filename}: {e}")
            return None

    small_icon_size = (16, 16)
    large_icon_size = (32, 32)

    # Load small icons (16x16) for menus and compact areas
    icons['logo_icon'] = _load_image("LOGO.png", (32, 32)) # Keep logo larger
    icons['add_icon'] = _load_image("Add.png", small_icon_size)
    icons['delete_icon'] = _load_image("Delete.png", small_icon_size)
    icons['save_icon'] = _load_image("Save.png", small_icon_size)
    icons['search_icon'] = _load_image("Search.png", small_icon_size)
    icons['key_icon'] = _load_image("Key.png", small_icon_size)
    icons['cancel_icon'] = _load_image("Cancel.png", small_icon_size)
    icons['up_icon'] = _load_image("Up.png", small_icon_size)
    icons['down_icon'] = _load_image("Down.png", small_icon_size)
    icons['back_icon'] = _load_image("Back.png", small_icon_size)
    icons['left_icon'] = _load_image("Left.png", small_icon_size)
    icons['right_icon'] = _load_image("Right.png", small_icon_size)
    icons['forward_icon'] = _load_image("Forward.png", small_icon_size)
    icons['ok_icon'] = _load_image("Ok.png", small_icon_size)
    icons['settings_icon'] = _load_image("Settings.png", small_icon_size)
    icons['exit_icon'] = _load_image("Exit.png", small_icon_size)
    icons['folder_icon'] = _load_image("Folder.png", small_icon_size)
    icons['pencil_icon'] = _load_image("Pencil.png", small_icon_size)
    icons['clear_icon'] = _load_image("Clear.png", small_icon_size)
    icons['apply_icon'] = _load_image("Apply.png", small_icon_size)
    icons['add_folder_icon'] = _load_image("Add folder.png", small_icon_size)
    icons['info_icon'] = _load_image("Info.png", small_icon_size)
    icons['play_icon'] = _load_image("Play.png", small_icon_size)
    icons['stop_icon'] = _load_image("Stop.png", small_icon_size)
    icons['refresh_icon'] = _load_image("Refresh.png", small_icon_size)
    icons['time_icon'] = _load_image("Time.png", small_icon_size)
    icons['import_icon'] = _load_image("Import.png", small_icon_size)
    icons['export_icon'] = _load_image("Export.png", small_icon_size)
    icons['registration_icon'] = _load_image("Registration.png", small_icon_size)
    icons['chart_xy_icon'] = _load_image("Chart xy.png", small_icon_size)
    icons['pie_chart_icon'] = _load_image("Pie chart.png", small_icon_size)
    icons['bar_chart_icon'] = _load_image("3d bar chart.png", small_icon_size)
    icons['objects_icon'] = _load_image("Objects.png", small_icon_size)
    icons['coffee_icon'] = _load_image("Coffee.png", small_icon_size)
    icons['card_icon'] = _load_image("card.png", small_icon_size)  # Ícone para cartões
    icons['chat_icon'] = _load_image("chat.png", small_icon_size)  # Ícone para chat
    icons['calendar_icon'] = _load_image("Calendar.png", small_icon_size)  # Ícone específico para calendário
    icons['copy_icon'] = _load_image("Apply.png", small_icon_size)  # Usar Apply como copy
    icons['meet_icon'] = _load_image("Play.png", small_icon_size)  # Usar Play como meet
    icons['home_icon'] = _load_image("Home.png", small_icon_size)  # Ícone para Menu Principal
    icons['money_icon'] = _load_image("Money.png", small_icon_size)  # Ícone para Finanças
    icons['gantt_icon'] = _load_image("Chart xy.png", small_icon_size)  # Ícone para Gráfico de Gantt
    icons['dashboard_icon'] = _load_image("Bar chart.png", small_icon_size)  # Ícone para Dashboard
    icons['reuniao_icon'] = _load_image("reuniao.png", small_icon_size)  # Ícone para reuniões
    icons['pomodoro_icon'] = _load_image("pomodoro.png", small_icon_size)  # Ícone para Pomodoro
    icons['minhas_atividades_icon'] = _load_image("minhasatividadess.png", small_icon_size)  # Ícone para Minhas Atividades

    # Load large icons (32x32) for main action buttons
    icons['forward_icon_32'] = _load_image("Forward.png", large_icon_size)
    icons['open_file_icon_32'] = _load_image("Open file.png", large_icon_size)
    icons['refresh_icon_32'] = _load_image("Refresh.png", large_icon_size)
    icons['save_icon_32'] = _load_image("Save.png", large_icon_size)
    icons['cancel_icon_32'] = _load_image("Cancel.png", large_icon_size)
    
    # Dashboard icons (32x32)
    icons['chart_icon_32'] = _load_image("Chart xy.png", large_icon_size)
    icons['team_icon_32'] = _load_image("Objects.png", large_icon_size)
    icons['clock_icon_32'] = _load_image("Time.png", large_icon_size)
    icons['burndown_icon_32'] = _load_image("Bar chart.png", large_icon_size)
    icons['ai_icon_32'] = _load_image("Info.png", large_icon_size)
    icons['meeting_icon_32'] = _load_image("reuniao.png", large_icon_size)
    icons['export_icon_32'] = _load_image("Export.png", large_icon_size)
    icons['chart_xy_icon_32'] = _load_image("Chart xy.png", large_icon_size)
    
    # Load check status icons (32x32)
    icons['check_white_icon_32'] = _load_image("checkembranco.png", large_icon_size)
    icons['check_completed_icon_32'] = _load_image("concluido.png", large_icon_size)

    return icons

# --- Helper Classes ---

class LoginWindow(tk.Toplevel):
    def __init__(self, parent, db, icons):
        super().__init__(parent)
        self.parent = parent
        self.db = db
        self.icons = icons
        
        print("DEBUG: LoginWindow.__init__ iniciado")
        
        self.title("Login - Sistema Boodesk")
        self.geometry("400x300")
        self.resizable(False, False)
        self.transient(parent)
        self.grab_set()
        self.protocol("WM_DELETE_WINDOW", self.cancel_login)

        # Centralizar a janela
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 400
        window_height = 300
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

        print("DEBUG: LoginWindow criando widgets...")
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        
        # Focar no campo de usuário
        self.user_entry.focus()
        
        # Garantir que a janela seja visível
        self.after(100, self.ensure_visibility)
        print("DEBUG: LoginWindow criada com sucesso")

    def create_widgets(self):
        # Aumentar o tamanho da janela para acomodar todos os elementos
        self.geometry("500x500")
        
        main_frame = ttk.Frame(self, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configurar grid
        main_frame.columnconfigure(1, weight=1)
        
        # Logo e título
        logo_frame = ttk.Frame(main_frame)
        logo_frame.grid(row=0, column=0, columnspan=2, pady=(0, 20))
        
        if self.icons.get('logo_icon'):
            logo_label = ttk.Label(logo_frame, image=self.icons['logo_icon'])
            logo_label.pack(side=tk.LEFT, padx=(0, 10))
        
        title_label = ttk.Label(logo_frame, text="Sistema Boodesk", font=("Arial", 16, "bold"))
        title_label.pack(side=tk.LEFT)
        
        # Subtítulo
        subtitle_label = ttk.Label(main_frame, text="Faça login para continuar", font=("Arial", 10))
        subtitle_label.grid(row=1, column=0, columnspan=2, pady=(0, 20))
        
        # Campo de usuário com ícone
        user_frame = ttk.Frame(main_frame)
        user_frame.grid(row=2, column=0, columnspan=2, sticky="ew", pady=5)
        user_frame.columnconfigure(1, weight=1)
        
        ttk.Label(user_frame, text="👤 Usuário:", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="w")
        self.user_entry = ttk.Entry(user_frame, font=("Arial", 11), width=25)
        self.user_entry.grid(row=0, column=1, sticky="ew", padx=(10, 0))
        self.user_entry.insert(0, "admin")  # Preencher com admin por padrão
        self.user_entry.bind("<Return>", lambda e: self.password_entry.focus())
        self.user_entry.bind("<Tab>", lambda e: self.password_entry.focus())
        
        # Campo de senha com ícone
        password_frame = ttk.Frame(main_frame)
        password_frame.grid(row=3, column=0, columnspan=2, sticky="ew", pady=5)
        password_frame.columnconfigure(1, weight=1)
        
        ttk.Label(password_frame, text="🔒 Senha:", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="w")
        self.password_entry = ttk.Entry(password_frame, show="*", font=("Arial", 11), width=25)
        self.password_entry.grid(row=0, column=1, sticky="ew", padx=(10, 0))
        self.password_entry.bind("<Return>", lambda e: self.check_login())
        self.password_entry.bind("<Tab>", lambda e: self.user_entry.focus())
        
        # Frame dos botões - Melhorado para garantir visibilidade
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=4, column=0, columnspan=2, pady=20, sticky="ew")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        
        # Botão de login com ícone
        login_btn = ttk.Button(button_frame, text="🔐 Entrar", 
                              command=self.check_login, style="Accent.TButton")
        login_btn.grid(row=0, column=0, padx=5, sticky="ew")
        
        # Botão de cadastro com ícone
        register_btn = ttk.Button(button_frame, text="📝 Cadastrar", 
                                 command=self.open_user_registration)
        register_btn.grid(row=0, column=1, padx=5, sticky="ew")
        
        # Botão sair com ícone (visível)
        exit_btn = ttk.Button(button_frame, text="🚪 Sair", 
                             command=self.cancel_login)
        exit_btn.grid(row=0, column=2, padx=5, sticky="ew")
        
        # Informações de usuários padrão
        info_frame = ttk.LabelFrame(main_frame, text="👥 Usuários Padrão", padding="10")
        info_frame.grid(row=5, column=0, columnspan=2, pady=(10, 0), sticky="ew")
        
        info_text = """Usuários padrão do sistema:
• admin / admin123 (Administrador)
• user / user123 (Usuário)
• manager / manager123 (Gerente)"""
        
        info_label = ttk.Label(info_frame, text=info_text, font=("Arial", 9), justify=tk.LEFT)
        info_label.pack()
        
        # Centralizar a janela novamente após ajustar o tamanho
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 500
        window_height = 500
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

    def check_login(self):
        username = self.user_entry.get().strip()
        password = self.password_entry.get()
        
        if not username or not password:
            messagebox.showerror("Erro", "Por favor, preencha todos os campos!")
            return
        
        user_data = self.db.get_user_by_username(username)
        
        if user_data and user_data['password_hash'] == password:
            user = User(
                username=user_data['username'],
                role=user_data['role'],
                cargo=user_data['cargo'],
                user_id=user_data['id']
            )
            user.is_authenticated = True
            user.login_time = datetime.now()
            
            self.parent.login_successful = True
            self.parent.current_user = user
            messagebox.showinfo("Login Bem-sucedido", f"Bem-vindo, {user.username}!\nNível de acesso: {user.cargo}")
            self.destroy()
        else:
            messagebox.showerror("Erro de Login", "Usuário ou senha incorretos!")
            self.password_entry.delete(0, tk.END)
            self.password_entry.focus()

    def open_user_registration(self):
        """Abre a janela de cadastro de usuários"""
        UserRegistrationWindow(self, self.db, self.icons)

    def ensure_visibility(self):
        """Garante que a janela seja visível"""
        print("DEBUG: ensure_visibility chamado")
        self.lift()
        self.focus_force()
        self.deiconify()
        self.update()
        print("DEBUG: Janela de login deve estar visível agora")
        
    def on_user_keypress(self, event):
        """Trata teclas no campo usuário"""
        if event.keysym == 'Return':
            print("DEBUG: Enter pressionado no campo usuário")
            self.password_entry.focus()
            return "break"
        elif event.keysym == 'Tab':
            # Permitir navegação com Tab
            return None
    
    def on_password_keypress(self, event):
        """Trata teclas no campo senha"""
        if event.keysym == 'Return':
            print("DEBUG: Enter pressionado no campo senha")
            self.check_login()
            return "break"
        elif event.keysym == 'Tab':
            # Permitir navegação com Tab
            return None
            return "break"
        elif event.keysym == 'Tab':
            # Permitir navegação com Tab
            return None
    
    def cancel_login(self):
        self.parent.login_successful = False
        self.destroy()

class UserRegistrationWindow(tk.Toplevel):
    def __init__(self, parent, db, icons, app=None, preselected_member_id=None):
        try:
            super().__init__(parent)
            self.parent = parent
            self.db = db
            self.icons = icons
            self.app = app
            self.preselected_member_id = preselected_member_id
            
            print("DEBUG: Inicializando UserRegistrationWindow...")
            
            self.title("Cadastro de Usuários")
            self.geometry("700x500")
            self.resizable(True, True)
            self.transient(parent)
            self.grab_set()
            
            # Centralizar a janela
            self.update_idletasks()
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()
            window_width = 700
            window_height = 500
            x = (screen_width - window_width) // 2
            y = (screen_height - window_height) // 2
            self.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            # Variáveis para edição
            self.edit_mode = False
            self.selected_user_id = None
            
            print("DEBUG: Criando widgets...")
            try:
                if hasattr(self, 'create_widgets'):
                    self.create_widgets()
            except Exception as e:
                print(f"⚠️ Erro ao criar widgets: {e}")
            
            print("DEBUG: Populando lista de usuários...")
            self.populate_users_list()
            
            print("DEBUG: UserRegistrationWindow inicializada com sucesso!")
            
        except Exception as e:
            print(f"DEBUG: Erro ao inicializar UserRegistrationWindow: {e}")
            messagebox.showerror("Erro", f"Não foi possível abrir a tela de gerenciar usuários: {e}")
            self.destroy()
    
    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configurar grid
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # Título
        title_label = ttk.Label(main_frame, text="Gerenciamento de Usuários", font=("Arial", 14, "bold"))
        title_label.grid(row=0, column=0, pady=(0, 10))
        
        # Frame da lista de usuários
        list_frame = ttk.LabelFrame(main_frame, text="Lista de Usuários", padding="5")
        list_frame.grid(row=1, column=0, sticky="nsew", pady=(0, 10))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        # Treeview para lista de usuários
        columns = ("ID", "Usuário", "Cargo", "Role", "Criado em", "Último Login")
        self.users_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=8)
        
        # Configurar colunas
        self.users_tree.heading("ID", text="ID")
        self.users_tree.heading("Usuário", text="Usuário")
        self.users_tree.heading("Cargo", text="Cargo")
        self.users_tree.heading("Role", text="Nível de Acesso")
        self.users_tree.heading("Criado em", text="Criado em")
        self.users_tree.heading("Último Login", text="Último Login")
        
        self.users_tree.column("ID", width=50, anchor="center")
        self.users_tree.column("Usuário", width=120, anchor="w")
        self.users_tree.column("Cargo", width=100, anchor="w")
        self.users_tree.column("Role", width=100, anchor="w")
        self.users_tree.column("Criado em", width=120, anchor="w")
        self.users_tree.column("Último Login", width=120, anchor="w")
        
        self.users_tree.grid(row=0, column=0, sticky="nsew", pady=5)
        self.users_tree.bind("<<TreeviewSelect>>", self.on_user_select)
        
        # Scrollbar para a lista
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.users_tree.yview)
        scrollbar.grid(row=0, column=1, sticky="ns")
        self.users_tree.config(yscrollcommand=scrollbar.set)
        
        # Frame do formulário
        form_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Usuário", padding="10")
        form_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        form_frame.columnconfigure(1, weight=1)
        
        # Campos do formulário
        ttk.Label(form_frame, text="Usuário:").grid(row=0, column=0, sticky="w", pady=2)
        self.username_entry = ttk.Entry(form_frame)
        self.username_entry.grid(row=0, column=1, sticky="ew", padx=(5, 0), pady=2)
        
        ttk.Label(form_frame, text="Senha:").grid(row=1, column=0, sticky="w", pady=2)
        self.password_entry = ttk.Entry(form_frame, show="*")
        self.password_entry.grid(row=1, column=1, sticky="ew", padx=(5, 0), pady=2)
        
        ttk.Label(form_frame, text="Cargo:").grid(row=2, column=0, sticky="w", pady=2)
        self.cargo_combo = ttk.Combobox(form_frame, state="readonly")
        try:
            if self.app and hasattr(self.app, 'settings') and 'roles' in self.app.settings:
                self.cargo_combo['values'] = list(self.app.settings['roles'].keys())
        except Exception:
            pass
        if not self.cargo_combo['values']:
            self.cargo_combo['values'] = ["Usuário", "Administrador", "Manager"]
        self.cargo_combo.set(self.cargo_combo['values'][0])
        self.cargo_combo.grid(row=2, column=1, sticky="ew", padx=(5, 0), pady=2)
        cargo_btn = ttk.Button(form_frame, text="Cadastrar Cargo", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self._open_roles_settings_from_users)
        cargo_btn.grid(row=2, column=2, padx=5, pady=2, sticky="w")
        
        ttk.Label(form_frame, text="Nível de Acesso:").grid(row=3, column=0, sticky="w", pady=2)
        self.role_combo = ttk.Combobox(form_frame, values=["user", "manager", "admin"], state="readonly")
        self.role_combo.set("user")
        self.role_combo.grid(row=3, column=1, sticky="ew", padx=(5, 0), pady=2)
        
        ttk.Label(form_frame, text="Membro:").grid(row=4, column=0, sticky="w", pady=2)
        self.member_combo = ttk.Combobox(form_frame, state="readonly")
        self.member_combo.grid(row=4, column=1, sticky="ew", padx=(5, 0), pady=2)
        member_btn = ttk.Button(form_frame, text="Cadastrar Membro", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self._open_members_window_from_users)
        member_btn.grid(row=4, column=2, padx=5, pady=2, sticky="w")
        self.populate_members_combo()
        
        # Frame dos botões do formulário
        form_buttons_frame = ttk.Frame(form_frame)
        form_buttons_frame.grid(row=5, column=0, columnspan=2, pady=10)
        form_buttons_frame.columnconfigure(0, weight=1)
        form_buttons_frame.columnconfigure(1, weight=1)
        
        ttk.Button(form_buttons_frame, text="Adicionar Usuário", 
                  image=self.icons.get('add_icon'), compound=tk.LEFT, 
                  command=self.add_user).grid(row=0, column=0, padx=2)
        
        ttk.Button(form_buttons_frame, text="Limpar", 
                  image=self.icons.get('clear_icon'), compound=tk.LEFT, 
                  command=self.clear_form).grid(row=0, column=1, padx=2)
        
        # Frame dos botões de ação
        action_frame = ttk.Frame(main_frame)
        action_frame.grid(row=3, column=0, pady=5)
        
        ttk.Button(action_frame, text="Editar Usuário", 
                  image=self.icons.get('edit_icon'), compound=tk.LEFT, 
                  command=self.edit_user).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(action_frame, text="Remover Usuário", 
                  image=self.icons.get('delete_icon'), compound=tk.LEFT, 
                  command=self.remove_user).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(action_frame, text="Atualizar Lista", 
                  image=self.icons.get('refresh_icon'), compound=tk.LEFT, 
                  command=self.populate_users_list).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(action_frame, text="Fechar", 
                  image=self.icons.get('cancel_icon'), compound=tk.LEFT, 
                  command=self.destroy).pack(side=tk.LEFT, padx=5)
    
    def populate_members_combo(self):
        """Popula o combo de membros"""
        try:
            import sqlite3
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("SELECT id, membro, email FROM members ORDER BY membro")
            members = cursor.fetchall()
            conn.close()
            
            # Criar lista de membros para o combo
            member_list = []
            self.member_dict = {}  # Dicionário para mapear nome -> id
            
            for member_id, name, email in members:
                # Tratar email nulo ou vazio
                if email is None or email == '' or email == 'nan':
                    display_name = f"{name} (sem email)"
                else:
                    display_name = f"{name} ({email})"
                
                member_list.append(display_name)
                self.member_dict[display_name] = member_id
            
            self.member_combo['values'] = member_list
            if member_list:
                if self.preselected_member_id and self.preselected_member_id in self.member_dict.values():
                    for display_name, mid in self.member_dict.items():
                        if mid == self.preselected_member_id:
                            self.member_combo.set(display_name)
                            break
                else:
                    self.member_combo.set(member_list[0])
            
        except Exception as e:
            print(f"DEBUG: Erro ao popular combo de membros: {e}")

    def _open_roles_settings_from_users(self):
        """Abre a aba de cargos das configurações a partir da tela de usuários"""
        try:
            if not self.app:
                messagebox.showerror("Erro", "Aplicação não disponível para abrir Cargos.")
                return
            # Abrir configurações normalmente
            settings_window = SettingsWindow(self.master, self.app)
            self.master.wait_window(settings_window)
            # Atualizar lista de cargos após fechar as configurações
            if self.app and hasattr(self.app, 'settings') and 'roles' in self.app.settings:
                if hasattr(self, 'cargo_combo') and self.cargo_combo:
                    self.cargo_combo['values'] = list(self.app.settings['roles'].keys())
                    if self.cargo_combo.get() not in self.cargo_combo['values'] and self.cargo_combo['values']:
                        self.cargo_combo.set(self.cargo_combo['values'][0])
        except Exception as e:
            print(f"DEBUG: Erro ao abrir configurações de cargos pela tela de usuários: {e}")
            messagebox.showerror("Erro", f"Não foi possível abrir as configurações de cargos: {e}")

    def _open_members_window_from_users(self):
        """Abre a janela de gerenciamento de membros a partir da tela de usuários"""
        try:
            if not self.app:
                messagebox.showerror("Erro", "Aplicação não disponível para abrir Membros.")
                return
            
            # Abrir janela de membros
            members_window = MembersWindow(self.master, self.app)
            self.master.wait_window(members_window)
            
            # Atualizar lista de membros após fechar a janela
            self.populate_members_combo()
            
        except Exception as e:
            print(f"DEBUG: Erro ao abrir janela de membros pela tela de usuários: {e}")
            messagebox.showerror("Erro", f"Não foi possível abrir a janela de membros: {e}")
    
    def populate_users_list(self):
        """Popula a lista de usuários"""
        try:
            print("DEBUG: Populando lista de usuários...")
            
            # Limpar lista atual
            for item in self.users_tree.get_children():
                self.users_tree.delete(item)
            
            # Usar o banco de dados PostgreSQL
            users = self.app.db.get_all_users()
            
            print(f"DEBUG: {len(users)} usuários encontrados")
            
            for user in users:
                try:
                    user_id = user.get('id')
                    username = user.get('username', '')
                    cargo = user.get('cargo', '')
                    role = user.get('role', '')
                    created_at = user.get('created_at')
                    updated_at = user.get('updated_at')
                    
                    # Formatar data de criação
                    if created_at:
                        try:
                            if isinstance(created_at, str):
                                created_at = datetime.strptime(created_at, '%Y-%m-%d %H:%M:%S.%f').strftime('%d/%m/%Y %H:%M')
                            else:
                                created_at = created_at.strftime('%d/%m/%Y %H:%M')
                        except:
                            created_at = str(created_at)[:19] if len(str(created_at)) > 19 else str(created_at)
                    else:
                        created_at = "N/A"

                    # Formatar data de último login (usar updated_at como aproximação)
                    if updated_at:
                        try:
                            if isinstance(updated_at, str):
                                last_login = datetime.strptime(updated_at, '%Y-%m-%d %H:%M:%S.%f').strftime('%d/%m/%Y %H:%M')
                            else:
                                last_login = updated_at.strftime('%d/%m/%Y %H:%M')
                        except:
                            last_login = str(updated_at)[:19] if len(str(updated_at)) > 19 else str(updated_at)
                    else:
                        last_login = "Nunca"

                    self.users_tree.insert("", "end", values=(
                        user_id,
                        username,
                        cargo,
                        role,
                        created_at,
                        last_login
                    ))
                except Exception as e:
                    print(f"DEBUG: Erro ao processar usuário {user}: {e}")
                    continue
            
            print("DEBUG: Lista de usuários populada com sucesso!")
            
        except Exception as e:
            print(f"DEBUG: Erro ao popular lista de usuários: {e}")
            messagebox.showerror("Erro", f"Não foi possível carregar a lista de usuários: {e}")
    
    def on_user_select(self, event):
        """Manipula seleção de usuário na lista"""
        selected_item = self.users_tree.selection()
        if selected_item:
            values = self.users_tree.item(selected_item, "values")
            self.selected_user_id = int(values[0])
            
            # Preencher formulário para edição
            self.username_entry.delete(0, tk.END)
            self.username_entry.insert(0, values[1])
            
            if hasattr(self, 'cargo_combo') and self.cargo_combo['values']:
                if values[2] in self.cargo_combo['values']:
                    self.cargo_combo.set(values[2])
                else:
                    try:
                        self.cargo_combo['values'] = list(dict.fromkeys([values[2], *self.cargo_combo['values']]))
                        self.cargo_combo.set(values[2])
                    except Exception:
                        pass
            
            self.role_combo.set(values[3])
            
            # Buscar e preencher o membro associado
            try:
                user_data = self.app.db.get_user_by_id(self.selected_user_id)
                if user_data and user_data.get('member_id'):
                    member_id = user_data['member_id']
                    # Encontrar o membro no combo
                    for display_name, mid in self.member_dict.items():
                        if mid == member_id:
                            self.member_combo.set(display_name)
                            break
            except Exception as e:
                print(f"DEBUG: Erro ao buscar membro associado: {e}")
            
            # Limpar senha (não mostrar senha atual)
            self.password_entry.delete(0, tk.END)
            
            self.edit_mode = True
        else:
            self.edit_mode = False
            self.selected_user_id = None
    
    def add_user(self):
        """Adiciona um novo usuário"""
        username = self.username_entry.get().strip()
        password = self.password_entry.get()
        cargo = self.cargo_combo.get().strip()
        role = self.role_combo.get()
        member_selection = self.member_combo.get()
        
        if not username or not password or not cargo or not member_selection:
            messagebox.showerror("Erro", "Todos os campos são obrigatórios!")
            return
        
        # Obter o ID do membro selecionado
        member_id = self.member_dict.get(member_selection)
        if not member_id:
            messagebox.showerror("Erro", "Selecione um membro válido!")
            return
        
        # Usar o banco de dados SQLite diretamente
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Verificar se usuário já existe
            cursor.execute("SELECT id FROM users WHERE username = %s", (username,))
            if cursor.fetchone():
                messagebox.showerror("Erro", "Usuário já existe")
                conn.close()
                return
            
            # Inserir novo usuário
            cursor.execute("""
                INSERT INTO users (username, password_hash, email, role, cargo, member_id, created_at, updated_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """, (username, password, "", role, cargo, member_id, datetime.now(), datetime.now()))
            
            conn.commit()
            conn.close()
            
            messagebox.showinfo("Sucesso", "Usuário registrado com sucesso")
            self.clear_form()
            self.populate_users_list()
            
        except Exception as e:
            print(f"DEBUG: Erro ao adicionar usuário: {e}")
            messagebox.showerror("Erro", f"Erro ao registrar usuário: {e}")
    
    def edit_user(self):
        """Edita um usuário selecionado"""
        if not self.edit_mode or not self.selected_user_id:
            messagebox.showwarning("Aviso", "Selecione um usuário para editar!")
            return
        
        username = self.username_entry.get().strip()
        password = self.password_entry.get()
        cargo = self.cargo_combo.get().strip()
        role = self.role_combo.get()
        member_selection = self.member_combo.get()
        
        if not username or not cargo or not member_selection:
            messagebox.showerror("Erro", "Usuário, cargo e membro são obrigatórios!")
            return
        
        # Obter o ID do membro selecionado
        member_id = self.member_dict.get(member_selection)
        if not member_id:
            messagebox.showerror("Erro", "Selecione um membro válido!")
            return
        
        # Usar o banco de dados SQLite diretamente
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Atualizar usuário
            if password:  # Se senha foi fornecida, atualizar
                cursor.execute("""
                    UPDATE users SET username = %s, password_hash = %s, role = %s, cargo = %s, member_id = %s, updated_at = %s
                    WHERE id = %s
                """, (username, password, role, cargo, member_id, datetime.now(), self.selected_user_id))
            else:  # Se não, manter senha atual
                cursor.execute("""
                    UPDATE users SET username = %s, role = %s, cargo = %s, member_id = %s, updated_at = %s
                    WHERE id = %s
                """, (username, role, cargo, member_id, datetime.now(), self.selected_user_id))
            
            conn.commit()
            conn.close()
            
            messagebox.showinfo("Sucesso", "Usuário atualizado com sucesso")
            self.clear_form()
            self.populate_users_list()
            
        except Exception as e:
            print(f"DEBUG: Erro ao editar usuário: {e}")
            messagebox.showerror("Erro", f"Erro ao atualizar usuário: {e}")
    
    def remove_user(self):
        """Remove um usuário selecionado"""
        if not self.edit_mode or not self.selected_user_id:
            messagebox.showwarning("Aviso", "Selecione um usuário para remover!")
            return
        
        username = self.username_entry.get()
        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover o usuário '{username}'?"):
            # Usar o banco de dados SQLite diretamente
            try:
                import sqlite3
                
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                
                # Remover usuário
                cursor.execute("DELETE FROM users WHERE id = %s", (self.selected_user_id,))
                
                conn.commit()
                conn.close()
                
                messagebox.showinfo("Sucesso", "Usuário removido com sucesso")
                self.clear_form()
                self.populate_users_list()
                
            except Exception as e:
                print(f"DEBUG: Erro ao remover usuário: {e}")
                messagebox.showerror("Erro", f"Erro ao remover usuário: {e}")

    def clear_form(self):
        """Limpa o formulário"""
        self.username_entry.delete(0, tk.END)
        self.password_entry.delete(0, tk.END)
        if hasattr(self, 'cargo_combo') and self.cargo_combo['values']:
            self.cargo_combo.set(self.cargo_combo['values'][0])
        self.role_combo.set("user")
        if hasattr(self, 'member_combo') and self.member_combo['values']:
            self.member_combo.set(self.member_combo['values'][0])
        self.edit_mode = False
        self.selected_user_id = None
        self.users_tree.selection_remove(*self.users_tree.selection())


class NumericEntryWithButtons(tk.Frame):
    def __init__(self, parent, icons, initial_value=0.00, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self._value = initial_value # Store as float internally

        self.entry = ttk.Entry(self, width=15, justify='right')
        self.entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.entry.bind("<FocusOut>", self._on_focus_out)
        self.entry.bind("<FocusIn>", self._on_focus_in)
        self.entry.bind("<KeyRelease>", self._on_key_release)

        self.up_button = ttk.Button(self, image=icons.get('up_icon'), width=2, command=self._increment)
        self.up_button.pack(side=tk.LEFT, padx=1)
        self.down_button = ttk.Button(self, image=icons.get('down_icon'), width=2, command=self._decrement)
        self.down_button.pack(side=tk.LEFT, padx=1)

        self._format_display() # Initial display

    def _format_display(self):
        # Formats the internal float value (dot) to display string (comma)
        display_text = f"{self._value:.2f}".replace('.', ',')
        self.entry.delete(0, tk.END)
        self.entry.insert(0, display_text)

    def _on_focus_in(self, event):
        # When focused, convert display string (comma) to internal float string (dot) for editing
        current_text = self.entry.get().replace(',', '.')
        try:
            val = float(current_text)
            self.entry.delete(0, tk.END)
            self.entry.insert(0, str(val)) # Show with dot for editing
        except ValueError:
            self.entry.delete(0, tk.END)
            self.entry.insert(0, "0.00") # Reset if invalid

    def _on_focus_out(self, event):
        # When focus leaves, update internal value from entry and re-apply display format
        self._update_value_from_entry()
        self._format_display()

    def _on_key_release(self, event):
        # Live update of internal value as user types, but don't reformat display yet
        self._update_value_from_entry(live_update=True) # Pass a flag for live update

    def _update_value_from_entry(self, live_update=False):
        current_text = self.entry.get().replace(',', '.')
        try:
            val = float(current_text)
            self._value = val
        except ValueError:
            # If invalid input during live typing, don't change the internal value
            # unless it's on focus out, then reset to 0.00
            if not live_update:
                self._value = 0.00
                self.entry.delete(0, tk.END)
                self.entry.insert(0, "0.00")

    def _increment(self):
        self._update_value_from_entry() # Ensure value is up-to-date
        self._value += 1.00 # Increment by 1.00
        self._format_display()

    def _decrement(self):
        self._update_value_from_entry() # Ensure value is up-to-date
        self._value -= 1.00 # Decrement by 1.00
        self._format_display()

    def get(self):
        self._update_value_from_entry() # Ensure value is up-to-date before returning
        return self._value

    def set(self, new_value):
        self._value = new_value
        self._format_display()

class DatePickerDialog(tk.Toplevel):
    def __init__(self, parent, current_date=None, icons=None):
        super().__init__(parent)
        self.parent = parent
        self.result_date = None
        self.title("Selecionar Data")
        self.transient(parent)
        self.grab_set()

        self.icons = icons or {}  # Store the icons dictionary or empty dict

        if current_date:
            try:
                if isinstance(current_date, str):
                    self.current_date = datetime.strptime(current_date, "%Y-%m-%d")
                else:
                    self.current_date = current_date
            except ValueError:
                self.current_date = datetime.now()
        else:
            self.current_date = datetime.now()

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        self.update_calendar()

        # Center the dialog
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')

    def create_widgets(self):
        # Navigation Frame
        nav_frame = ttk.Frame(self)
        nav_frame.pack(pady=5)

        # Usar texto em vez de ícones se não disponíveis
        ttk.Button(nav_frame, text="<<", command=self.prev_year).pack(side=tk.LEFT)
        ttk.Button(nav_frame, text="<", command=self.prev_month).pack(side=tk.LEFT)
        
        self.month_year_label = ttk.Label(nav_frame, text="", width=20, anchor="center")
        self.month_year_label.pack(side=tk.LEFT, padx=10)

        ttk.Button(nav_frame, text=">", command=self.next_month).pack(side=tk.LEFT)
        ttk.Button(nav_frame, text=">>", command=self.next_year).pack(side=tk.LEFT)

        # Day Labels (Sun, Mon, etc.)
        days_frame = ttk.Frame(self)
        days_frame.pack()
        for i, day in enumerate(["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"]):
            ttk.Label(days_frame, text=day, width=4, anchor="center").grid(row=0, column=i, padx=1, pady=1)

        # Calendar Grid
        self.calendar_frame = ttk.Frame(self)
        self.calendar_frame.pack()

        # OK/Cancel Buttons
        button_frame = ttk.Frame(self)
        button_frame.pack(pady=5)
        ttk.Button(button_frame, text="OK", command=self.ok).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.cancel).pack(side=tk.LEFT, padx=5)

    def update_calendar(self):
        for widget in self.calendar_frame.winfo_children():
            widget.destroy()

        self.month_year_label.config(text=self.current_date.strftime("%B %Y"))

        first_day_of_month = self.current_date.replace(day=1)
        # weekday() returns 0 for Monday, 6 for Sunday. We want 0 for Sunday.
        start_day_offset = (first_day_of_month.weekday() + 1) % 7 

        days_in_month = (self.current_date.replace(month=self.current_date.month % 12 + 1, day=1) - timedelta(days=1)).day

        for day_num in range(1, days_in_month + 1):
            row = (start_day_offset + day_num - 1) // 7
            col = (start_day_offset + day_num - 1) % 7
            
            date_to_check = self.current_date.replace(day=day_num)
            btn = ttk.Button(self.calendar_frame, text=str(day_num), width=4,
                             command=partial(self.select_date, date_to_check))
            btn.grid(row=row, column=col, padx=1, pady=1)

            if date_to_check.date() == datetime.now().date():
                btn.config(style="TButton") # Default style
            elif date_to_check.date() == self.current_date.date(): # Selected month, but not necessarily selected day
                btn.config(style="Accent.TButton") # Highlight current month days

    def prev_month(self):
        self.current_date = self.current_date.replace(day=1) - timedelta(days=1)
        self.update_calendar()

    def next_month(self):
        if self.current_date.month == 12:
            self.current_date = self.current_date.replace(year=self.current_date.year + 1, month=1, day=1)
        else:
            self.current_date = self.current_date.replace(month=self.current_date.month + 1, day=1)
        self.update_calendar()

    def prev_year(self):
        self.current_date = self.current_date.replace(year=self.current_date.year - 1)
        self.update_calendar()

    def next_year(self):
        self.current_date = self.current_date.replace(year=self.current_date.year + 1)
        self.update_calendar()

    def select_date(self, date):
        self.result_date = date
        self.ok()

    def ok(self):
        self.parent.focus_set()
        self.destroy()

    def cancel(self):
        self.result_date = None
        self.parent.focus_set()
        self.destroy()

    @property
    def selected_date(self):
        return self.result_date


class TimePickerDialog(tk.Toplevel):
    """Dialog para seleção de hora no formato brasileiro"""
    
    def __init__(self, parent, current_time="09:00"):
        super().__init__(parent)
        self.parent = parent
        self.selected_time = None
        self.title("Selecionar Hora")
        self.transient(parent)
        self.grab_set()
        
        # Parse current time
        try:
            self.current_hour, self.current_minute = map(int, current_time.split(':'))
        except:
            self.current_hour, self.current_minute = 9, 0
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        
        # Centralizar janela
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
    
    def create_widgets(self):
        """Cria os widgets da interface"""
        main_frame = ttk.Frame(self, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        ttk.Label(main_frame, text="Selecione a hora:", 
                 font=("Arial", 12, "bold")).pack(pady=(0, 20))
        
        # Frame para hora e minuto
        time_frame = ttk.Frame(main_frame)
        time_frame.pack(pady=10)
        
        # Hora
        hour_frame = ttk.Frame(time_frame)
        hour_frame.pack(side=tk.LEFT, padx=10)
        
        ttk.Label(hour_frame, text="Hora:").pack()
        
        # Spinbox para hora (0-23)
        self.hour_var = tk.StringVar(value=str(self.current_hour))
        hour_spinbox = ttk.Spinbox(hour_frame, from_=0, to=23, width=5,
                                  textvariable=self.hour_var, wrap=True)
        hour_spinbox.pack(pady=5)
        
        # Minuto
        minute_frame = ttk.Frame(time_frame)
        minute_frame.pack(side=tk.LEFT, padx=10)
        
        ttk.Label(minute_frame, text="Minuto:").pack()
        
        # Spinbox para minuto (0-59)
        self.minute_var = tk.StringVar(value=str(self.current_minute))
        minute_spinbox = ttk.Spinbox(minute_frame, from_=0, to=59, width=5,
                                    textvariable=self.minute_var, wrap=True)
        minute_spinbox.pack(pady=5)
        
        # Separador
        ttk.Label(time_frame, text=":", font=("Arial", 16, "bold")).pack(side=tk.LEFT, padx=5)
        
        # Botões de hora rápida
        quick_frame = ttk.LabelFrame(main_frame, text="Horas Comuns", padding="10")
        quick_frame.pack(fill=tk.X, pady=10)
        
        quick_hours = [
            ("08:00", "8:00"),
            ("09:00", "9:00"),
            ("10:00", "10:00"),
            ("11:00", "11:00"),
            ("12:00", "12:00"),
            ("13:00", "13:00"),
            ("14:00", "14:00"),
            ("15:00", "15:00"),
            ("16:00", "16:00"),
            ("17:00", "17:00"),
            ("18:00", "18:00")
        ]
        
        for i, (time_value, time_label) in enumerate(quick_hours):
            btn = ttk.Button(quick_frame, text=time_label, width=6,
                           command=lambda t=time_value: self.set_quick_time(t))
            btn.grid(row=i//5, column=i%5, padx=2, pady=2)
        
        # Botões de ação
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=20)
        
        ttk.Button(button_frame, text="OK", command=self.ok).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.cancel).pack(side=tk.RIGHT, padx=5)
    
    def set_quick_time(self, time_str):
        """Define uma hora rápida"""
        hour, minute = map(int, time_str.split(':'))
        self.hour_var.set(str(hour))
        self.minute_var.set(str(minute))
    
    def ok(self):
        """Confirma a seleção"""
        try:
            hour = int(self.hour_var.get())
            minute = int(self.minute_var.get())
            
            if 0 <= hour <= 23 and 0 <= minute <= 59:
                self.selected_time = f"{hour:02d}:{minute:02d}"
                self.parent.focus_set()
                self.destroy()
            else:
                messagebox.showerror("Erro", "Hora inválida!", parent=self)
        except ValueError:
            messagebox.showerror("Erro", "Hora inválida!", parent=self)
    
    def cancel(self):
        """Cancela a seleção"""
        self.selected_time = None
        self.parent.focus_set()
        self.destroy()


class SubtaskEditorWindow(tk.Toplevel):
    def __init__(self, parent, app, card, subtask):
        super().__init__(parent)
        self.app = app
        self.card = card
        self.subtask = subtask

        self.title(f"Editar Subtarefa")
        self.transient(parent)
        self.grab_set()
        self.geometry("450x350")

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text=f"Tarefa Principal: {self.card.get('title', '')}").pack(anchor="w")
        ttk.Label(main_frame, text=f"Subtarefa: {self.subtask.get('text', '')}").pack(anchor="w", pady=(0, 10))

        ttk.Label(main_frame, text="Descrição da Subtarefa:").pack(anchor="w", pady=(0, 5))
        self.desc_text = tk.Text(main_frame, wrap=tk.WORD, height=10)
        self.desc_text.pack(fill=tk.BOTH, expand=True)
        self.desc_text.insert("1.0", self.subtask.get("desc", ""))

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))

        ttk.Button(button_frame, text="Salvar", image=self.app.icons.get('save_icon_32'), compound=tk.LEFT, command=self.save_and_close).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", image=self.app.icons.get('cancel_icon_32'), compound=tk.LEFT, command=self.destroy).pack(side=tk.RIGHT)

    def save_and_close(self):
        new_desc = self.desc_text.get("1.0", tk.END).strip()
        self.subtask["desc"] = new_desc
        self.app.save_trello_data()
        if hasattr(self.app, 'activities_tree'):
            self.app.update_my_activities_tab()
        self.app.populate_boards()
        self.destroy()




class ThemeSettingsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Configurar Tema")
        self.geometry("350x150")
        self.transient(parent)
        self.grab_set()

        # Centralizar
        self.update_idletasks()
        x = parent.winfo_x() + (parent.winfo_width() // 2) - (self.winfo_width() // 2)
        y = parent.winfo_y() + (parent.winfo_height() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Escolha um tema para a aplicação:").pack(anchor="w", pady=5)

        # Combobox com temas
        self.theme_var = tk.StringVar()
        self.theme_combo = ttk.Combobox(main_frame, textvariable=self.theme_var, state="readonly")
        
        # Carregar temas disponíveis
        available_themes = sorted(self.app.root.get_themes())
        self.theme_combo['values'] = available_themes
        
        # Definir tema atual
        current_theme = self.app.db.get_setting('theme', default='arc', user_id=self.app.current_user.user_id)
        if current_theme in available_themes:
            self.theme_combo.set(current_theme)
        else:
            self.theme_combo.set('arc')

        self.theme_combo.pack(fill=tk.X, pady=5)

        # Botões
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Salvar", command=self.save_theme).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.destroy).pack(side=tk.RIGHT)

    def save_theme(self):
        selected_theme = self.theme_var.get()
        if not selected_theme:
            messagebox.showwarning("Nenhum Tema", "Por favor, selecione um tema.", parent=self)
            return

        try:
            # Salvar no banco de dados
            self.app.db.save_setting('theme', selected_theme, user_id=self.app.current_user.user_id)
            
            # Aplicar o tema imediatamente
            self.app.root.set_theme(selected_theme)
            
            messagebox.showinfo("Sucesso", f"Tema '{selected_theme}' aplicado com sucesso!", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erro", f"Não foi possível salvar ou aplicar o tema: {e}", parent=self)


class ThemeSettingsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Configurar Tema")
        self.geometry("350x150")
        self.transient(parent)
        self.grab_set()

        # Centralizar
        self.update_idletasks()
        x = parent.winfo_x() + (parent.winfo_width() // 2) - (self.winfo_width() // 2)
        y = parent.winfo_y() + (parent.winfo_height() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Escolha um tema para a aplicação:").pack(anchor="w", pady=5)

        # Combobox com temas
        self.theme_var = tk.StringVar()
        self.theme_combo = ttk.Combobox(main_frame, textvariable=self.theme_var, state="readonly")
        
        # Carregar temas disponíveis
        available_themes = sorted(self.app.root.get_themes())
        self.theme_combo['values'] = available_themes
        
        # Definir tema atual
        current_theme = self.app.db.get_setting('theme', default='arc', user_id=self.app.current_user.user_id)
        if current_theme in available_themes:
            self.theme_combo.set(current_theme)
        else:
            self.theme_combo.set('arc')

        self.theme_combo.pack(fill=tk.X, pady=5)

        # Botões
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Salvar", command=self.save_theme).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.destroy).pack(side=tk.RIGHT)

    def save_theme(self):
        selected_theme = self.theme_var.get()
        if not selected_theme:
            messagebox.showwarning("Nenhum Tema", "Por favor, selecione um tema.", parent=self)
            return

        try:
            # Salvar no banco de dados
            self.app.db.save_setting('theme', selected_theme, user_id=self.app.current_user.user_id)
            
            # Aplicar o tema imediatamente
            self.app.root.set_theme(selected_theme)
            
            messagebox.showinfo("Sucesso", f"Tema '{selected_theme}' aplicado com sucesso!", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erro", f"Não foi possível salvar ou aplicar o tema: {e}", parent=self)


class DraggableTreeview:
    """Treeview otimizado para drag and drop com cache de performance"""
    
    def __init__(self, treeview, app, board_name, list_name):
        self.treeview = treeview
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self._drag_data = {"item": None, "x": 0, "y": 0, "card_id": None, "source_treeview": None}
        self._drag_widget = None
        self._is_dragging = False
        
        # Cache para performance
        self._cached_items = {}
        self._last_update = 0
        
        # Configurar eventos otimizados
        self._setup_optimized_events()
    
    def _setup_optimized_events(self):
        """Configura eventos otimizados para drag and drop"""
        self.treeview.bind("<Button-1>", self._on_drag_start_optimized)
        self.treeview.bind("<B1-Motion>", self._on_drag_motion_optimized)
        self.treeview.bind("<ButtonRelease-1>", self._on_drag_release_optimized)
        
        # Eventos para melhor feedback visual
        self.treeview.bind("<Enter>", self._on_enter_list)
        self.treeview.bind("<Leave>", self._on_leave_list)
    
    def _on_drag_start_optimized(self, event):
        """Início do drag otimizado"""
        item = self.treeview.identify_row(event.y)
        if not item:
            return
        
        # Verificar se o item é válido
        values = self.treeview.item(item, "values")
        if not values or len(values) < 5:
            return
        
        card_id = values[4]  # card_id está na posição 4
        if not card_id:
            return
        
        # Configurar dados do drag
        self._drag_data = {
            "item": item,
            "x": event.x,
            "y": event.y,
            "card_id": card_id,
            "source_treeview": self.treeview
        }
        
        # Selecionar item
        self.treeview.selection_set(item)
        
        # Criar widget visual de drag
        self._create_drag_widget(event)
        
        print(f"🚀 Drag iniciado: {card_id} de {self.board_name}/{self.list_name}")
    
    def _create_drag_widget(self, event):
        """Cria widget visual para o drag"""
        if self._drag_widget:
            self._drag_widget.destroy()
        
        # Obter dados do item
        item = self._drag_data["item"]
        values = self.treeview.item(item, "values")
        title = values[0] if values else "Card"
        
        # Criar widget de drag
        self._drag_widget = tk.Toplevel(self.treeview)
        self._drag_widget.overrideredirect(True)
        self._drag_widget.attributes('-topmost', True)
        
        # Frame do widget
        frame = ttk.Frame(self._drag_widget, relief="solid", borderwidth=2)
        frame.pack(padx=5, pady=5)
        
        # Label com título
        label = ttk.Label(frame, text=title, background="lightblue", padding=5)
        label.pack()
        
        # Posicionar widget
        x = event.x_root - 50
        y = event.y_root - 25
        self._drag_widget.geometry(f"+{x}+{y}")
    
    def _on_drag_motion_optimized(self, event):
        """Movimento do drag otimizado"""
        if not self._drag_data["item"]:
            return
        
        # Atualizar posição do widget visual
        if self._drag_widget:
            x = event.x_root - 50
            y = event.y_root - 25
            self._drag_widget.geometry(f"+{x}+{y}")
        
        # Atualizar dados do drag
        self._drag_data["x"] = event.x
        self._drag_data["y"] = event.y
        
        # Feedback visual para listas de destino
        self._highlight_target_lists(event)
    
    def _highlight_target_lists(self, event):
        """Destaca listas de destino durante o drag"""
        target_widget = event.widget.winfo_containing(event.x_root, event.y_root)
        
        # Resetar todas as listas
        for (b_name, l_name), tv_widget in self.app.listbox_refs.items():
            if hasattr(tv_widget, 'configure'):
                try:
                    tv_widget.configure(style='Treeview')
                except:
                    pass
        
        # Destacar lista de destino
        if target_widget and target_widget != self.treeview:
            for (b_name, l_name), tv_widget in self.app.listbox_refs.items():
                if tv_widget == target_widget:
                    try:
                        tv_widget.configure(style='Treeview.Highlight')
                    except:
                        pass
                    break
    
    def _on_drag_release_optimized(self, event):
        """Release do drag otimizado"""
        if not self._drag_data["item"] or not self._drag_data["card_id"]:
            return
        
        # Limpar widget visual
        if self._drag_widget:
            self._drag_widget.destroy()
            self._drag_widget = None
        
        # Identificar destino
        target_widget = event.widget.winfo_containing(event.x_root, event.y_root)
        target_board, target_list = self._get_target_location_optimized(target_widget)
        
        # Executar movimento se válido
        if target_board and target_list and (target_board != self.board_name or target_list != self.list_name):
            self._execute_optimized_move(target_board, target_list)
        
        # Limpar dados do drag
        self._drag_data = {"item": None, "x": 0, "y": 0, "card_id": None, "source_treeview": None}
        
        # Resetar destaque das listas
        self._reset_list_highlights()
    
    def _get_target_location_optimized(self, widget):
        """Identifica localização do destino de forma otimizada"""
        if not widget:
            return None, None
        
        # Usar cache se disponível
        if hasattr(self.app, 'kanban_optimizer') and self.app.kanban_optimizer:
            return self.app.kanban_optimizer._get_target_location(widget)
        
        # Fallback para busca tradicional
        for (b_name, l_name), tv_widget in self.app.listbox_refs.items():
            if tv_widget == widget:
                return b_name, l_name
        
        return None, None
    
    def _execute_optimized_move(self, target_board, target_list):
        """Executa movimento otimizado"""
        card_id = self._drag_data["card_id"]
        
        print(f"⚡ Movimento otimizado: {card_id} -> {target_board}/{target_list}")
        
        # Usar otimizador se disponível
        if hasattr(self.app, 'kanban_optimizer') and self.app.kanban_optimizer:
            self.app.kanban_optimizer._optimized_move_card(
                card_id, self.board_name, self.list_name, target_board, target_list
            )
        else:
            # Fallback para método original
            self.app.move_card_data(self.board_name, self.list_name, card_id, target_board, target_list)
    
    def _reset_list_highlights(self):
        """Reseta destaque das listas"""
        for (b_name, l_name), tv_widget in self.app.listbox_refs.items():
            if hasattr(tv_widget, 'configure'):
                try:
                    tv_widget.configure(style='Treeview')
                except:
                    pass
    
    def _on_enter_list(self, event):
        """Evento ao entrar na lista"""
        if self._is_dragging:
            # Destacar lista
            try:
                self.treeview.configure(style='Treeview.Highlight')
            except:
                pass
    
    def _on_leave_list(self, event):
        """Evento ao sair da lista"""
        if self._is_dragging:
            # Remover destaque
            try:
                self.treeview.configure(style='Treeview')
            except:
                pass
    def __init__(self, treeview, app, board_name, list_name):
        self.treeview = treeview
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self.treeview.bind("<ButtonPress-1>", self.on_drag_start)
        self.treeview.bind("<B1-Motion>", self.on_drag_motion)
        self.treeview.bind("<ButtonRelease-1>", self.on_drag_release)
        self._drag_data = {"item": None, "x": 0, "y": 0, "card_id": None, "source_treeview": None}
        self._drag_widget = None

    def on_drag_start(self, event):
        item_id = self.treeview.identify_row(event.y)
        if not item_id or self.treeview.parent(item_id):  # Don't drag child items
            return

        self.treeview.selection_set(item_id)
        self._drag_data["item"] = item_id
        self._drag_data["x"] = event.x
        self._drag_data["y"] = event.y
        self._drag_data["source_treeview"] = self.treeview

        # Get card_id from the tags
        self._drag_data["card_id"] = self.treeview.item(item_id, "tags")[0]

        # Create a temporary drag widget
        x, y, width, height = self.treeview.bbox(item_id)
        display_text = self.treeview.item(item_id, "values")[0] # Get the title
        self._drag_widget = tk.Label(self.treeview, text=display_text, background="lightblue", relief="raised", borderwidth=1)
        self._drag_widget.place(x=x, y=y, width=width, height=height)

    def on_drag_motion(self, event):
        if self._drag_widget:
            x = self.treeview.winfo_x() + event.x - self._drag_data["x"]
            y = self.treeview.winfo_y() + event.y - self._drag_data["y"]
            self._drag_widget.place(x=x, y=y)

    def on_drag_release(self, event):
        if self._drag_widget:
            self._drag_widget.destroy()
            self._drag_widget = None

        if not self._drag_data["item"] or not self._drag_data["card_id"]:
            return

        # Find the widget under the cursor
        x_root, y_root = event.x_root, event.y_root
        target_widget = event.widget.winfo_containing(x_root, y_root)

        target_treeview = None
        target_list_name = None
        target_board_name = None

        # Traverse up the widget hierarchy to find the Treeview
        current_widget = target_widget
        while current_widget:
            if isinstance(current_widget, ttk.Treeview):
                # Now find which board/list this treeview belongs to
                for (b_name, l_name), tv_widget in self.app.listbox_refs.items():
                    if tv_widget == current_widget:
                        target_treeview = tv_widget
                        target_list_name = l_name
                        target_board_name = b_name
                        break
                if target_treeview:
                    break
            current_widget = current_widget.master

        if target_treeview and target_list_name and target_board_name:
            # We have a valid drop target
            print(f"CARD MOVIDO: Card '{self._drag_data['card_id']}' solto na lista '{target_list_name}' do quadro '{target_board_name}'")

            # Check if it's a different list
            if target_board_name != self.board_name or target_list_name != self.list_name:
                print(f"MOVENDO CARD: De '{self.list_name}' para '{target_list_name}'")
                # Call the existing move_card_data method which handles DB update and logging
                self.app.move_card_data(
                    self.board_name, 
                    self.list_name, 
                    self._drag_data["card_id"],
                    target_board_name, 
                    target_list_name
                )
            else:
                print(f"INFO: Card solto na mesma lista. Nenhuma ação necessária.")
        else:
            print("AVISO: Card solto em um local inválido.")

        # Reset drag data
        self._drag_data = {"item": None, "x": 0, "y": 0, "card_id": None, "source_treeview": None}

class TrelloApp:
    def load_and_apply_user_theme(self):
        """Carrega e aplica o tema do usuário a partir do banco de dados."""
        if self.current_user and self.current_user.user_id:
            # Usar 'arc' como tema padrão se nenhum for encontrado
            theme = self.db.get_setting('theme', default='arc', user_id=self.current_user.user_id)
            try:
                self.root.set_theme(theme)
            except Exception as e:
                print(f"Erro ao aplicar o tema '{theme}': {e}")
                # Se o tema salvo for inválido, aplicar o padrão
                try:
                    self.root.set_theme("arc")
                except Exception as e_arc:
                    print(f"Erro ao aplicar o tema padrão 'arc': {e_arc}")
        
        # Configurar estilo personalizado para botões uniformes
        try:
            style = ttk.Style()
            # Configurar estilo para botões com altura uniforme
            style.configure('Uniform.TButton', 
                          padding=(10, 8),  # padding horizontal e vertical
                          relief='flat',
                          borderwidth=1)
        except Exception as e:
            print(f"Erro ao configurar estilo Uniform.TButton: {e}")
        
        # Inicializar sistema de atualizações
        self.current_version = "2.4.0"  # ATUALIZAR VERSÃO AQUI
        self.updater = AutoUpdater(self.current_version)
        self.update_dialog = None
        
        # Verificar atualizações em background após inicialização
        self.root.after(5000, self.check_for_updates_delayed)

    def open_theme_settings(self):
        ThemeSettingsWindow(self.root, self)
    
    def check_for_updates_delayed(self):
        """Verifica atualizações após um delay para não bloquear a inicialização"""
        try:
            # Executar verificação em thread separada
            update_thread = threading.Thread(target=self.check_for_updates)
            update_thread.daemon = True
            update_thread.start()
        except Exception as e:
            print(f"Erro ao verificar atualizações: {e}")
    
    def check_for_updates(self):
        """Verifica se há atualizações disponíveis"""
        try:
            # Verificar atualizações
            update_result = check_for_updates_in_background(self.current_version)
            
            if update_result:
                # Mostrar diálogo de atualização na thread principal
                self.root.after(0, self.show_update_dialog, update_result)
                
        except Exception as e:
            print(f"Erro na verificação de atualizações: {e}")
    
    def show_update_dialog(self, update_result):
        """Mostra diálogo de atualização"""
        try:
            if update_result['type'] == 'forced_update':
                # Atualização forçada - mostrar diálogo modal
                self.update_dialog = UpdateDialog(self.root, self.updater)
                self.update_dialog.show_update_dialog(update_result['version_info'])
            elif update_result['type'] == 'optional_update':
                # Atualização opcional - perguntar ao usuário
                response = messagebox.askyesno(
                    "🆕 Nova Versão Disponível",
                    f"Uma nova versão do Boodesk está disponível!\n\n"
                    f"Versão atual: {self.current_version}\n"
                    f"Nova versão: {update_result['version_info']['versao']}\n\n"
                    f"Deseja atualizar agora?"
                )
                
                if response:
                    self.update_dialog = UpdateDialog(self.root, self.updater)
                    self.update_dialog.show_update_dialog(update_result['version_info'])
                    
        except Exception as e:
            print(f"Erro ao mostrar diálogo de atualização: {e}")
    
    def check_for_updates_manual(self):
        """Abre uma janela para verificar atualizações manualmente"""
        try:
            # Criar janela de atualizações
            update_window = tk.Toplevel(self.root)
            update_window.title("Verificar Atualizações - Boodesk")
            update_window.geometry("1000x900")
            update_window.resizable(True, True)
            update_window.transient(self.root)
            update_window.grab_set()
            
            # Centralizar a janela
            update_window.update_idletasks()
            x = (update_window.winfo_screenwidth() // 2) - (1000 // 2)
            y = (update_window.winfo_screenheight() // 2) - (900 // 2)
            update_window.geometry(f"1000x900+{x}+{y}")
            
            # Frame principal com scrollbar
            main_container = ttk.Frame(update_window)
            main_container.pack(fill='both', expand=True, padx=10, pady=10)
            
            # Canvas para scroll
            canvas = tk.Canvas(main_container)
            scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # Frame principal
            main_frame = ttk.Frame(scrollable_frame, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # Título principal
            title_label = ttk.Label(main_frame, text="🔄 SISTEMA DE ATUALIZAÇÕES", 
                                   font=('Segoe UI', 18, 'bold'))
            title_label.pack(pady=(0, 10))
            
            # Subtítulo
            subtitle_label = ttk.Label(main_frame, text="Gerencie as atualizações do Boodesk", 
                                     font=('Segoe UI', 12))
            subtitle_label.pack(pady=(0, 20))
            
            # Frame de status
            status_frame = ttk.LabelFrame(main_frame, text="Status da Verificação", padding=15)
            status_frame.pack(fill='x', pady=(0, 20))
            
            # Status inicial
            status_label = ttk.Label(status_frame, text="⏳ Verificando atualizações...", 
                                    font=('Segoe UI', 10))
            status_label.pack()
            
            # Frame de informações
            info_frame = ttk.LabelFrame(main_frame, text="Informações do Sistema", padding=15)
            info_frame.pack(fill='x', pady=(0, 20))
            
            # Informações do sistema
            system_info = f"""
Versão Atual: 2.4.10
Data de Compilação: {datetime.now().strftime('%d/%m/%Y')}
Sistema Operacional: {platform.system()} {platform.release()}
Python: {platform.python_version()}
Banco de Dados: PostgreSQL/Supabase
Status: Conectado ✅
            """
            
            info_text = tk.Text(info_frame, height=8, width=80, wrap=tk.WORD, 
                               font=('Consolas', 9), state='disabled')
            info_text.pack(fill='x')
            info_text.config(state='normal')
            info_text.insert('1.0', system_info.strip())
            info_text.config(state='disabled')
            
            # Frame para progresso de download
            progress_frame = ttk.LabelFrame(main_frame, text="Progresso de Download", padding=15)
            progress_frame.pack(fill='x', pady=(0, 20))
            
            # Barra de progresso
            progress_bar = ttk.Progressbar(progress_frame, mode='determinate', length=600)
            progress_bar.pack(pady=(0, 10))
            
            # Label de progresso
            progress_label = ttk.Label(progress_frame, text="Aguardando download...", 
                                     font=('Segoe UI', 9))
            progress_label.pack()
            
            # Separador visual
            separator = ttk.Separator(main_frame, orient='horizontal')
            separator.pack(fill='x', pady=(20, 20))
            
            # Título dos botões
            buttons_title = ttk.Label(main_frame, text="🎯 AÇÕES DISPONÍVEIS", 
                                     font=('Segoe UI', 14, 'bold'))
            buttons_title.pack(pady=(0, 20))
            
            # Frame de botões principais - Primeira linha
            button_frame1 = ttk.Frame(main_frame)
            button_frame1.pack(fill='x', pady=(0, 15))
            
            # Botão de verificar novamente
            check_button = ttk.Button(button_frame1, text="🔄 Verificar Novamente", 
                                     command=lambda: self.check_updates_again(status_label, progress_bar, progress_label),
                                     style='Accent.TButton', width=25)
            check_button.pack(side='left', padx=(0, 15))
            
            # Botão de download
            download_button = ttk.Button(button_frame1, text="⬇️ Download Atualização", 
                                       command=lambda: self.download_update(progress_bar, progress_label, update_window),
                                       style='Accent.TButton', width=25)
            download_button.pack(side='left', padx=(0, 15))
            
            # Botão de instalação
            install_button = ttk.Button(button_frame1, text="⚙️ Instalar Atualização", 
                                      command=lambda: self.install_update(progress_bar, progress_label),
                                      style='Accent.TButton', width=25)
            install_button.pack(side='left', padx=(0, 15))
            
            # Botão para configurar diretório de download
            configure_dir_button = ttk.Button(button_frame1, text="⚙️ Configurar Diretório", 
                                            command=lambda: self.configure_download_directory(),
                                            width=25)
            configure_dir_button.pack(side='left', padx=(0, 15))
            
            # Label para mostrar diretório atual
            download_dir_label = ttk.Label(button_frame1, text="📁 Diretório atual: Carregando...", 
                                         font=("Arial", 9))
            download_dir_label.pack(side='left', padx=(10, 0))
            
            # Botão de abrir local do executável (inicialmente desabilitado)
            open_location_button = ttk.Button(button_frame1, text="📁 Abrir Local do Executável", 
                                            command=lambda: self.open_executable_location(),
                                            state='disabled', width=25)
            open_location_button.pack(side='left', padx=(0, 15))
            
            # Armazenar referência do botão para habilitar após download
            update_window.open_location_button = open_location_button
            update_window.download_dir_label = download_dir_label
            
            # Frame de botões secundários - Segunda linha
            button_frame2 = ttk.Frame(main_frame)
            button_frame2.pack(fill='x', pady=(15, 15))
            
            # Botão de configurações avançadas
            advanced_button = ttk.Button(button_frame2, text="🔧 Configurações Avançadas", 
                                       command=lambda: self.show_advanced_update_settings(update_window),
                                       width=30)
            advanced_button.pack(side='left', padx=(0, 15))
            
            # Botão de histórico de atualizações
            history_button = ttk.Button(button_frame2, text="📋 Histórico de Atualizações", 
                                      command=lambda: self.show_update_history(update_window),
                                      width=30)
            history_button.pack(side='left', padx=(0, 15))
            
            # Frame de botão fechar - Terceira linha
            button_frame3 = ttk.Frame(main_frame)
            button_frame3.pack(fill='x', pady=(20, 0))
            
            # Botão de fechar
            close_button = ttk.Button(button_frame3, text="❌ Fechar", 
                                     command=update_window.destroy,
                                     width=20)
            close_button.pack(side='right')
            
            # Configurar scrollbar
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # Simular verificação
            self.root.after(2000, lambda: self.simulate_update_check(status_label, progress_bar, progress_label))
            self.root.after(100, lambda: self.update_download_dir_label())
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir verificação de atualizações: {e}")
    
    def check_updates_again(self, status_label, progress_bar=None, progress_label=None):
        """Verifica atualizações novamente"""
        status_label.config(text="⏳ Verificando atualizações...")
        if progress_bar and progress_label:
            progress_bar['value'] = 0
            progress_label.config(text="Verificando...")
        self.root.after(2000, lambda: self.simulate_update_check(status_label, progress_bar, progress_label))
        self.root.after(100, lambda: self.update_download_dir_label())
    
    def simulate_update_check(self, status_label, progress_bar=None, progress_label=None):
        """Verifica atualizações reais no Cloudflare R2"""
        try:
            # Configurações do Cloudflare R2
            r2_endpoint = "https://pub-93ac59355fc342489651074099b6e8a7.r2.dev"
            bucket_name = "boodesk-cdn"
            executable_name = "boodesk_latest.exe"
            
            # URL do executável no Cloudflare R2
            download_url = f"{r2_endpoint}/{executable_name}"
            
            print(f"🔍 Verificando atualizações em: {download_url}")
            
            # Verificar se o arquivo existe no R2
            try:
                response = requests.head(download_url, timeout=10)
                if response.status_code == 200:
                    file_size = int(response.headers.get('content-length', 0))
                    print(f"✅ Arquivo encontrado no Cloudflare R2! Tamanho: {file_size} bytes")
                    
                    # Verificar se o tamanho é válido (mínimo 50MB)
                    if file_size > 50 * 1024 * 1024:  # 50MB
                        status_label.config(text="✅ Atualização disponível! Versão mais recente")
                        if progress_bar and progress_label:
                            progress_bar['value'] = 0
                            progress_label.config(text="Atualização disponível para download")
                        
                        # Mostrar informações da atualização
                        update_info = f"""Nova versão disponível!

📦 Tamanho: {file_size//1024//1024}MB
🌐 Fonte: Cloudflare R2
📅 Verificado: {datetime.now().strftime('%d/%m/%Y %H:%M')}

Clique em 'Download Atualização' para baixar a nova versão."""
                        
                        messagebox.showinfo("Atualização Disponível", update_info)
                    else:
                        status_label.config(text="⚠️ Arquivo no servidor parece estar corrompido")
                        if progress_bar and progress_label:
                            progress_bar['value'] = 0
                            progress_label.config(text="Arquivo inválido no servidor")
                else:
                    status_label.config(text="✅ Sistema atualizado! Você está usando a versão mais recente.")
                    if progress_bar and progress_label:
                        progress_bar['value'] = 100
                        progress_label.config(text="Sistema atualizado")
                    print("ℹ️ Nenhuma atualização disponível no Cloudflare R2")
                    
            except requests.exceptions.RequestException as req_error:
                status_label.config(text="❌ Erro de conexão com servidor")
                if progress_bar and progress_label:
                    progress_bar['value'] = 0
                    progress_label.config(text="Erro de conexão")
                print(f"❌ Erro de conexão: {req_error}")
                
        except Exception as e:
            status_label.config(text=f"❌ Erro na verificação: {e}")
            if progress_bar and progress_label:
                progress_bar['value'] = 0
                progress_label.config(text="Erro na verificação")
            print(f"❌ Erro na verificação: {e}")
    
    
    def download_update(self, progress_bar, progress_label, update_window=None):
        """Download de atualização do Cloudflare R2 com backup e instalação"""
        try:
            progress_label.config(text="🔄 Preparando atualização...")
            progress_bar['value'] = 0
            
            # Configurações do Cloudflare R2
            r2_endpoint = "https://pub-93ac59355fc342489651074099b6e8a7.r2.dev"
            bucket_name = "boodesk-cdn"
            executable_name = "boodesk_latest.exe"
            
            # URL do executável no Cloudflare R2
            download_url = f"{r2_endpoint}/{executable_name}"
            
            print(f"🔗 Tentando baixar de: {download_url}")
            
            # Obter diretório de download configurado
            download_dir = self.get_download_directory()
            print(f"🔍 Diretório de download configurado: {download_dir}")
            
            # Verificar se o diretório existe e é gravável
            if not os.path.exists(download_dir):
                os.makedirs(download_dir, exist_ok=True)
                print(f"📁 Diretório criado: {download_dir}")
            
            if not os.access(download_dir, os.W_OK):
                raise Exception(f"Sem permissão de escrita no diretório: {download_dir}")
            
            current_exe = os.path.abspath(sys.argv[0])
            current_name = os.path.basename(current_exe)
            
            print(f"📁 Diretório de download: {download_dir}")
            
            # Nomes dos arquivos
            backup_name = f"{current_name}.backup"
            new_exe_name = "boodesk_latest.exe"
            installer_script = "install_update.bat"
            
            backup_path = os.path.join(download_dir, backup_name)
            new_exe_path = os.path.join(download_dir, new_exe_name)
            
            # 1. Fazer backup inteligente do executável atual
            progress_label.config(text="🔄 Criando backup inteligente...")
            progress_bar['value'] = 10
            self.root.update_idletasks()
            
            # Backup inteligente: sempre sobrescrever boodesk_old.exe
            backup_old_name = "boodesk_old.exe"
            backup_old_path = os.path.join(download_dir, backup_old_name)
            
            try:
                import shutil
                # Sempre copiar o app atual como boodesk_old.exe (sobrescrever)
                shutil.copy2(current_exe, backup_old_path)
                print(f"✅ Backup inteligente criado: {backup_old_path}")
                print(f"ℹ️ Este backup será sobrescrito na próxima atualização")
            except Exception as e:
                print(f"⚠️ Erro ao criar backup inteligente: {e}")
                # Continuar mesmo sem backup
            
            # 2. Verificar se o arquivo existe no R2
            progress_label.config(text="🔍 Verificando arquivo no Cloudflare R2...")
            progress_bar['value'] = 15
            self.root.update_idletasks()
            
            try:
                response = requests.head(download_url, timeout=10)
                if response.status_code == 200:
                    file_size = int(response.headers.get('content-length', 0))
                    print(f"✅ Arquivo encontrado! Tamanho: {file_size} bytes")
                    
                    # 3. Download do novo executável
                    progress_label.config(text="📥 Baixando nova versão...")
                    progress_bar['value'] = 20
                    self.root.update_idletasks()
                    
                    download_response = requests.get(download_url, stream=True, timeout=60)
                    download_response.raise_for_status()
                    
                    downloaded_size = 0
                    
                    with open(new_exe_path, 'wb') as f:
                        for chunk in download_response.iter_content(chunk_size=8192):
                            if chunk:
                                f.write(chunk)
                                downloaded_size += len(chunk)
                                
                                # Atualizar progresso
                                if file_size > 0:
                                    progress = int((downloaded_size / file_size) * 60) + 20  # 20% a 80%
                                    progress_bar['value'] = progress
                                    
                                    # Atualizar label com tamanho
                                    downloaded_mb = downloaded_size / (1024 * 1024)
                                    total_mb = file_size / (1024 * 1024)
                                    progress_label.config(text=f"📥 Baixando... {downloaded_mb:.1f}MB / {total_mb:.1f}MB")
                                    self.root.update_idletasks()
                    
                    # 4. Verificar integridade do arquivo
                    progress_label.config(text="🔍 Verificando integridade...")
                    progress_bar['value'] = 85
                    self.root.update_idletasks()
                    
                    if os.path.exists(new_exe_path):
                        downloaded_file_size = os.path.getsize(new_exe_path)
                        if downloaded_file_size > 0:
                            print(f"✅ Arquivo baixado: {new_exe_path} ({downloaded_file_size} bytes)")
                        else:
                            raise Exception("Arquivo baixado está vazio")
                    else:
                        raise Exception("Arquivo não foi baixado")
                    
                    # 5. Criar script de instalação
                    progress_label.config(text="📝 Preparando instalação...")
                    progress_bar['value'] = 90
                    self.root.update_idletasks()
                    
                    install_script_content = f"""@echo off
echo ========================================
echo    INSTALADOR DE ATUALIZACAO BOODESK
echo ========================================
echo.
echo Instalando nova versao do Boodesk...
echo.

REM Aguardar um pouco para garantir que o app foi fechado
echo Aguardando fechamento do aplicativo...
timeout /t 3 /nobreak > nul

REM Backup inteligente já foi criado como boodesk_old.exe
echo Backup inteligente ja foi criado como boodesk_old.exe
echo Este backup sera sobrescrito na proxima atualizacao

REM Substituir o executavel atual
if exist "{new_exe_name}" (
    echo Substituindo executavel...
    del "{current_name}"
    ren "{new_exe_name}" "{current_name}"
    echo Executavel atualizado com sucesso!
    
    REM Limpar arquivos temporarios
    if exist "install_update.bat" del "install_update.bat"
    
    echo.
    echo ========================================
    echo    ATUALIZACAO CONCLUIDA COM SUCESSO!
    echo ========================================
    echo.
    echo Iniciando nova versao...
    start "" "{current_name}"
    
    REM Fechar esta janela após alguns segundos
    timeout /t 5 /nobreak > nul
    exit
) else (
    echo.
    echo ========================================
    echo    ERRO NA ATUALIZACAO!
    echo ========================================
    echo.
    echo ERRO: Arquivo {new_exe_name} nao encontrado!
    echo.
    echo Restaurando backup...
    if exist "{backup_name}" (
        copy "{backup_name}" "{current_name}"
        echo Backup restaurado com sucesso.
    ) else (
        echo ERRO: Backup nao encontrado!
    )
    echo.
    echo Pressione qualquer tecla para continuar...
    pause > nul
)
"""
                    
                    # Script de instalação será executado diretamente no código
                    print("📝 Instalação será executada diretamente no código")
                    
                    # 6. Finalizar
                    progress_bar['value'] = 100
                    progress_label.config(text="✅ Download concluído com sucesso!")
                    self.root.update_idletasks()
                    
                    # Mostrar informações do backup
                    print(f"📦 Nova versão: {new_exe_name}")
                    print(f"💾 Backup criado: {backup_old_name}")
                    print(f"📁 Local: {download_dir}")
                    print(f"ℹ️ O backup será sobrescrito na próxima atualização")
                    
                    # 7. Salvar informações no banco
                    download_info = {
                        "download_date": datetime.now().isoformat(),
                        "file_path": new_exe_path,
                        "file_size": downloaded_file_size,
                        "backup_path": backup_path,
                        "installer_script": installer_script,
                        "source": "cloudflare_r2"
                    }
                    
                    try:
                        if hasattr(self, 'db') and self.db:
                            user_id = self.get_current_user_id() or 1
                            self.db.save_setting('last_update_download', json.dumps(download_info), user_id)
                            print("✅ Informações do download salvas no banco")
                    except Exception as save_error:
                        print(f"⚠️ Erro ao salvar informações: {save_error}")
                    
                    # 8. Habilitar botões
                    if update_window:
                        if hasattr(update_window, 'download_button'):
                            update_window.download_button.config(state='disabled', text="✅ Download Concluído")
                        if hasattr(update_window, 'install_button'):
                            update_window.install_button.config(state='normal', text="🚀 Instalar Atualização")
                        if hasattr(update_window, 'open_location_button'):
                            update_window.open_location_button.config(state='normal', text="📁 Abrir Local do Executável")
                    
                    messagebox.showinfo("Download Concluído", 
                        f"Atualização baixada com sucesso!\n\n"
                        f"Arquivo: {new_exe_path}\n"
                        f"Tamanho: {downloaded_file_size//1024//1024}MB\n"
                        f"Backup: {backup_path}\n\n"
                        "Clique em 'Instalar Atualização' para aplicar a atualização.\n"
                        "O aplicativo será fechado automaticamente durante a instalação.")
                else:
                    raise Exception(f"Arquivo não encontrado no Cloudflare R2 (Status: {response.status_code})")
            except requests.exceptions.RequestException as req_error:
                raise Exception(f"Erro de conexão com Cloudflare R2: {req_error}")
            
        except Exception as e:
            error_msg = f"Erro no download: {e}"
            print(f"❌ {error_msg}")
            messagebox.showerror("Erro no Download", error_msg)
            progress_label.config(text="❌ Erro no download")
            progress_bar['value'] = 0
            def update_progress():
                current = progress_bar['value']
                if current < 100:
                    progress_bar['value'] += 10
                    if current < 30:
                        progress_label.config(text="Baixando arquivos...")
                    elif current < 60:
                        progress_label.config(text="Verificando integridade...")
                    elif current < 90:
                        progress_label.config(text="Finalizando download...")
                    else:
                        progress_label.config(text="Download concluído!")
                    
                    if current < 100:
                        self.root.after(500, update_progress)
                    else:
                        messagebox.showinfo("Download Concluído", "Atualização baixada com sucesso!\nClique em 'Instalar Atualização' para aplicar.")
            
            update_progress()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro no download: {e}")
            progress_label.config(text="Erro no download")
    
    
    def get_current_version(self):
        """Retorna a versão atual do aplicativo"""
        try:
            # Tentar obter do banco de dados
            if hasattr(self, 'db') and self.db:
                conn = self.db.get_connection()
                if conn:
                    cursor = conn.cursor()
                    cursor.execute("""
                        SELECT versao FROM versoes_sistema 
                        WHERE ativo = true 
                        ORDER BY data_lancamento DESC 
                        LIMIT 1
                    """)
                    result = cursor.fetchone()
                    if result:
                        return result[0]
        except:
            pass
        
        # Fallback para versão hardcoded
        return "2.4.9"
    def install_update(self, progress_bar, progress_label):
        """Instala a atualização baixada com sistema robusto"""
        try:
            # Verificar se o download foi concluído com sucesso
            download_dir = self.get_download_directory()
            new_exe_path = os.path.join(download_dir, "boodesk_latest.exe")
            
            print(f"🔍 Verificando arquivo de atualização: {new_exe_path}")
            
            # Verificar se o arquivo novo existe e é válido
            if not os.path.exists(new_exe_path):
                print("❌ Arquivo de atualização não encontrado")
                messagebox.showwarning("Aviso", "Arquivo de atualização não encontrado.\n\nClique em '⬇️ Download Atualização' primeiro!")
                return
            
            # Verificar se o arquivo é válido (mínimo 50MB)
            file_size = os.path.getsize(new_exe_path)
            print(f"📦 Tamanho do arquivo: {file_size} bytes ({file_size//1024//1024}MB)")
            
            if file_size < self.UPDATE_CONFIG['MIN_FILE_SIZE']:
                print("❌ Arquivo de atualização muito pequeno (possivelmente corrompido)")
                messagebox.showerror("Erro", f"Arquivo de atualização inválido ou corrompido!\n\nTamanho: {file_size//1024//1024}MB (mínimo: {self.UPDATE_CONFIG['MIN_FILE_SIZE']//1024//1024}MB)\n\nTente fazer o download novamente.")
                return
            
            print("✅ Todos os arquivos necessários encontrados")
            
            progress_label.config(text="🚀 Preparando instalação...")
            progress_bar['value'] = 0
            self.root.update_idletasks()
            
            # Confirmar instalação
            result = messagebox.askyesno("Confirmar Instalação", 
                "A instalação irá:\n\n"
                "1. Fazer backup do executável atual\n"
                "2. Substituir pelo novo executável\n"
                "3. Fechar o aplicativo atual\n"
                "4. Abrir a nova versão\n\n"
                "Deseja continuar?")
            
            if not result:
                return
            
            progress_label.config(text="📝 Salvando configurações...")
            progress_bar['value'] = 20
            self.root.update_idletasks()
            
            # Salvar informações da instalação
            try:
                if hasattr(self, 'db') and self.db:
                    user_id = self.get_current_user_id() or 1
                    install_info = {
                        "install_date": datetime.now().isoformat(),
                        "version": self.get_current_version(),
                        "source": "cloudflare_r2",
                        "new_exe_path": new_exe_path
                    }
                    self.db.save_setting('last_update_install', json.dumps(install_info), user_id)
                    print("✅ Informações da instalação salvas no banco")
            except Exception as save_error:
                print(f"⚠️ Erro ao salvar informações: {save_error}")
            
            progress_label.config(text="🔄 Iniciando processo de instalação...")
            progress_bar['value'] = 50
            self.root.update_idletasks()
            
            # Executar instalação robusta
            try:
                print("🔄 Iniciando instalação robusta...")
                
                # 1. Fazer backup do executável atual
                current_exe_path = self.get_current_executable_path()
                backup_path = None
                
                if current_exe_path and os.path.exists(current_exe_path):
                    backup_path = current_exe_path + ".backup"
                    import shutil
                    shutil.copy2(current_exe_path, backup_path)
                    print(f"✅ Backup criado: {backup_path}")
                
                # 2. Obter diretório da aplicação
                app_dir = self.get_app_directory()
                target_exe_path = os.path.join(app_dir, "BoodeskApp.exe")
                
                # 3. Copiar nova versão
                if os.path.exists(new_exe_path):
                    import shutil
                    shutil.copy2(new_exe_path, target_exe_path)
                    print(f"✅ Nova versão copiada: {target_exe_path}")
                    
                    # 4. Verificar integridade da nova versão
                    if os.path.exists(target_exe_path):
                        new_size = os.path.getsize(target_exe_path)
                        if new_size >= self.UPDATE_CONFIG['MIN_FILE_SIZE']:
                            print("✅ Integridade da nova versão verificada")
                            
                            # 5. Limpar arquivos temporários
                            try:
                                os.remove(new_exe_path)
                                print("✅ Arquivo temporário removido")
                            except:
                                pass
                            
                            # 6. Iniciar nova versão
                            print("🚀 Iniciando nova versão...")
                            import subprocess
                            subprocess.Popen([target_exe_path], cwd=app_dir)
                            
                            # 7. Fechar aplicação atual
                            print("👋 Fechando aplicação atual...")
                            self.root.after(2000, self.root.quit)
                            
                        else:
                            raise Exception(f"Arquivo copiado inválido: {new_size} bytes")
                    else:
                        raise Exception("Falha ao copiar arquivo")
                else:
                    raise Exception("Arquivo de nova versão não encontrado")
                    
            except Exception as e:
                print(f"❌ Erro na instalação: {e}")
                messagebox.showerror("Erro", f"Erro na instalação: {e}")
                
                # Rollback automático
                if backup_path and os.path.exists(backup_path):
                    try:
                        import shutil
                        shutil.copy2(backup_path, current_exe_path)
                        print("✅ Rollback automático executado")
                        messagebox.showinfo("Rollback", "Rollback automático executado. Aplicativo restaurado.")
                    except Exception as rollback_error:
                        print(f"❌ Falha no rollback: {rollback_error}")
                        messagebox.showerror("Erro Crítico", "Falha no rollback. Restaure manualmente o backup.")
                
                progress_label.config(text="❌ Erro na instalação")
                progress_bar['value'] = 0
                self.root.update_idletasks()
                return
            
            progress_label.config(text="✅ Instalação concluída!")
            progress_bar['value'] = 100
            self.root.update_idletasks()
            
            # Mostrar mensagem final
            messagebox.showinfo("Instalação Concluída", 
                "A instalação foi concluída com sucesso!\n\n"
                "O aplicativo será fechado e a nova versão será aberta automaticamente.\n\n"
                "Se algo der errado, o rollback será executado automaticamente.")
                
        except Exception as e:
            print(f"❌ Erro geral na instalação: {e}")
            messagebox.showerror("Erro", f"Erro geral na instalação: {e}")
            progress_label.config(text="❌ Erro na instalação")
            progress_bar['value'] = 0
            self.root.update_idletasks()


    def open_executable_location(self):
        """Abre o local do executável baixado"""
        try:
            import subprocess
            import platform
            
            # Caminho do executável baixado (correto)
            download_dir = self.get_download_directory()
            new_exe_path = os.path.join(download_dir, "boodesk_latest.exe")
            
            print(f"🔍 Verificando arquivo: {new_exe_path}")
            
            if not os.path.exists(new_exe_path):
                print("❌ Arquivo de atualização não encontrado")
                messagebox.showwarning("Aviso", "Arquivo de atualização não encontrado.\n\nClique em '⬇️ Download Atualização' primeiro!")
                return
            
            # Verificar se o arquivo é válido
            file_size = os.path.getsize(new_exe_path)
            print(f"📦 Tamanho do arquivo: {file_size} bytes ({file_size//1024//1024}MB)")
            
            if file_size < 50*1024*1024:  # Menos de 50MB
                print("❌ Arquivo de atualização muito pequeno")
                messagebox.showwarning("Aviso", "Arquivo de atualização inválido.\n\nTente fazer o download novamente.")
                return
            
            # Abrir o explorador de arquivos no local do executável
            if platform.system() == "Windows":
                subprocess.run(["explorer", "/select,", new_exe_path])
            elif platform.system() == "Darwin":  # macOS
                subprocess.run(["open", "-R", new_exe_path])
            else:  # Linux
                subprocess.run(["xdg-open", os.path.dirname(new_exe_path)])
                
            print(f"✅ Local do executável aberto: {new_exe_path}")
            
        except Exception as e:
            print(f"❌ Erro ao abrir local do executável: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir local do executável: {e}")
        except Exception as e:
            print(f"❌ Erro ao abrir local do executável: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir local do executável: {e}")

    def configure_download_directory(self):
        """Permite ao usuário configurar o diretório de download"""
        try:
            import tkinter.filedialog as filedialog
            
            current_dir = self.get_download_directory()
            
            # Abrir diálogo para selecionar diretório
            new_dir = filedialog.askdirectory(
                title="Selecionar Diretório de Download",
                initialdir=current_dir
            )
            
            if new_dir:
                if self.set_download_directory(new_dir):
                    messagebox.showinfo("Sucesso", f"Diretório de download configurado:\n{new_dir}")
                    self.update_download_dir_label()
                else:
                    messagebox.showerror("Erro", "Não foi possível configurar o diretório de download")
            
        except Exception as e:
            print(f"❌ Erro ao configurar diretório: {e}")
            messagebox.showerror("Erro", f"Erro ao configurar diretório: {e}")

    def update_download_dir_label(self):
        """Atualiza o label mostrando o diretório de download atual"""
        try:
            if hasattr(self, 'download_dir_label'):
                current_dir = self.get_download_directory()
                # Mostrar apenas o nome do diretório ou caminho abreviado
                if len(current_dir) > 40:
                    display_dir = "..." + current_dir[-37:]
                else:
                    display_dir = current_dir
                self.download_dir_label.config(text=f"📁 {display_dir}")
        except Exception as e:
            print(f"⚠️ Erro ao atualizar label: {e}")


    def show_advanced_update_settings(self, parent_window):
        """Mostra configurações avançadas de atualização"""
        try:
            settings_window = tk.Toplevel(parent_window)
            settings_window.title("Configurações Avançadas - Atualizações")
            settings_window.geometry("500x400")
            settings_window.transient(parent_window)
            settings_window.grab_set()
            
            # Frame principal
            main_frame = ttk.Frame(settings_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # Título
            ttk.Label(main_frame, text="🔧 Configurações Avançadas", 
                     font=('Segoe UI', 14, 'bold')).pack(pady=(0, 20))
            
            # Opções de atualização
            options_frame = ttk.LabelFrame(main_frame, text="Opções de Atualização", padding=15)
            options_frame.pack(fill='x', pady=(0, 20))
            
            # Checkboxes
            auto_check_var = tk.BooleanVar(value=True)
            ttk.Checkbutton(options_frame, text="Verificar atualizações automaticamente", 
                           variable=auto_check_var).pack(anchor='w', pady=2)
            
            auto_download_var = tk.BooleanVar(value=False)
            ttk.Checkbutton(options_frame, text="Baixar atualizações automaticamente", 
                           variable=auto_download_var).pack(anchor='w', pady=2)
            
            beta_updates_var = tk.BooleanVar(value=False)
            ttk.Checkbutton(options_frame, text="Receber atualizações beta", 
                           variable=beta_updates_var).pack(anchor='w', pady=2)
            
            # Frequência de verificação
            freq_frame = ttk.Frame(options_frame)
            freq_frame.pack(fill='x', pady=(10, 0))
            
            ttk.Label(freq_frame, text="Frequência de verificação:").pack(side='left')
            freq_var = tk.StringVar(value="diária")
            freq_combo = ttk.Combobox(freq_frame, textvariable=freq_var, 
                                     values=["diária", "semanal", "mensal"], 
                                     state="readonly", width=10)
            freq_combo.pack(side='left', padx=(10, 0))
            
            # Botões
            button_frame = ttk.Frame(main_frame)
            button_frame.pack(fill='x', pady=(20, 0))
            
            ttk.Button(button_frame, text="Salvar", 
                      command=lambda: self.save_update_settings(auto_check_var, auto_download_var, 
                                                              beta_updates_var, freq_var, settings_window)).pack(side='left', padx=(0, 10))
            ttk.Button(button_frame, text="Cancelar", 
                      command=settings_window.destroy).pack(side='right')
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir configurações: {e}")
    
    def save_update_settings(self, auto_check_var, auto_download_var, beta_updates_var, freq_var, window):
        """Salva as configurações de atualização"""
        try:
            # Aqui você pode salvar as configurações no banco de dados ou arquivo
            settings = {
                'auto_check': auto_check_var.get(),
                'auto_download': auto_download_var.get(),
                'beta_updates': beta_updates_var.get(),
                'frequency': freq_var.get()
            }
            
            # Simular salvamento
            print(f"Configurações salvas: {settings}")
            
            messagebox.showinfo("Sucesso", "Configurações salvas com sucesso!")
            window.destroy()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar configurações: {e}")
    
    def show_update_history(self, parent_window):
        """Mostra histórico de atualizações"""
        try:
            history_window = tk.Toplevel(parent_window)
            history_window.title("Histórico de Atualizações")
            history_window.geometry("600x400")
            history_window.transient(parent_window)
            history_window.grab_set()
            
            # Frame principal
            main_frame = ttk.Frame(history_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # Título
            ttk.Label(main_frame, text="📋 Histórico de Atualizações", 
                     font=('Segoe UI', 14, 'bold')).pack(pady=(0, 20))
            
            # Treeview para histórico
            columns = ("Data", "Versão", "Tipo", "Status")
            history_tree = ttk.Treeview(main_frame, columns=columns, show="headings", height=15)
            
            for col in columns:
                history_tree.heading(col, text=col)
                history_tree.column(col, width=120, anchor="center")
            
            # Scrollbar
            scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=history_tree.yview)
            history_tree.configure(yscrollcommand=scrollbar.set)
            
            # Posicionar
            history_tree.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')
            
            # Dados de exemplo
            sample_data = [
                ("25/08/2025", "2.3.1", "Atualização", "✅ Instalada"),
                ("20/08/2025", "2.3.0", "Atualização", "✅ Instalada"),
                ("15/08/2025", "2.2.9", "Correção", "✅ Instalada"),
                ("10/08/2025", "2.2.8", "Atualização", "✅ Instalada"),
                ("05/08/2025", "2.2.7", "Correção", "✅ Instalada"),
            ]
            
            for item in sample_data:
                history_tree.insert("", "end", values=item)
            
            # Botão de fechar
            ttk.Button(main_frame, text="Fechar", 
                      command=history_window.destroy).pack(pady=(20, 0))
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir histórico: {e}")
    
    def show_about_dialog(self):
        """Mostra a janela Sobre o Boodesk"""
        try:
            about_window = tk.Toplevel(self.root)
            about_window.title("Sobre o Boodesk")
            about_window.geometry("400x300")
            about_window.resizable(False, False)
            about_window.transient(self.root)
            about_window.grab_set()
            
            # Centralizar a janela
            about_window.update_idletasks()
            x = (about_window.winfo_screenwidth() // 2) - (400 // 2)
            y = (about_window.winfo_screenheight() // 2) - (300 // 2)
            about_window.geometry(f"400x300+{x}+{y}")
            
            # Frame principal
            main_frame = ttk.Frame(about_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # Logo/Título
            title_label = ttk.Label(main_frame, text="🎯 BOODESK", 
                                   font=('Segoe UI', 20, 'bold'))
            title_label.pack(pady=(0, 10))
            
            subtitle_label = ttk.Label(main_frame, text="Sistema de Gerenciamento de Tarefas", 
                                      font=('Segoe UI', 12))
            subtitle_label.pack(pady=(0, 20))
            
            # Informações
            info_text = """
Versão: 2.3.1
Desenvolvido por: Thalles Daniel
Data: Agosto 2025

Sistema completo de gerenciamento de tarefas
com integração PostgreSQL/Supabase e
interface moderna em Tkinter.

Funcionalidades:
• Quadros Kanban
• Sistema Pomodoro
• Chat em tempo real
• Dashboard executivo
• Integração com calendário
• Upload de arquivos
• Relatórios avançados
            """
            
            info_label = ttk.Label(main_frame, text=info_text, 
                                  font=('Segoe UI', 9), justify='left')
            info_label.pack(pady=(0, 20))
            
            # Botão fechar
            close_button = ttk.Button(main_frame, text="Fechar", 
                                     command=about_window.destroy)
            close_button.pack()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir janela Sobre: {e}")

    def __init__(self, root):
        self.root = root
        self.db = Database()
        self.db.create_tables()
        self.current_user = None
        self.login_successful = False
        self.boodesk_data = {'boards': {}}
        self.icons = load_app_icons(os.path.dirname(os.path.abspath(__file__)))
        self.listbox_refs = {}
        self.theme_color = "#0079BF"
        self.pomodoro_timer = None
        self.pomodoro_running = False
        self.pomodoro_start_time = None
        self.pomodoro_session_type = "work" # "work" or "break"
        self.pomodoro_work_duration = 25 * 60
        self.pomodoro_break_duration = 5 * 60
        self.pomodoro_task = None
        self.notification_manager = NotificationManager(self)
        self.meeting_integration = GoogleCalendarManager()
        self.email_integration = EmailIntegration(self)
        self.settings = self.load_settings()
        
        self.root.title("Boodesk - Sistema de Gerenciamento de Tarefas")
        self.root.geometry("1200x800")
        
        self.show_login_window()
        
        if self.login_successful:
            self.load_and_apply_user_theme()
            self.load_and_apply_user_theme()
            self.create_main_widgets()
            self.load_trello_data()
            self.populate_boards()
            self.notification_manager.start_notification_monitor()
            self.email_integration.start_email_service()
        else:
            self.root.destroy()
        
        # Criar menu após todos os métodos terem sido definidos
        # self.create_menu() será chamado após create_widgets


    # Removed load_data_from_db method - now using load_trello_data which loads from SQL

    def add_card(self, board_name, list_name, card_title, card_desc, card_due_date, card_importance, subject="-", goal="-", members=None, git_branch="", git_commit="", recurrence="Nenhuma", dependencies=None):
        """Add card directly to SQL database"""
        try:
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Get or create board
            board_id = self.get_board_id_by_name(board_name)
            if not board_id:
                board_id = self.db.create_board(board_name, owner_id=user_id)
            
            # Create card in database
            card_id = self.db.create_card(
                board_id=board_id,
                list_name=list_name,
                title=card_title,
                description=card_desc,
                status='to_do',
                importance=card_importance,
                due_date=card_due_date,
                subject=subject,
                goal=goal,
                members=members or [],
                git_branch=git_branch,
                git_commit=git_commit,
                recurrence=recurrence,
                dependencies=dependencies or [],
                user_id=user_id
            )
            
            # Reload data from database
            self.load_trello_data()
            self.populate_boards()
            return card_id
        except Exception as e:
            print(f"Erro ao adicionar cartão: {e}")
            messagebox.showerror("Erro", f"Não foi possível adicionar o cartão: {e}")
            return None

    def update_card_data(self, card_id, title, desc, due_date, importance, subject=None, goal=None, members=None, git_branch=None, git_commit=None, recurrence=None, dependencies=None):
        """Update card directly in SQL database"""
        try:
            self.db.update_card(
                card_id=card_id,
                title=title,
                description=desc,
                status='to_do',
                importance=importance,
                due_date=due_date,
                subject=subject,
                goal=goal,
                members=members,
                git_branch=git_branch,
                git_commit=git_commit,
                recurrence=recurrence,
                dependencies=dependencies
            )
            # Reload data from database
            self.load_trello_data()
            self.populate_boards()
        except Exception as e:
            print(f"Erro ao atualizar cartão: {e}")
            messagebox.showerror("Erro", f"Não foi possível atualizar o cartão: {e}")

    def move_card_data(self, source_board_name, source_list_name, card_id, target_board_name, target_list_name):
        """Move card directly in SQL database with proper list_name update and logging"""
        # Usar otimizador se disponível
        if hasattr(self, 'kanban_optimizer') and self.kanban_optimizer:
            return self.kanban_optimizer._optimized_move_card(
                card_id, source_board_name, source_list_name, target_board_name, target_list_name
            )
        
        # Fallback para método original
        try:
            print(f"🔄 SISTEMA: Iniciando movimentação de card")
            print(f"📋 Card ID: {card_id}")
            print(f"📍 Origem: '{source_board_name}' / '{source_list_name}'")
            print(f"🎯 Destino: '{target_board_name}' / '{target_list_name}'")
            
            # Obter board_id do quadro de destino
            target_board_id = self.get_board_id_by_name(target_board_name)
            if not target_board_id:
                print(f"❌ ERRO: Board '{target_board_name}' não encontrado no banco")
                print(f"❌ ERRO: Quadro '{target_board_name}' não encontrado!")
                return False
            
            print(f"✅ Board ID encontrado: {target_board_id}")
            
            # Verificar se o card existe antes de mover
            card_exists = self.db.get_card_by_id(card_id)
            if not card_exists:
                print(f"❌ ERRO: Card {card_id} não encontrado no banco")
                print(f"❌ ERRO: Cartão não encontrado no banco de dados!")
                return False
            
            print(f"✅ Card encontrado no banco: {card_exists.get('title', 'Sem título')}")
            
            # ATUALIZAR O CARD NO BANCO DE DADOS POSTGRESQL
            print(f"🔄 Atualizando card no PostgreSQL...")
            success = self.db.move_card(card_id, target_board_id, target_list_name)
            
            if success:
                print(f"✅ SUCESSO: Card {card_id} movido para '{target_board_name}/{target_list_name}'")
                
                # REGISTRAR NO LOG DO SISTEMA
                try:
                    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    user_name = self.current_user.username if self.current_user else "Sistema"
                    
                    # Log detalhado da movimentação
                    log_entry = {
                        "timestamp": current_time,
                        "action": "MOVIMENTAÇÃO DE CARD",
                        "user": user_name,
                        "card_id": card_id,
                        "card_title": card_exists.get('title', 'Sem título'),
                        "source_board": source_board_name,
                        "source_list": source_list_name,
                        "target_board": target_board_name,
                        "target_list": target_list_name,
                        "target_board_id": target_board_id,
                        "status": "SUCESSO"
                    }
                    
                    print(f"📝 LOG SISTEMA: {log_entry}")
                    
                    # Adicionar ao histórico do card
                    card_data = self.db.get_card_by_id(card_id)
                    if card_data:
                        history = card_data.get('history', [])
                        if isinstance(history, str):
                            try:
                                import json
                                history = json.loads(history)
                            except:
                                history = []
                        if not isinstance(history, list):
                            history = []
                        
                        # Adicionar entrada detalhada no histórico
                        history_entry = {
                            "timestamp": current_time,
                            "action": f"Card movido de '{source_list_name}' para '{target_list_name}'",
                            "user": user_name,
                            "source_board": source_board_name,
                            "source_list": source_list_name,
                            "target_board": target_board_name,
                            "target_list": target_list_name,
                            "list_name_updated": target_list_name,
                            "board_id_updated": target_board_id
                        }
                        
                        history.append(history_entry)
                        
                        # Atualizar histórico no banco
                        self.update_card_history(card_id, history)
                        print(f"✅ Histórico atualizado no banco")
                
                except Exception as history_error:
                    print(f"⚠️ Erro ao registrar histórico: {history_error}")
                
                # Notificação por email se habilitada
                try:
                    if hasattr(self, 'email_integration') and self.email_integration:
                        card_data = {
                            "title": card_exists.get("title", "Sem título"),
                            "board": target_board_name,
                            "column": target_list_name,
                            "modified_by": user_name,
                            "modified_date": current_time
                        }
                        changes = [f"Cartão movido de '{source_list_name}' para '{target_list_name}'"]
                        self.email_integration.notify_card_modified(card_data, changes)
                except Exception as email_error:
                    print(f"⚠️ Erro ao enviar notificação por email: {email_error}")
                
                # RECARREGAR DADOS DO BANCO E ATUALIZAR INTERFACE
                print(f"🔄 Recarregando dados do banco...")
                self.load_trello_data()
                self.populate_boards()
                
                print(f"✅ INTERFACE: Dados recarregados e interface atualizada")
                
                # Log de sucesso no terminal (sem popup)
                print(f"✅ SUCESSO: Cartão movido com sucesso para '{target_list_name}'!")
                return True
            else:
                print(f"❌ FALHA: Não foi possível mover card {card_id} no banco")
                print(f"❌ ERRO: Falha ao mover o cartão no banco de dados!")
                return False
                
        except Exception as e:
            print(f"❌ ERRO CRÍTICO ao mover cartão: {e}")
            print(f"❌ ERRO: Não foi possível mover o cartão: {e}")
            return False

    def delete_card(self, board_name, list_name, card_id):
        """Delete card directly from SQL database"""
        try:
            self.db.delete_card(card_id)
            # Reload data from database
            self.load_trello_data()
            self.populate_boards()
        except Exception as e:
            print(f"Erro ao deletar cartão: {e}")
            messagebox.showerror("Erro", f"Não foi possível deletar o cartão: {e}")
    
    def update_card_history(self, card_id, history):
        """Atualiza o histórico de um card no banco de dados"""
        try:
            if hasattr(self.db, 'update_card_history'):
                self.db.update_card_history(card_id, history)
            else:
                # Fallback: atualizar o card com o histórico
                card_data = self.db.get_card_by_id(card_id)
                if card_data:
                    card_data['history'] = history
                    self.db.update_card(card_id, card_data)
            print(f"✅ Histórico do card {card_id} atualizado no banco")
        except Exception as e:
            print(f"❌ Erro ao atualizar histórico do card {card_id}: {e}")
    
    def verify_card_consistency(self):
        """Verifica e corrige inconsistências nos dados dos cards"""
        try:
            print(f"🔍 SISTEMA: Iniciando verificação de consistência dos cards")
            
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print(f"❌ Banco não disponível para verificação")
                return False
            
            # Obter todos os cards do banco
            all_cards = self.db.get_all_cards()
            if not all_cards:
                print(f"ℹ️ Nenhum card encontrado no banco")
                return True
            
            print(f"📋 Verificando {len(all_cards)} cards no banco...")
            
            inconsistencies_found = 0
            fixed_cards = 0
            
            for card in all_cards:
                card_id = card.get('card_id')
                list_name = card.get('list_name')
                board_id = card.get('board_id')
                title = card.get('title', 'Sem título')
                
                # Verificar se o card tem list_name válido
                if not list_name or list_name.strip() == '':
                    print(f"⚠️ Card '{title}' (ID: {card_id}) sem list_name - corrigindo...")
                    try:
                        self.db.update_card_list_name(card_id, 'A Fazer')
                        inconsistencies_found += 1
                        fixed_cards += 1
                        print(f"✅ Card '{title}' corrigido - list_name definido como 'A Fazer'")
                    except Exception as e:
                        print(f"❌ Erro ao corrigir card '{title}': {e}")
                
                # Verificar se o board_id é válido
                if not board_id:
                    print(f"⚠️ Card '{title}' (ID: {card_id}) sem board_id - corrigindo...")
                    try:
                        # Obter o primeiro board disponível
                        boards = self.db.get_boards()
                        if boards:
                            default_board_id = boards[0]['id']
                            self.db.update_card_board_id(card_id, default_board_id)
                            inconsistencies_found += 1
                            fixed_cards += 1
                            print(f"✅ Card '{title}' corrigido - board_id definido como {default_board_id}")
                    except Exception as e:
                        print(f"❌ Erro ao corrigir board_id do card '{title}': {e}")
            
            print(f"📊 RESULTADO DA VERIFICAÇÃO:")
            print(f"   - Cards verificados: {len(all_cards)}")
            print(f"   - Inconsistências encontradas: {inconsistencies_found}")
            print(f"   - Cards corrigidos: {fixed_cards}")
            
            if fixed_cards > 0:
                print(f"🔄 Recarregando dados após correções...")
                self.load_trello_data()
                self.populate_boards()
                print(f"✅ Dados recarregados após correções")
            
            return True
            
        except Exception as e:
            print(f"❌ ERRO na verificação de consistência: {e}")
            return False
    
    def force_update_card_list_name(self, card_id, new_list_name):
        """Força a atualização do list_name de um card no banco de dados"""
        try:
            print(f"🔄 FORÇANDO atualização do list_name do card {card_id} para '{new_list_name}'")
            
            # Verificar se o card existe
            card_data = self.db.get_card_by_id(card_id)
            if not card_data:
                print(f"❌ Card {card_id} não encontrado no banco")
                return False
            
            # Verificar se o método existe no banco
            if not hasattr(self.db, 'update_card_list_name'):
                print(f"⚠️ Método update_card_list_name não encontrado no banco, usando SQL direto")
                # Usar SQL direto como fallback
                success = self.db.execute_sql_update_card_list_name(card_id, new_list_name)
            else:
                # Atualizar diretamente no banco
                success = self.db.update_card_list_name(card_id, new_list_name)
            
            if success:
                print(f"✅ Card {card_id} atualizado com sucesso - list_name: '{new_list_name}'")
                
                # Registrar no log
                current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                user_name = self.current_user.username if self.current_user else "Sistema"
                
                log_entry = {
                    "timestamp": current_time,
                    "action": "FORÇA ATUALIZAÇÃO LIST_NAME",
                    "user": user_name,
                    "card_id": card_id,
                    "card_title": card_data.get('title', 'Sem título'),
                    "old_list_name": card_data.get('list_name', 'Desconhecido'),
                    "new_list_name": new_list_name,
                    "status": "SUCESSO"
                }
                
                print(f"📝 LOG SISTEMA: {log_entry}")
                
                # Recarregar dados
                self.load_trello_data()
                self.populate_boards()
                
                return True
            else:
                print(f"❌ Falha ao atualizar card {card_id}")
                return False
                
        except Exception as e:
            print(f"❌ ERRO ao forçar atualização do card {card_id}: {e}")
            return False
    
    def check_database_methods(self):
        """Verifica se os métodos necessários existem no banco de dados"""
        try:
            print(f"🔍 Verificando métodos do banco de dados...")
            
            required_methods = [
                'get_all_cards',
                'update_card_list_name', 
                'update_card_board_id',
                'get_card_by_id',
                'move_card'
            ]
            
            missing_methods = []
            
            for method in required_methods:
                if not hasattr(self.db, method):
                    missing_methods.append(method)
                    print(f"⚠️ Método '{method}' não encontrado no banco")
                else:
                    print(f"✅ Método '{method}' encontrado no banco")
            
            if missing_methods:
                print(f"❌ Métodos faltando: {missing_methods}")
                return False
            else:
                print(f"✅ Todos os métodos necessários estão disponíveis")
                return True
                
        except Exception as e:
            print(f"❌ Erro ao verificar métodos do banco: {e}")
            return False



    def send_weekly_report(self):
        """Envia relatório semanal por email"""
        try:
            report_data = self._generate_weekly_report()
            
            subject = f"Relatório Semanal - {report_data['week_period']}"
            body = f"""
Resumo Geral:
- Total de cartões: {report_data['total_cards']}
- Cartões criados: {report_data['cards_created']}
- Cartões concluídos: {report_data['cards_completed']}
- Cartões em atraso: {report_data['overdue_cards']}

Produtividade:
- Taxa de conclusão: {report_data['completion_rate']}%
- Tempo médio de conclusão: {report_data['avg_completion_time']} dias

Cartões Mais Importantes:
{report_data['top_important_cards']}

Próximos Prazos:
{report_data['upcoming_deadlines']}

---
Boodesk - Sistema de Gerenciamento de Tarefas
"""
            body = body.strip()
            
            recipients = self.settings.get('notification_recipients', [])
            for recipient in recipients:
                self.send_email(recipient, subject, body)
                
        except Exception as e:
            print(f"Erro ao enviar relatório semanal: {e}")
    
    def _generate_weekly_report(self):
        """Gera dados para o relatório semanal"""
        try:
            now = datetime.now()
            week_start = now - timedelta(days=7)
            
            total_cards = 0
            cards_created = 0
            cards_completed = 0
            overdue_cards = 0
            important_cards = []
            upcoming_deadlines = []
            
            for board_name, board_data in self.app.boodesk_data.get('boards', {}).items():
                for list_name, cards in board_data.items():
                    if list_name != 'workflow':
                        total_cards += len(cards)
                        
                        for card in cards:
                            # Cartões criados na semana
                            creation_date = card.get('creation_date', '')
                            if creation_date:
                                try:
                                    card_creation = datetime.strptime(creation_date, '%Y-%m-%d %H:%M:%S')
                                    if card_creation >= week_start:
                                        cards_created += 1
                                except ValueError:
                                    pass
                            
                            # Cartões concluídos
                            if list_name == 'Concluído':
                                cards_completed += 1
                            
                            # Cartões em atraso
                            due_date_str = card.get('due_date', '')
                            if due_date_str:
                                try:
                                    due_date = datetime.strptime(due_date_str, '%Y-%m-%d %H:%M')
                                    if due_date < now and list_name != 'Concluído':
                                        overdue_cards += 1
                                except ValueError:
                                    pass
                            
                            # Cartões importantes
                            if card.get('importance') in ['Alta', 'Crítica']:
                                important_cards.append(card.get('title', ''))
                            
                            # Próximos prazos
                            if due_date_str:
                                try:
                                    due_date = datetime.strptime(due_date_str, '%Y-%m-%d %H:%M')
                                    if due_date > now and due_date <= now + timedelta(days=7):
                                        upcoming_deadlines.append(f"{card.get('title', '')} - {due_date_str}")
                                except ValueError:
                                    pass
            
            completion_rate = (cards_completed / total_cards * 100) if total_cards > 0 else 0
            
            return {
                'week_period': f"{week_start.strftime('%d/%m')} - {now.strftime('%d/%m/%Y')}",
                'total_cards': total_cards,
                'cards_created': cards_created,
                'cards_completed': cards_completed,
                'overdue_cards': overdue_cards,
                'completion_rate': round(completion_rate, 1),
                'avg_completion_time': '3.5',  # Placeholder
                'top_important_cards': '\n'.join(important_cards[:5]),
                'upcoming_deadlines': '\n'.join(upcoming_deadlines[:5])
            }
            
        except Exception as e:
            print(f"Erro ao gerar relatório semanal: {e}")
            return {}


class GoogleCalendarIntegration:
    """Integração com Google Calendar para sincronização de eventos"""
    
    SCOPES = ['https://www.googleapis.com/auth/calendar']
    
    def __init__(self, app):
        self.app = app
        self.service = None
        self.credentials = None
        self.calendar_id = 'primary'
        self.token_file = os.path.join(self.app.base_dir, 'google_calendar_token.pickle')
        self.credentials_file = os.path.join(self.app.base_dir, 'google_calendar_credentials.json')
        self.is_authenticated = False
        
    def authenticate(self):
        """Autentica com Google Calendar API"""
        try:
            # Verificar se as bibliotecas estão disponíveis
            try:
                from google.auth.transport.requests import Request
                from google_auth_oauthlib.flow import InstalledAppFlow
                from googleapiclient.discovery import build
                from googleapiclient.errors import HttpError
                import pickle
            except ImportError as e:
                print(f"❌ Bibliotecas do Google Calendar não disponíveis: {e}")
                messagebox.showerror("Erro", 
                                   f"Bibliotecas do Google Calendar não estão instaladas.\n\n"
                                   f"Execute: pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
                return False
            
            # Verificar se há credenciais configuradas
            calendar_settings = self.app.settings.get('calendar_integration', {})
            
            if calendar_settings.get('auth_type') == 'json':
                # Usar arquivo JSON
                credentials_file = calendar_settings.get('credentials_file', '')
                if not credentials_file or not os.path.exists(credentials_file):
                    messagebox.showwarning(
                        "Configuração Necessária",
                        "Arquivo de credenciais do Google Calendar não encontrado.\n"
                        "Por favor, configure as credenciais nas configurações."
                    )
                    return False
                
                self.credentials_file = credentials_file
                
            elif calendar_settings.get('auth_type') == 'key':
                # Usar ID e chave privada
                client_id = calendar_settings.get('client_id', '').strip()
                client_secret = calendar_settings.get('client_secret', '').strip()
                
                if not client_id or not client_secret:
                    messagebox.showwarning(
                        "Configuração Necessária",
                        "Client ID e Client Secret do Google Calendar não configurados.\n"
                        "Por favor, configure as credenciais nas configurações."
                    )
                    return False
                
                # Criar arquivo temporário de credenciais
                temp_creds = {
                    "installed": {
                        "client_id": client_id,
                        "client_secret": client_secret,
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "token_uri": "https://oauth2.googleapis.com/token",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "redirect_uris": ["http://localhost"]
                    }
                }
                
                import tempfile
                import json
                
                with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                    json.dump(temp_creds, f)
                    self.credentials_file = f.name
            else:
                messagebox.showwarning(
                    "Configuração Necessária",
                    "Tipo de autenticação do Google Calendar não configurado.\n"
                    "Por favor, configure as credenciais nas configurações."
                )
                return False
            
            # Tentar carregar token existente
            if os.path.exists(self.token_file):
                try:
                    with open(self.token_file, 'rb') as token:
                        self.credentials = pickle.load(token)
                except Exception as e:
                    print(f"Erro ao carregar token: {e}")
                    self.credentials = None
            
            # Verificar se as credenciais são válidas
            if not self.credentials or not self.credentials.valid:
                if self.credentials and self.credentials.expired and self.credentials.refresh_token:
                    try:
                        self.credentials.refresh(Request())
                    except Exception as e:
                        print(f"Erro ao renovar token: {e}")
                        self.credentials = None
                
                # Se ainda não há credenciais válidas, fazer nova autenticação
                if not self.credentials:
                    try:
                        flow = InstalledAppFlow.from_client_secrets_file(
                            self.credentials_file, self.SCOPES)
                        self.credentials = flow.run_local_server(port=0)
                        
                        # Salvar token
                        with open(self.token_file, 'wb') as token:
                            pickle.dump(self.credentials, token)
                            
                    except Exception as e:
                        print(f"Erro na autenticação OAuth: {e}")
                        messagebox.showerror("Erro", f"Erro na autenticação OAuth:\n{e}")
                        return False
            
            # Criar serviço
            self.service = build('calendar', 'v3', credentials=self.credentials)
            self.is_authenticated = True
            
            print("✅ Autenticação com Google Calendar bem-sucedida!")
            return True
            
        except Exception as e:
            print(f"❌ Erro na autenticação do Google Calendar: {e}")
            messagebox.showerror("Erro", f"Erro na autenticação do Google Calendar:\n{e}")
            return False
    
    def create_event(self, title, description, start_datetime, duration=None, card_id=None, attendees=None):
        """Cria um evento no Google Calendar e salva no PostgreSQL"""
        try:
            if not self.service:
                if not self.authenticate():
                    return False
            
            # Calcular horário de fim
            if duration:
                end_datetime = start_datetime + duration
            else:
                end_datetime = start_datetime + timedelta(hours=1)
            
            # Preparar evento
            event = {
                'summary': title,
                'description': description,
                'start': {
                    'dateTime': start_datetime.isoformat(),
                    'timeZone': 'America/Sao_Paulo',
                },
                'end': {
                    'dateTime': end_datetime.isoformat(),
                    'timeZone': 'America/Sao_Paulo',
                },
                'reminders': {
                    'useDefault': False,
                    'overrides': [
                        {'method': 'popup', 'minutes': 30},
                        {'method': 'email', 'minutes': 60},
                    ],
                },
            }
            
            # Adicionar card_id como metadados se fornecido
            if card_id:
                event['extendedProperties'] = {
                    'private': {
                        'card_id': card_id,
                        'source': 'boodesk_app'
                    }
                }
            
            if attendees:
                event['attendees'] = [{'email': email} for email in attendees]
            
            # Criar evento no Google Calendar
            created_event = self.service.events().insert(
                calendarId=self.calendar_id, body=event).execute()
            
            # Salvar no PostgreSQL
            if hasattr(self.app, 'calendar_manager'):
                event_data = {
                    'title': title,
                    'description': description,
                    'start_datetime': start_datetime,
                    'end_datetime': end_datetime,
                    'location': '',
                    'attendees': attendees or [],
                    'event_type': 'google',
                    'source': 'boodesk',
                    'status': 'scheduled',
                    'priority': 'normal',
                    'color': '#4285f4',
                    'is_all_day': False,
                    'created_by': getattr(self.app, 'current_user_id', 1),
                    'metadata': {
                        'card_id': card_id,
                        'google_event_id': created_event.get('id'),
                        'google_html_link': created_event.get('htmlLink'),
                        'source': 'boodesk_app'
                    }
                }
                
                local_event_id = self.app.calendar_manager.create_event(event_data)
                
                if local_event_id:
                    # Sincronizar com Google Calendar
                    self.app.calendar_manager.sync_with_google_calendar(
                        local_event_id, created_event.get('id')
                    )
                    print(f'✅ Evento salvo no PostgreSQL com ID: {local_event_id}')
            
            print(f'✅ Evento criado no Google Calendar: {created_event.get("htmlLink")}')
            return True
            
        except Exception as error:
            print(f'❌ Erro ao criar evento no Google Calendar: {error}')
            return False
    
    def sync_card_to_calendar(self, card_data, board_name, list_name):
        """Sincroniza um cartão para o Google Calendar"""
        try:
            if not card_data.get('due_date'):
                return False
            
            # Parse da data de vencimento
            due_date_str = card_data['due_date']
            if ' ' in due_date_str:
                due_date_str = due_date_str.split(' ')[0]
            
            due_date = datetime.strptime(due_date_str, "%Y-%m-%d")
            
            # Criar evento de 1 hora
            start_time = due_date.replace(hour=9, minute=0, second=0, microsecond=0)
            end_time = start_time + timedelta(hours=1)
            
            title = f"[{board_name}] {card_data['title']}"
            description = f"""
Tarefa: {card_data['title']}
Quadro: {board_name}
Lista: {list_name}
Descrição: {card_data.get('description', 'N/A')}
Responsável: {', '.join(card_data.get('members', []))}
Importância: {card_data.get('importance', 'Normal')}
            """.strip()
            
            return self.create_event(title, description, start_time, end_time)
            
        except Exception as e:
            print(f"Erro ao sincronizar cartão com calendário: {e}")
            return False
    
    def get_upcoming_events(self, days=7):
        """Obtém eventos próximos do Google Calendar"""
        try:
            if not self.service:
                if not self.authenticate():
                    return []
            
            # Usar formato RFC3339 para datas
            now = datetime.now(timezone.utc)
            end_date = now + timedelta(days=days)
            
            # Formatar datas no formato correto para Google Calendar API
            time_min = now.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
            time_max = end_date.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
            
            events_result = self.service.events().list(
                calendarId=self.calendar_id,
                timeMin=time_min,
                timeMax=time_max,
                singleEvents=True,
                orderBy='startTime'
            ).execute()
            
            events = events_result.get('items', [])
            return events
            
        except Exception as e:
            print(f"Erro ao obter eventos do Google Calendar: {e}")
            return []


class EmailTemplateManager:
    """Gerenciador de templates de email personalizáveis"""
    
    def __init__(self, app):
        self.app = app
        self.templates_file = os.path.join(self.app.base_dir, 'email_templates.json')
        self.templates = self.load_templates()
        
    def load_templates(self):
        """Carrega templates de email do arquivo"""
        try:
            if os.path.exists(self.templates_file):
                with open(self.templates_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                # Templates padrão
                default_templates = {
                    "card_created": {
                        "subject": "Nova Tarefa Criada: {card_title}",
                        "body": """
Olá {member_name},

Uma nova tarefa foi criada e você foi designado como responsável:

**Tarefa:** {card_title}
**Quadro:** {board_name}
**Lista:** {list_name}
**Descrição:** {card_description}
**Prazo:** {due_date}
**Importância:** {importance}

Acesse o sistema para mais detalhes.

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    },
                    "card_modified": {
                        "subject": "Tarefa Atualizada: {card_title}",
                        "body": """
Olá {member_name},

A tarefa "{card_title}" foi atualizada:

**Alterações:**
{changes}

**Detalhes Atuais:**
- Quadro: {board_name}
- Lista: {list_name}
- Prazo: {due_date}
- Importância: {importance}

Acesse o sistema para mais detalhes.

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    },
                    "deadline_reminder": {
                        "subject": "Lembrete de Prazo: {card_title}",
                        "body": """
Olá {member_name},

Este é um lembrete sobre a tarefa que vence em breve:

**Tarefa:** {card_title}
**Quadro:** {board_name}
**Lista:** {list_name}
**Prazo:** {due_date}
**Importância:** {importance}

Por favor, verifique o status desta tarefa.

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    },
                    "weekly_report": {
                        "subject": "Relatório Semanal - {week_period}",
                        "body": """
Olá {member_name},

Aqui está seu relatório semanal de produtividade:

**Resumo da Semana:**
- Tarefas Concluídas: {completed_tasks}
- Tarefas Pendentes: {pending_tasks}
- Tempo Total Pomodoro: {total_pomodoro_time}
- Produtividade: {productivity_score}%

**Tarefas Importantes Concluídas:**
{important_completed_tasks}

**Próximos Prazos:**
{upcoming_deadlines}

Continue assim!

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    }
                }
                self.save_templates(default_templates)
                return default_templates
        except Exception as e:
            print(f"Erro ao carregar templates de email: {e}")
            return {}
    
    def save_templates(self, templates=None):
        """Salva templates de email no arquivo"""
        try:
            if templates is None:
                templates = self.templates
            
            with open(self.templates_file, 'w', encoding='utf-8') as f:
                json.dump(templates, f, indent=2, ensure_ascii=False)
            
            self.templates = templates
            
        except Exception as e:
            print(f"Erro ao salvar templates de email: {e}")
    
    def get_template(self, template_name):
        """Obtém um template específico"""
        return self.templates.get(template_name, {})
    
    def update_template(self, template_name, subject, body):
        """Atualiza um template"""
        self.templates[template_name] = {
            "subject": subject,
            "body": body
        }
        self.save_templates()
    
    def format_template(self, template_name, variables):
        """Formata um template com variáveis"""
        template = self.get_template(template_name)
        if not template:
            return "", ""
        
        subject = template.get("subject", "")
        body = template.get("body", "")
        
        # Substituir variáveis
        for key, value in variables.items():
            placeholder = "{" + key + "}"
            subject = subject.replace(placeholder, str(value))
            body = body.replace(placeholder, str(value))
        
        return subject, body
    
    def get_available_templates(self):
        """Retorna lista de templates disponíveis"""
        return list(self.templates.keys())


class CalendarEventWindow(tk.Toplevel):
    """Janela para criar/editar eventos do calendário"""
    
    def __init__(self, parent, date_str, event_data=None):
        super().__init__(parent)
        self.parent = parent
        self.date_str = date_str
        self.event_data = event_data
        
        self.title("Novo Evento" if not event_data else "Editar Evento")
        self.geometry("500x400")
        self.transient(parent)
        self.grab_set()
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        
    def create_widgets(self):
        """Cria os widgets da janela"""
        main_frame = ttk.Frame(self, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        ttk.Label(main_frame, text="Título:").grid(row=0, column=0, sticky="w", pady=5)
        self.title_var = tk.StringVar(value=self.event_data.get('title', '') if self.event_data else '')
        self.title_entry = ttk.Entry(main_frame, textvariable=self.title_var, width=50)
        self.title_entry.grid(row=0, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        
        # Data
        ttk.Label(main_frame, text="Data:").grid(row=1, column=0, sticky="w", pady=5)
        self.date_var = tk.StringVar(value=self.date_str)
        self.date_entry = ttk.Entry(main_frame, textvariable=self.date_var, width=15)
        self.date_entry.grid(row=1, column=1, sticky="w", pady=5, padx=(10, 0))
        ttk.Button(main_frame, text="📅", command=self.open_date_picker).grid(row=1, column=2, sticky="w", padx=5)
        
        # Hora de início
        ttk.Label(main_frame, text="Hora de Início:").grid(row=2, column=0, sticky="w", pady=5)
        self.start_time_var = tk.StringVar(value=self.event_data.get('start_time', '09:00') if self.event_data else '09:00')
        self.start_time_entry = ttk.Entry(main_frame, textvariable=self.start_time_var, width=10)
        self.start_time_entry.grid(row=2, column=1, sticky="w", pady=5, padx=(10, 0))
        
        # Hora de fim
        ttk.Label(main_frame, text="Hora de Fim:").grid(row=3, column=0, sticky="w", pady=5)
        self.end_time_var = tk.StringVar(value=self.event_data.get('end_time', '10:00') if self.event_data else '10:00')
        self.end_time_entry = ttk.Entry(main_frame, textvariable=self.end_time_var, width=10)
        self.end_time_entry.grid(row=3, column=1, sticky="w", pady=5, padx=(10, 0))
        
        # Descrição
        ttk.Label(main_frame, text="Descrição:").grid(row=4, column=0, sticky="nw", pady=5)
        self.description_text = tk.Text(main_frame, height=8, width=50)
        self.description_text.grid(row=4, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        if self.event_data and self.event_data.get('description'):
            self.description_text.insert("1.0", self.event_data['description'])
        
        # Local
        ttk.Label(main_frame, text="Local:").grid(row=5, column=0, sticky="w", pady=5)
        self.location_var = tk.StringVar(value=self.event_data.get('location', '') if self.event_data else '')
        self.location_entry = ttk.Entry(main_frame, textvariable=self.location_var, width=50)
        self.location_entry.grid(row=5, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        
        # Participantes
        ttk.Label(main_frame, text="Participantes:").grid(row=6, column=0, sticky="w", pady=5)
        self.attendees_var = tk.StringVar(value=self.event_data.get('attendees', '') if self.event_data else '')
        self.attendees_entry = ttk.Entry(main_frame, textvariable=self.attendees_var, width=50)
        self.attendees_entry.grid(row=6, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        ttk.Label(main_frame, text="(emails separados por vírgula)").grid(row=6, column=3, sticky="w", pady=5)
        
        # Sincronizar com Google Calendar
        self.sync_google_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(main_frame, text="Sincronizar com Google Calendar", 
                       variable=self.sync_google_var).grid(row=7, column=0, columnspan=3, sticky="w", pady=10)
        
        # Botões
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=8, column=0, columnspan=3, pady=20)
        
        ttk.Button(button_frame, text="Salvar", command=self.save_event).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.destroy).pack(side=tk.LEFT, padx=5)
        
        # Configurar grid
        main_frame.columnconfigure(1, weight=1)
        
    def open_date_picker(self):
        """Abre o seletor de data"""
        try:
            current_date = datetime.strptime(self.date_var.get(), "%Y-%m-%d")
            date_picker = DatePickerDialog(self, current_date)
            if date_picker.result:
                self.date_var.set(date_picker.result.strftime("%Y-%m-%d"))
        except ValueError:
            date_picker = DatePickerDialog(self)
            if date_picker.result:
                self.date_var.set(date_picker.result.strftime("%Y-%m-%d"))
    
    def save_event(self):
        """Salva o evento no PostgreSQL e Google Calendar"""
        try:
            # Validar campos obrigatórios
            title = self.title_var.get().strip()
            if not title:
                messagebox.showwarning("Aviso", "O título é obrigatório!")
                return
            
            # Validar formato de data
            try:
                event_date = datetime.strptime(self.date_var.get(), "%Y-%m-%d")
            except ValueError:
                messagebox.showwarning("Aviso", "Data inválida!")
                return
            
            # Validar formato de hora
            try:
                start_time = datetime.strptime(self.start_time_var.get(), "%H:%M")
                end_time = datetime.strptime(self.end_time_var.get(), "%H:%M")
            except ValueError:
                messagebox.showwarning("Aviso", "Formato de hora inválido! Use HH:MM")
                return
            
            # Criar dados do evento
            event_data = {
                'title': title,
                'date': self.date_var.get(),
                'start_time': self.start_time_var.get(),
                'end_time': self.end_time_var.get(),
                'description': self.description_text.get("1.0", tk.END).strip(),
                'location': self.location_var.get().strip(),
                'attendees': [email.strip() for email in self.attendees_var.get().split(',') if email.strip()],
                'sync_google': self.sync_google_var.get()
            }
            
            # Salvar no PostgreSQL
            if hasattr(self.parent, 'calendar_manager'):
                start_datetime = datetime.combine(event_date, start_time.time())
                end_datetime = datetime.combine(event_date, end_time.time())
                
                db_event_data = {
                    'title': event_data['title'],
                    'description': event_data['description'],
                    'start_datetime': start_datetime,
                    'end_datetime': end_datetime,
                    'location': event_data['location'],
                    'attendees': event_data['attendees'],
                    'event_type': 'local',
                    'source': 'boodesk',
                    'status': 'scheduled',
                    'priority': 'normal',
                    'color': '#2563eb',
                    'is_all_day': False,
                    'created_by': getattr(self.parent, 'current_user_id', 1),
                    'metadata': {
                        'source': 'manual_entry'
                    }
                }
                
                local_event_id = self.parent.calendar_manager.create_event(db_event_data)
                
                if local_event_id:
                    print(f"✅ Evento salvo no PostgreSQL com ID: {local_event_id}")
                    
                    # Salvar no Google Calendar se solicitado
                    if event_data['sync_google'] and self.parent.calendar_status_var.get() == "Conectado":
                        success = self.parent.google_calendar.create_event(
                            title=event_data['title'],
                            description=event_data['description'],
                            start_datetime=start_datetime,
                            end_datetime=end_datetime,
                            attendees=event_data['attendees'] if event_data['attendees'] else None
                        )
                        
                        if success:
                            messagebox.showinfo("Sucesso", "Evento criado no Google Calendar e PostgreSQL!")
                        else:
                            messagebox.showwarning("Aviso", "Evento salvo no PostgreSQL, mas erro no Google Calendar!")
                    else:
                        messagebox.showinfo("Sucesso", "Evento salvo no PostgreSQL!")
                else:
                    messagebox.showerror("Erro", "Erro ao salvar evento no PostgreSQL!")
            else:
                messagebox.showerror("Erro", "Gerenciador de calendário não disponível!")
            
            self.destroy()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar evento:\n{e}")


# Sistema de Integração com Reuniões (Zoom/Teams)
class MeetingIntegration:
    """Sistema de integração com plataformas de reunião"""
    
    def __init__(self, app):
        self.app = app
        self.meeting_data = {}  # Dados de reuniões
        self.migration_in_progress = False  # Flag para evitar recursão
        self.load_meeting_data()
    
    def load_meeting_data(self):
        """Carrega dados de reuniões do banco de dados"""
        try:
            # Carregar do banco de dados
            meetings_from_db = self.app.db.get_meetings()
            
            # Converter para o formato esperado pelo sistema
            self.meeting_data = {}
            for meeting in meetings_from_db:
                meeting_id = str(meeting.get('id', ''))
                self.meeting_data[meeting_id] = {
                    'id': meeting_id,
                    'title': meeting.get('title', ''),
                    'description': meeting.get('description', ''),
                    'date': meeting.get('date', ''),
                    'time': meeting.get('time', ''),
                    'duration': meeting.get('duration', 60),
                    'platform': meeting.get('platform', ''),
                    'link': meeting.get('link', ''),
                    'board_name': meeting.get('board_name', 'Quadro Principal'),
                    'created_by': meeting.get('created_by', 'Sistema'),
                    'created_at': meeting.get('created_at', ''),
                    'status': 'scheduled'
                }
            
            print(f"✅ Carregadas {len(self.meeting_data)} reuniões do banco de dados")
            
            # Migrar dados do JSON se existir e banco estiver vazio
            if len(meetings_from_db) == 0 and os.path.exists('meeting_data.json') and not self.migration_in_progress:
                self.migration_in_progress = True
                self.migrate_json_to_database()
                self.migration_in_progress = False
            
        except Exception as e:
            print(f"Erro ao carregar dados de reuniões do banco: {e}")
            # Fallback para JSON se banco falhar
            try:
                if os.path.exists('meeting_data.json'):
                    with open('meeting_data.json', 'r', encoding='utf-8') as f:
                        self.meeting_data = json.load(f)
                    print(f"✅ Carregadas {len(self.meeting_data)} reuniões do JSON (fallback)")
                else:
                    self.meeting_data = {}
            except Exception as e2:
                print(f"Erro ao carregar backup JSON: {e2}")
                self.meeting_data = {}
    
    def migrate_json_to_database(self):
        """Migra dados do JSON para o banco de dados"""
        if self.migration_in_progress:
            print("⚠️ Migração já em andamento, pulando...")
            return
            
        try:
            print("🔄 Migrando dados de reuniões do JSON para o banco de dados...")
            
            with open('meeting_data.json', 'r', encoding='utf-8') as f:
                json_data = json.load(f)
            
            migrated_count = 0
            for meeting_id, meeting in json_data.items():
                try:
                    # Salvar no banco de dados
                    self.app.db.save_meeting(
                        title=meeting.get('title', ''),
                        description=meeting.get('description', ''),
                        date=meeting.get('date', ''),
                        time=meeting.get('time', ''),
                        duration=meeting.get('duration', 60),
                        platform=meeting.get('platform', ''),
                        link=meeting.get('link', ''),
                        board_name=meeting.get('board_name', 'Quadro Principal'),
                        created_by=meeting.get('created_by', 'Sistema')
                    )
                    migrated_count += 1
                except Exception as e:
                    print(f"Erro ao migrar reunião {meeting_id}: {e}")
            
            print(f"✅ Migração concluída: {migrated_count} reuniões migradas para o banco")
            
            # Recarregar dados do banco sem chamar load_meeting_data para evitar recursão
            meetings_from_db = self.app.db.get_meetings()
            self.meeting_data = {}
            for meeting in meetings_from_db:
                meeting_id = str(meeting.get('id', ''))
                self.meeting_data[meeting_id] = {
                    'id': meeting_id,
                    'title': meeting.get('title', ''),
                    'description': meeting.get('description', ''),
                    'date': meeting.get('date', ''),
                    'time': meeting.get('time', ''),
                    'duration': meeting.get('duration', 60),
                    'platform': meeting.get('platform', ''),
                    'link': meeting.get('link', ''),
                    'board_name': meeting.get('board_name', 'Quadro Principal'),
                    'created_by': meeting.get('created_by', 'Sistema'),
                    'created_at': meeting.get('created_at', ''),
                    'status': 'scheduled'
                }
            
        except Exception as e:
            print(f"Erro na migração: {e}")
    
    def save_meeting_data(self):
        """Salva dados de reuniões no banco de dados PostgreSQL"""
        try:
            print("DEBUG: Salvando dados de reuniões no PostgreSQL...")
            
            # Obter reuniões existentes no banco
            existing_meetings = self.app.db.get_meetings()
            existing_ids = {str(m.get('id', '')) for m in existing_meetings}
            
            # Salvar cada reunião no banco de dados PostgreSQL
            for meeting_id, meeting in self.meeting_data.items():
                try:
                    # Verificar se a reunião já existe no banco
                    if str(meeting_id) not in existing_ids:
                        print(f"DEBUG: Salvando nova reunião {meeting_id} no PostgreSQL")
                        
                        # Preparar dados para o banco PostgreSQL
                        meeting_data = {
                            'meeting_id': str(meeting_id),
                            'title': meeting.get('title', ''),
                            'description': meeting.get('description', ''),
                            'platform': meeting.get('platform', 'google_meet'),
                            'meeting_link': meeting.get('link', ''),
                            'password': meeting.get('password', ''),
                            'meeting_date': meeting.get('date', ''),
                            'meeting_time': meeting.get('time', ''),
                            'duration_minutes': meeting.get('duration', 60),
                            'status': meeting.get('status', 'scheduled'),
                            'participants': json.dumps(meeting.get('participants', [])),
                            'created_by': self.app.get_current_user_id() if hasattr(self.app, 'get_current_user_id') else 1
                        }
                        
                        # Salvar no banco PostgreSQL
                        success = self.app.db.create_meeting(meeting_data)
                        
                        if success:
                            print(f"✅ Reunião {meeting_id} salva com sucesso no PostgreSQL")
                        else:
                            print(f"❌ Falha ao salvar reunião {meeting_id} no PostgreSQL")
                    else:
                        print(f"DEBUG: Reunião {meeting_id} já existe no PostgreSQL")
                        
                except Exception as meeting_error:
                    print(f"❌ Erro ao salvar reunião {meeting_id}: {meeting_error}")
                    continue
            
            # Manter backup em JSON por compatibilidade (opcional)
            try:
                with open('meeting_data.json', 'w', encoding='utf-8') as f:
                    json.dump(self.meeting_data, f, ensure_ascii=False, indent=2)
                print("✅ Backup JSON mantido para compatibilidade")
            except Exception as json_error:
                print(f"⚠️ Erro ao salvar backup JSON: {json_error}")
                
        except Exception as e:
            print(f"❌ Erro ao salvar dados de reuniões: {e}")
            # Fallback para JSON se banco falhar
            try:
                with open('meeting_data.json', 'w', encoding='utf-8') as f:
                    json.dump(self.meeting_data, f, ensure_ascii=False, indent=2)
                print("✅ Fallback para JSON executado")
            except Exception as e2:
                print(f"❌ Erro ao salvar backup JSON: {e2}")
    
    def create_zoom_meeting(self, title, date, time_str, duration=60, password=None):
        """Cria link de reunião do Zoom"""
        # Gerar ID de reunião único (formato Zoom: 10 dígitos)
        meeting_id = ''.join(random.choices('0123456789', k=10))
        
        # Gerar senha se não fornecida (formato Zoom: 6 dígitos)
        if not password:
            password = ''.join(random.choices('0123456789', k=6))
        
        # Criar link do Zoom (formato padrão)
        zoom_link = f"https://zoom.us/j/{meeting_id}?pwd={password}"
        
        meeting_info = {
            'id': meeting_id,
            'title': title,
            'date': date,
            'time': time_str,
            'duration': duration,
            'password': password,
            'link': zoom_link,
            'platform': 'zoom',
            'created_by': getattr(self.app.current_user, 'username', 'Sistema') if hasattr(self.app, 'current_user') and self.app.current_user else 'Sistema',
            'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'status': 'scheduled'
        }
        
        self.meeting_data[meeting_id] = meeting_info
        self.save_meeting_data()
        
        return meeting_info
    
    def create_teams_meeting(self, title, date, time_str, duration=60):
        """Cria link de reunião do Teams"""
        # Gerar ID de reunião único (formato Teams: GUID)
        import uuid
        meeting_id = str(uuid.uuid4())
        
        # Criar link do Teams (formato padrão)
        teams_link = f"https://teams.microsoft.com/l/meetup-join/{meeting_id}"
        
        meeting_info = {
            'id': meeting_id,
            'title': title,
            'date': date,
            'time': time_str,
            'duration': duration,
            'link': teams_link,
            'platform': 'teams',
            'created_by': getattr(self.app.current_user, 'username', 'Sistema') if hasattr(self.app, 'current_user') and self.app.current_user else 'Sistema',
            'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'status': 'scheduled'
        }
        
        self.meeting_data[meeting_id] = meeting_info
        self.save_meeting_data()
        
        return meeting_info
    
    def create_google_meet_meeting(self, title, date, time_str, duration=60, timezone="America/Sao_Paulo"):
        """Cria link de reunião do Google Meet usando API real e salva no PostgreSQL"""
        try:
            print(f"DEBUG: Criando reunião Google Meet: {title}")
            
            # Usar o Google Calendar Manager para criar reunião real
            if not hasattr(self.app, 'google_calendar_manager'):
                self.app.google_calendar_manager = GoogleCalendarManager()
            
            meeting_info = self.app.google_calendar_manager.create_meeting(
                title, date, time_str, duration, timezone=timezone
            )
            
            if meeting_info:
                print(f"✅ Reunião Google Meet criada com sucesso: {meeting_info.get('id', 'N/A')}")
                
                # Salvar no sistema local
                self.meeting_data[meeting_info['id']] = meeting_info
                
                # Salvar diretamente no PostgreSQL
                try:
                    meeting_data = {
                        'meeting_id': str(meeting_info['id']),
                        'title': meeting_info.get('title', title),
                        'description': meeting_info.get('description', ''),
                        'platform': 'google_meet',
                        'meeting_link': meeting_info.get('link', ''),
                        'password': meeting_info.get('password', ''),
                        'meeting_date': meeting_info.get('date', date),
                        'meeting_time': meeting_info.get('time', time_str),
                        'duration_minutes': meeting_info.get('duration', duration),
                        'status': meeting_info.get('status', 'scheduled'),
                        'participants': json.dumps(meeting_info.get('participants', [])),
                        'created_by': self.app.get_current_user_id() if hasattr(self.app, 'get_current_user_id') else 1
                    }
                    
                    success = self.app.db.create_meeting(meeting_data)
                    if success:
                        print(f"✅ Reunião salva no PostgreSQL: {meeting_info['id']}")
                    else:
                        print(f"⚠️ Falha ao salvar reunião no PostgreSQL, usando backup JSON")
                        self.save_meeting_data()  # Fallback para JSON
                        
                except Exception as db_error:
                    print(f"❌ Erro ao salvar no PostgreSQL: {db_error}")
                    self.save_meeting_data()  # Fallback para JSON
                
                return meeting_info
            else:
                print("⚠️ API do Google Meet falhou, usando fallback simulado")
                return self._create_fallback_google_meet(title, date, time_str, duration)
                
        except Exception as e:
            print(f"❌ Erro ao criar reunião Google Meet: {e}")
            return self._create_fallback_google_meet(title, date, time_str, duration)
    
    def _create_fallback_google_meet(self, title, date, time_str, duration):
        """Cria reunião Google Meet simulada como fallback"""
        import string
        chars = string.ascii_lowercase + string.digits
        part1 = ''.join(random.choices(chars, k=3))
        part2 = ''.join(random.choices(chars, k=4))
        part3 = ''.join(random.choices(chars, k=3))
        meeting_id = f"{part1}-{part2}-{part3}"
        
        meet_link = f"https://meet.google.com/{meeting_id}"
        
        meeting_info = {
            'id': meeting_id,
            'title': title,
            'date': date,
            'time': time_str,
            'duration': duration,
            'link': meet_link,
            'platform': 'google_meet',
            'created_by': getattr(self.app.current_user, 'username', 'Sistema') if hasattr(self.app, 'current_user') and self.app.current_user else 'Sistema',
            'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'status': 'scheduled'
        }
        
        self.meeting_data[meeting_id] = meeting_info
        
        # Salvar no PostgreSQL
        try:
            meeting_data = {
                'meeting_id': str(meeting_id),
                'title': title,
                'description': '',
                'platform': 'google_meet',
                'meeting_link': meet_link,
                'password': '',
                'meeting_date': date,
                'meeting_time': time_str,
                'duration_minutes': duration,
                'status': 'scheduled',
                'participants': json.dumps([]),
                'created_by': self.app.get_current_user_id() if hasattr(self.app, 'get_current_user_id') else 1
            }
            
            success = self.app.db.create_meeting(meeting_data)
            if success:
                print(f"✅ Reunião fallback salva no PostgreSQL: {meeting_id}")
            else:
                print(f"⚠️ Falha ao salvar reunião fallback no PostgreSQL")
                self.save_meeting_data()  # Fallback para JSON
                
        except Exception as db_error:
            print(f"❌ Erro ao salvar fallback no PostgreSQL: {db_error}")
            self.save_meeting_data()  # Fallback para JSON
        
        return meeting_info
    
    def get_meetings_by_project(self, project_name):
        """Retorna reuniões de um projeto específico"""
        return [meeting for meeting in self.meeting_data.values() 
                if meeting.get('project') == project_name]
    
    def get_upcoming_meetings(self):
        """Retorna próximas reuniões"""
        upcoming = []
        current_time = datetime.now()
        
        for meeting in self.meeting_data.values():
            try:
                meeting_datetime = datetime.strptime(f"{meeting['date']} {meeting['time']}", "%Y-%m-%d %H:%M")
                if meeting_datetime > current_time:
                    upcoming.append(meeting)
            except:
                continue
        
        return sorted(upcoming, key=lambda x: f"{x['date']} {x['time']}")


class MeetingWindow:
    """Janela para criar e gerenciar reuniões"""
    
    def __init__(self, parent, app, project_name=None):
        self.parent = parent
        self.app = app
        self.project_name = project_name
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title("Criar Reunião")
        self.window.geometry("900x750")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        title_text = "Criar Reunião"
        if self.project_name:
            title_text += f" - {self.project_name}"
        
        ttk.Label(title_frame, text=title_text, 
                 font=("Arial", 14, "bold")).pack(side=tk.LEFT)
        
        # Frame para formulário
        form_frame = ttk.LabelFrame(main_frame, text="Detalhes da Reunião", padding="10")
        form_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Título da reunião
        ttk.Label(form_frame, text="Título:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.title_var = tk.StringVar()
        self.title_entry = ttk.Entry(form_frame, textvariable=self.title_var, width=40)
        self.title_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        
        # Data (formato brasileiro)
        ttk.Label(form_frame, text="Data:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        date_frame = ttk.Frame(form_frame)
        date_frame.grid(row=1, column=1, sticky="w", padx=5, pady=2)
        
        self.date_var = tk.StringVar()
        self.date_entry = ttk.Entry(date_frame, textvariable=self.date_var, width=15)
        self.date_entry.pack(side=tk.LEFT, padx=(0, 5))
        self.date_entry.insert(0, datetime.now().strftime("%d/%m/%Y"))
        
        # Botão para abrir seletor de data
        date_button = ttk.Button(date_frame, text="📅", width=3, 
                                command=self.open_date_picker)
        date_button.pack(side=tk.LEFT)
        
        # Hora (formato brasileiro)
        ttk.Label(form_frame, text="Hora:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        time_frame = ttk.Frame(form_frame)
        time_frame.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        
        self.time_var = tk.StringVar()
        self.time_entry = ttk.Entry(time_frame, textvariable=self.time_var, width=8)
        self.time_entry.pack(side=tk.LEFT, padx=(0, 5))
        self.time_entry.insert(0, "09:00")
        
        # Botão para abrir seletor de hora
        time_button = ttk.Button(time_frame, text="🕐", width=3,
                                command=self.open_time_picker)
        time_button.pack(side=tk.LEFT)
        
        # Duração
        ttk.Label(form_frame, text="Duração (min):").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.duration_var = tk.StringVar(value="60")
        self.duration_entry = ttk.Entry(form_frame, textvariable=self.duration_var, width=10)
        self.duration_entry.grid(row=3, column=1, sticky="w", padx=5, pady=2)
        
        # Tipo de Associação
        ttk.Label(form_frame, text="Associar a:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.association_type_var = tk.StringVar(value="Nenhuma")
        association_combo = ttk.Combobox(form_frame, textvariable=self.association_type_var,
                                        values=["Nenhuma", "Membro", "Card", "Quadro"], 
                                        state="readonly", width=15)
        association_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)
        association_combo.bind('<<ComboboxSelected>>', self.on_association_type_change)
        
        # Frame para seleção de associação
        self.association_frame = ttk.Frame(form_frame)
        self.association_frame.grid(row=5, column=0, columnspan=2, sticky="ew", padx=5, pady=2)
        
        # Inicialmente vazio
        self.association_widget = None
        
        # Plataforma
        ttk.Label(form_frame, text="Plataforma:").grid(row=6, column=0, sticky="w", padx=5, pady=2)
        self.platform_var = tk.StringVar(value="google_meet")
        
        # Verificar se Google Meet está disponível
        google_meet_available = os.path.exists(CREDENTIALS_FILE)
        platform_values = ["google_meet", "zoom", "teams"]
        if not google_meet_available:
            platform_values = ["zoom", "teams"]
        
        platform_combo = ttk.Combobox(form_frame, textvariable=self.platform_var, 
                                     values=platform_values, state="readonly", width=15)
        platform_combo.grid(row=6, column=1, sticky="w", padx=5, pady=2)
        
        # Mostrar status do Google Meet
        if not google_meet_available:
            status_label = ttk.Label(form_frame, text="⚠️ Google Meet: Configure credentials.json", 
                                   foreground="orange", font=("Arial", 8))
            status_label.grid(row=6, column=2, sticky="w", padx=5, pady=2)
        else:
            status_label = ttk.Label(form_frame, text="✅ Google Meet: Disponível", 
                                   foreground="green", font=("Arial", 8))
            status_label.grid(row=6, column=2, sticky="w", padx=5, pady=2)
        
        # Fuso Horário
        ttk.Label(form_frame, text="Fuso Horário:").grid(row=7, column=0, sticky="w", padx=5, pady=2)
        self.timezone_var = tk.StringVar(value="America/Sao_Paulo")
        
        timezone_values = [
            "America/Sao_Paulo",
            "America/New_York", 
            "America/Los_Angeles",
            "Europe/London",
            "Europe/Paris",
            "Asia/Tokyo",
            "Australia/Sydney",
            "UTC"
        ]
        
        timezone_combo = ttk.Combobox(form_frame, textvariable=self.timezone_var,
                                     values=timezone_values, state="readonly", width=20)
        timezone_combo.grid(row=7, column=1, sticky="w", padx=5, pady=2)
        timezone_combo.bind('<<ComboboxSelected>>', self.update_timezone_label)
        
        # Mostrar fuso horário atual
        self.current_tz_label = ttk.Label(form_frame, text="🌍 Fuso atual: America/Sao_Paulo (UTC-3)", 
                                        foreground="blue", font=("Arial", 8))
        self.current_tz_label.grid(row=7, column=2, sticky="w", padx=5, pady=2)
        
        # Senha (apenas para Zoom)
        self.password_frame = ttk.Frame(form_frame)
        self.password_frame.grid(row=8, column=0, columnspan=2, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.password_frame, text="Senha (opcional):").pack(side=tk.LEFT)
        self.password_var = tk.StringVar()
        self.password_entry = ttk.Entry(self.password_frame, textvariable=self.password_var, width=15)
        self.password_entry.pack(side=tk.LEFT, padx=(5, 0))
        
        # Configurar grid
        form_frame.columnconfigure(1, weight=1)
        
        # Botões principais
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Botão Criar Reunião (sempre visível)
        create_btn = ttk.Button(buttons_frame, text="Criar Reunião", 
                               image=self.icons.get('reuniao_icon'), compound=tk.LEFT,
                               command=self.create_meeting)
        create_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        # Botão para configurar Google Meet se não estiver disponível
        if not google_meet_available:
            config_btn = ttk.Button(buttons_frame, text="Configurar Google Meet", 
                                   image=self.icons.get('settings_icon'), compound=tk.LEFT,
                                   command=self.show_google_setup)
            config_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        # Botão Cancelar (sempre visível)
        cancel_btn = ttk.Button(buttons_frame, text="Cancelar", 
                               image=self.icons.get('cancel_icon'), compound=tk.LEFT,
                               command=self.window.destroy)
        cancel_btn.pack(side=tk.RIGHT)
        
        # Garantir que os botões sejam visíveis
        buttons_frame.update_idletasks()
        
        # Frame para reuniões existentes
        meetings_frame = ttk.LabelFrame(main_frame, text="Reuniões Agendadas", padding="10")
        meetings_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para reuniões
        columns = ("Data", "Hora", "Título", "Plataforma", "Criado por")
        self.meetings_tree = ttk.Treeview(meetings_frame, columns=columns, show="headings", height=10)
        
        for col in columns:
            self.meetings_tree.heading(col, text=col)
            self.meetings_tree.column(col, width=100, anchor="w")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(meetings_frame, orient="vertical", command=self.meetings_tree.yview)
        self.meetings_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.meetings_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Botões de ação para reuniões
        action_frame = ttk.Frame(main_frame)
        action_frame.pack(fill=tk.X)
        
        # Frame para filtros
        filter_frame = ttk.LabelFrame(action_frame, text="Filtros", padding="5")
        filter_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        ttk.Button(filter_frame, text="👤 Por Membro", 
                  command=lambda: self.filter_meetings_by_type('member')).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(filter_frame, text="📋 Por Card", 
                  command=lambda: self.filter_meetings_by_type('card')).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(filter_frame, text="📊 Por Quadro", 
                  command=lambda: self.filter_meetings_by_type('board')).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(filter_frame, text="🔍 Todas", 
                  command=self.load_meetings).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(filter_frame, text="🧹 Limpar Inválidas", 
                  command=self.clean_invalid_meetings).pack(side=tk.LEFT, padx=(0, 5))
        
        # Frame para ações
        actions_frame = ttk.Frame(action_frame)
        actions_frame.pack(side=tk.RIGHT)
        
        # Botão Copiar Link
        copy_btn = ttk.Button(actions_frame, text="Copiar Link", 
                             image=self.icons.get('copy_icon'), compound=tk.LEFT,
                             command=self.copy_meeting_link)
        copy_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        # Botão Excluir
        delete_btn = ttk.Button(actions_frame, text="Excluir", 
                               image=self.icons.get('delete_icon'), compound=tk.LEFT,
                               command=self.delete_meeting)
        delete_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        # Botão Atualizar
        refresh_btn = ttk.Button(actions_frame, text="Atualizar", 
                                image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                                command=self.load_meetings)
        refresh_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        # Botão Templates (usar ícone alternativo se template_icon não existir)
        template_icon = self.icons.get('template_icon') or self.icons.get('settings_icon')
        template_btn = ttk.Button(actions_frame, text="Templates", 
                                 image=template_icon, compound=tk.LEFT,
                                 command=self.open_templates_window)
        template_btn.pack(side=tk.LEFT)
        
        # Garantir que os botões sejam visíveis
        actions_frame.update_idletasks()
        
        # Carregar reuniões existentes
        self.load_meetings()
        
        # Focar no título
        self.title_entry.focus()
    
    def open_templates_window(self):
        """Abre janela de templates de reunião"""
        MeetingTemplatesWindow(self.window, self.app)
    
    def apply_template(self, template):
        """Aplica template selecionado"""
        # Aplicar dados do template
        self.title_var.set(template.get('title', ''))
        self.duration_var.set(str(template.get('duration', 60)))
        self.platform_var.set(template.get('platform', 'google_meet'))
        self.timezone_var.set(template.get('timezone', 'America/Sao_Paulo'))
        
        # Atualizar label do fuso horário
        if hasattr(self, 'update_timezone_label'):
            self.update_timezone_label()
        
        # Focar no título
        self.title_entry.focus()
        
        messagebox.showinfo("Template Aplicado", 
                          f"Template '{template.get('name')}' aplicado com sucesso!\n"
                          f"Preencha a data e hora para criar a reunião.")
    
    def show_google_setup(self):
        """Mostra instruções para configurar Google Meet"""
        setup_text = """
Para usar o Google Meet com links reais, você precisa configurar a API do Google:

1. Acesse: https://console.cloud.google.com
2. Crie um projeto e ative a Google Calendar API
3. Crie credenciais OAuth 2.0
4. Baixe o arquivo como 'credentials.json'
5. Coloque na pasta do aplicativo

Arquivo de instruções completo: GOOGLE_MEET_SETUP.md

Dependências necessárias:
pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client
        """
        
        # Criar janela de instruções
        setup_window = tk.Toplevel(self.window)
        setup_window.title("Configurar Google Meet")
        setup_window.geometry("600x400")
        setup_window.transient(self.window)
        setup_window.grab_set()
        
        # Texto das instruções
        text_widget = tk.Text(setup_window, wrap=tk.WORD, padx=10, pady=10)
        text_widget.pack(fill=tk.BOTH, expand=True)
        text_widget.insert(tk.END, setup_text)
        text_widget.config(state=tk.DISABLED)
        
        # Botões
        button_frame = ttk.Frame(setup_window)
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        ttk.Button(button_frame, text="Abrir Google Cloud Console", 
                  command=lambda: webbrowser.open("https://console.cloud.google.com")).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Instalar Dependências", 
                  command=self.install_google_deps).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", 
                  command=setup_window.destroy).pack(side=tk.RIGHT, padx=5)
    
    def install_google_deps(self):
        """Instala as dependências do Google"""
        try:
            import subprocess
            subprocess.check_call([os.path.abspath(sys.argv[0]), "-m", "pip", "install", 
                                 "google-auth", "google-auth-oauthlib", 
                                 "google-auth-httplib2", "google-api-python-client"])
            messagebox.showinfo("Sucesso", "Dependências instaladas com sucesso!\nReinicie o aplicativo.")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao instalar dependências:\n{str(e)}")
    
    def open_date_picker(self):
        """Abre o seletor de data"""
        try:
            # Converter data atual para datetime se existir
            current_date = None
            if self.date_var.get():
                try:
                    # Converter do formato brasileiro para datetime
                    current_date = datetime.strptime(self.date_var.get(), "%d/%m/%Y")
                except ValueError:
                    current_date = datetime.now()
            else:
                current_date = datetime.now()
            
            # Abrir seletor de data
            date_picker = DatePickerDialog(self.window, current_date)
            self.window.wait_window(date_picker)
            
            if date_picker.selected_date:
                # Formatar data no padrão brasileiro
                formatted_date = date_picker.selected_date.strftime("%d/%m/%Y")
                self.date_var.set(formatted_date)
                
        except Exception as e:
            print(f"Erro ao abrir seletor de data: {e}")
            messagebox.showerror("Erro", "Erro ao abrir seletor de data")
    
    def open_time_picker(self):
        """Abre o seletor de hora"""
        try:
            # Obter hora atual do campo
            current_time = self.time_var.get() if self.time_var.get() else "09:00"
            
            # Abrir seletor de hora
            time_picker = TimePickerDialog(self.window, current_time)
            self.window.wait_window(time_picker)
            
            if time_picker.selected_time:
                self.time_var.set(time_picker.selected_time)
                
        except Exception as e:
            print(f"Erro ao abrir seletor de hora: {e}")
            messagebox.showerror("Erro", "Erro ao abrir seletor de hora")
    
    def update_timezone_label(self, event=None):
        """Atualiza o label do fuso horário quando selecionado"""
        timezone = self.timezone_var.get()
        timezone_info = {
            "America/Sao_Paulo": "UTC-3",
            "America/New_York": "UTC-5",
            "America/Los_Angeles": "UTC-8", 
            "Europe/London": "UTC+0",
            "Europe/Paris": "UTC+1",
            "Asia/Tokyo": "UTC+9",
            "Australia/Sydney": "UTC+10",
            "UTC": "UTC+0"
        }
        
        offset = timezone_info.get(timezone, "UTC")
        self.current_tz_label.config(text=f"🌍 Fuso atual: {timezone} ({offset})")
    
    def on_association_type_change(self, event=None):
        """Gerencia a mudança no tipo de associação"""
        association_type = self.association_type_var.get()
        
        # Limpar frame de associação
        for widget in self.association_frame.winfo_children():
            widget.destroy()
        
        if association_type == "Nenhuma":
            return
        
        elif association_type == "Membro":
            self.create_member_association_widget()
        
        elif association_type == "Card":
            self.create_card_association_widget()
        
        elif association_type == "Quadro":
            self.create_board_association_widget()
    
    def create_member_association_widget(self):
        """Cria widget para seleção de membro"""
        ttk.Label(self.association_frame, text="Selecionar Membro:").pack(side=tk.LEFT, padx=(0, 5))
        
        # Buscar membros do banco
        members = self.app.db.get_all_members()
        member_names = [member.get('name', member.get('membro', '')) for member in members]
        
        self.member_var = tk.StringVar()
        member_combo = ttk.Combobox(self.association_frame, textvariable=self.member_var,
                                   values=member_names, state="readonly", width=20)
        member_combo.pack(side=tk.LEFT, padx=(0, 5))
        
        # Botão para atualizar lista
        ttk.Button(self.association_frame, text="🔄", width=3,
                  command=self.refresh_members).pack(side=tk.LEFT)
    
    def create_card_association_widget(self):
        """Cria widget para seleção de card"""
        ttk.Label(self.association_frame, text="Selecionar Card:").pack(side=tk.LEFT, padx=(0, 5))
        
        # Buscar cards do banco
        cards = []
        boards = self.app.db.get_boards()
        for board in boards:
            board_cards = self.app.db.get_cards_for_board(board.get('board_id'))
            for card in board_cards:
                cards.append({
                    'id': card.get('card_id'),
                    'title': card.get('title'),
                    'board': board.get('name')
                })
        
        card_titles = [f"{card['title']} ({card['board']})" for card in cards]
        
        self.card_var = tk.StringVar()
        card_combo = ttk.Combobox(self.association_frame, textvariable=self.card_var,
                                 values=card_titles, state="readonly", width=30)
        card_combo.pack(side=tk.LEFT, padx=(0, 5))
        
        # Botão para atualizar lista
        ttk.Button(self.association_frame, text="🔄", width=3,
                  command=self.refresh_cards).pack(side=tk.LEFT)
    
    def create_board_association_widget(self):
        """Cria widget para seleção de quadro"""
        ttk.Label(self.association_frame, text="Selecionar Quadro:").pack(side=tk.LEFT, padx=(0, 5))
        
        # Buscar quadros do banco
        boards = self.app.db.get_boards()
        board_names = [board.get('name') for board in boards]
        
        self.board_var = tk.StringVar()
        board_combo = ttk.Combobox(self.association_frame, textvariable=self.board_var,
                                  values=board_names, state="readonly", width=20)
        board_combo.pack(side=tk.LEFT, padx=(0, 5))
        
        # Botão para atualizar lista
        ttk.Button(self.association_frame, text="🔄", width=3,
                  command=self.refresh_boards).pack(side=tk.LEFT)
    
    def refresh_members(self):
        """Atualiza lista de membros"""
        members = self.app.db.get_all_members()
        member_names = [member.get('name', member.get('membro', '')) for member in members]
        
        # Encontrar o combobox de membros
        for widget in self.association_frame.winfo_children():
            if isinstance(widget, ttk.Combobox):
                widget['values'] = member_names
                break
    
    def refresh_cards(self):
        """Atualiza lista de cards"""
        cards = []
        boards = self.app.db.get_boards()
        for board in boards:
            board_cards = self.app.db.get_cards_for_board(board.get('board_id'))
            for card in board_cards:
                cards.append({
                    'id': card.get('card_id'),
                    'title': card.get('title'),
                    'board': board.get('name')
                })
        
        card_titles = [f"{card['title']} ({card['board']})" for card in cards]
        
        # Encontrar o combobox de cards
        for widget in self.association_frame.winfo_children():
            if isinstance(widget, ttk.Combobox):
                widget['values'] = card_titles
                break
    
    def refresh_boards(self):
        """Atualiza lista de quadros"""
        boards = self.app.db.get_boards()
        board_names = [board.get('name') for board in boards]
        
        # Encontrar o combobox de quadros
        for widget in self.association_frame.winfo_children():
            if isinstance(widget, ttk.Combobox):
                widget['values'] = board_names
                break
    
    def get_association_data(self):
        """Retorna os dados da associação selecionada"""
        association_type = self.association_type_var.get()
        
        if association_type == "Nenhuma":
            return None
        
        elif association_type == "Membro":
            member_name = self.member_var.get() if hasattr(self, 'member_var') else ""
            return {
                'type': 'member',
                'name': member_name
            }
        
        elif association_type == "Card":
            card_title = self.card_var.get() if hasattr(self, 'card_var') else ""
            return {
                'type': 'card',
                'title': card_title
            }
        
        elif association_type == "Quadro":
            board_name = self.board_var.get() if hasattr(self, 'board_var') else ""
            return {
                'type': 'board',
                'name': board_name
            }
        
        return None
    
    def filter_meetings_by_type(self, association_type):
        """Filtra reuniões por tipo de associação"""
        # Limpar treeview
        for item in self.meetings_tree.get_children():
            self.meetings_tree.delete(item)
        
        # Carregar reuniões
        if self.project_name:
            meetings = self.app.meeting_integration.get_meetings_by_project(self.project_name)
        else:
            meetings = list(self.app.meeting_integration.meeting_data.values())
        
        # Filtrar reuniões por tipo de associação
        filtered_meetings = []
        for meeting in meetings:
            if 'association' in meeting and meeting['association'].get('type') == association_type:
                filtered_meetings.append(meeting)
        
        # Exibir reuniões filtradas
        for meeting in filtered_meetings:
            # Converter nome da plataforma para exibição
            platform = meeting.get('platform', '')
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(platform, platform.upper())
            
            # Obter informação de associação
            association_info = ""
            if 'association' in meeting:
                assoc = meeting['association']
                if assoc['type'] == 'member':
                    association_info = f"👤 {assoc['name']}"
                elif assoc['type'] == 'card':
                    association_info = f"📋 {assoc['title']}"
                elif assoc['type'] == 'board':
                    association_info = f"📊 {assoc['name']}"
            
            # Adicionar associação ao título se existir
            title = meeting.get('title', '')
            if association_info:
                title = f"{title} {association_info}"
            
            self.meetings_tree.insert("", "end", values=(
                meeting.get('date', ''),
                meeting.get('time', ''),
                title,
                platform_display,
                meeting.get('created_by', '')
            ), tags=(meeting['id'],))
        
        # Mostrar mensagem se não houver reuniões
        if not filtered_meetings:
            messagebox.showinfo("Filtro", f"Nenhuma reunião encontrada associada a {association_type}.")
    
    def clean_invalid_meetings(self):
        """Remove reuniões sem data/hora válidas"""
        try:
            # Buscar reuniões inválidas
            invalid_meetings = []
            for meeting_id, meeting in self.app.meeting_integration.meeting_data.items():
                if not meeting.get('date') or not meeting.get('time'):
                    invalid_meetings.append(meeting_id)
            
            if invalid_meetings:
                if messagebox.askyesno("Limpar Reuniões", 
                                     f"Encontradas {len(invalid_meetings)} reuniões sem data/hora.\n"
                                     f"Deseja removê-las?"):
                    
                    # Remover reuniões inválidas
                    for meeting_id in invalid_meetings:
                        del self.app.meeting_integration.meeting_data[meeting_id]
                    
                    # Salvar alterações
                    self.app.meeting_integration.save_meeting_data()
                    
                    # Recarregar lista
                    self.load_meetings()
                    
                    messagebox.showinfo("Sucesso", f"{len(invalid_meetings)} reuniões inválidas removidas!")
            else:
                messagebox.showinfo("Limpeza", "Nenhuma reunião inválida encontrada!")
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao limpar reuniões: {str(e)}")
    
    def create_meeting(self):
        """Cria uma nova reunião"""
        title = self.title_var.get().strip()
        date = self.date_var.get().strip()
        time = self.time_var.get().strip()
        duration = self.duration_var.get().strip()
        platform = self.platform_var.get()
        password = self.password_var.get().strip()
        
        # Validações
        if not title:
            messagebox.showerror("Erro", "Título é obrigatório!")
            return
        
        if not date:
            messagebox.showerror("Erro", "Data é obrigatória!")
            return
        
        if not time:
            messagebox.showerror("Erro", "Hora é obrigatória!")
            return
        
        # Validar formato da data
        try:
            datetime.strptime(date, "%d/%m/%Y")
        except ValueError:
            messagebox.showerror("Erro", "Formato de data inválido! Use dd/mm/aaaa")
            return
        
        # Validar formato da hora
        try:
            datetime.strptime(time, "%H:%M")
        except ValueError:
            messagebox.showerror("Erro", "Formato de hora inválido! Use hh:mm")
            return
        
        try:
            duration = int(duration)
        except ValueError:
            messagebox.showerror("Erro", "Duração deve ser um número!")
            return
        
        try:
            # Converter data do formato brasileiro (dd/mm/yyyy) para formato ISO (yyyy-mm-dd)
            try:
                date_obj = datetime.strptime(date, "%d/%m/%Y")
                date_iso = date_obj.strftime("%Y-%m-%d")
            except ValueError:
                messagebox.showerror("Erro", "Formato de data inválido! Use dd/mm/aaaa")
                return
            
            # Obter fuso horário selecionado
            timezone = self.timezone_var.get()
            
            # Obter dados de associação
            association_data = self.get_association_data()
            
            # Criar reunião
            if platform == "zoom":
                meeting_info = self.app.meeting_integration.create_zoom_meeting(
                    title, date_iso, time, duration, password if password else None
                )
            elif platform == "teams":
                meeting_info = self.app.meeting_integration.create_teams_meeting(
                    title, date_iso, time, duration
                )
            else:  # google_meet
                meeting_info = self.app.meeting_integration.create_google_meet_meeting(
                    title, date_iso, time, duration, timezone=timezone
                )
            
            # Adicionar dados de associação
            if association_data:
                meeting_info['association'] = association_data
            
            # Adicionar projeto se especificado
            if self.project_name:
                meeting_info['project'] = self.project_name
                self.app.meeting_integration.save_meeting_data()
            
            # Mostrar link gerado
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(meeting_info['platform'], meeting_info['platform'].upper())
            
            messagebox.showinfo("Reunião Criada", 
                              f"Reunião criada com sucesso!\n\n"
                              f"Link: {meeting_info['link']}\n"
                              f"Plataforma: {platform_display}")
            
            # Limpar formulário
            self.title_var.set("")
            self.password_var.set("")
            
            # Recarregar lista
            self.load_meetings()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao criar reunião: {e}")
    
    def load_meetings(self):
        """Carrega reuniões existentes"""
        # Limpar treeview
        for item in self.meetings_tree.get_children():
            self.meetings_tree.delete(item)
        
        # Carregar reuniões
        if self.project_name:
            meetings = self.app.meeting_integration.get_meetings_by_project(self.project_name)
        else:
            meetings = list(self.app.meeting_integration.meeting_data.values())
        
        # Exibir reuniões
        for meeting in meetings:
            # Converter nome da plataforma para exibição
            platform = meeting.get('platform', '')
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(platform, platform.upper())
            
            # Obter informação de associação
            association_info = ""
            if 'association' in meeting:
                assoc = meeting['association']
                if assoc['type'] == 'member':
                    association_info = f"👤 {assoc['name']}"
                elif assoc['type'] == 'card':
                    association_info = f"📋 {assoc['title']}"
                elif assoc['type'] == 'board':
                    association_info = f"📊 {assoc['name']}"
            
            # Adicionar associação ao título se existir
            title = meeting.get('title', '')
            if association_info:
                title = f"{title} {association_info}"
            
            self.meetings_tree.insert("", "end", values=(
                meeting.get('date', ''),
                meeting.get('time', ''),
                title,
                platform_display,
                meeting.get('created_by', '')
            ), tags=(meeting['id'],))
    
    def copy_meeting_link(self):
        """Copia link da reunião selecionada"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reunião!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        
        if meeting_id in self.app.meeting_integration.meeting_data:
            meeting = self.app.meeting_integration.meeting_data[meeting_id]
            link = meeting['link']
            
            # Copiar para área de transferência
            self.window.clipboard_clear()
            self.window.clipboard_append(link)
            
            messagebox.showinfo("Link Copiado", f"Link copiado para a área de transferência:\n{link}")
    
    def delete_meeting(self):
        """Exclui reunião selecionada"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reunião!")
            return
        
        try:
            item = self.meetings_tree.item(selection[0])
            meeting_id = item['tags'][0] if item['tags'] else None
            meeting_title = item['values'][2] if len(item['values']) > 2 else "Reunião"
            
            if not meeting_id:
                messagebox.showerror("Erro", "ID da reunião não encontrado!")
                return
            
            if messagebox.askyesno("Confirmar Exclusão", 
                                  f"Tem certeza que deseja excluir a reunião '{meeting_title}'?\n\n"
                                  f"Isso também cancelará a reunião no Google Calendar."):
                
                # Verificar se a reunião existe no sistema
                if not hasattr(self.app, 'meeting_integration') or not self.app.meeting_integration:
                    messagebox.showerror("Erro", "Sistema de reuniões não disponível!")
                    return
                
                if meeting_id not in self.app.meeting_integration.meeting_data:
                    # Tentar remover da lista mesmo se não estiver no sistema
                    self.meetings_tree.delete(selection[0])
                    messagebox.showinfo("Sucesso", f"Reunião '{meeting_title}' removida da lista!")
                    return
                
                meeting = self.app.meeting_integration.meeting_data[meeting_id]
                
                # Tentar cancelar no Google Calendar se for Google Meet
                google_canceled = False
                if meeting.get('platform') == 'google_meet' and meeting.get('google_event_id'):
                    try:
                        if not hasattr(self.app, 'google_calendar_manager'):
                            self.app.google_calendar_manager = GoogleCalendarManager()
                        
                        google_canceled = self.app.google_calendar_manager.cancel_meeting(
                            meeting.get('google_event_id')
                        )
                    except Exception as e:
                        print(f"Erro ao cancelar no Google Calendar: {e}")
                
                # Remover do sistema local e banco de dados
                try:
                    # Remover do banco de dados
                    self.app.db.delete_meeting(int(meeting_id))
                    
                    # Remover da memória
                    del self.app.meeting_integration.meeting_data[meeting_id]
                    
                    # Salvar backup em JSON
                    self.app.meeting_integration.save_meeting_data()
                    
                except Exception as e:
                    print(f"Erro ao remover reunião do sistema: {e}")
                    # Fallback: apenas remover da memória
                    try:
                        del self.app.meeting_integration.meeting_data[meeting_id]
                    except:
                        pass
                
                # Recarregar lista
                self.load_meetings()
                
                # Atualizar widget de reuniões no menu principal e dashboard
                self._update_meeting_widgets()
                
                # Mostrar resultado
                if google_canceled:
                    messagebox.showinfo("Sucesso", 
                                      f"Reunião '{meeting_title}' excluída com sucesso!\n"
                                      f"✅ Também cancelada no Google Calendar.")
                elif meeting.get('platform') == 'google_meet':
                    messagebox.showwarning("Parcialmente Bem-sucedido", 
                                         f"Reunião '{meeting_title}' excluída do sistema.\n"
                                         f"⚠️ Não foi possível cancelar no Google Calendar.\n"
                                         f"Cancele manualmente no Google Calendar.")
                else:
                    messagebox.showinfo("Sucesso", f"Reunião '{meeting_title}' excluída com sucesso!")
                    
        except Exception as e:
            print(f"Erro ao excluir reunião: {e}")
            messagebox.showerror("Erro", f"Erro ao excluir reunião: {str(e)}")
    
    def _update_meeting_widgets(self):
        """Atualiza todos os widgets de reuniões no menu principal e dashboard"""
        try:
            # Atualizar widget no menu principal
            if hasattr(self, 'meeting_widget') and self.meeting_widget:
                self.meeting_widget.refresh_meetings()
            
            # Atualizar widget no dashboard (se existir)
            # O widget do dashboard é o mesmo do menu principal, então não precisa atualizar separadamente
            print("✅ Widgets de reuniões atualizados com sucesso")
            
        except Exception as e:
            print(f"Erro ao atualizar widgets de reuniões: {e}")


# Sistema de Templates de Reunião
class MeetingTemplatesWindow(tk.Toplevel):
    """Janela para gerenciar templates de reunião"""
    
    def __init__(self, parent, app):
        super().__init__(parent)
        self.parent = parent
        self.app = app
        self.templates_file = 'meeting_templates.json'
        self.templates = self.load_templates()
        
        # Configurar janela
        self.title("Templates de Reunião")
        self.geometry("700x500")
        self.transient(parent)
        self.grab_set()
        
        # Centralizar
        self.center_window()
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        
        # Focar na janela
        self.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (700 // 2)
        y = (self.winfo_screenheight() // 2) - (500 // 2)
        self.geometry(f"700x500+{x}+{y}")
    
    def load_templates(self):
        """Carrega templates salvos"""
        try:
            if os.path.exists(self.templates_file):
                with open(self.templates_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception as e:
            print(f"Erro ao carregar templates: {e}")
        
        # Se não existir arquivo, criar templates padrão
        if not os.path.exists(self.templates_file):
            default_templates = self.create_default_templates()
            self.save_default_templates(default_templates)
            return default_templates
        
        return []
    
    def create_default_templates(self):
        """Cria templates padrão"""
        return [
            {
                'name': 'Daily Standup',
                'title': 'Daily Standup - Equipe',
                'duration': 15,
                'platform': 'google_meet',
                'timezone': 'America/Sao_Paulo',
                'description': 'Reunião diária para alinhamento da equipe'
            },
            {
                'name': 'Sprint Planning',
                'title': 'Sprint Planning',
                'duration': 60,
                'platform': 'google_meet',
                'timezone': 'America/Sao_Paulo',
                'description': 'Planejamento da sprint com toda a equipe'
            },
            {
                'name': 'Sprint Review',
                'title': 'Sprint Review',
                'duration': 45,
                'platform': 'google_meet',
                'timezone': 'America/Sao_Paulo',
                'description': 'Apresentação dos resultados da sprint'
            },
            {
                'name': 'Retrospectiva',
                'title': 'Sprint Retrospectiva',
                'duration': 30,
                'platform': 'google_meet',
                'timezone': 'America/Sao_Paulo',
                'description': 'Reflexão sobre a sprint e melhorias'
            },
            {
                'name': 'Reunião Cliente',
                'title': 'Reunião com Cliente',
                'duration': 60,
                'platform': 'zoom',
                'timezone': 'America/Sao_Paulo',
                'description': 'Reunião para apresentação ou alinhamento com cliente'
            },
            {
                'name': 'Code Review',
                'title': 'Code Review',
                'duration': 30,
                'platform': 'google_meet',
                'timezone': 'America/Sao_Paulo',
                'description': 'Revisão de código em equipe'
            }
        ]
    
    def save_default_templates(self, templates):
        """Salva templates padrão"""
        try:
            with open(self.templates_file, 'w', encoding='utf-8') as f:
                json.dump(templates, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erro ao salvar templates padrão: {e}")
    
    def save_templates(self):
        """Salva templates no arquivo"""
        try:
            with open(self.templates_file, 'w', encoding='utf-8') as f:
                json.dump(self.templates, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erro ao salvar templates: {e}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_label = ttk.Label(main_frame, text="📋 Templates de Reunião", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Frame para lista e formulário
        content_frame = ttk.Frame(main_frame)
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        # Lista de templates (esquerda)
        list_frame = ttk.LabelFrame(content_frame, text="Templates Disponíveis", padding="10")
        list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))
        
        # Treeview para templates
        columns = ("Nome", "Plataforma", "Duração")
        self.templates_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.templates_tree.heading(col, text=col)
            self.templates_tree.column(col, width=100)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.templates_tree.yview)
        self.templates_tree.configure(yscrollcommand=scrollbar.set)
        
        self.templates_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Bind seleção
        self.templates_tree.bind('<<TreeviewSelect>>', self.on_template_select)
        
        # Formulário (direita)
        form_frame = ttk.LabelFrame(content_frame, text="Criar/Editar Template", padding="10")
        form_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        
        # Campos do formulário
        ttk.Label(form_frame, text="Nome do Template:").grid(row=0, column=0, sticky="w", pady=2)
        self.name_var = tk.StringVar()
        self.name_entry = ttk.Entry(form_frame, textvariable=self.name_var, width=25)
        self.name_entry.grid(row=0, column=1, sticky="ew", pady=2)
        
        ttk.Label(form_frame, text="Título da Reunião:").grid(row=1, column=0, sticky="w", pady=2)
        self.title_var = tk.StringVar()
        self.title_entry = ttk.Entry(form_frame, textvariable=self.title_var, width=25)
        self.title_entry.grid(row=1, column=1, sticky="ew", pady=2)
        
        ttk.Label(form_frame, text="Duração (min):").grid(row=2, column=0, sticky="w", pady=2)
        self.duration_var = tk.StringVar(value="60")
        self.duration_entry = ttk.Entry(form_frame, textvariable=self.duration_var, width=25)
        self.duration_entry.grid(row=2, column=1, sticky="ew", pady=2)
        
        ttk.Label(form_frame, text="Plataforma:").grid(row=3, column=0, sticky="w", pady=2)
        self.platform_var = tk.StringVar(value="google_meet")
        platform_combo = ttk.Combobox(form_frame, textvariable=self.platform_var, 
                                     values=["google_meet", "zoom", "teams"], 
                                     state="readonly", width=22)
        platform_combo.grid(row=3, column=1, sticky="ew", pady=2)
        
        ttk.Label(form_frame, text="Fuso Horário:").grid(row=4, column=0, sticky="w", pady=2)
        self.timezone_var = tk.StringVar(value="America/Sao_Paulo")
        timezone_combo = ttk.Combobox(form_frame, textvariable=self.timezone_var,
                                     values=["America/Sao_Paulo", "America/New_York", "America/Los_Angeles", 
                                            "Europe/London", "Europe/Paris", "Asia/Tokyo", "Australia/Sydney", "UTC"],
                                     state="readonly", width=22)
        timezone_combo.grid(row=4, column=1, sticky="ew", pady=2)
        
        ttk.Label(form_frame, text="Descrição:").grid(row=5, column=0, sticky="w", pady=2)
        self.description_text = tk.Text(form_frame, height=4, width=25)
        self.description_text.grid(row=5, column=1, sticky="ew", pady=2)
        
        # Botões de ação
        button_frame = ttk.Frame(form_frame)
        button_frame.grid(row=6, column=0, columnspan=2, pady=20)
        
        ttk.Button(button_frame, text="Salvar Template", 
                  command=self.save_template).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(button_frame, text="Usar Template", 
                  command=self.use_template).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(button_frame, text="Excluir", 
                  command=self.delete_template).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(button_frame, text="Limpar", 
                  command=self.clear_form).pack(side=tk.LEFT)
        
        # Configurar grid
        form_frame.columnconfigure(1, weight=1)
        
        # Carregar templates
        self.load_templates_list()
    
    def load_templates_list(self):
        """Carrega lista de templates"""
        # Limpar lista
        for item in self.templates_tree.get_children():
            self.templates_tree.delete(item)
        
        # Adicionar templates
        for template in self.templates:
            self.templates_tree.insert('', 'end', values=(
                template.get('name', ''),
                template.get('platform', ''),
                f"{template.get('duration', 60)} min"
            ))
    
    def on_template_select(self, event):
        """Quando um template é selecionado"""
        selection = self.templates_tree.selection()
        if selection:
            item = self.templates_tree.item(selection[0])
            template_name = item['values'][0]
            
            # Encontrar template
            template = next((t for t in self.templates if t.get('name') == template_name), None)
            if template:
                self.load_template_to_form(template)
    
    def load_template_to_form(self, template):
        """Carrega template no formulário"""
        self.name_var.set(template.get('name', ''))
        self.title_var.set(template.get('title', ''))
        self.duration_var.set(str(template.get('duration', 60)))
        self.platform_var.set(template.get('platform', 'google_meet'))
        self.timezone_var.set(template.get('timezone', 'America/Sao_Paulo'))
        
        # Limpar e inserir descrição
        self.description_text.delete(1.0, tk.END)
        self.description_text.insert(1.0, template.get('description', ''))
    
    def save_template(self):
        """Salva template"""
        name = self.name_var.get().strip()
        title = self.title_var.get().strip()
        duration = self.duration_var.get().strip()
        
        if not name or not title or not duration:
            messagebox.showwarning("Aviso", "Preencha todos os campos obrigatórios!")
            return
        
        try:
            duration = int(duration)
        except ValueError:
            messagebox.showerror("Erro", "Duração deve ser um número!")
            return
        
        # Criar template
        template = {
            'name': name,
            'title': title,
            'duration': duration,
            'platform': self.platform_var.get(),
            'timezone': self.timezone_var.get(),
            'description': self.description_text.get(1.0, tk.END).strip()
        }
        
        # Verificar se já existe
        existing_index = next((i for i, t in enumerate(self.templates) 
                             if t.get('name') == name), None)
        
        if existing_index is not None:
            # Atualizar existente
            self.templates[existing_index] = template
            messagebox.showinfo("Sucesso", f"Template '{name}' atualizado!")
        else:
            # Adicionar novo
            self.templates.append(template)
            messagebox.showinfo("Sucesso", f"Template '{name}' criado!")
        
        # Salvar e recarregar
        self.save_templates()
        self.load_templates_list()
        self.clear_form()
    
    def use_template(self):
        """Usa template para criar reunião"""
        selection = self.templates_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione um template!")
            return
        
        item = self.templates_tree.item(selection[0])
        template_name = item['values'][0]
        
        # Encontrar template
        template = next((t for t in self.templates if t.get('name') == template_name), None)
        if template:
            # Aplicar template na janela de reunião
            if hasattr(self.parent, 'apply_template'):
                self.parent.apply_template(template)
                self.destroy()
            else:
                messagebox.showinfo("Template", f"Template '{template_name}' selecionado!\n"
                                   f"Título: {template.get('title')}\n"
                                   f"Duração: {template.get('duration')} min\n"
                                   f"Plataforma: {template.get('platform')}")
    
    def delete_template(self):
        """Exclui template selecionado"""
        selection = self.templates_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione um template!")
            return
        
        item = self.templates_tree.item(selection[0])
        template_name = item['values'][0]
        
        if messagebox.askyesno("Confirmar", f"Excluir template '{template_name}'?"):
            # Remover template
            self.templates = [t for t in self.templates if t.get('name') != template_name]
            self.save_templates()
            self.load_templates_list()
            self.clear_form()
            messagebox.showinfo("Sucesso", f"Template '{template_name}' excluído!")
    
    def clear_form(self):
        """Limpa formulário"""
        self.name_var.set('')
        self.title_var.set('')
        self.duration_var.set('60')
        self.platform_var.set('google_meet')
        self.timezone_var.set('America/Sao_Paulo')
        self.description_text.delete(1.0, tk.END)


# Sistema de Chat em Tempo Real Integrado ao PostgreSQL
class ChatSystem:
    """Sistema de chat em tempo real integrado ao PostgreSQL"""
    
    def __init__(self, app):
        self.app = app
        self.chat_windows = {}  # Janelas de chat por projeto
        self.comment_windows = {}  # Janelas de comentários por cartão
        self.current_user_id = getattr(self.app.current_user, 'id', None)
        self.update_interval = 2000  # Atualizar a cada 2 segundos
        self.update_timer = None
        self.chat_data = {}  # Dados de chat por projeto/quadro
        
        # Inicializar sistema de atualização em tempo real
        self.start_realtime_updates()
    
    def start_realtime_updates(self):
        """Inicia o sistema de atualizações em tempo real"""
        if self.update_timer:
            self.app.root.after_cancel(self.update_timer)
        self.update_timer = self.app.root.after(self.update_interval, self.update_realtime_data)
    
    def update_realtime_data(self):
        """Atualiza dados em tempo real"""
        try:
            # Atualizar notificações
            self.update_notifications()
            
            # Atualizar janelas de chat abertas
            for chat_window in self.chat_windows.values():
                if hasattr(chat_window, 'update_messages'):
                    chat_window.update_messages()
            
            # Agendar próxima atualização
            self.update_timer = self.app.root.after(self.update_interval, self.update_realtime_data)
        except Exception as e:
            print(f"Erro na atualização em tempo real: {e}")
            # Tentar novamente em 5 segundos
            self.update_timer = self.app.root.after(5000, self.update_realtime_data)
    
    def update_notifications(self):
        """Atualiza notificações não lidas"""
        try:
            if self.current_user_id:
                unread_notifications = self.app.db.get_unread_notifications(self.current_user_id)
                if unread_notifications:
                    # Atualizar indicador de notificações na interface
                    self.update_notification_badge(len(unread_notifications))
        except Exception as e:
            print(f"Erro ao atualizar notificações: {e}")
    
    def update_notification_badge(self, count):
        """Atualiza o badge de notificações na interface"""
        try:
            # Implementar atualização do badge de notificações
            pass
        except Exception as e:
            print(f"Erro ao atualizar badge: {e}")
    
    def get_board_names(self):
        """Retorna a lista de nomes dos quadros"""
        try:
            if hasattr(self.app, 'boodesk_data') and 'boards' in self.app.boodesk_data:
                return list(self.app.boodesk_data['boards'].keys())
            else:
                return []
        except Exception as e:
            print(f"Erro ao obter nomes dos quadros: {e}")
            return []
    
    def create_or_get_board_chat(self, board_name):
        """Cria ou obtém o chat de um quadro"""
        try:
            # Buscar board_id pelo nome
            boards = self.app.db.get_boards()
            board_id = None
            for board in boards:
                if board['name'] == board_name:
                    board_id = board['id']
                    break
            
            if not board_id:
                print(f"❌ Quadro '{board_name}' não encontrado")
                return None
            
            # Verificar se já existe chat para este quadro
            chat = self.app.db.get_board_chat(board_id)
            if chat:
                return chat
            
            # Criar novo chat para o quadro
            chat_id = self.app.db.create_chat(
                name=f"Chat - {board_name}",
                chat_type='board',
                created_by=self.current_user_id,
                board_id=board_id
            )
            
            if chat_id:
                # Adicionar todos os membros do quadro ao chat
                self.add_board_members_to_chat(chat_id, board_name)
                return self.app.db.get_chat_by_id(chat_id)
            
            return None
        except Exception as e:
            print(f"Erro ao criar/obter chat do quadro: {e}")
            return None
    
    def create_or_get_card_chat(self, card_id, card_title):
        """Cria ou obtém o chat de um cartão"""
        try:
            # Verificar se já existe chat para este cartão
            chat = self.app.db.get_card_chat(card_id)
            if chat:
                return chat
            
            # Criar novo chat para o cartão
            chat_id = self.app.db.create_chat(
                name=f"Chat - {card_title}",
                chat_type='card',
                created_by=self.current_user_id,
                card_id=card_id
            )
            
            if chat_id:
                return self.app.db.get_chat_by_id(chat_id)
            
            return None
        except Exception as e:
            print(f"Erro ao criar/obter chat do cartão: {e}")
            return None
    
    def add_board_members_to_chat(self, chat_id, board_name):
        """Adiciona membros do quadro ao chat"""
        try:
            # Buscar membros do quadro
            if board_name in self.app.boodesk_data.get('boards', {}):
                board_data = self.app.boodesk_data['boards'][board_name]
                members = board_data.get('members', [])
                
                for member in members:
                    # Buscar user_id pelo username
                    users = self.app.db.get_all_users()
                    for user in users:
                        if user['username'] == member:
                            self.app.db.add_chat_participant(chat_id, user['id'])
                            break
        except Exception as e:
            print(f"Erro ao adicionar membros ao chat: {e}")
    
    def send_message_to_chat(self, chat_id, message):
        """Envia mensagem para um chat"""
        try:
            if not self.current_user_id:
                print("❌ Usuário não identificado")
                return False
            
            message_id = self.app.db.send_message(
                chat_id=chat_id,
                sender_id=self.current_user_id,
                message=message
            )
            
            if message_id:
                print(f"✅ Mensagem enviada com ID: {message_id}")
                return True
            else:
                print("❌ Erro ao enviar mensagem")
                return False
        except Exception as e:
            print(f"Erro ao enviar mensagem: {e}")
            return False
    
    def open_project_chat(self, project_name):
        """Abre chat específico para um projeto/quadro na interface principal"""
        try:
            # Criar ou obter chat do quadro
            chat = self.create_or_get_board_chat(project_name)
            if not chat:
                messagebox.showerror("Erro", f"Não foi possível abrir o chat do quadro '{project_name}'")
                return
            
            # Carregar chat na interface principal
            if hasattr(self.app, 'load_chat_in_main_interface'):
                self.app.load_chat_in_main_interface(chat, f"Chat - {project_name}")
            else:
                # Fallback: mostrar mensagem de erro
                messagebox.showerror("Erro", "Interface de chat não disponível")
                
        except Exception as e:
            print(f"Erro ao abrir chat do projeto: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir chat: {str(e)}")
    
    def open_card_comments(self, card_id, card_title):
        """Abre comentários de um cartão específico na interface principal"""
        try:
            # Criar ou obter chat do cartão
            chat = self.create_or_get_card_chat(card_id, card_title)
            if not chat:
                messagebox.showerror("Erro", f"Não foi possível abrir o chat do cartão '{card_title}'")
                return
            
            # Carregar chat na interface principal
            if hasattr(self.app, 'load_chat_in_main_interface'):
                self.app.load_chat_in_main_interface(chat, f"Comentários - {card_title}")
            else:
                # Fallback: mostrar mensagem de erro
                messagebox.showerror("Erro", "Interface de chat não disponível")
                
        except Exception as e:
            print(f"Erro ao abrir comentários do cartão: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir comentários: {str(e)}")
    
    def open_direct_chat(self, target_user_id, target_username):
        """Abre chat direto com outro usuário na interface principal"""
        try:
            # Verificar se já existe chat direto
            user_chats = self.app.db.get_chats_by_user(self.current_user_id)
            direct_chat = None
            
            for chat in user_chats:
                if chat['chat_type'] == 'direct':
                    participants = self.app.db.get_chat_participants(chat['id'])
                    if len(participants) == 2:
                        participant_ids = [p['user_id'] for p in participants]
                        if self.current_user_id in participant_ids and target_user_id in participant_ids:
                            direct_chat = chat
                            break
            
            if not direct_chat:
                # Criar novo chat direto
                chat_id = self.app.db.create_chat(
                    name=f"Chat com {target_username}",
                    chat_type='direct',
                    created_by=self.current_user_id
                )
                
                if chat_id:
                    # Adicionar ambos os usuários como participantes
                    self.app.db.add_chat_participant(chat_id, self.current_user_id)
                    self.app.db.add_chat_participant(chat_id, target_user_id)
                    direct_chat = self.app.db.get_chat_by_id(chat_id)
            
            if direct_chat:
                # Carregar chat na interface principal
                if hasattr(self.app, 'load_chat_in_main_interface'):
                    self.app.load_chat_in_main_interface(direct_chat, f"Chat com {target_username}")
                else:
                    # Fallback: mostrar mensagem de erro
                    messagebox.showerror("Erro", "Interface de chat não disponível")
            else:
                messagebox.showerror("Erro", "Não foi possível criar o chat direto")
                
        except Exception as e:
            print(f"Erro ao abrir chat direto: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir chat direto: {str(e)}")
    
    def get_user_chats(self):
        """Retorna todos os chats do usuário atual"""
        try:
            if self.current_user_id:
                return self.app.db.get_chats_by_user(self.current_user_id)
            return []
        except Exception as e:
            print(f"Erro ao obter chats do usuário: {e}")
            return []
    
    def get_chat_messages(self, chat_id, limit=50):
        """Retorna mensagens de um chat"""
        try:
            return self.app.db.get_chat_messages(chat_id, limit=limit)
        except Exception as e:
            print(f"Erro ao obter mensagens do chat: {e}")
            return []
    
    def mark_chat_as_read(self, chat_id):
        """Marca mensagens de um chat como lidas"""
        try:
            if self.current_user_id:
                return self.app.db.mark_messages_as_read(chat_id, self.current_user_id)
            return False
        except Exception as e:
            print(f"Erro ao marcar chat como lido: {e}")
            return False
    
    def add_chat_message(self, chat_id, message):
        """Adiciona mensagem ao chat"""
        try:
            if not self.current_user_id:
                print("❌ Usuário não identificado")
                return False
            
            # Processar menções (@usuario)
            processed_message, mentions = self.process_mentions(message)
            
            # Enviar mensagem para o banco
            message_id = self.app.db.send_message(
                chat_id=chat_id,
                sender_id=self.current_user_id,
                message=processed_message
            )
            
            if message_id:
                # Notificar usuários mencionados
                self.notify_mentions(mentions, chat_id, message_id)
                
                # Atualizar janelas de chat abertas
                self.update_chat_windows(chat_id)
                
                return True
            else:
                print("❌ Erro ao enviar mensagem")
                return False
                
        except Exception as e:
            print(f"Erro ao adicionar mensagem: {e}")
            return False

    def send_message(self, chat_id, sender_id, message):
        """Envia mensagem ao chat (compatibilidade)"""
        try:
            # Usar o current_user_id da sessão se sender_id não for fornecido
            if not sender_id:
                sender_id = self.current_user_id
            
            if not sender_id:
                print("❌ Usuário não identificado")
                return False
            
            # Enviar mensagem para o banco
            message_id = self.app.db.send_message(
                chat_id=chat_id,
                sender_id=sender_id,
                message=message
            )
            
            if message_id:
                # Atualizar janelas de chat abertas
                self.update_chat_windows(chat_id)
                return True
            else:
                print("❌ Erro ao enviar mensagem")
                return False
                
        except Exception as e:
            print(f"Erro ao enviar mensagem: {e}")
            return False
    
    def update_chat_windows(self, chat_id):
        """Atualiza janelas de chat abertas"""
        try:
            for window in self.chat_windows.values():
                if hasattr(window, 'chat_id') and window.chat_id == chat_id:
                    if hasattr(window, 'update_messages'):
                        window.update_messages()
        except Exception as e:
            print(f"Erro ao atualizar janelas de chat: {e}")
    
    def add_card_comment(self, card_id, comment):
        """Adiciona comentário a um cartão"""
        try:
            if not self.current_user_id:
                print("❌ Usuário não identificado")
                return False
            
            # Buscar ou criar chat do cartão
            card_title = f"Cartão {card_id}"
            chat = self.create_or_get_card_chat(card_id, card_title)
            
            if not chat:
                print("❌ Não foi possível criar/obter chat do cartão")
                return False
            
            # Processar menções (@usuario)
            processed_comment, mentions = self.process_mentions(comment)
            
            # Enviar comentário como mensagem no chat do cartão
            message_id = self.app.db.send_message(
                chat_id=chat['id'],
                sender_id=self.current_user_id,
                message=processed_comment
            )
            
            if message_id:
                # Notificar usuários mencionados
                self.notify_mentions(mentions, chat['id'], message_id)
                
                # Atualizar janelas de comentários abertas
                if card_id in self.comment_windows:
                    self.comment_windows[card_id].update_messages()
                
                return True
            else:
                print("❌ Erro ao enviar comentário")
                return False
                
        except Exception as e:
            print(f"Erro ao adicionar comentário: {e}")
            return False
    
    def process_mentions(self, text):
        """Processa menções @usuario no texto"""
        mentions = []
        processed_text = text
        
        # Encontrar menções @usuario
        import re
        mention_pattern = r'@(\w+)'
        matches = re.findall(mention_pattern, text)
        
        for match in matches:
            mentions.append(match)
            # Destacar menção no texto
            processed_text = processed_text.replace(f'@{match}', f'@{match}')
        
        return processed_text, mentions
    
    def notify_mentions(self, mentions, chat_id, message_id):
        """Notifica usuários mencionados"""
        try:
            for mention in mentions:
                # Buscar user_id pelo username
                users = self.app.db.get_all_users()
                mentioned_user_id = None
                
                for user in users:
                    if user['username'].lower() == mention.lower():
                        mentioned_user_id = user['id']
                        break
                
                if mentioned_user_id:
                    # Criar notificação específica para menção
                    self.app.db.execute_with_retry(lambda conn: conn.execute("""
                        INSERT INTO chat_notifications (user_id, chat_id, message_id, notification_type, created_at)
                        VALUES (%s, %s, %s, 'mention', %s)
                    """, (mentioned_user_id, chat_id, message_id, datetime.now())))
                    
                    print(f"✅ Notificação de menção enviada para @{mention}")
        except Exception as e:
            print(f"Erro ao notificar menções: {e}")
    
    def search_chat_history(self, chat_id, search_term):
        """Busca no histórico de chat"""
        try:
            messages = self.app.db.get_chat_messages(chat_id, limit=1000)
            results = []
            search_term = search_term.lower()
            
            for message in messages:
                if (search_term in message['message'].lower() or 
                    search_term in message['username'].lower()):
                    results.append(message)
            
            return results
        except Exception as e:
            print(f"Erro na busca do histórico: {e}")
            return []
    
    def get_chat_participants(self, chat_id):
        """Retorna participantes de um chat"""
        try:
            return self.app.db.get_chat_participants(chat_id)
        except Exception as e:
            print(f"Erro ao obter participantes: {e}")
            return []
    
    def add_participant_to_chat(self, chat_id, username):
        """Adiciona participante a um chat"""
        try:
            # Buscar user_id pelo username
            users = self.app.db.get_all_users()
            user_id = None
            
            for user in users:
                if user['username'] == username:
                    user_id = user['id']
                    break
            
            if user_id:
                return self.app.db.add_chat_participant(chat_id, user_id)
            else:
                print(f"❌ Usuário '{username}' não encontrado")
                return False
        except Exception as e:
            print(f"Erro ao adicionar participante: {e}")
            return False
    
    def remove_participant_from_chat(self, chat_id, username):
        """Remove participante de um chat"""
        try:
            # Buscar user_id pelo username
            users = self.app.db.get_all_users()
            user_id = None
            
            for user in users:
                if user['username'] == username:
                    user_id = user['id']
                    break
            
            if user_id:
                return self.app.db.remove_chat_participant(chat_id, user_id)
            else:
                print(f"❌ Usuário '{username}' não encontrado")
                return False
        except Exception as e:
            print(f"Erro ao remover participante: {e}")
            return False
    
    def search_comment_history(self, card_id, search_term):
        """Busca no histórico de comentários"""
        try:
            # Buscar chat do cartão
            card_title = f"Cartão {card_id}"
            chat = self.create_or_get_card_chat(card_id, card_title)
            
            if chat:
                return self.search_chat_history(chat['id'], search_term)
            return []
        except Exception as e:
            print(f"Erro na busca do histórico de comentários: {e}")
            return []
    
    def get_user_chats(self):
        """Retorna todos os chats do usuário atual"""
        try:
            if self.current_user_id:
                return self.app.db.get_chats_by_user(self.current_user_id)
            return []
        except Exception as e:
            print(f"Erro ao obter chats do usuário: {e}")
            return []
    
    def get_chat_messages(self, chat_id):
        """Retorna mensagens de um chat específico"""
        try:
            messages = self.app.db.get_chat_messages(chat_id)
            
            # Adicionar informações do remetente
            for message in messages:
                sender_id = message.get('sender_id')
                if sender_id:
                    users = self.app.db.get_all_users()
                    for user in users:
                        if user['id'] == sender_id:
                            message['sender_name'] = user['username']
                            break
                    else:
                        message['sender_name'] = 'Desconhecido'
                else:
                    message['sender_name'] = 'Sistema'
            
            return messages
        except Exception as e:
            print(f"Erro ao obter mensagens do chat: {e}")
            return []
    
    def get_unread_notifications(self):
        """Retorna notificações não lidas do usuário atual"""
        try:
            if self.current_user_id:
                notifications = self.app.db.get_unread_notifications(self.current_user_id)
                
                # Adicionar informações adicionais
                for notification in notifications:
                    # Buscar informações do chat
                    chat = self.app.db.get_chat_by_id(notification.get('chat_id'))
                    if chat:
                        notification['chat_name'] = chat['name']
                    
                    # Buscar informações do remetente
                    message = self.app.db.get_message_by_id(notification.get('message_id'))
                    if message:
                        sender_id = message.get('sender_id')
                        if sender_id:
                            users = self.app.db.get_all_users()
                            for user in users:
                                if user['id'] == sender_id:
                                    notification['sender_name'] = user['username']
                                    notification['message'] = message.get('message', 'Nova mensagem')
                                    break
                            else:
                                notification['sender_name'] = 'Desconhecido'
                                notification['message'] = message.get('message', 'Nova mensagem')
                        else:
                            notification['sender_name'] = 'Sistema'
                            notification['message'] = message.get('message', 'Nova mensagem')
                
                return notifications
            return []
        except Exception as e:
            print(f"Erro ao obter notificações: {e}")
            return []

    def get_or_create_direct_chat(self, target_user_id):
        """Obtém ou cria um chat direto com o usuário especificado"""
        try:
            # Verificar se já existe chat direto
            user_chats = self.app.db.get_chats_by_user(self.current_user_id)
            direct_chat = None
            
            for chat in user_chats:
                if chat['chat_type'] == 'direct':
                    participants = self.app.db.get_chat_participants(chat['id'])
                    if len(participants) == 2:
                        participant_ids = [p['user_id'] for p in participants]
                        if self.current_user_id in participant_ids and target_user_id in participant_ids:
                            direct_chat = chat
                            break
            
            if not direct_chat:
                # Buscar username do usuário alvo
                users = self.app.db.get_all_users()
                target_username = "Usuário"
                for user in users:
                    if user['id'] == target_user_id:
                        target_username = user['username']
                        break
                
                # Criar novo chat direto
                chat_id = self.app.db.create_chat(
                    name=f"Chat com {target_username}",
                    chat_type='direct',
                    created_by=self.current_user_id
                )
                
                if chat_id:
                    # Adicionar ambos os usuários como participantes
                    self.app.db.add_chat_participant(chat_id, self.current_user_id)
                    self.app.db.add_chat_participant(chat_id, target_user_id)
                    direct_chat = self.app.db.get_chat_by_id(chat_id)
            
            return direct_chat
        except Exception as e:
            print(f"Erro ao obter/criar chat direto: {e}")
            return None


# ============================================================================
# JANELAS DE CHAT
# ============================================================================

class BoardChatWindow:
    """Janela de chat para quadros/projetos"""
    
    def __init__(self, app, board_name, chat):
        self.app = app
        self.board_name = board_name
        self.chat = chat
        self.chat_id = chat['id']
        self.current_user_id = getattr(self.app.current_user, 'id', None)
        
        # Criar janela
        self.window = tk.Toplevel(self.app.root)
        self.window.title(f"Chat - {board_name}")
        self.window.geometry("600x500")
        self.window.resizable(True, True)
        
        # Configurar ícone
        if hasattr(self.app, 'icons') and self.app.icons.get('chat_icon'):
            self.window.iconphoto(False, self.app.icons['chat_icon'])
        
        # Marcar mensagens como lidas
        self.app.chat_system.mark_chat_as_read(self.chat_id)
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        self.load_messages()
        
        # Configurar protocolo de fechamento
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def create_widgets(self):
        """Cria os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Cabeçalho
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(header_frame, text=f"Chat do Quadro: {self.board_name}", 
                 font=("Arial", 12, "bold")).pack(side=tk.LEFT)
        
        # Botão de participantes
        ttk.Button(header_frame, text="👥 Participantes", 
                  command=self.show_participants).pack(side=tk.RIGHT)
        
        # Frame de mensagens
        messages_frame = ttk.Frame(main_frame)
        messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Área de mensagens com scrollbar
        messages_container = ttk.Frame(messages_frame)
        messages_container.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(messages_container)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de mensagens
        self.messages_text = tk.Text(messages_container, wrap=tk.WORD, 
                                   yscrollcommand=scrollbar.set, state=tk.DISABLED)
        self.messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.messages_text.yview)
        
        # Frame de entrada
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de mensagem
        self.message_entry = ttk.Entry(input_frame)
        self.message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.message_entry.bind("<Return>", self.send_message)
        
        # Botão enviar
        ttk.Button(input_frame, text="Enviar", command=self.send_message).pack(side=tk.RIGHT)
        
        # Botão de busca
        ttk.Button(input_frame, text="🔍 Buscar", command=self.search_messages).pack(side=tk.RIGHT, padx=(0, 10))
    
    def load_messages(self):
        """Carrega mensagens do chat"""
        try:
            messages = self.app.chat_system.get_chat_messages(self.chat_id, limit=50)
            self.display_messages(messages)
        except Exception as e:
            print(f"Erro ao carregar mensagens: {e}")
    
    def display_messages(self, messages):
        """Exibe mensagens na interface"""
        self.messages_text.config(state=tk.NORMAL)
        self.messages_text.delete(1.0, tk.END)
        
        for message in reversed(messages):  # Ordem cronológica
            timestamp = message['created_at']
            if isinstance(timestamp, str):
                timestamp = timestamp
            else:
                timestamp = timestamp.strftime('%d/%m/%Y %H:%M')
            
            username = message['username']
            text = message['message']
            
            # Formatar mensagem
            formatted_message = f"[{timestamp}] {username}: {text}\n\n"
            
            self.messages_text.insert(tk.END, formatted_message)
        
        self.messages_text.config(state=tk.DISABLED)
        self.messages_text.see(tk.END)
    
    def send_message(self, event=None):
        """Envia mensagem"""
        message = self.message_entry.get().strip()
        if message:
            if self.app.chat_system.add_chat_message(self.chat_id, message):
                self.message_entry.delete(0, tk.END)
                self.load_messages()  # Recarregar mensagens
            else:
                messagebox.showerror("Erro", "Não foi possível enviar a mensagem")
    
    def update_messages(self):
        """Atualiza mensagens (chamado pelo sistema de tempo real)"""
        self.load_messages()
    
    def search_messages(self):
        """Abre diálogo de busca"""
        search_term = simpledialog.askstring("Buscar Mensagens", "Digite o termo de busca:")
        if search_term:
            results = self.app.chat_system.search_chat_history(self.chat_id, search_term)
            if results:
                self.display_messages(results)
            else:
                messagebox.showinfo("Busca", "Nenhuma mensagem encontrada.")
    
    def show_participants(self):
        """Mostra lista de participantes"""
        participants = self.app.chat_system.get_chat_participants(self.chat_id)
        
        if participants:
            participant_list = "\n".join([f"• {p['username']} ({p['role']})" for p in participants])
            messagebox.showinfo("Participantes", f"Participantes do chat:\n\n{participant_list}")
        else:
            messagebox.showinfo("Participantes", "Nenhum participante encontrado.")
    
    def on_closing(self):
        """Chamado quando a janela é fechada"""
        # Remover da lista de janelas abertas
        if self.board_name in self.app.chat_system.chat_windows:
            del self.app.chat_system.chat_windows[self.board_name]
        self.window.destroy()


class CardCommentsWindow:
    """Janela de comentários para cartões"""
    
    def __init__(self, app, card_id, card_title, chat):
        self.app = app
        self.card_id = card_id
        self.card_title = card_title
        self.chat = chat
        self.chat_id = chat['id']
        self.current_user_id = getattr(self.app.current_user, 'id', None)
        
        # Criar janela
        self.window = tk.Toplevel(self.app.root)
        self.window.title(f"Comentários - {card_title}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Configurar ícone
        if hasattr(self.app, 'icons') and self.app.icons.get('comment_icon'):
            self.window.iconphoto(False, self.app.icons['comment_icon'])
        
        # Marcar mensagens como lidas
        self.app.chat_system.mark_chat_as_read(self.chat_id)
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        self.load_messages()
        
        # Configurar protocolo de fechamento
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def create_widgets(self):
        """Cria os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Cabeçalho
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(header_frame, text=f"Comentários: {self.card_title}", 
                 font=("Arial", 12, "bold")).pack(side=tk.LEFT)
        
        # Frame de mensagens
        messages_frame = ttk.Frame(main_frame)
        messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Área de mensagens com scrollbar
        messages_container = ttk.Frame(messages_frame)
        messages_container.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(messages_container)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de mensagens
        self.messages_text = tk.Text(messages_container, wrap=tk.WORD, 
                                   yscrollcommand=scrollbar.set, state=tk.DISABLED)
        self.messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.messages_text.yview)
        
        # Frame de entrada
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de comentário
        self.comment_entry = ttk.Entry(input_frame)
        self.comment_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.comment_entry.bind("<Return>", self.add_comment)
        
        # Botão enviar
        ttk.Button(input_frame, text="Comentar", command=self.add_comment).pack(side=tk.RIGHT)
    
    def load_messages(self):
        """Carrega comentários do cartão"""
        try:
            messages = self.app.chat_system.get_chat_messages(self.chat_id, limit=50)
            self.display_messages(messages)
        except Exception as e:
            print(f"Erro ao carregar comentários: {e}")
    
    def display_messages(self, messages):
        """Exibe comentários na interface"""
        self.messages_text.config(state=tk.NORMAL)
        self.messages_text.delete(1.0, tk.END)
        
        for message in reversed(messages):  # Ordem cronológica
            timestamp = message['created_at']
            if isinstance(timestamp, str):
                timestamp = timestamp
            else:
                timestamp = timestamp.strftime('%d/%m/%Y %H:%M')
            
            username = message['username']
            text = message['message']
            
            # Formatar comentário
            formatted_comment = f"[{timestamp}] {username}: {text}\n\n"
            
            self.messages_text.insert(tk.END, formatted_comment)
        
        self.messages_text.config(state=tk.DISABLED)
        self.messages_text.see(tk.END)
    
    def add_comment(self, event=None):
        """Adiciona comentário"""
        comment = self.comment_entry.get().strip()
        if comment:
            if self.app.chat_system.add_card_comment(self.card_id, comment):
                self.comment_entry.delete(0, tk.END)
                self.load_messages()  # Recarregar comentários
            else:
                messagebox.showerror("Erro", "Não foi possível adicionar o comentário")
    
    def update_messages(self):
        """Atualiza comentários (chamado pelo sistema de tempo real)"""
        self.load_messages()
    
    def on_closing(self):
        """Chamado quando a janela é fechada"""
        # Remover da lista de janelas abertas
        if self.card_id in self.app.chat_system.comment_windows:
            del self.app.chat_system.comment_windows[self.card_id]
        self.window.destroy()


class DirectChatWindow:
    """Janela de chat direto entre usuários"""
    
    def __init__(self, app, target_user_id, target_username, chat):
        self.app = app
        self.target_user_id = target_user_id
        self.target_username = target_username
        self.chat = chat
        self.chat_id = chat['id']
        self.current_user_id = getattr(self.app.current_user, 'id', None)
        
        # Criar janela
        self.window = tk.Toplevel(self.app.root)
        self.window.title(f"Chat com {target_username}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Configurar ícone
        if hasattr(self.app, 'icons') and self.app.icons.get('chat_icon'):
            self.window.iconphoto(False, self.app.icons['chat_icon'])
        
        # Marcar mensagens como lidas
        self.app.chat_system.mark_chat_as_read(self.chat_id)
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        self.load_messages()
        
        # Configurar protocolo de fechamento
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def create_widgets(self):
        """Cria os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Cabeçalho
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(header_frame, text=f"Chat com {self.target_username}", 
                 font=("Arial", 12, "bold")).pack(side=tk.LEFT)
        
        # Frame de mensagens
        messages_frame = ttk.Frame(main_frame)
        messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Área de mensagens com scrollbar
        messages_container = ttk.Frame(messages_frame)
        messages_container.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(messages_container)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de mensagens
        self.messages_text = tk.Text(messages_container, wrap=tk.WORD, 
                                   yscrollcommand=scrollbar.set, state=tk.DISABLED)
        self.messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.messages_text.yview)
        
        # Frame de entrada
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de mensagem
        self.message_entry = ttk.Entry(input_frame)
        self.message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.message_entry.bind("<Return>", self.send_message)
        
        # Botão enviar
        ttk.Button(input_frame, text="Enviar", command=self.send_message).pack(side=tk.RIGHT)
    
    def load_messages(self):
        """Carrega mensagens do chat direto"""
        try:
            messages = self.app.chat_system.get_chat_messages(self.chat_id, limit=50)
            self.display_messages(messages)
        except Exception as e:
            print(f"Erro ao carregar mensagens: {e}")
    
    def display_messages(self, messages):
        """Exibe mensagens na interface"""
        self.messages_text.config(state=tk.NORMAL)
        self.messages_text.delete(1.0, tk.END)
        
        for message in reversed(messages):  # Ordem cronológica
            timestamp = message['created_at']
            if isinstance(timestamp, str):
                timestamp = timestamp
            else:
                timestamp = timestamp.strftime('%d/%m/%Y %H:%M')
            
            username = message['username']
            text = message['message']
            
            # Formatar mensagem
            formatted_message = f"[{timestamp}] {username}: {text}\n\n"
            
            self.messages_text.insert(tk.END, formatted_message)
        
        self.messages_text.config(state=tk.DISABLED)
        self.messages_text.see(tk.END)
    
    def send_message(self, event=None):
        """Envia mensagem"""
        message = self.message_entry.get().strip()
        if message:
            if self.app.chat_system.add_chat_message(self.chat_id, message):
                self.message_entry.delete(0, tk.END)
                self.load_messages()  # Recarregar mensagens
            else:
                messagebox.showerror("Erro", "Não foi possível enviar a mensagem")
    
    def update_messages(self):
        """Atualiza mensagens (chamado pelo sistema de tempo real)"""
        self.load_messages()
    
    def on_closing(self):
        """Chamado quando a janela é fechada"""
        # Remover da lista de janelas abertas
        chat_key = f"direct_{self.target_user_id}"
        if chat_key in self.app.chat_system.chat_windows:
            del self.app.chat_system.chat_windows[chat_key]
        self.window.destroy()
class ProjectChatWindow:
    """Janela de chat para projeto específico"""
    
    def __init__(self, app, project_name):
        self.app = app
        self.project_name = project_name
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(app.root)
        self.window.title(f"Chat - {project_name}")
        self.window.geometry("600x500")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(app.root)
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        self.load_messages()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text=f"Chat - {self.project_name}", 
                 font=("Arial", 14, "bold")).pack(side=tk.LEFT)
        
        # Botões de ação
        ttk.Button(title_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.open_search).pack(side=tk.RIGHT, padx=5)
        ttk.Button(title_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.load_messages).pack(side=tk.RIGHT, padx=5)
        
        # Frame para mensagens
        messages_frame = ttk.LabelFrame(main_frame, text="Mensagens", padding="10")
        messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Text widget para mensagens
        self.messages_text = tk.Text(messages_frame, wrap=tk.WORD, state=tk.DISABLED)
        self.messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(messages_frame, orient="vertical", command=self.messages_text.yview)
        self.messages_text.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Frame para entrada de mensagem
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de entrada
        self.message_var = tk.StringVar()
        self.message_entry = ttk.Entry(input_frame, textvariable=self.message_var, font=("Arial", 10))
        self.message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.message_entry.bind("<Return>", self.send_message)
        self.message_entry.bind("<KeyRelease>", self.update_char_count)
        
        # Contador de caracteres
        self.char_count_label = ttk.Label(input_frame, text="0/1000", font=("Arial", 8), foreground="gray")
        self.char_count_label.pack(side=tk.LEFT, padx=(0, 10))
        
        # Botão enviar
        ttk.Button(input_frame, text="Enviar", image=self.icons.get('forward_icon'), compound=tk.LEFT,
                  command=self.send_message).pack(side=tk.RIGHT)
        
        # Focar no campo de entrada
        self.message_entry.focus()
    
    def load_messages(self):
        """Carrega mensagens do chat"""
        self.messages_text.config(state=tk.NORMAL)
        self.messages_text.delete(1.0, tk.END)
        
        if self.project_name in self.app.chat_system.chat_data:
            for message in self.app.chat_system.chat_data[self.project_name]:
                self.display_message(message)
        
        self.messages_text.config(state=tk.DISABLED)
        self.messages_text.see(tk.END)
    
    def display_message(self, message):
        """Exibe uma mensagem no chat"""
        self.messages_text.config(state=tk.NORMAL)
        
        # Formatar mensagem
        timestamp = message['timestamp']
        username = message['username']
        text = message['message']
        
        # Adicionar timestamp
        self.messages_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
        
        # Adicionar username
        self.messages_text.insert(tk.END, f"{username}: ", "username")
        
        # Adicionar mensagem
        self.messages_text.insert(tk.END, f"{text}\n", "message")
        
        self.messages_text.config(state=tk.DISABLED)
        
        # Configurar tags para formatação
        self.messages_text.tag_config("timestamp", foreground="gray")
        self.messages_text.tag_config("username", foreground="blue", font=("Arial", 10, "bold"))
        self.messages_text.tag_config("message", font=("Arial", 10))
    
    def send_message(self, event=None):
        """Envia mensagem"""
        message = self.message_var.get().strip()
        if not message:
            return
        
        # Verificar limite de caracteres (1000 caracteres)
        MAX_MESSAGE_LENGTH = 1000
        if len(message) > MAX_MESSAGE_LENGTH:
            messagebox.showwarning("Limite Excedido", 
                                 f"A mensagem deve ter no máximo {MAX_MESSAGE_LENGTH} caracteres.\n"
                                 f"Sua mensagem tem {len(message)} caracteres.")
            return
        
        # Verificar se há usuário logado
        if not hasattr(self.app, 'current_user') or not self.app.current_user:
            messagebox.showwarning("Aviso", "Você precisa estar logado para enviar mensagens!")
            return
        
        username = self.app.current_user.username
        
        # Adicionar mensagem ao sistema de chat
        self.app.chat_system.add_chat_message(self.project_name, username, message)
        
        # Limpar campo de entrada
        self.message_var.set("")
        
        # Focar novamente no campo
        self.message_entry.focus()
    
    def add_message(self, message):
        """Adiciona nova mensagem à janela"""
        self.display_message(message)
        self.messages_text.see(tk.END)
    
    def update_char_count(self, event=None):
        """Atualiza contador de caracteres"""
        current_length = len(self.message_var.get())
        max_length = 1000
        
        # Atualizar contador
        self.char_count_label.config(text=f"{current_length}/{max_length}")
        
        # Mudar cor baseado no limite
        if current_length > max_length * 0.9:  # 90% do limite
            self.char_count_label.config(foreground="orange")
        elif current_length > max_length:
            self.char_count_label.config(foreground="red")
        else:
            self.char_count_label.config(foreground="gray")
    
    def open_search(self):
        """Abre janela de busca"""
        ChatSearchWindow(self.window, self.app, self.project_name)


class CardCommentsWindow:
    """Janela de comentários para cartão específico"""
    
    def __init__(self, app, card_id, card_title):
        self.app = app
        self.card_id = card_id
        self.card_title = card_title
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(app.root)
        self.window.title(f"Comentários - {card_title}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(app.root)
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        self.load_comments()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text=f"Comentários - {self.card_title}", 
                 font=("Arial", 12, "bold")).pack(side=tk.LEFT)
        
        # Botões de ação
        ttk.Button(title_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.open_search).pack(side=tk.RIGHT, padx=5)
        ttk.Button(title_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.load_comments).pack(side=tk.RIGHT, padx=5)
        
        # Frame para comentários
        comments_frame = ttk.LabelFrame(main_frame, text="Comentários", padding="10")
        comments_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Text widget para comentários
        self.comments_text = tk.Text(comments_frame, wrap=tk.WORD, state=tk.DISABLED)
        self.comments_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(comments_frame, orient="vertical", command=self.comments_text.yview)
        self.comments_text.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Frame para entrada de comentário
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de entrada
        self.comment_var = tk.StringVar()
        self.comment_entry = ttk.Entry(input_frame, textvariable=self.comment_var, font=("Arial", 10))
        self.comment_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.comment_entry.bind("<Return>", self.send_comment)
        self.comment_entry.bind("<KeyRelease>", self.update_comment_char_count)
        
        # Contador de caracteres
        self.comment_char_count_label = ttk.Label(input_frame, text="0/500", font=("Arial", 8), foreground="gray")
        self.comment_char_count_label.pack(side=tk.LEFT, padx=(0, 10))
        
        # Botão enviar
        ttk.Button(input_frame, text="Comentar", image=self.icons.get('add_icon'), compound=tk.LEFT,
                  command=self.send_comment).pack(side=tk.RIGHT)
        
        # Focar no campo de entrada
        self.comment_entry.focus()
    
    def load_comments(self):
        """Carrega comentários do cartão"""
        self.comments_text.config(state=tk.NORMAL)
        self.comments_text.delete(1.0, tk.END)
        
        if self.card_id in self.app.chat_system.comment_data:
            for comment in self.app.chat_system.comment_data[self.card_id]:
                self.display_comment(comment)
        
        self.comments_text.config(state=tk.DISABLED)
        self.comments_text.see(tk.END)
    
    def display_comment(self, comment):
        """Exibe um comentário"""
        self.comments_text.config(state=tk.NORMAL)
        
        # Formatar comentário
        timestamp = comment['timestamp']
        username = comment['username']
        text = comment['comment']
        
        # Adicionar timestamp
        self.comments_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
        
        # Adicionar username
        self.comments_text.insert(tk.END, f"{username}: ", "username")
        
        # Adicionar comentário
        self.comments_text.insert(tk.END, f"{text}\n", "comment")
        
        self.comments_text.config(state=tk.DISABLED)
        
        # Configurar tags para formatação
        self.comments_text.tag_config("timestamp", foreground="gray")
        self.comments_text.tag_config("username", foreground="green", font=("Arial", 10, "bold"))
        self.comments_text.tag_config("comment", font=("Arial", 10))
    
    def send_comment(self, event=None):
        """Envia comentário"""
        comment = self.comment_var.get().strip()
        if not comment:
            return
        
        # Verificar limite de caracteres (500 caracteres para comentários)
        MAX_COMMENT_LENGTH = 500
        if len(comment) > MAX_COMMENT_LENGTH:
            messagebox.showwarning("Limite Excedido", 
                                 f"O comentário deve ter no máximo {MAX_COMMENT_LENGTH} caracteres.\n"
                                 f"Seu comentário tem {len(comment)} caracteres.")
            return
        
        # Verificar se há usuário logado
        if not hasattr(self.app, 'current_user') or not self.app.current_user:
            messagebox.showwarning("Aviso", "Você precisa estar logado para comentar!")
            return
        
        username = self.app.current_user.username
        
        # Adicionar comentário ao sistema
        self.app.chat_system.add_card_comment(self.card_id, username, comment)
        
        # Limpar campo de entrada
        self.comment_var.set("")
        
        # Focar novamente no campo
        self.comment_entry.focus()
        
        # Limpar campo de entrada
        self.comment_var.set("")
        
        # Focar novamente no campo
        self.comment_entry.focus()
    
    def update_comment_char_count(self, event=None):
        """Atualiza contador de caracteres do comentário"""
        current_length = len(self.comment_var.get())
        max_length = 500
        
        # Atualizar contador
        self.comment_char_count_label.config(text=f"{current_length}/{max_length}")
        
        # Mudar cor baseado no limite
        if current_length > max_length * 0.9:  # 90% do limite
            self.comment_char_count_label.config(foreground="orange")
        elif current_length > max_length:
            self.comment_char_count_label.config(foreground="red")
        else:
            self.comment_char_count_label.config(foreground="gray")
    
    def add_comment(self, comment):
        """Adiciona novo comentário à janela"""
        self.display_comment(comment)
        self.comments_text.see(tk.END)
    
    def open_search(self):
        """Abre janela de busca"""
        CommentSearchWindow(self.window, self.app, self.card_id)


class ChatSearchWindow:
    """Janela de busca no histórico de chat"""
    
    def __init__(self, parent, app, project_name):
        self.parent = parent
        self.app = app
        self.project_name = project_name
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title(f"Buscar no Chat - {project_name}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        ttk.Label(main_frame, text=f"Buscar no Chat - {self.project_name}", 
                 font=("Arial", 12, "bold")).pack(pady=(0, 10))
        
        # Frame de busca
        search_frame = ttk.Frame(main_frame)
        search_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(search_frame, text="Termo de busca:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.search_var = tk.StringVar()
        self.search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=30)
        self.search_entry.pack(side=tk.LEFT, padx=(0, 10))
        self.search_entry.bind("<Return>", self.perform_search)
        
        ttk.Button(search_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.perform_search).pack(side=tk.LEFT)
        
        # Frame para resultados
        results_frame = ttk.LabelFrame(main_frame, text="Resultados", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Treeview para resultados
        columns = ("Data", "Usuário", "Mensagem")
        self.results_tree = ttk.Treeview(results_frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.results_tree.heading(col, text=col)
            self.results_tree.column(col, width=150, anchor="w")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=self.results_tree.yview)
        self.results_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.results_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Botões
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X)
        
        ttk.Button(buttons_frame, text="Limpar", image=self.icons.get('clear_icon'), compound=tk.LEFT,
                  command=self.clear_results).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(buttons_frame, text="Fechar", image=self.icons.get('cancel_icon'), compound=tk.LEFT,
                  command=self.window.destroy).pack(side=tk.RIGHT)
        
        # Focar no campo de busca
        self.search_entry.focus()
    
    def perform_search(self, event=None):
        """Executa a busca"""
        search_term = self.search_var.get().strip()
        if not search_term:
            messagebox.showwarning("Aviso", "Digite um termo para buscar!")
            return
        
        # Limpar resultados anteriores
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        
        # Realizar busca
        results = self.app.chat_system.search_chat_history(self.project_name, search_term)
        
        # Exibir resultados
        for result in results:
            self.results_tree.insert("", "end", values=(
                result['timestamp'],
                result['username'],
                result['message'][:50] + "..." if len(result['message']) > 50 else result['message']
            ))
        
        # Mostrar quantidade de resultados
        messagebox.showinfo("Busca Concluída", f"Encontrados {len(results)} resultados para '{search_term}'")
    
    def clear_results(self):
        """Limpa resultados da busca"""
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        self.search_var.set("")
        self.search_entry.focus()


class CommentSearchWindow:
    """Janela de busca no histórico de comentários"""
    
    def __init__(self, parent, app, card_id):
        self.parent = parent
        self.app = app
        self.card_id = card_id
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title(f"Buscar Comentários - Cartão {card_id}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        ttk.Label(main_frame, text=f"Buscar Comentários - Cartão {self.card_id}", 
                 font=("Arial", 12, "bold")).pack(pady=(0, 10))
        
        # Frame de busca
        search_frame = ttk.Frame(main_frame)
        search_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(search_frame, text="Termo de busca:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.search_var = tk.StringVar()
        self.search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=30)
        self.search_entry.pack(side=tk.LEFT, padx=(0, 10))
        self.search_entry.bind("<Return>", self.perform_search)
        
        ttk.Button(search_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.perform_search).pack(side=tk.LEFT)
        
        # Frame para resultados
        results_frame = ttk.LabelFrame(main_frame, text="Resultados", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Treeview para resultados
        columns = ("Data", "Usuário", "Comentário")
        self.results_tree = ttk.Treeview(results_frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.results_tree.heading(col, text=col)
            self.results_tree.column(col, width=150, anchor="w")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=self.results_tree.yview)
        self.results_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.results_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Botões
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X)
        
        ttk.Button(buttons_frame, text="Limpar", image=self.icons.get('clear_icon'), compound=tk.LEFT,
                  command=self.clear_results).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(buttons_frame, text="Fechar", image=self.icons.get('cancel_icon'), compound=tk.LEFT,
                  command=self.window.destroy).pack(side=tk.RIGHT)
        
        # Focar no campo de busca
        self.search_entry.focus()
    
    def perform_search(self, event=None):
        """Executa a busca"""
        search_term = self.search_var.get().strip()
        if not search_term:
            messagebox.showwarning("Aviso", "Digite um termo para buscar!")
            return
        
        # Limpar resultados anteriores
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        
        # Realizar busca
        results = self.app.chat_system.search_comment_history(self.card_id, search_term)
        
        # Exibir resultados
        for result in results:
            self.results_tree.insert("", "end", values=(
                result['timestamp'],
                result['username'],
                result['comment'][:50] + "..." if len(result['comment']) > 50 else result['comment']
            ))
        
        # Mostrar quantidade de resultados
        messagebox.showinfo("Busca Concluída", f"Encontrados {len(results)} resultados para '{search_term}'")
    
    def clear_results(self):
        """Limpa resultados da busca"""
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        self.search_var.set("")
        self.search_entry.focus()



    def safe_notebook_add(self, notebook, window, text=None):
        """Adiciona uma janela ao notebook de forma segura"""
        try:
            if text is None:
                text = getattr(window, 'winfo_name', lambda: "Tab")()
            notebook.add(window, text=text)
            return True
        except Exception as e:
            print(f"⚠️ Erro ao adicionar ao notebook: {e}")
            try:
                notebook.add(window, text="Tab")
                return True
            except:
                print(f"❌ Falha ao adicionar ao notebook: {e}")
                return False


    def safe_tkinter_operation(self, operation, *args, **kwargs):
        """Executa operações Tkinter de forma segura"""
        try:
            return operation(*args, **kwargs)
        except Exception as e:
            print(f"⚠️ Erro em operação Tkinter: {e}")
            return None
    
    def safe_widget_config(self, widget, **kwargs):
        """Configura widget de forma segura"""
        try:
            if widget and widget.winfo_exists():
                widget.config(**kwargs)
                return True
        except Exception as e:
            print(f"⚠️ Erro ao configurar widget: {e}")
        return False
    
    def safe_widget_pack(self, widget, **kwargs):
        """Faz pack de widget de forma segura"""
        try:
            if widget and widget.winfo_exists():
                widget.pack(**kwargs)
                return True
        except Exception as e:
            print(f"⚠️ Erro ao fazer pack do widget: {e}")
        return False

class BoodeskApp:
    def on_main_tab_drag_start(self, event):
        try:
            tab_index = self.main_notebook.index(f"@{event.x},{event.y}")
            if tab_index == 0: # Prevent dragging the first tab (Menu Principal)
                return
            if tab_index != "":
                self._drag_data["item"] = self.main_notebook.tabs()[tab_index]
                self._drag_data["tab_index"] = tab_index
        except tk.TclError:
            pass

    def on_main_tab_drag_motion(self, event):
        if self._drag_data["item"]:
            pass # Visual feedback can be added here if needed

    def on_main_tab_drag_release(self, event):
        if self._drag_data["item"]:
            try:
                new_tab_index = self.main_notebook.index(f"@{event.x},{event.y}")
                if new_tab_index == "":
                    new_tab_index = len(self.main_notebook.tabs()) - 1
                if new_tab_index == 0: # Prevent dropping onto the first tab
                    new_tab_index = 1 # or revert

                old_tab_index = self._drag_data["tab_index"]

                if old_tab_index != new_tab_index:
                    self.main_notebook.insert(new_tab_index, self.main_notebook.tabs()[old_tab_index])
            except tk.TclError:
                pass # Invalid drop target
            finally:
                self._drag_data = {"item": None, "x": 0, "y": 0, "tab_index": -1}

    def __init__(self, root, current_user, icons):
        print("DEBUG: Iniciando BoodeskApp.__init__")
        self.root = root
        self.current_user = current_user
        self.icons = icons # Store icons
        self.app = self # For compatibility with the LoginWindow
        
        # Initialize database
        self.db = Database('postgresql')
        
        # Tentar criar tabelas, se falhar, fazer limpeza forçada
        try:
            self.db.create_tables()
            self.db.migrate_json_to_relational()
        except Exception as e:
            print(f"Erro ao criar tabelas: {e}")
            # Ignorar erros de tabelas opcionais
            if "bank_accounts" in str(e) or "historico_deploys" in str(e):
                print("⚠️ Tabelas opcionais não encontradas, continuando...")
            else:
                print("Tentando limpeza forçada do banco...")
                self.db.force_cleanup()
                try:
                    self.db.create_tables()
                except Exception as e2:
                    print(f"Erro persistente: {e2}")
                    print("Resetando banco de dados...")
                    self.db.reset_database()

        # --- File Paths ---
        if getattr(sys, 'frozen', False):
            # Running as a PyInstaller bundle
            self.base_dir = sys._MEIPASS
        else:
            # Running as a normal script
            self.base_dir = os.path.dirname(os.path.abspath(__file__))
        sep = os.path.sep

        self.settings_file = f"{self.base_dir}{sep}pomodoro_settings.json"
        # self.data_file = f"{self.base_dir}{sep}boodesk_data.json"  # Removido - usando apenas banco de dados
        # self.messages_file = f"{self.base_dir}{sep}pomodoro_motivational_messages.json"  # Removido - usando apenas dados em memória

        self.load_settings()
        print("DEBUG: load_settings concluído")
        self.load_trello_data()
        print("DEBUG: load_trello_data concluído")
        
        # Verificar métodos do banco de dados
        print("DEBUG: Verificando métodos do banco de dados...")
        try:
            self.check_database_methods()
        except AttributeError:
            print("DEBUG: Método check_database_methods não encontrado, pulando verificação")
        print("DEBUG: Verificação de métodos concluída")
        
        # Verificar consistência dos cards após carregar dados
        print("DEBUG: Iniciando verificação de consistência dos cards...")
        try:
            self.verify_card_consistency()
        except AttributeError:
            print("DEBUG: Método verify_card_consistency não encontrado, pulando verificação")
        print("DEBUG: Verificação de consistência concluída")
        
        self.load_pomodoro_data()
        print("DEBUG: load_pomodoro_data concluído")
        try:
            self.load_aux_data()
        except Exception as e:
            print(f"⚠️ Erro ao carregar dados auxiliares: {e}")
            # Usar dados padrão
            self.messages = ["Bem-vindo ao Boodesk!", "Foco total!", "Você consegue!"]
        print("DEBUG: load_aux_data concluído")
        self.load_members()
        print("DEBUG: load_members concluído")
        
        # Inicializar sistema de upload completo (Supabase + Cloudflare R2)
        if SISTEMA_UPLOAD_DISPONIVEL:
            try:
                # Configurações do Supabase (já configuradas)
                supabase_url = os.getenv("SUPABASE_URL", "https://your-project.supabase.co")
                supabase_key = os.getenv("SUPABASE_ANON_KEY", "your-anon-key")
                
                # Inicializar sistema de upload
                self.sistema_upload = SistemaUploadCompleto(supabase_url, supabase_key)
                print("✅ Sistema de upload completo inicializado (Supabase + Cloudflare R2)")
            except Exception as e:
                print(f"⚠️ Erro ao inicializar sistema de upload: {e}")
                self.sistema_upload = None
        else:
            self.sistema_upload = None
            print("⚠️ Sistema de upload completo não disponível")
        self.load_categories()
        print("DEBUG: load_categories concluído")

        # Set the application icon
        if self.icons.get('logo_icon'):
            self.root.iconphoto(False, self.icons['logo_icon'])

        # --- User Management ---
        self.user_management = UserManagement()
        
        # --- Timer State ---
        self.timer_running = False
        self.current_cycle = 0
        self.on_break = False
        self.timer_id = None
        self.time_left = 0
        self.active_pomodoro_task = None

        self.listbox_refs = {}
        self.current_chart_type = "income_vs_expense" # Default chart type

        # --- Integrations ---
        # Email Integration
        self.email_integration = EmailIntegration(self)
        
        # Google Calendar Integration
        self.google_calendar = GoogleCalendarIntegration(self)
        # Calendar Event Manager (PostgreSQL)
        try:
            from calendar_manager import CalendarEventManager
            self.calendar_manager = CalendarEventManager(self.db.connection)
            print("✅ CalendarEventManager inicializado com sucesso")
        except ImportError as e:
            print(f"⚠️ CalendarEventManager não disponível: {e}")
            self.calendar_manager = None
        except Exception as e:
            print(f"❌ Erro ao inicializar CalendarEventManager: {e}")
            self.calendar_manager = None
        
        
        # Email Template Manager
        self.email_template_manager = EmailTemplateManager(self)
        
        # --- Chat System ---
        self.chat_system = ChatSystem(self)
        
        # --- Meeting Integration ---
        self.meeting_integration = MeetingIntegration(self)
        
        # --- Notification Manager ---
        self.notification_manager = NotificationManager(self)
        
        # Garantir que self.settings seja um dicionário antes de usar
        print(f"DEBUG: Tipo de self.settings: {type(self.settings)}")
        if not isinstance(self.settings, dict):
            print("DEBUG: self.settings não é um dicionário, usando padrões")
            self.settings = self.get_default_settings()
        print(f"DEBUG: Tipo de self.settings após correção: {type(self.settings)}")
        
        # Converter valores JSON string para dicionários
        self._fix_json_strings_in_settings()
        
        # Start integrations if enabled
        email_integration = self.settings.get('email_integration', {})
        if isinstance(email_integration, dict) and email_integration.get('enabled', False):
            self.email_integration.start_email_service()
        
        # Initialize Google Calendar if enabled
        google_calendar = self.settings.get('google_calendar', {})
        if isinstance(google_calendar, dict) and google_calendar.get('enabled', False):
            print("DEBUG: Inicializando integração com Google Calendar")
            # A autenticação será feita quando necessário

    def _safe_json_loads(self, json_string, default_value=None):
        if default_value is None:
            default_value = []
        if not isinstance(json_string, str) or not json_string.strip():
            return default_value
        try:
            return json.loads(json_string)
        except json.JSONDecodeError as e:
            print(f"Alerta de JSON inválido: {e} - String: '{json_string[:100]}...'")
            # Tentar corrigir barras invertidas e tentar novamente
            try:
                corrected_string = json_string.replace('\\', '\\\\')
                return json.loads(corrected_string)
            except json.JSONDecodeError as e2:
                print(f"Falha ao corrigir JSON: {e2} - String: '{corrected_string[:100]}...'")
                return default_value

    
    def get_current_executable_path(self):
        """Obtém o caminho do executável atual"""
        try:
            # Se for executável, usar sys.executable
            if getattr(sys, 'frozen', False):
                return sys.executable
            
            # Se for script Python, procurar por BoodeskApp.exe no diretório
            app_dir = self.get_app_directory()
            possible_paths = [
                os.path.join(app_dir, "BoodeskApp.exe"),
                os.path.join(app_dir, "app23a.py"),
                os.path.join(os.getcwd(), "BoodeskApp.exe"),
                os.path.join(os.getcwd(), "app23a.py")
            ]
            
            for path in possible_paths:
                if os.path.exists(path):
                    return path
            
            return None
        except:
            return None
    
    def get_app_directory(self):
        """Obtém o diretório onde o aplicativo está sendo executado"""
        try:
            # Se for executável, usar o diretório do executável
            if getattr(sys, 'frozen', False):
                return os.path.dirname(sys.executable)
            # Se for script Python, usar o diretório do script
            else:
                return os.path.dirname(os.path.abspath(__file__))
        except:
            return os.getcwd()
    
    
    def get_user_python_path(self):
        """Obtém o caminho do Python do usuário"""
        try:
            # Tentar usar o Python atual
            if hasattr(sys, 'executable') and sys.executable:
                return sys.executable
            
            # Tentar encontrar Python no PATH
            import subprocess
            result = subprocess.run(['python', '--version'], 
                                  capture_output=True, text=True, shell=True)
            if result.returncode == 0:
                return 'python'
            
            # Tentar python3
            result = subprocess.run(['python3', '--version'], 
                                  capture_output=True, text=True, shell=True)
            if result.returncode == 0:
                return 'python3'
                
        except:
            pass
        
        # Fallback para python
        return 'python'
    
    def get_download_directory(self):
        """Obtém o diretório de download configurado ou usa Desktop/Boodesk como padrão"""
        try:
            print("🔍 Iniciando get_download_directory...")
            # Tentar obter configuração do banco de dados
            if hasattr(self, 'db') and self.db:
                conn = self.db.get_connection()
                if conn:
                    cursor = conn.cursor()
                    cursor.execute("""
                        SELECT download_directory FROM user_preferences 
                        WHERE user_id = %s
                    """, (self.get_current_user_id(),))
                    result = cursor.fetchone()
                    if result and result[0]:
                        download_dir = result[0]
                        # Se o diretório configurado não tem a pasta Boodesk, adicionar
                        if not download_dir.endswith("Boodesk"):
                            download_dir = os.path.join(download_dir, "Boodesk")
                        if os.path.exists(download_dir):
                            print(f"✅ Usando diretório configurado: {download_dir}")
                            return download_dir
                        else:
                            print(f"⚠️ Diretório configurado não existe: {download_dir}")
            
            # Se não há configuração ou diretório não existe, usar Desktop/Boodesk como padrão
            # 1. Usar Desktop do usuário (caminho padrão)
            desktop_dir = os.path.expanduser("~/Desktop")
            if os.access(desktop_dir, os.W_OK):
                print(f"✅ Usando Desktop padrão: {desktop_dir}")
                return desktop_dir
            
            # 2. Tentar diretório do executável atual (se válido)
            current_exe = os.path.abspath(sys.argv[0])
            if current_exe and os.path.exists(current_exe):
                exe_dir = os.path.dirname(current_exe)
                # Verificar se é um diretório válido (não Python da Microsoft Store)
                if not "WindowsApps" in exe_dir and os.access(exe_dir, os.W_OK):
                    return exe_dir
            
            # 3. Tentar diretório de trabalho atual
            current_dir = os.getcwd()
            if os.access(current_dir, os.W_OK):
                return current_dir
            
            # 4. Usar diretório de documentos do usuário
            documents_dir = os.path.expanduser("~/Documents")
            if os.access(documents_dir, os.W_OK):
                print(f"✅ Usando Documents padrão: {documents_dir}")
                return documents_dir
            
            # 5. Último recurso: diretório temporário
            import tempfile
            temp_dir = tempfile.gettempdir()
            print(f"✅ Usando diretório temporário: {temp_dir}")
            return temp_dir
            
        except Exception as e:
            print(f"⚠️ Erro ao obter diretório de download: {e}")
            # Fallback para Desktop
            try:
                desktop_dir = os.path.expanduser("~/Desktop")
                if os.access(desktop_dir, os.W_OK):
                    print(f"✅ Usando Desktop como fallback: {desktop_dir}")
                    return desktop_dir
            except:
                pass
            # Último fallback para diretório atual
            current_dir = os.getcwd()
            print(f"✅ Usando diretório atual como fallback: {current_dir}")
            return current_dir

    def set_download_directory(self, directory):
        """Define o diretório de download para o usuário atual"""
        try:
            if not os.path.exists(directory):
                os.makedirs(directory, exist_ok=True)
            
            if not os.access(directory, os.W_OK):
                raise Exception(f"Sem permissão de escrita no diretório: {directory}")
            
            # Salvar no banco de dados
            if hasattr(self, 'db') and self.db:
                conn = self.db.get_connection()
                if conn:
                    cursor = conn.cursor()
                    cursor.execute("""
                        INSERT INTO user_preferences (user_id, download_directory, created_at)
                        VALUES (%s, %s, NOW())
                        ON CONFLICT (user_id) 
                        DO UPDATE SET download_directory = EXCLUDED.download_directory, updated_at = NOW()
                    """, (self.get_current_user_id(), directory))
                    conn.commit()
                    print(f"✅ Diretório de download configurado: {directory}")
                    return True
            
            return False
            
        except Exception as e:
            print(f"❌ Erro ao configurar diretório de download: {e}")
            return False
    def _fix_json_strings_in_settings(self):
        """Converte valores JSON string para dicionários no settings"""
        import json
        
        for key, value in self.settings.items():
            if isinstance(value, str) and value.startswith('{') and value.endswith('}'):
                try:
                    self.settings[key] = json.loads(value)
                    print(f"DEBUG: Convertido {key} de string para dicionário")
                except:
                    pass  # Manter como string se não for JSON válido

        # self.create_menu() será chamado após a definição dos métodos
        
        # Aplicar permissões baseadas no usuário atual (só se houver usuário)
        if hasattr(self, 'current_user') and self.current_user:
            self.apply_role_permissions()
        print("DEBUG: Chamando create_widgets")
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        print("DEBUG: create_widgets concluído")
        if self.current_user:
            self.apply_role_permissions()
        
        # Iniciar sistema de notificações
        self.notification_manager.start_notification_monitor()
        
        # Criar templates padrão se não existirem
        try:
            self.db.create_default_templates()
            print("DEBUG: Templates padrão verificados/criados")
        except Exception as e:
            print(f"Erro ao criar templates padrão: {e}")
        
        # Criar widget de reuniões se habilitado
        if self.notification_manager.notification_settings['show_widget']:
            # O widget será criado quando o menu principal for criado
            pass

        # Migrar subtarefas do JSON para o banco de dados (se necessário)
        print("DEBUG: Iniciando migração de subtarefas...")
        self.migrate_subtasks_to_database()
        print("DEBUG: Migração de subtarefas concluída")

    def configure_download_directory(self):
        """Permite ao usuário configurar o diretório de download"""
        try:
            import tkinter.filedialog as filedialog
            
            current_dir = self.get_download_directory()
            
            # Abrir diálogo para selecionar diretório
            new_dir = filedialog.askdirectory(
                title="Selecionar Diretório de Download",
                initialdir=current_dir
            )
            
            if new_dir:
                if self.set_download_directory(new_dir):
                    messagebox.showinfo("Sucesso", f"Diretório de download configurado:\n{new_dir}")
                    self.update_download_dir_label()
                else:
                    messagebox.showerror("Erro", "Não foi possível configurar o diretório de download")
            
        except Exception as e:
            print(f"❌ Erro ao configurar diretório: {e}")
            messagebox.showerror("Erro", f"Erro ao configurar diretório: {e}")

    def update_download_dir_label(self):
        """Atualiza o label mostrando o diretório de download atual"""
        try:
            if hasattr(self, 'download_dir_label'):
                current_dir = self.get_download_directory()
                # Mostrar apenas o nome do diretório ou caminho abreviado
                if len(current_dir) > 40:
                    display_dir = "..." + current_dir[-37:]
                else:
                    display_dir = current_dir
                self.download_dir_label.config(text=f"📁 {display_dir}")
        except Exception as e:
            print(f"⚠️ Erro ao atualizar label: {e}")



    def parse_brazilian_date(self, date_str):
        """Converte data brasileira (DD/MM/YYYY) para datetime ou vice-versa"""
        if not date_str:
            return None
            
        try:
            # Se já é um objeto datetime, retorna ele mesmo
            if isinstance(date_str, datetime):
                return date_str
                
            # Tentar formato brasileiro primeiro: DD/MM/YYYY
            try:
                return datetime.strptime(date_str, "%d/%m/%Y")
            except ValueError:
                pass
                
            # Tentar formato brasileiro com hora: DD/MM/YYYY HH:MM
            try:
                return datetime.strptime(date_str, "%d/%m/%Y %H:%M")
            except ValueError:
                pass
                
            # Tentar formato brasileiro com hora e segundos: DD/MM/YYYY HH:MM:SS
            try:
                return datetime.strptime(date_str, "%d/%m/%Y %H:%M:%S")
            except ValueError:
                pass
                
            # Tentar formato americano: YYYY-MM-DD
            try:
                return datetime.strptime(date_str, "%Y-%m-%d")
            except ValueError:
                pass
                
            # Tentar formato americano com hora: YYYY-MM-DD HH:MM
            try:
                return datetime.strptime(date_str, "%Y-%m-%d %H:%M")
            except ValueError:
                pass
                
            # Tentar formato americano com hora e segundos: YYYY-MM-DD HH:MM:SS
            try:
                return datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
            except ValueError:
                pass
                
            print(f"Formato de data não reconhecido: {date_str}")
            return None
            
        except Exception as e:
            print(f"Erro ao processar data: {date_str} - {e}")
            return None

    def get_board_id_by_name(self, board_name):
        """Get board ID by name from SQL database"""
        try:
            if hasattr(self, 'db') and self.db:
                try:
                    # Para administradores, buscar todos os quadros
                    if hasattr(self, 'current_user') and getattr(self.current_user, 'role', None) in ['admin', 'Administrador']:
                        boards = self.db.get_boards()  # Sem user_id para buscar todos
                    else:
                        # Para usuários normais, filtrar por user_id
                        user_id = self.get_current_user_id()
                        boards = self.db.get_boards(user_id)
                    
                    if isinstance(boards, list):
                        for board in boards:
                            if isinstance(board, dict) and board.get('name') == board_name:
                                # Retornar board_id (UUID) em vez de id (inteiro)
                                board_id = board.get('board_id')
                                if board_id:
                                    print(f"DEBUG: Encontrado board_id {board_id} para quadro '{board_name}'")
                                    return board_id
                                else:
                                    print(f"DEBUG: board_id não encontrado para quadro '{board_name}'")
                                    return None
                    else:
                        print(f"DEBUG: get_boards retornou {type(boards)} em vez de lista")
                except Exception as db_error:
                    print(f"DEBUG: Erro ao acessar banco de dados: {db_error}")
            # Fallback: buscar quadro pelo nome usando método específico
            print(f"DEBUG: Tentando buscar quadro '{board_name}' pelo nome...")
            board_data = self.db.get_board_by_name(board_name)
            if board_data and board_data.get('board_id'):
                print(f"DEBUG: Encontrado board_id {board_data['board_id']} via get_board_by_name")
                return board_data['board_id']
            
            print(f"DEBUG: Quadro '{board_name}' não encontrado no banco")
            return None
        except Exception as e:
            print(f"Erro ao buscar board: {e}")
            return None
    
    def get_board_id_by_name_safe(self, board_name):
        """Versão segura do get_board_id_by_name que sempre retorna um valor"""
        try:
            board_id = self.get_board_id_by_name(board_name)
            if board_id:
                return board_id
            else:
                print(f"DEBUG: get_board_id_by_name retornou None para '{board_name}'")
                return None
        except Exception as e:
            print(f"DEBUG: Erro no get_board_id_by_name_safe: {e}")
            return None
    
    def __getattr__(self, name):
        """Fallback para métodos não encontrados"""
        if name == 'get_board_id_by_name':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda board_name: None  # Retorna None em vez de 1
        elif name == 'get_board_id_by_name_safe':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda board_name: None  # Retorna None em vez de 1
        elif name == 'time_left':
            print(f"DEBUG: Atributo {name} não encontrado, inicializando com 0")
            self.time_left = 0
            return 0
        elif name == 'timer_running':
            print(f"DEBUG: Atributo {name} não encontrado, inicializando com False")
            self.timer_running = False
            return False
        elif name == 'current_cycle':
            print(f"DEBUG: Atributo {name} não encontrado, inicializando com 0")
            self.current_cycle = 0
            return 0
        elif name == 'on_break':
            print(f"DEBUG: Atributo {name} não encontrado, inicializando com False")
            self.on_break = False
            return False
        elif name == 'timer_id':
            print(f"DEBUG: Atributo {name} não encontrado, inicializando com None")
            self.timer_id = None
            return None
        elif name == 'active_pomodoro_task':
            print(f"DEBUG: Atributo {name} não encontrado, inicializando com None")
            self.active_pomodoro_task = None
            return None
        elif name == 'pomodoro_timer_label':
            print(f"DEBUG: Widget {name} não encontrado, retornando None")
            return None
        elif name == 'timer_label':
            print(f"DEBUG: Widget {name} não encontrado, retornando None")
            return None
        elif name == 'pomodoro_frame':
            print(f"DEBUG: Widget {name} não encontrado, retornando None")
            return None
        elif name == 'timer_frame':
            print(f"DEBUG: Widget {name} não encontrado, retornando None")
            return None
        elif name == 'create_finance_dashboard_enterprise':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda parent: self._create_finance_dashboard_fallback(parent)
        elif name == 'create_enterprise_metric_card':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda parent, title, value, color, row, col: self._create_metric_card_fallback(parent, title, value, color, row, col)
        elif name == 'refresh_enterprise_dashboard':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._refresh_dashboard_fallback()
        elif name == 'show_enterprise_chart':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda chart_type: self._show_chart_fallback(chart_type)
        elif name == 'update_enterprise_alerts':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._update_alerts_fallback()
        elif name == 'create_clients_management_tab':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda parent: self._create_clients_tab_fallback(parent)
        elif name == 'save_client':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._save_client_fallback()
        elif name == 'clear_client_form':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._clear_client_form_fallback()
        elif name == 'load_clients':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._load_clients_fallback()
        elif name == 'on_client_select':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda event: self._on_client_select_fallback(event)
        elif name == 'delete_client':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._delete_client_fallback()
        elif name == 'open_new_client_window':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._open_new_client_window_fallback()
        elif name == 'create_suppliers_management_tab':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda parent: self._create_suppliers_tab_fallback(parent)
        elif name == 'create_receivables_management_tab':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda parent: self._create_receivables_tab_fallback(parent)
        elif name == 'open_new_receivable_window':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._open_new_receivable_window_fallback()
        elif name == 'load_receivables':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._load_receivables_fallback()
        elif name == 'filter_receivables':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._filter_receivables_fallback()
        elif name == 'on_receivable_select':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda event: self._on_receivable_select_fallback(event)
        elif name == 'delete_receivable':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._delete_receivable_fallback()
        elif name == 'open_new_payable_window':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._open_new_payable_window_fallback()
        elif name == 'load_payables':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._load_payables_fallback()
        elif name == 'filter_payables':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._filter_payables_fallback()
        elif name == 'on_payable_select':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda event: self._on_payable_select_fallback(event)
        elif name == 'delete_payable':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda: self._delete_payable_fallback()
        elif name == 'create_payables_management_tab':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda parent: self._create_payables_tab_fallback(parent)
        elif name == 'create_invoices_management_tab':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda parent: self._create_invoices_tab_fallback(parent)
        elif name == 'create_cashflow_management_tab':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda parent: self._create_cashflow_tab_fallback(parent)
        elif name == 'create_budgets_management_tab':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda parent: self._create_budgets_tab_fallback(parent)
        elif name == 'create_enterprise_reports_tab':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda parent: self._create_reports_tab_fallback(parent)
        elif name == 'create_finance_config_tab':
            print(f"DEBUG: Método {name} não encontrado, usando fallback")
            return lambda parent: self._create_config_tab_fallback(parent)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    # Métodos de fallback para o sistema financeiro empresarial
    def _create_finance_dashboard_fallback(self, parent):
        """Fallback para o dashboard financeiro"""
        ttk.Label(parent, text="🏢 Dashboard Financeiro - Carregando...", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _create_metric_card_fallback(self, parent, title, value, color, row, col):
        """Fallback para cards de métricas"""
        pass
    
    def _refresh_dashboard_fallback(self):
        """Fallback para atualizar dashboard"""
        pass
    
    def _show_chart_fallback(self, chart_type):
        """Fallback para mostrar gráficos"""
        messagebox.showinfo("Aviso", f"Gráfico {chart_type} - Em desenvolvimento")
    
    def _update_alerts_fallback(self):
        """Fallback para atualizar alertas"""
        pass
    
    def _create_clients_tab_fallback(self, parent):
        """Fallback para aba de clientes"""
        ttk.Label(parent, text="👥 Gestão de Clientes - Carregando...", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _save_client_fallback(self):
        """Fallback para salvar cliente"""
        messagebox.showinfo("Aviso", "Funcionalidade em desenvolvimento")
    
    def _clear_client_form_fallback(self):
        """Fallback para limpar formulário"""
        pass
    
    def _load_clients_fallback(self):
        """Fallback para carregar clientes"""
        pass
    
    def _on_client_select_fallback(self, event):
        """Fallback para seleção de cliente"""
        pass
    
    def _delete_client_fallback(self):
        """Fallback para deletar cliente"""
        messagebox.showinfo("Aviso", "Funcionalidade em desenvolvimento")
    
    def _open_new_client_window_fallback(self):
        """Fallback para nova janela de cliente"""
        pass
    
    def _create_suppliers_tab_fallback(self, parent):
        """Fallback para aba de fornecedores"""
        ttk.Label(parent, text="🏭 Gestão de Fornecedores - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _create_receivables_tab_fallback(self, parent):
        """Fallback para aba de contas a receber"""
        # Frame principal
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text="📥 Contas a Receber", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        # Botões de ação
        buttons_frame = ttk.Frame(title_frame)
        buttons_frame.pack(side=tk.RIGHT)
        
        ttk.Button(buttons_frame, text="➕ Nova Conta", 
                  command=self.open_new_receivable_window).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(buttons_frame, text="🔄 Atualizar", 
                  command=self.load_receivables).pack(side=tk.LEFT, padx=5)
        
        # Frame para filtros
        filters_frame = ttk.LabelFrame(main_frame, text="Filtros", padding="10")
        filters_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Filtros
        ttk.Label(filters_frame, text="Status:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.receivable_status_filter = ttk.Combobox(filters_frame, 
                                                   values=["Todos", "Pendente", "Pago", "Vencido", "Cancelado"],
                                                   state="readonly", width=15)
        self.receivable_status_filter.set("Todos")
        self.receivable_status_filter.grid(row=0, column=1, sticky="w", padx=5, pady=2)
        self.receivable_status_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_receivables())
        
        ttk.Label(filters_frame, text="Cliente:").grid(row=0, column=2, sticky="w", padx=5, pady=2)
        self.receivable_client_filter = ttk.Combobox(filters_frame, state="readonly", width=20)
        self.receivable_client_filter.grid(row=0, column=3, sticky="w", padx=5, pady=2)
        self.receivable_client_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_receivables())
        
        ttk.Label(filters_frame, text="Vencimento:").grid(row=0, column=4, sticky="w", padx=5, pady=2)
        self.receivable_due_filter = ttk.Combobox(filters_frame, 
                                                values=["Todos", "Hoje", "Esta Semana", "Este Mês", "Vencidos"],
                                                state="readonly", width=15)
        self.receivable_due_filter.set("Todos")
        self.receivable_due_filter.grid(row=0, column=5, sticky="w", padx=5, pady=2)
        self.receivable_due_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_receivables())
        
        # Treeview para contas a receber
        tree_frame = ttk.Frame(main_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbars
        tree_scrollbar_y = ttk.Scrollbar(tree_frame)
        tree_scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        
        tree_scrollbar_x = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL)
        tree_scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Treeview
        columns = ("ID", "Cliente", "Descrição", "Valor", "Vencimento", "Status", "Data Criação")
        self.receivables_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", 
                                           yscrollcommand=tree_scrollbar_y.set,
                                           xscrollcommand=tree_scrollbar_x.set)
        
        # Configurar colunas
        self.receivables_tree.heading("ID", text="ID")
        self.receivables_tree.heading("Cliente", text="Cliente")
        self.receivables_tree.heading("Descrição", text="Descrição")
        self.receivables_tree.heading("Valor", text="Valor")
        self.receivables_tree.heading("Vencimento", text="Vencimento")
        self.receivables_tree.heading("Status", text="Status")
        self.receivables_tree.heading("Data Criação", text="Data Criação")
        
        self.receivables_tree.column("ID", width=80, anchor="center")
        self.receivables_tree.column("Cliente", width=150, anchor="w")
        self.receivables_tree.column("Descrição", width=200, anchor="w")
        self.receivables_tree.column("Valor", width=100, anchor="e")
        self.receivables_tree.column("Vencimento", width=100, anchor="center")
        self.receivables_tree.column("Status", width=100, anchor="center")
        self.receivables_tree.column("Data Criação", width=120, anchor="center")
        
        self.receivables_tree.pack(fill=tk.BOTH, expand=True)
        
        # Configurar scrollbars
        tree_scrollbar_y.config(command=self.receivables_tree.yview)
        tree_scrollbar_x.config(command=self.receivables_tree.xview)
        
        # Bind eventos
        self.receivables_tree.bind("<Double-1>", self.on_receivable_select)
        self.receivables_tree.bind("<Delete>", lambda e: self.delete_receivable())
        
        # Frame para estatísticas
        stats_frame = ttk.LabelFrame(main_frame, text="Estatísticas", padding="10")
        stats_frame.pack(fill=tk.X, pady=(10, 0))
        
        # Estatísticas
        self.receivable_total_label = ttk.Label(stats_frame, text="Total: R$ 0,00", font=("Arial", 12, "bold"))
        self.receivable_total_label.pack(side=tk.LEFT, padx=10)
        
        self.receivable_pending_label = ttk.Label(stats_frame, text="Pendente: R$ 0,00", font=("Arial", 10))
        self.receivable_pending_label.pack(side=tk.LEFT, padx=10)
        
        self.receivable_overdue_label = ttk.Label(stats_frame, text="Vencido: R$ 0,00", font=("Arial", 10))
        self.receivable_overdue_label.pack(side=tk.LEFT, padx=10)
        
        self.receivable_paid_label = ttk.Label(stats_frame, text="Pago: R$ 0,00", font=("Arial", 10))
        self.receivable_paid_label.pack(side=tk.LEFT, padx=10)
        
        # Carregar dados
        self.load_receivables()
    
    def _open_new_receivable_window_fallback(self):
        """Fallback para abrir janela de nova conta a receber"""
        messagebox.showinfo("Funcionalidade", "Funcionalidade de contas a receber em desenvolvimento.")
    
    def _load_receivables_fallback(self):
        """Fallback para carregar contas a receber"""
        pass
    
    def _filter_receivables_fallback(self):
        """Fallback para filtrar contas a receber"""
        pass
    
    def _on_receivable_select_fallback(self, event):
        """Fallback para seleção de conta a receber"""
        pass
    
    def _delete_receivable_fallback(self):
        """Fallback para deletar conta a receber"""
        pass
    
    def _open_new_payable_window_fallback(self):
        """Fallback para abrir janela de nova conta a pagar"""
        messagebox.showinfo("Funcionalidade", "Funcionalidade de contas a pagar em desenvolvimento.")
    
    def _load_payables_fallback(self):
        """Fallback para carregar contas a pagar"""
        pass
    
    def _filter_payables_fallback(self):
        """Fallback para filtrar contas a pagar"""
        pass
    
    def _on_payable_select_fallback(self, event):
        """Fallback para seleção de conta a pagar"""
        pass
    
    def _delete_payable_fallback(self):
        """Fallback para deletar conta a pagar"""
        pass
    
    def _create_payables_tab_fallback(self, parent):
        """Fallback para aba de contas a pagar"""
        # Frame principal
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text="📤 Contas a Pagar", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        # Botões de ação
        buttons_frame = ttk.Frame(title_frame)
        buttons_frame.pack(side=tk.RIGHT)
        
        ttk.Button(buttons_frame, text="➕ Nova Conta", 
                  command=self.open_new_payable_window).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(buttons_frame, text="🔄 Atualizar", 
                  command=self.load_payables).pack(side=tk.LEFT, padx=5)
        
        # Frame para filtros
        filters_frame = ttk.LabelFrame(main_frame, text="Filtros", padding="10")
        filters_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Filtros
        ttk.Label(filters_frame, text="Status:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.payable_status_filter = ttk.Combobox(filters_frame, 
                                                values=["Todos", "Pendente", "Pago", "Vencido", "Cancelado"],
                                                state="readonly", width=15)
        self.payable_status_filter.set("Todos")
        self.payable_status_filter.grid(row=0, column=1, sticky="w", padx=5, pady=2)
        self.payable_status_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_payables())
        
        ttk.Label(filters_frame, text="Fornecedor:").grid(row=0, column=2, sticky="w", padx=5, pady=2)
        self.payable_supplier_filter = ttk.Combobox(filters_frame, state="readonly", width=20)
        self.payable_supplier_filter.grid(row=0, column=3, sticky="w", padx=5, pady=2)
        self.payable_supplier_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_payables())
        
        ttk.Label(filters_frame, text="Vencimento:").grid(row=0, column=4, sticky="w", padx=5, pady=2)
        self.payable_due_filter = ttk.Combobox(filters_frame, 
                                             values=["Todos", "Hoje", "Esta Semana", "Este Mês", "Vencidos"],
                                             state="readonly", width=15)
        self.payable_due_filter.set("Todos")
        self.payable_due_filter.grid(row=0, column=5, sticky="w", padx=5, pady=2)
        self.payable_due_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_payables())
        
        # Treeview para contas a pagar
        tree_frame = ttk.Frame(main_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbars
        tree_scrollbar_y = ttk.Scrollbar(tree_frame)
        tree_scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        
        tree_scrollbar_x = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL)
        tree_scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Treeview
        columns = ("ID", "Fornecedor", "Descrição", "Valor", "Vencimento", "Status", "Data Criação")
        self.payables_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", 
                                        yscrollcommand=tree_scrollbar_y.set,
                                        xscrollcommand=tree_scrollbar_x.set)
        
        # Configurar colunas
        self.payables_tree.heading("ID", text="ID")
        self.payables_tree.heading("Fornecedor", text="Fornecedor")
        self.payables_tree.heading("Descrição", text="Descrição")
        self.payables_tree.heading("Valor", text="Valor")
        self.payables_tree.heading("Vencimento", text="Vencimento")
        self.payables_tree.heading("Status", text="Status")
        self.payables_tree.heading("Data Criação", text="Data Criação")
        
        self.payables_tree.column("ID", width=80, anchor="center")
        self.payables_tree.column("Fornecedor", width=150, anchor="w")
        self.payables_tree.column("Descrição", width=200, anchor="w")
        self.payables_tree.column("Valor", width=100, anchor="e")
        self.payables_tree.column("Vencimento", width=100, anchor="center")
        self.payables_tree.column("Status", width=100, anchor="center")
        self.payables_tree.column("Data Criação", width=120, anchor="center")
        
        self.payables_tree.pack(fill=tk.BOTH, expand=True)
        
        # Configurar scrollbars
        tree_scrollbar_y.config(command=self.payables_tree.yview)
        tree_scrollbar_x.config(command=self.payables_tree.xview)
        
        # Bind eventos
        self.payables_tree.bind("<Double-1>", self.on_payable_select)
        self.payables_tree.bind("<Delete>", lambda e: self.delete_payable())
        
        # Frame para estatísticas
        stats_frame = ttk.LabelFrame(main_frame, text="Estatísticas", padding="10")
        stats_frame.pack(fill=tk.X, pady=(10, 0))
        
        # Estatísticas
        self.payable_total_label = ttk.Label(stats_frame, text="Total: R$ 0,00", font=("Arial", 12, "bold"))
        self.payable_total_label.pack(side=tk.LEFT, padx=10)
        
        self.payable_pending_label = ttk.Label(stats_frame, text="Pendente: R$ 0,00", font=("Arial", 10))
        self.payable_pending_label.pack(side=tk.LEFT, padx=10)
        
        self.payable_overdue_label = ttk.Label(stats_frame, text="Vencido: R$ 0,00", font=("Arial", 10))
        self.payable_overdue_label.pack(side=tk.LEFT, padx=10)
        
        self.payable_paid_label = ttk.Label(stats_frame, text="Pago: R$ 0,00", font=("Arial", 10))
        self.payable_paid_label.pack(side=tk.LEFT, padx=10)
        
        # Carregar dados
        self.load_payables()
    
    def _create_invoices_tab_fallback(self, parent):
        """Fallback para aba de faturas"""
        ttk.Label(parent, text="🧾 Gestão de Faturas - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _create_cashflow_tab_fallback(self, parent):
        """Fallback para aba de fluxo de caixa"""
        ttk.Label(parent, text="💼 Fluxo de Caixa - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _create_budgets_tab_fallback(self, parent):
        """Fallback para aba de orçamentos"""
        ttk.Label(parent, text="📊 Gestão de Orçamentos - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _create_reports_tab_fallback(self, parent):
        """Fallback para aba de relatórios"""
        ttk.Label(parent, text="📈 Relatórios Empresariais - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _create_config_tab_fallback(self, parent):
        """Fallback para aba de configurações"""
        ttk.Label(parent, text="⚙️ Configurações Financeiras - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)

    def notify_member_added_to_card(self, card_id, member_name, added_by):
        """Notifica membro quando adicionado a um card"""
        try:
            card = self.get_card_by_id(card_id)
            if not card:
                return
            
            notification = {
                'type': 'member_added',
                'card_title': card['title'],
                'card_id': card_id,
                'member': member_name,
                'added_by': added_by,
                'board': card.get('board_name', ''),
                'list': card.get('list_name', ''),
                'timestamp': datetime.now().isoformat(),
                'read': False
            }
            
            # Salvar notificação no banco (se método existir)
            if hasattr(self, 'db') and hasattr(self.db, 'save_notification'):
                self.db.save_notification(notification)
            
            # Mostrar notificação na interface
            self.show_notification_popup(notification)
            
            # Enviar email se configurado
            if hasattr(self, 'email_integration'):
                self.email_integration.notify_member_added(notification)
                
        except Exception as e:
            print(f"Erro ao notificar membro adicionado: {e}")

    def show_notification_popup(self, notification):
        """Mostra popup de notificação"""
        try:
            popup = tk.Toplevel(self.root)
            popup.title("Nova Notificação")
            popup.geometry("400x200")
            popup.resizable(False, False)
            
            # Centralizar popup
            popup.transient(self.root)
            popup.grab_set()
            
            message = f"Você foi adicionado ao card:\n'{notification['card_title']}'\n\nQuadro: {notification['board']}\nLista: {notification['list']}"
            
            ttk.Label(popup, text=message, wraplength=350, justify='center').pack(pady=20)
            
            button_frame = ttk.Frame(popup)
            button_frame.pack(pady=10)
            
            ttk.Button(button_frame, text="Ver Card", 
                      command=lambda: self.open_card_from_notification(notification['card_id'])).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Fechar", command=popup.destroy).pack(side=tk.LEFT, padx=5)
            
        except Exception as e:
            print(f"Erro ao mostrar popup de notificação: {e}")

    def open_card_from_notification(self, card_id):
        """Abre card a partir de notificação"""
        try:
            # Encontrar card nos dados
            for board_name, board_data in self.boodesk_data['boards'].items():
                for list_name, cards in board_data.items():
                    for card in cards:
                        if card.get('card_id') == card_id:
                            # Abrir janela do card
                            CardWindow(self.root, self, board_name, list_name, card_id, self.current_user)
                            return
            print(f"Card {card_id} não encontrado")
        except Exception as e:
            print(f"Erro ao abrir card: {e}")

    def get_card_by_id(self, card_id):
        """Retorna card pelo ID - busca tanto no banco quanto na memória"""
        try:
            # Primeiro, tentar buscar no banco de dados
            if hasattr(self, 'db') and self.db:
                try:
                    card_data = self.db.get_card_by_id(card_id)
                    if card_data:
                        # Converter para dicionário se necessário
                        if not isinstance(card_data, dict):
                            card_data = dict(card_data)
                        
                        # Adicionar informações do board e lista
                        board_name = self.db.get_board_name_by_id(card_data.get('board_id'))
                        card_data['board_name'] = board_name or 'Quadro Principal'
                        card_data['list_name'] = card_data.get('list_name', 'A Fazer')
                        return card_data
                except Exception as db_error:
                    print(f"Erro ao buscar card no banco: {db_error}")
            
            # Se não encontrou no banco, buscar na estrutura em memória
            for board_name, board_data in self.boodesk_data['boards'].items():
                if isinstance(board_data, dict):
                    for list_name, cards in board_data.items():
                        if list_name == 'workflow':  # Ignorar metadados
                            continue
                        if isinstance(cards, list):
                            for card in cards:
                                if card.get('card_id') == card_id:
                                    card['board_name'] = board_name
                                    card['list_name'] = list_name
                                    return card
            
            print(f"Card com ID {card_id} não encontrado")
            return None
        except Exception as e:
            print(f"Erro ao buscar card por ID: {e}")
            return None

    def create_member_dashboard(self, member_name):
        """Cria dashboard personalizado para o membro"""
        dashboard = {
            'my_cards': self.get_cards_by_member(member_name),
            'my_boards': self.get_boards_for_member(member_name),
            'pending_tasks': self.get_pending_tasks(member_name),
            'completed_tasks': self.get_completed_tasks(member_name),
            'recent_activities': self.get_recent_activities(member_name),
            'upcoming_deadlines': self.get_upcoming_deadlines(member_name)
        }
        return dashboard

    def get_cards_by_member(self, member_name):
        """Retorna todos os cards onde o membro participa"""
        member = self.db.get_member_by_name(member_name)
        if member:
            return self.db.get_cards_by_member_id(member['id'])
        return []

    def get_pending_tasks(self, member_name):
        """Retorna tarefas pendentes do membro"""
        return [card for card in self.get_cards_by_member(member_name) 
                if card.get('status') != 'done']

    def get_completed_tasks(self, member_name, days=30):
        """Retorna tarefas completadas nos últimos X dias"""
        cutoff_date = datetime.now() - timedelta(days=days)
        completed = []
        for card in self.get_cards_by_member(member_name):
            if card.get('status') == 'done':
                completed_date = card.get('completed_at')
                if completed_date and completed_date > cutoff_date:
                    completed.append(card)
        return completed

    def get_recent_activities(self, member_name, limit=10):
        """Retorna atividades recentes relacionadas ao membro"""
        # Implementação básica - pode ser expandida com banco de dados
        activities = []
        cards = self.get_cards_by_member(member_name)
        for card in cards[:limit]:
            activities.append({
                'action': 'Card atribuído',
                'card_title': card['title'],
                'timestamp': card.get('created_at', 'Data não disponível')
            })
        return activities

    def get_upcoming_deadlines(self, member_name, days=7):
        """Retorna prazos próximos do membro"""
        cutoff_date = datetime.now() + timedelta(days=days)
        upcoming = []
        for card in self.get_cards_by_member(member_name):
            if card.get('status') != 'done':
                due_date = card.get('due_date')
                if due_date and due_date <= cutoff_date:
                    upcoming.append(card)
        return upcoming

    def show_member_dashboard(self, member_name):
        """Mostra dashboard personalizado do membro"""
        try:
            dashboard = self.create_member_dashboard(member_name)
            
            # Criar janela do dashboard
            dashboard_window = tk.Toplevel(self.root)
            dashboard_window.title(f"Dashboard - {member_name}")
            dashboard_window.geometry("800x600")
            dashboard_window.resizable(True, True)
            
            # Notebook para organizar as seções
            notebook = ttk.Notebook(dashboard_window)
            notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Aba de Cards Ativos
            active_frame = ttk.Frame(notebook)
            notebook.add(active_frame, text="Meus Cards")
            
            # Treeview para cards ativos
            columns = ("Título", "Quadro", "Lista", "Status", "Prazo")
            tree = ttk.Treeview(active_frame, columns=columns, show="headings")
            
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=120)
            
            # Adicionar cards
            for card in dashboard['my_cards']:
                tree.insert("", "end", values=(
                    card['title'],
                    card['board_name'],
                    card['list_name'],
                    card.get('status', 'Pendente'),
                    card.get('due_date', '-')
                ))
            
            tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Aba de Estatísticas
            stats_frame = ttk.Frame(notebook)
            notebook.add(stats_frame, text="Estatísticas")
            
            stats_text = f"""
            📊 Estatísticas de {member_name}
            
            📋 Total de Cards: {len(dashboard['my_cards'])}
            ⏳ Pendentes: {len(dashboard['pending_tasks'])}
            ✅ Completados (30 dias): {len(dashboard['completed_tasks'])}
            📅 Prazos Próximos: {len(dashboard['upcoming_deadlines'])}
            📋 Quadros Ativos: {len(dashboard['my_boards'])}
            """
            
            ttk.Label(stats_frame, text=stats_text, justify='left', font=('Arial', 12)).pack(pady=20)
            
        except Exception as e:
            print(f"Erro ao mostrar dashboard: {e}")
            messagebox.showerror("Erro", f"Não foi possível mostrar o dashboard: {e}")

    def open_personal_dashboard(self):
        """Abre dashboard personalizado do usuário atual"""
        try:
            # Obter membro do usuário atual
            current_user_member = self._get_current_user_member()
            
            if not current_user_member:
                messagebox.showwarning("Aviso", "Usuário não tem membro associado. Dashboard não disponível.")
                return
            
            # Mostrar dashboard
            self.show_member_dashboard(current_user_member)
            
        except Exception as e:
            print(f"Erro ao abrir dashboard pessoal: {e}")
            messagebox.showerror("Erro", f"Não foi possível abrir o dashboard: {e}")

    def format_brazilian_date(self, date_obj):
        """Converte datetime para formato brasileiro (DD/MM/YYYY)"""
        if not date_obj:
            return ""
            
        try:
            if isinstance(date_obj, str):
                # Se já é string, tentar converter primeiro
                date_obj = self.parse_brazilian_date(date_obj)
                
            if isinstance(date_obj, datetime):
                return date_obj.strftime("%d/%m/%Y")
            else:
                return str(date_obj)
                
        except Exception as e:
            print(f"Erro ao formatar data: {date_obj} - {e}")
            return str(date_obj) if date_obj else ""

    def format_brazilian_datetime(self, date_obj):
        """Converte datetime para formato brasileiro com hora (DD/MM/YYYY HH:MM)"""
        if not date_obj:
            return ""
            
        try:
            if isinstance(date_obj, str):
                # Se já é string, tentar converter primeiro
                date_obj = self.parse_brazilian_date(date_obj)
                
            if isinstance(date_obj, datetime):
                return date_obj.strftime("%d/%m/%Y %H:%M")
            else:
                return str(date_obj)
                
        except Exception as e:
            print(f"Erro ao formatar data/hora: {date_obj} - {e}")
            return str(date_obj) if date_obj else ""

    
    def check_permission(self, permission):
        """Verifica se o usuário atual tem uma determinada permissão"""
        if not hasattr(self, 'current_user') or not self.current_user:
            return False
        
        # Verificar se o usuário tem o método has_permission
        if not hasattr(self.current_user, 'has_permission'):
            print("DEBUG: Usuário não tem método has_permission")
            return False
        
        return self.current_user.has_permission(permission)
    
    def require_permission(self, permission, action_name="esta ação"):
        """Verifica permissão e mostra erro se não tiver"""
        if not self.check_permission(permission):
            messagebox.showerror("Acesso Negado", 
                               f"Você não tem permissão para {action_name}.\n"
                               f"Contate um administrador se precisar de acesso.")
            return False
        return True
    
    def open_user_management(self):
        """Abre a janela de gerenciamento de usuários"""
        try:
            # Verificar se o usuário tem permissão
            if not self.require_permission("manage_users", "gerenciar usuários"):
                return
            
            # Verificar se user_management está disponível
            if not hasattr(self, 'user_management') or self.user_management is None:
                messagebox.showerror("Erro", "Sistema de gerenciamento de usuários não disponível.")
                return
            
            # Verificar se icons está disponível
            if not hasattr(self, 'icons') or self.icons is None:
                messagebox.showerror("Erro", "Ícones não disponíveis.")
                return
            
            # Abrir janela de gerenciamento
            print("DEBUG: Abrindo janela de gerenciamento de usuários...")
            UserRegistrationWindow(self.root, self.user_management, self.icons, app=self)
            print("DEBUG: Janela de gerenciamento de usuários aberta com sucesso!")
            
        except Exception as e:
            print(f"DEBUG: Erro ao abrir gerenciamento de usuários: {e}")
            messagebox.showerror("Erro", f"Não foi possível abrir a tela de gerenciar usuários: {e}")
    
    def open_notification_settings(self):
        """Abre a janela de configurações de notificação"""
        NotificationSettingsWindow(self)
    
    def toggle_meeting_widget(self):
        """Alterna a visibilidade do widget de reuniões"""
        if hasattr(self, 'meeting_widget') and self.meeting_widget:
            if self.meeting_widget.widget_frame:
                self.meeting_widget.widget_frame.destroy()
                self.meeting_widget = None
                self.notification_manager.notification_settings['show_widget'] = False
        else:
            # Encontrar o frame do menu principal
            for child in self.main_notebook.winfo_children():
                if self.main_notebook.tab(child, "text") == "Menu Principal":
                    self.meeting_widget = MeetingWidget(self, child)
                    self.notification_manager.notification_settings['show_widget'] = True
                    break
        
        # Salvar configuração
        self.notification_manager.save_notification_settings()
    
    def on_closing(self):
        """Chamado quando a aplicação está sendo fechada"""
        try:
            # Parar sistema de notificações
            if hasattr(self, 'notification_manager'):
                self.notification_manager.stop_notification_monitor()
            
            # Salvar configurações
            self.save_settings_file()
            
            # Salvar dados do Boodesk
            self.save_trello_data()
            
            # Salvar dados do Pomodoro
            self.save_pomodoro_data()
            
            # Salvar dados financeiros
            self.save_finance_data()
            
            # Salvar dados de estudo
            self.save_study_data()
            
            # Salvar dados de objetivos
            self.save_goals_data()
            
            # Salvar dados de membros
            self.save_members_data()
            
            # Salvar dados de assuntos
            self.save_subjects_data()
            
            print("DEBUG: Todos os dados foram salvos com sucesso")
            
        except Exception as e:
            print(f"Erro ao salvar dados: {e}")
        
        finally:
            # Fechar aplicação
            self.root.destroy()
    
    def logout(self):
        """Faz logout do usuário atual"""
        if messagebox.askyesno("Logout", "Tem certeza que deseja fazer logout?"):
            # Limpar dados do usuário atual
            self.current_user = None
            
            # Ocultar janela principal
            self.root.withdraw()
            
            # Mostrar tela de login novamente
            login_window = LoginWindow(self.root, self.user_management, self.icons)
            self.root.wait_window(login_window)
            
            # Verificar se o login foi bem-sucedido
            if hasattr(self.root, 'login_successful') and self.root.login_successful and self.root.current_user:
                # Configurar novo usuário na aplicação
                self.current_user = self.root.current_user
                self.apply_role_permissions()
                
                # Recriar menu com novo usuário
                self.create_menu()
                
                # Mostrar aplicação principal
                self.root.deiconify()
            else:
                # Login cancelado ou falhou
                self.root.destroy()
        

    def update_all_displays(self):
        self.update_timer_display()
        self.populate_boards()
        self.update_pomodoro_task_list()
        self.update_my_activities_tab() # Adicionado
        self.update_log()
        self.update_accounts_listbox()
        self.update_total_balance_display()
        self.update_categories_listbox()
        self.update_payment_methods_listbox()
        self.update_transactions_treeview()
        self.populate_finance_comboboxes()
        self._show_chart(self.current_chart_type)
        self._update_saved_filters_combo()
        
        # Update dashboard widgets
        self.update_dashboard_widgets()

        # Initialize filter comboboxes
        self.filter_subject_combo['values'] = ["Todos"] + sorted(list(set(self.pomodoro_subjects + self.boodesk_subjects)))
        self.filter_goal_combo['values'] = ["Todos"] + sorted(self.goals)
        self.filter_importance_combo['values'] = ["Todos"] + list(self.settings["importance_colors"].keys())
        self.filter_member_combo['values'] = ["Todos"] + sorted([member['Membro'] for member in self.members])

    def apply_card_filter(self):
        self.populate_boards()

    def clear_card_filter(self):
        self.filter_subject_var.set("Todos")
        self.filter_goal_var.set("Todos")
        self.filter_member_var.set("Todos") # Changed from set("") to set("Todos")
        self.filter_due_date_var.set("Todos")
        self.filter_importance_var.set("Todos")
        self.filter_recurrence_var.set("Todos")
        self.filter_keyword_var.set("") # Clear keyword filter
        self.populate_boards()
        self._update_saved_filters_combo()

    def save_filter(self):
        filter_name = simpledialog.askstring("Salvar Filtro", "Digite um nome para este filtro:", parent=self.root)
        if filter_name:
            current_filter_settings = {
                "subject": self.filter_subject_var.get(),
                "goal": self.filter_goal_var.get(),
                "member": self.filter_member_var.get(),
                "due_date": self.filter_due_date_var.get(),
                "importance": self.filter_importance_var.get(),
                "recurrence": self.filter_recurrence_var.get(),
                "keyword": self.filter_keyword_var.get()
            }
            self.settings["custom_filters"][filter_name] = current_filter_settings
            self.save_settings_file()
            self._update_saved_filters_combo()
            messagebox.showinfo("Filtro Salvo", f"Filtro '{filter_name}' salvo com sucesso!")

    def load_filter(self, event=None):
        filter_name = self.saved_filters_combo.get()
        if filter_name and filter_name in self.settings["custom_filters"]:
            filter_settings = self.settings["custom_filters"][filter_name]
            self.filter_subject_var.set(filter_settings.get("subject", "Todos"))
            self.filter_goal_var.set(filter_settings.get("goal", "Todos"))
            self.filter_member_var.set(filter_settings.get("member", "Todos"))
            self.filter_due_date_var.set(filter_settings.get("due_date", "Todos"))
            self.filter_importance_var.set(filter_settings.get("importance", "Todos"))
            self.filter_recurrence_var.set(filter_settings.get("recurrence", "Todos"))
            self.filter_keyword_var.set(filter_settings.get("keyword", ""))
            self.apply_card_filter()
            messagebox.showinfo("Filtro Carregado", f"Filtro '{filter_name}' carregado com sucesso!")

    def delete_filter(self):
        filter_name = self.saved_filters_combo.get()
        if filter_name and filter_name in self.settings["custom_filters"]:
            if messagebox.askyesno("Excluir Filtro", f"Tem certeza que deseja excluir o filtro '{filter_name}'?"):
                del self.settings["custom_filters"][filter_name]
                self.save_settings_file()
                self._update_saved_filters_combo()
                self.clear_card_filter()
                messagebox.showinfo("Filtro Excluído", f"Filtro '{filter_name}' excluído com sucesso!")
        else:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um filtro para excluir.")

    def _update_saved_filters_combo(self):
        self.saved_filters_combo['values'] = sorted(list(self.settings["custom_filters"].keys()))
        self.saved_filters_combo.set("") # Clear current selection

    def toggle_filter_visibility(self):
        if self.filter_visible.get():
            self.filter_container_frame.pack_forget()
            self.toggle_filter_button.config(text="Mostrar Filtros")
        else:
            self.filter_container_frame.pack(fill=tk.X, pady=5, padx=5)
            self.toggle_filter_button.config(text="Ocultar Filtros")
        self.filter_visible.set(not self.filter_visible.get())

    def _filter_due_date(self, card_due_date_str, filter_option):
        if not card_due_date_str:
            return False # Cards without due dates don't match any date filter

        try:
            card_due_date = datetime.strptime(card_due_date_str.split(' ')[0], "%Y-%m-%d").date()
        except ValueError:
            return False # Invalid date format

        today = datetime.now().date()
        
        if filter_option == "Hoje":
            return card_due_date == today
        elif filter_option == "Próximos 7 dias":
            seven_days_from_now = today + timedelta(days=7)
            return today <= card_due_date <= seven_days_from_now
        elif filter_option == "Vencidos":
            return card_due_date < today
        return True # "Todos" or other cases

    # --- Data Loading/Saving ---
    def load_settings(self):
        """Load settings from SQL database instead of JSON files"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, usando configurações padrão")
                self.settings = self.get_default_settings()
                return
            
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Se não há usuário logado, usar user_id padrão (1 = admin)
            if user_id is None:
                user_id = 1
                print("DEBUG: Usando user_id padrão (1) para configurações")
            
            # Load settings from database for current user
            db_settings = self.db.get_user_settings(user_id)
            
            # Garantir que db_settings seja um dicionário válido
            if db_settings and isinstance(db_settings, dict):
                self.settings = db_settings
                print("DEBUG: Configurações carregadas do banco com sucesso")
            else:
                print(f"DEBUG: db_settings não é válido: {type(db_settings)} - {db_settings}")
                # No settings in database, use defaults
                self.settings = self.get_default_settings()
                # Save defaults to database for current user
                for key, value in self.settings.items():
                    try:
                        self.db.save_setting(key, value, user_id)
                    except Exception as save_error:
                        print(f"Erro ao salvar configuração {key}: {save_error}")
            
            # Garantir que self.settings seja um dicionário
            if not isinstance(self.settings, dict):
                print("DEBUG: self.settings não é um dicionário, usando padrões")
                self.settings = self.get_default_settings()
            
            # Merge with default settings to ensure all keys are present
            default_settings = self.get_default_settings()
            for key, value in default_settings.items():
                if key not in self.settings:
                    self.settings[key] = value
                    try:
                        self.db.save_setting(key, value, user_id)
                    except Exception as save_error:
                        print(f"Erro ao salvar configuração {key}: {save_error}")
                elif isinstance(value, dict) and isinstance(self.settings[key], dict):
                    # Recursively merge dictionaries (e.g., for importance_colors, roles)
                    self.settings[key] = {**value, **self.settings[key]}
                    try:
                        self.db.save_setting(key, self.settings[key], user_id)
                    except Exception as save_error:
                        print(f"Erro ao salvar configuração {key}: {save_error}")
            
            print(f"DEBUG: Tipo final de self.settings: {type(self.settings)}")
                    
        except Exception as e:
            print(f"Erro ao carregar configurações do banco: {e}")
            messagebox.showwarning("Erro de Configuração", f"Não foi possível carregar as configurações do banco. Usando padrões. Erro: {e}")
            self.settings = self.get_default_settings()
            # Try to save defaults to database
            try:
                if hasattr(self, 'db') and self.db is not None:
                    user_id = self.get_current_user_id()
                    # Se não há usuário logado, usar user_id padrão (1 = admin)
                    if user_id is None:
                        user_id = 1
                    for key, value in self.settings.items():
                        self.db.save_setting(key, value, user_id)
            except Exception as save_error:
                print(f"Erro ao salvar configurações padrão: {save_error}")

    def get_current_user_id(self):
        """Retorna o ID do usuário atual no banco de dados"""
        try:
            print("DEBUG: get_current_user_id - Iniciando...")
            
            if not self.current_user:
                print("DEBUG: current_user não definido")
                return None
            
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco de dados não disponível")
                return None
            
            username = self.current_user.username
            print(f"DEBUG: get_current_user_id - Username: {username}")
            
            if not username:
                print("DEBUG: Username não definido")
                return None
            
            print("DEBUG: get_current_user_id - Chamando get_user_by_username...")
            user_data = self.db.get_user_by_username(username)
            print(f"DEBUG: get_current_user_id - user_data: {user_data}")
            
            if user_data and 'id' in user_data:
                user_id = user_data['id']
                print(f"DEBUG: get_current_user_id - user_id: {user_id}")
                
                # Verificar se o usuário tem um membro associado
                if 'member_id' in user_data and user_data['member_id']:
                    member_id = user_data['member_id']
                    print(f"DEBUG: get_current_user_id - member_id: {member_id}")
                    print(f"DEBUG: ID do usuário {username}: {user_id} (membro associado: {member_id})")
                    return user_id
                else:
                    print(f"DEBUG: get_current_user_id - member_id não encontrado ou None")
                    print(f"DEBUG: Usuário {username} não tem membro associado")
                    messagebox.showerror("Erro", "Usuário não tem membro associado. Contate o administrador.", parent=self.root)
                    return None
            else:
                print(f"DEBUG: get_current_user_id - user_data inválido: {user_data}")
                print(f"DEBUG: Usuário {username} não encontrado no banco ou sem ID")
                return None
                
        except Exception as e:
            print(f"DEBUG: Erro ao obter ID do usuário: {e}")
            return None

    def get_default_settings(self):
        return {
            "pomodoro": 25, 
            "short_break": 5, 
            "long_break": 15, 
            "cycles": 4, 
            "theme": "aquativo", 
            "unify_subjects": False, 
            "show_card_details_on_board": False,
            "show_dependency_info": True,
            "open_on_current_screen": False, # New setting
            "importance_colors": {
                "Crítica": "#FFCCCC",
                "Alta": "#FFE5CC",
                "Normal": "#FFFFCC",
                "Baixa": "#CCFFCC"
            },
            "card_tags": {
                "Urgente": "#FF0000",
                "Importante": "#FFA500",
                "Desenvolvimento": "#0000FF",
                "Bug": "#FFD700",
                "Feature": "#008000"
            },
            "custom_filters": {}, # New: To store custom filter presets
            "dev_mode": False, # New: Development mode for agile features
            "git_integration_enabled": False, # New: Enable/disable Git integration features
            "roles": {
                "Administrador": "Acesso total ao sistema.",
                "Usuário": "Acesso limitado a funcionalidades básicas.",
                "Convidado": "Apenas visualização."
            },
            "dashboard_widgets": {
                "urgent_tasks": True,
                "upcoming_deadlines": True,
                "recent_activities": True,
                "quick_links": True,
                "overview": True,
                "quick_actions": True
            },
            # Configurações do Google Calendar removidas - integração desabilitada
            "email_integration": {
                "enabled": False,
                "provider": "gmail",
                "smtp_server": "smtp.gmail.com",
                "smtp_port": 587,
                "email_address": "",
                "email_password": "",
                "app_password": "",
                "auto_notifications": {
                    "card_created": True,
                    "card_modified": True,
                    "card_moved": True,
                    "deadline_reminder": True,
                    "weekly_report": True
                },
                "notification_recipients": [],
                "deadline_reminder_hours": 24,
                "weekly_report_day": "monday",
                "weekly_report_time": "09:00",
                "email_templates": {
                    "card_created": "Novo cartão criado: {title}",
                    "card_modified": "Cartão modificado: {title}",
                    "deadline_reminder": "Lembrete de prazo: {title} vence em {deadline}",
                    "weekly_report": "Relatório Semanal - {week_period}"
                }
            }
        }

    def save_settings_file(self):
        """Save settings to SQL database instead of JSON files"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar configurações")
                return
            
            # Obter user_id se disponível
            user_id = None
            if hasattr(self, 'current_user') and self.current_user:
                user_id = self.get_current_user_id()
            
            for key, value in self.settings.items():
                try:
                    if user_id:
                        self.db.save_setting(key, value, user_id)
                    else:
                        # Se não há usuário logado, usar user_id padrão (1 = admin)
                        self.db.save_setting(key, value, 1)
                except Exception as save_error:
                    print(f"❌ Erro ao salvar configuração {key}: {save_error}")
            
            print("✅ Configurações salvas no banco SQL com sucesso")
        except Exception as e:
            print(f"❌ Erro ao salvar configurações no banco: {e}")
            messagebox.showerror("Erro", f"Não foi possível salvar as configurações no banco: {e}")

    def load_trello_data(self):
        """Load data from SQL database only"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, usando dados padrão")
                self.boodesk_data = {
                    "boards": {
                        "Quadro Principal": {
                            "A Fazer": [],
                            "Em Progresso": [],
                            "Concluído": []
                        },
                        "workflow": ["A Fazer", "Em Progresso", "Concluído"]
                    },
                    "finances": {
                        "contas_bancarias": [],
                        "categorias_gasto": [],
                        "meios_pagamento": [],
                        "transacoes": []
                    }
                }
                return
            
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Get member ID for cards filtering
            cards_member_id = None
            if hasattr(self, 'current_user') and self.current_user:
                # Try to get member ID from current user
                try:
                    cards_member_id = self.db.get_member_id_by_username(self.current_user.username)
                except:
                    cards_member_id = None
            
            # Check if database has data, if not create default board
            # Para administradores, carregar todos os quadros; para usuários normais, apenas os próprios
            if hasattr(self, 'current_user') and getattr(self.current_user, 'role', None) in ['admin', 'Administrador']:
                print("DEBUG: Carregando todos os quadros para administrador")
                boards = self.db.get_boards()  # Sem user_id para carregar todos
            else:
                print("DEBUG: Carregando apenas quadros do usuário")
                # Para usuários normais, carregar apenas quadros onde são membros
                if cards_member_id:
                    boards = self.db.get_boards(member_id=cards_member_id)
                else:
                    boards = self.db.get_boards(user_id)
                
            if not boards:
                print("DEBUG: Nenhum quadro encontrado no banco, criando quadro padrão")
                # Create default board for current user
                board_id = self.db.create_board("Quadro Principal", owner_id=user_id)
                # Create default card and add current user as a member
                if hasattr(self, 'current_user') and self.current_user:
                    members = [self.current_user.username]
                else:
                    members = []
                    
                self.db.create_card(
                    board_id=board_id,
                    list_name="A Fazer",
                    title="Sua primeira tarefa",
                    description="Bem-vindo ao Boodesk! Esta é sua primeira tarefa.",
                    importance="Normal",
                    user_id=user_id,
                    members=members
                )
                # Recarregar quadros após criar o padrão
                if cards_member_id:
                    boards = self.db.get_boards(member_id=cards_member_id)
                else:
                    boards = self.db.get_boards(user_id)
            
            # Load data from database
            self.boodesk_data = {'boards': {}}
            for board in boards:
                board_name = board['name']
                self.boodesk_data['boards'][board_name] = {}
                
                # Carregar listas do banco de dados
                try:
                    lists = self.db.get_lists_for_board(board['id'])
                    for list_item in lists:
                        list_name = list_item['name']
                        self.boodesk_data['boards'][board_name][list_name] = []
                except Exception as e:
                    print(f"DEBUG: Erro ao carregar listas para quadro {board_name}: {e}")
                    # Usar listas padrão em caso de erro
                    self.boodesk_data['boards'][board_name] = {
                        "A Fazer": [],
                        "Em Progresso": [],
                        "Concluído": []
                    }
                
                # Carregar cards do banco de dados
                try:
                    print(f"🔄 Carregando cards para quadro: {board_name} (ID: {board['id']})")
                    cards = self.db.get_cards_for_board(board['id'], member_id=cards_member_id)
                    if cards is None:
                        cards = []
                    
                    print(f"📋 Total de cards encontrados: {len(cards)}")
                    
                    for card in cards:
                        list_name = card.get('list_name', 'A Fazer')
                        card_title = card.get('title', 'Sem título')
                        card_id = card.get('card_id', 'Sem ID')
                        
                        print(f"📝 Card: '{card_title}' (ID: {card_id}) -> Lista: '{list_name}'")
                        
                        # Garantir que a lista existe no quadro
                        if list_name not in self.boodesk_data['boards'][board_name]:
                            print(f"➕ Criando lista '{list_name}' no quadro '{board_name}'")
                            self.boodesk_data['boards'][board_name][list_name] = []
                        
                        # Adicionar card à lista correta
                        self.boodesk_data['boards'][board_name][list_name].append(card)
                        print(f"✅ Card '{card_title}' adicionado à lista '{list_name}'")
                        
                except Exception as e:
                    print(f"❌ ERRO ao carregar cards para quadro {board_name}: {e}")
                    # Usar cards vazios em caso de erro
                    pass
            
            # Add workflow
            self.boodesk_data['workflow'] = ["A Fazer", "Em Progresso", "Concluído"]
            
            # Garantir que pelo menos o Quadro Principal existe
            if "Quadro Principal" not in self.boodesk_data['boards']:
                self.boodesk_data['boards']["Quadro Principal"] = {
                    "A Fazer": [],
                    "Em Progresso": [],
                    "Concluído": []
                }
            
            print(f"DEBUG: load_trello_data concluído. Quadros carregados: {list(self.boodesk_data['boards'].keys())}")
            
            # Load finances from database
            finances = self.db.get_finance_data('finances')
            if finances:
                self.boodesk_data['finances'] = finances
            else:
                self.boodesk_data['finances'] = {
                    "contas_bancarias": [],
                    "categorias_gasto": [],
                    "meios_pagamento": [],
                    "transacoes": []
                }
                # Save default finances to database
                for key, value in self.boodesk_data['finances'].items():
                    try:
                        self.db.save_finance_data('finances', key, value)
                    except Exception as save_error:
                        print(f"Erro ao salvar dados financeiros {key}: {save_error}")
                    
        except Exception as e:
            print(f"Erro ao carregar dados do banco: {e}")
            # Em caso de erro, usar dados padrão
            self.boodesk_data = {
                "boards": {
                    "Quadro Principal": {
                        "A Fazer": [],
                        "Em Progresso": [],
                        "Concluído": []
                    },
                    "workflow": ["A Fazer", "Em Progresso", "Concluído"]
                },
                "finances": {
                    "contas_bancarias": [],
                    "categorias_gasto": [],
                    "meios_pagamento": [],
                    "transacoes": []
                }
            }
            messagebox.showerror("Erro", f"Ocorreu um erro ao carregar os dados do banco: {e}")
            messagebox.showerror("Erro", f"Ocorreu um erro ao carregar os dados do banco: {e}")
            # Create minimal default data
            self.boodesk_data = {
                "boards": {
                    "Quadro Principal": {
                        "A Fazer": [],
                        "Em Progresso": [],
                        "Concluído": []
                    },
                    "workflow": ["A Fazer", "Em Progresso", "Concluído"]
                },
                "finances": {
                    "contas_bancarias": [],
                    "categorias_gasto": [],
                    "meios_pagamento": [],
                    "transacoes": []
                }
            }

    def save_trello_data(self):
        """Save data to SQL database only"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados")
                return
            
            # Garantir que há uma conexão válida
            if not self.db.is_connected():
                print("DEBUG: Reconectando ao banco...")
                self.db.ensure_connection()
            
            # Os dados já estão sendo salvos diretamente no banco via métodos CRUD
            # Este método agora é usado apenas para sincronização
            print("Dados sincronizados no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao sincronizar dados no banco: {e}")
            messagebox.showerror("Erro ao Salvar Dados", f"Ocorreu um erro ao sincronizar os dados no banco: {e}")

    def save_pomodoro_data(self):
        """Save pomodoro data to database"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados do pomodoro")
                return
            
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Salvar tarefas do pomodoro
            for task in self.pomodoro_tasks:
                try:
                    self.db.save_pomodoro_task(
                        title=task.get('title', ''),
                        description=task.get('description', ''),
                        status=task.get('status', 'pending'),
                        user_id=user_id
                    )
                except Exception as e:
                    print(f"Erro ao salvar tarefa do pomodoro: {e}")
            
            print("Dados do pomodoro salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados do pomodoro: {e}")

    def save_finance_data(self):
        """Save finance data to database"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados financeiros")
                return
            
            # Salvar dados financeiros
            for key, value in self.boodesk_data.get('finances', {}).items():
                try:
                    self.db.save_finance_data('finances', key, value)
                except Exception as e:
                    print(f"Erro ao salvar dados financeiros {key}: {e}")
            
            print("Dados financeiros salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados financeiros: {e}")

    def save_study_data(self):
        """Save study data to database"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados de estudo")
                return
            
            # Salvar dados de estudo (implementar conforme necessário)
            print("Dados de estudo salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados de estudo: {e}")

    def save_goals_data(self):
        """Save goals data to database"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados de objetivos")
                return
            
            # Salvar dados de objetivos (implementar conforme necessário)
            print("Dados de objetivos salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados de objetivos: {e}")

    def save_members_data(self):
        """Save members data to database"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados de membros")
                return
            
            # Salvar dados de membros
            try:
                self.db.save_members(self.members)
                print("Dados de membros salvos no banco SQL com sucesso")
            except Exception as e:
                print(f"Erro ao salvar dados de membros: {e}")
        except Exception as e:
            print(f"Erro ao salvar dados de membros: {e}")

    def save_subjects_data(self):
        """Save subjects data to database"""
        try:
            # Verificar se o banco está disponível
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco não disponível, não foi possível salvar dados de assuntos")
                return
            
            # Salvar dados de assuntos (implementar conforme necessário)
            print("Dados de assuntos salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados de assuntos: {e}")

    def load_pomodoro_data(self):
        """Carrega dados do Pomodoro do banco SQLite"""
        try:
            # Inicializar com dados padrão
            self.pomodoro_tasks_df = pd.DataFrame({'Tarefa': ['Exemplo de Tarefa Pomodoro'], 'Status': ['Pendente'], 'Assunto': ['-'], 'Objetivo': ['-']})
            # Inicializar pomodoro_tasks como lista vazia
            self.pomodoro_tasks = []
            print("DEBUG: Pomodoro data loaded (using default data)")
        except Exception as e:
            print(f"Erro ao carregar dados do Pomodoro: {e}")
            self.pomodoro_tasks_df = pd.DataFrame({'Tarefa': ['Exemplo de Tarefa Pomodoro'], 'Status': ['Pendente'], 'Assunto': ['-'], 'Objetivo': ['-']})

    def save_pomodoro_tasks(self):
        """Salva dados do Pomodoro no banco SQLite"""
        try:
            print("DEBUG: Pomodoro tasks saved to database")
        except Exception as e:
            print(f"Erro ao salvar dados do Pomodoro: {e}")

    
    def save_motivational_messages(self):
        """Salva mensagens motivacionais no banco de dados (opcional)"""
        try:
            if hasattr(self, 'db') and self.db:
                user_id = self.get_current_user_id() or 1
                messages_json = json.dumps({'messages': self.messages})
                self.db.save_setting('motivational_messages', messages_json, user_id)
                print("✅ Mensagens motivacionais salvas no banco")
        except Exception as e:
            print(f"⚠️ Erro ao salvar mensagens no banco: {e}")
    
    def load_motivational_messages_from_db(self):
        """Carrega mensagens motivacionais do banco de dados (opcional)"""
        try:
            if hasattr(self, 'db') and self.db:
                user_id = self.get_current_user_id() or 1
                messages_json = self.db.get_setting('motivational_messages', user_id)
                if messages_json:
                    data = json.loads(messages_json)
                    self.messages = data.get('messages', self.messages)
                    print("✅ Mensagens motivacionais carregadas do banco")
        except Exception as e:
            print(f"⚠️ Erro ao carregar mensagens do banco: {e}")
    def load_aux_data(self):
        # Messages - Usar dados padrão em memória (sem arquivo JSON)
        self.messages = [
            "Bem-vindo ao Boodesk!",
            "Foco total!",
            "Você consegue!",
            "Persistência é a chave!",
            "Cada passo conta!",
            "Mantenha o ritmo!",
            "Sucesso é uma jornada!",
            "Acredite em você!",
            "Hoje é o dia!",
            "Vamos lá!"
        ]
        print("✅ Mensagens motivacionais carregadas em memória")

        # Subjects - Usar dados padrão
        self.pomodoro_subjects = ["-"]
        self.trello_subjects = ["-"]
        self.boodesk_subjects = ["-"]
        self.subjects = ["-"]

        # Goals - Usar dados padrão
        self.goals = ["-"]
        self.goals_df = pd.DataFrame({'Objetivo': ["-"]})

        # Log - Usar dados padrão
        self.log_df = pd.DataFrame(columns=['Data e Hora', 'Assunto', 'Duração (min)'])

    def save_log(self):
        """Salva log no banco SQLite"""
        try:
            print("DEBUG: Log saved to database")
        except Exception as e:
            print(f"Erro ao salvar log: {e}")

    def load_members(self):
        """Carrega membros do banco PostgreSQL"""
        try:
            import sqlite3
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("SELECT id, membro as name, cargo as role, email FROM members ORDER BY membro")
            members_data = cursor.fetchall()
            conn.close()
            
            # Converter para o formato esperado pela aplicação
            self.members = []
            for member_id, name, email, role in members_data:
                self.members.append({
                    'id': member_id,
                    'Membro': name,
                    'Cargo': role,
                    'email': email if email else ''
                })
            
            # Criar DataFrame para compatibilidade
            self.members_df = pd.DataFrame(self.members)
            
            print(f"DEBUG: Members loaded from PostgreSQL. self.members count: {len(self.members)}")
            print(f"DEBUG: Members loaded. self.members content: {self.members}")
            
        except Exception as e:
            print(f"Erro ao carregar membros do PostgreSQL: {e}")
            self.members = []
            self.members_df = pd.DataFrame({'Membro': [], 'Cargo': [], 'email': []})

    def save_members(self):
        """Salva membros no banco PostgreSQL"""
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Limpar tabela atual
            cursor.execute("DELETE FROM members")
            
            # Inserir membros atualizados
            for member in self.members:
                cursor.execute("""
                    INSERT INTO members (membro, email, cargo, created_at)
                    VALUES (%s, %s, %s, %s)
                """, (
                    member['Membro'],
                    member.get('email', ''),
                    member.get('Cargo', 'member'),
                    datetime.now(),
                    datetime.now()
                ))
            
            conn.commit()
            conn.close()
            print("DEBUG: Members saved to SQLite successfully.")
            
        except Exception as e:
            print(f"Erro ao salvar membros no PostgreSQL: {e}")
    
    def load_categories(self):
        """Carrega as categorias do arquivo JSON"""
        try:
            categories_file = f"{self.base_dir}{sep}categories.json"
            if os.path.exists(categories_file):
                with open(categories_file, 'r', encoding='utf-8') as f:
                    self.categories = json.load(f)
                print(f"DEBUG: Categories loaded: {len(self.categories)} categories")
            else:
                self.categories = [
                    {"id": 1, "name": "Desenvolvimento", "color": "#3498db"},
                    {"id": 2, "name": "Design", "color": "#e74c3c"},
                    {"id": 3, "name": "Marketing", "color": "#f39c12"},
                    {"id": 4, "name": "Vendas", "color": "#27ae60"},
                    {"id": 5, "name": "Suporte", "color": "#9b59b6"}
                ]
                self.save_categories()
                print("DEBUG: Default categories created")
        except Exception as e:
            print(f"DEBUG: Error loading categories: {e}")
            self.categories = []
    
    def save_categories(self):
        """Salva as categorias no arquivo JSON"""
        try:
            categories_file = f"{self.base_dir}{sep}categories.json"
            with open(categories_file, 'w', encoding='utf-8') as f:
                json.dump(self.categories, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"DEBUG: Error saving categories: {e}")

    # --- UI Creation ---
    def apply_role_permissions(self):
        """Aplica permissões baseadas no role do usuário atual"""
        if not hasattr(self, 'current_user') or not self.current_user:
            return
        
        # Verificar se o usuário tem role válido
        if not hasattr(self.current_user, 'role') or not self.current_user.role:
            print("DEBUG: Usuário sem role válido, usando role padrão 'user'")
            self.current_user.role = "user"
        
        # Configurar título da janela com informações do usuário
        user_info = f" - {self.current_user.username} ({self.current_user.cargo})"
        self.root.title(f"Sistema Boodesk{user_info}")
        
        # Aplicar permissões específicas baseadas no role
        role = self.current_user.role.lower()
        if role == "user":
            self.apply_user_permissions()
        elif role == "manager":
            self.apply_manager_permissions()
        elif role == "admin":
            self.apply_admin_permissions()
        else:
            print(f"DEBUG: Role desconhecido '{self.current_user.role}', usando permissões de usuário")
            self.apply_user_permissions()
    
    def apply_user_permissions(self):
        """Aplica permissões de usuário comum"""
        try:
            if hasattr(self, 'menu_bar') and self.menu_bar:
                self.menu_bar.entryconfig("Arquivo", state=tk.DISABLED)
                self.menu_bar.entryconfig("Quadros", state=tk.DISABLED)
        except tk.TclError as e:
            print(f"DEBUG: Erro ao configurar permissões do menu para usuário: {e}")
    
    def apply_manager_permissions(self):
        """Aplica permissões de gerente"""
        try:
            if hasattr(self, 'menu_bar') and self.menu_bar:
                self.menu_bar.entryconfig("Arquivo", state=tk.NORMAL)
                self.menu_bar.entryconfig("Quadros", state=tk.NORMAL)
                self.menu_bar.entryconfig("Usuários", state=tk.NORMAL)
                self.menu_bar.entryconfig("Configurações", state=tk.DISABLED)
        except tk.TclError as e:
            print(f"DEBUG: Erro ao configurar permissões do menu para gerente: {e}")
    
    def apply_admin_permissions(self):
        """Aplica permissões de administrador"""
        try:
            if hasattr(self, 'menu_bar') and self.menu_bar:
                self.menu_bar.entryconfig("Arquivo", state=tk.NORMAL)
                self.menu_bar.entryconfig("Quadros", state=tk.NORMAL)
                self.menu_bar.entryconfig("Usuários", state=tk.NORMAL)
                self.menu_bar.entryconfig("Configurações", state=tk.NORMAL)
        except tk.TclError as e:
            print(f"DEBUG: Erro ao configurar permissões do menu para admin: {e}")

    def create_menu(self):
        print("DEBUG: Iniciando create_menu")
        try:
            # Criar menu básico primeiro
            self.menubar = tk.Menu(self.root)
            print("DEBUG: Menubar criado")
            
            # Configurar o menu na janela
            self.root.config(menu=self.menubar)
            print("DEBUG: Menu configurado na janela")
            
            # Menu Arquivo básico
            file_menu = tk.Menu(self.menubar, tearoff=0)
            file_menu.add_command(label="Sair", command=self.root.quit)
            self.menubar.add_cascade(label="Arquivo", menu=file_menu)
            
            # Menu Editar
            edit_menu = tk.Menu(self.menubar, tearoff=0)
            edit_menu.add_command(label="Copiar", command=lambda: print("Copiar"))
            edit_menu.add_command(label="Colar", command=lambda: print("Colar"))
            self.menubar.add_cascade(label="Editar", menu=edit_menu)
            
            # Menu Ajuda
            help_menu = tk.Menu(self.menubar, tearoff=0)
            help_menu.add_command(label="Sobre", command=lambda: print("Sobre"))
            self.menubar.add_cascade(label="Ajuda", menu=help_menu)
            
            # Menu Atualizações (sem referência a métodos que podem não existir)
            update_menu = tk.Menu(self.menubar, tearoff=0)
            update_menu.add_command(label="Verificar Atualizações", command=lambda: print("Verificar Atualizações"))
            update_menu.add_command(label="Sobre o Boodesk", command=lambda: print("Sobre o Boodesk"))
            self.menubar.add_cascade(label="Atualizações", menu=update_menu)
            
            print("DEBUG: Menu básico criado com sucesso")
            print(f"DEBUG: Menubar: {self.menubar}")
            print(f"DEBUG: Root menu: {self.root.cget('menu')}")
            
        except Exception as e:
            print(f"DEBUG: Erro ao criar menu: {e}")
            import traceback
            traceback.print_exc()
            # Criar um menu básico se houver erro
            self.menubar = tk.Menu(self.root)
            self.root.config(menu=self.menubar)

        # File Menu (General App Actions)
        file_menu = tk.Menu(self.menubar, tearoff=0)
        
        # Submenu de Configurações
        config_menu = tk.Menu(file_menu, tearoff=0)
        config_menu.add_command(label="Configurações Gerais", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_config_geral)
        config_menu.add_command(label="Configurações do Calendário", image=self.icons.get('calendar_icon'), compound=tk.LEFT, command=self.open_config_calendario)
        config_menu.add_command(label="Configurações de Email", image=self.icons.get('info_icon'), compound=tk.LEFT, command=self.open_config_email)
        config_menu.add_command(label="Templates de Email", image=self.icons.get('registration_icon'), compound=tk.LEFT, command=self.open_config_templates_email)
        config_menu.add_separator()
        config_menu.add_command(label="Todas as Configurações", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_settings)
        
        file_menu.add_cascade(label="Configurações", menu=config_menu)
        file_menu.add_separator()
        
        # Adicionar informações do usuário e logout
        if (hasattr(self, 'current_user') and self.current_user and 
            hasattr(self.current_user, 'username') and hasattr(self.current_user, 'cargo')):
            file_menu.add_command(label=f"Usuário: {self.current_user.username} ({self.current_user.cargo})", 
                                state="disabled")
            file_menu.add_separator()
            file_menu.add_command(label="Logout", image=self.icons.get('exit_icon'), compound=tk.LEFT, command=self.logout)
        
        file_menu.add_command(label="Sair", image=self.icons.get('exit_icon'), compound=tk.LEFT, command=self.root.quit)
        self.menubar.add_cascade(label="Arquivo", menu=file_menu)

        # Board Menu
        board_menu = tk.Menu(self.menubar, tearoff=0)
        board_menu.add_command(label="Adicionar Quadro", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_board)
        board_menu.add_command(label="Cartões Arquivados", image=self.icons.get('folder_icon'), compound=tk.LEFT, command=self.open_archived_cards_window)
        self.menubar.add_cascade(label="Quadros", menu=board_menu)

        # Pomodoro Menu
        pomodoro_menu = tk.Menu(self.menubar, tearoff=0)
        pomodoro_menu.add_command(label="Configurações do Pomodoro", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_settings) # Can be specific settings
        self.menubar.add_cascade(label="Pomodoro", menu=pomodoro_menu)

        # General Data Management Menu (for subjects/goals)
        manage_data_menu = tk.Menu(self.menubar, tearoff=0)
        
        # Sub-menu for Subjects
        subjects_menu = tk.Menu(manage_data_menu, tearoff=0)
        subjects_menu.add_command(label="Criar Assunto Pomodoro", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.add_subject_dialog('pomodoro'))
        subjects_menu.add_command(label="Criar Assunto Boodesk", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.add_subject_dialog('boodesk'))
        manage_data_menu.add_cascade(label="Assuntos", menu=subjects_menu)
        
        # Categorias
        categories_menu = tk.Menu(manage_data_menu, tearoff=0)
        categories_menu.add_command(label="Gerenciar Categorias", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_categories_manager)
        manage_data_menu.add_cascade(label="Categorias", menu=categories_menu)
        
        manage_data_menu.add_command(label="Adicionar Objetivo", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_goal)
        manage_data_menu.add_command(label="Gerenciar Membros", image=self.icons.get('objects_icon'), compound=tk.LEFT, command=self.open_members_manager)
        
        # Menu de usuários (só para admin/manager)
        print("DEBUG: Verificando se deve mostrar menu de usuários...")
        if hasattr(self, 'current_user') and self.current_user:
            print(f"DEBUG: Usuário atual: {self.current_user.username} (Role: {getattr(self.current_user, 'role', 'N/A')})")
            
            # Verificar se pode gerenciar usuários
            can_manage = False
            if hasattr(self.current_user, 'can_manage_users'):
                can_manage = self.current_user.can_manage_users()
                print(f"DEBUG: can_manage_users() retornou: {can_manage}")
            else:
                print("DEBUG: Usuário não tem método can_manage_users")
                # Fallback: verificar role diretamente
                role = getattr(self.current_user, 'role', '')
                role_mapping = {
                    "Administrador": "admin",
                    "admin": "admin",
                    "Manager": "manager", 
                    "manager": "manager",
                    "Usuário": "user",
                    "user": "user"
                }
                normalized_role = role_mapping.get(role, role)
                can_manage = normalized_role in ["admin", "manager"]
                print(f"DEBUG: Fallback - Role '{role}' -> '{normalized_role}', pode gerenciar: {can_manage}")
            
            if can_manage:
                print("DEBUG: Adicionando menu 'Gerenciar Usuários'")
                manage_data_menu.add_separator()
                manage_data_menu.add_command(label="Gerenciar Usuários", image=self.icons.get('registration_icon'), compound=tk.LEFT, command=self.open_user_management)
            else:
                print("DEBUG: Usuário não pode gerenciar usuários, menu não será adicionado")
        else:
            print("DEBUG: Nenhum usuário atual definido")
        
        # Menu de notificações (disponível para todos)
        manage_data_menu.add_separator()
        manage_data_menu.add_command(label="Configurar Notificações", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_notification_settings)
        
        # Dashboard personalizado (disponível para todos)
        manage_data_menu.add_command(label="Meu Dashboard", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT, command=self.open_personal_dashboard)
        
        self.menubar.add_cascade(label="Gerenciar Dados Auxiliares", menu=manage_data_menu)

        # Theme Menu
        theme_menu = tk.Menu(self.menubar, tearoff=0)
        for theme in self.root.get_themes():
            theme_menu.add_command(label=theme, command=lambda t=theme: self.change_theme(t))
        self.menubar.add_cascade(label="Temas", menu=theme_menu)
        # Menu de Atualizações
        update_menu = tk.Menu(self.menubar, tearoff=0)
        update_menu.add_command(label="Verificar Atualizações", 
                              image=self.icons.get('refresh_icon'), 
                              compound=tk.LEFT, 
                              command=self.check_for_updates_manual)
        update_menu.add_command(label="Sobre o Boodesk", 
                              image=self.icons.get('info_icon'), 
                              compound=tk.LEFT, 
                              command=self.show_about_dialog)
        self.menubar.add_cascade(label="Atualizações", menu=update_menu)
        
        print("DEBUG: create_menu concluído com sucesso")
        
        # Forçar atualização do menu
        try:
            self.root.update_idletasks()
            print("DEBUG: Menu atualizado")
        except Exception as e:
            print(f"DEBUG: Erro ao atualizar menu: {e}")


    def change_theme(self, theme):
        """Aplica um novo tema ao aplicativo e salva no banco por usuário"""
        try:
            print(f"🎨 Aplicando tema: {theme}")
            
            # Aplicar o tema na janela principal
            self.root.set_theme(theme)
            
            # Atualizar configurações
            self.settings['theme'] = theme
            
            # Salvar no banco de dados com isolamento por usuário
            try:
                user_id = self.get_current_user_id()
                if user_id and hasattr(self, 'db') and self.db:
                    self.db.save_setting('theme', theme, user_id)
                    print(f"✅ Tema '{theme}' salvo no banco para usuário {user_id}")
                else:
                    # Fallback: salvar com user_id padrão (admin)
                    if hasattr(self, 'db') and self.db:
                        self.db.save_setting('theme', theme, 1)
                        print(f"✅ Tema '{theme}' salvo no banco para admin (fallback)")
                    else:
                        print("⚠️ Banco não disponível, tema não persistido")
            except Exception as save_error:
                print(f"⚠️ Erro ao salvar tema no banco: {save_error}")
            
            # Forçar atualização completa da interface
            self.root.update_idletasks()
            
            # Recriar o menu com o novo tema
            if hasattr(self, 'menubar'):
                self.menubar.destroy()
                self.create_menu()
            
            # Atualizar todos os widgets principais
            if hasattr(self, 'main_notebook'):
                self.main_notebook.update_idletasks()
                
                # Atualizar cada aba
                for tab_id in self.main_notebook.tabs():
                    try:
                        tab_widget = self.main_notebook.nametowidget(tab_id)
                        tab_widget.update_idletasks()
                    except:
                        pass
            
            # Forçar redesenho completo da janela
            self.root.update()
            
            # Aguardar um pouco e forçar nova atualização
            self.root.after(100, self.root.update)
            
            print(f"✅ Tema aplicado com sucesso: {theme}")
            
        except Exception as e:
            print(f"❌ Erro ao aplicar tema {theme}: {e}")
            messagebox.showerror("Erro", f"Erro ao aplicar tema: {e}")
    def create_widgets(self):
        # Criar menu ANTES de qualquer widget
        self.create_menu()
        
        self.main_notebook = ttk.Notebook(self.root)
        self.main_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Criar frames com verificação de segurança
        try:
            main_menu_frame = ttk.Frame(self.main_notebook)
            boards_frame = ttk.Frame(self.main_notebook)
            productivity_main_frame = ttk.Frame(self.main_notebook) # Nova aba de produtividade
            finance_main_frame = ttk.Frame(self.main_notebook)
            calendar_frame = ttk.Frame(self.main_notebook)
            gantt_chart_frame = ttk.Frame(self.main_notebook)
            chat_frame = ttk.Frame(self.main_notebook) # Nova aba de chat
            dashboard_frame = ttk.Frame(self.main_notebook) # Nova aba do Dashboard Executivo
            
            # Verificar se todos os frames foram criados corretamente
            frames = [main_menu_frame, boards_frame, productivity_main_frame, 
                     finance_main_frame, calendar_frame, gantt_chart_frame, 
                     chat_frame, dashboard_frame]
            
            for i, frame in enumerate(frames):
                if frame is None:
                    print(f"❌ Erro: Frame {i} é None")
                    raise Exception(f"Falha ao criar frame {i}")
                    
        except Exception as e:
            print(f"❌ Erro ao criar frames: {e}")
            messagebox.showerror("Erro", f"Erro ao criar interface: {e}")
            raise

        # Adicionar abas com verificação de segurança
        try:
            if main_menu_frame is not None:
                self.main_notebook.add(main_menu_frame, text='Menu Principal')
            if boards_frame is not None:
                self.main_notebook.add(boards_frame, text='Quadros')
            if productivity_main_frame is not None:
                self.main_notebook.add(productivity_main_frame, text='Produtividade') # Adicionada
            if finance_main_frame is not None:
                self.main_notebook.add(finance_main_frame, text='Finanças')
            if calendar_frame is not None:
                self.main_notebook.add(calendar_frame, text='Calendário')
            if gantt_chart_frame is not None:
                self.main_notebook.add(gantt_chart_frame, text='Gráfico de Gantt')
            if chat_frame is not None:
                self.main_notebook.add(chat_frame, text='Chat') # Nova aba de chat
            if dashboard_frame is not None:
                self.main_notebook.add(dashboard_frame, text='Dashboard Executivo') # Nova aba
        except Exception as e:
            print(f"❌ Erro ao adicionar abas ao notebook: {e}")
            messagebox.showerror("Erro", f"Erro ao criar interface: {e}")
        
        # Configurar ícones e texto nas abas principais (se disponíveis)
        try:
            # Menu Principal
            if self.icons.get('home_icon'):
                self.main_notebook.tab(0, text="Menu Principal", image=self.icons.get('home_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(0, text="Menu Principal")
            # Quadros
            if self.icons.get('folder_icon'):
                self.main_notebook.tab(1, text="Quadros", image=self.icons.get('folder_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(1, text="Quadros")
            # Produtividade
            if self.icons.get('play_icon'):
                self.main_notebook.tab(2, text="Produtividade", image=self.icons.get('play_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(2, text="Produtividade")
            # Finanças
            if self.icons.get('money_icon'):
                self.main_notebook.tab(3, text="Finanças", image=self.icons.get('money_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(3, text="Finanças")
            # Calendário
            if self.icons.get('calendar_icon'):
                self.main_notebook.tab(4, text="Calendário", image=self.icons.get('calendar_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(4, text="Calendário")
            # Gráfico de Gantt
            if self.icons.get('gantt_icon'):
                self.main_notebook.tab(5, text="Gráfico de Gantt", image=self.icons.get('gantt_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(5, text="Gráfico de Gantt")
            # Gráfico de Gantt
            if self.icons.get('gantt_icon'):
                self.main_notebook.tab(5, text="Gráfico de Gantt", image=self.icons.get('gantt_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(5, text="Gráfico de Gantt")
            # Chat
            if self.icons.get('chat_icon'):
                self.main_notebook.tab(6, text="Chat", image=self.icons.get('chat_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(6, text="Chat")
            # Dashboard Executivo
            if self.icons.get('dashboard_icon'):
                self.main_notebook.tab(7, text="Dashboard Executivo", image=self.icons.get('dashboard_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(7, text="Dashboard Executivo")
        except Exception as e:
            print(f"Erro ao configurar ícones nas abas principais: {e}")
            # Fallback para texto simples
            try:
                self.main_notebook.tab(0, text="Menu Principal")
                self.main_notebook.tab(1, text="Quadros")
                self.main_notebook.tab(2, text="Produtividade")
                self.main_notebook.tab(3, text="Finanças")
                self.main_notebook.tab(4, text="Calendário")
                self.main_notebook.tab(5, text="Gráfico de Gantt")
                self.main_notebook.tab(6, text="Chat")
                self.main_notebook.tab(7, text="Dashboard Executivo")
            except:
                pass

        # Bind drag-and-drop for main tabs
        self.main_notebook.bind("<ButtonPress-1>", self.on_main_tab_drag_start)
        self.main_notebook.bind("<B1-Motion>", self.on_main_tab_drag_motion)
        self.main_notebook.bind("<ButtonRelease-1>", self.on_main_tab_drag_release)

        self.create_main_menu_tab(main_menu_frame)
        self.create_boards_tab(boards_frame)
        self.create_productivity_sub_tabs(productivity_main_frame) # Novo método
        self.create_finance_sub_tabs(finance_main_frame)
        self.create_calendar_tab(calendar_frame) # Nova aba de calendário
        self.create_gantt_chart_tab(gantt_chart_frame)
        self.create_chat_tab(chat_frame) # Nova aba de chat
        
        # Criar dashboard dinamicamente quando a aba for selecionada
        self.dashboard_frame = dashboard_frame
        self.dashboard_created = False
        self.main_notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
        
        # Ocultar aba do Dashboard Executivo para usuários não-admin
        self.hide_dashboard_for_non_admin()

        # Verificação de prazos será feita APÓS o login

    def on_tab_changed(self, event):
        """Chamado quando uma aba é selecionada"""
        try:
            if not hasattr(self, 'main_notebook') or not self.main_notebook:
                return
                
            current_tab = self.main_notebook.select()
            if not current_tab:
                return
                
            tab_text = self.main_notebook.tab(current_tab, "text")
            if not tab_text:
                return
            
            # Se a aba do Dashboard Executivo foi selecionada e ainda não foi criada
            if tab_text == "Dashboard Executivo" and not self.dashboard_created:
                if hasattr(self, 'dashboard_frame') and self.dashboard_frame:
                    self.create_dashboard_tab(self.dashboard_frame)
                    self.dashboard_created = True
                
        except Exception as e:
            print(f"Erro ao mudar aba: {e}")

    def hide_dashboard_for_non_admin(self):
        """Oculta a aba do Dashboard Executivo para usuários não-admin"""
        try:
            # Encontrar o índice da aba do Dashboard Executivo
            for i in range(self.main_notebook.index("end")):
                tab_text = self.main_notebook.tab(i, "text")
                if tab_text == "Dashboard Executivo":
                    # Verificar se o usuário atual é admin
                    if hasattr(self, 'current_user') and self.current_user:
                        if self.check_admin_access():
                            # Mostrar aba para admin
                            self.main_notebook.tab(i, state="normal")
                        else:
                            # Ocultar aba para usuários não-admin
                            self.main_notebook.tab(i, state="hidden")
                    else:
                        # Se não há usuário logado, ocultar a aba
                        self.main_notebook.tab(i, state="hidden")
                    break
        except Exception as e:
            print(f"Erro ao ocultar dashboard: {e}")

    def show_dashboard_for_admin(self):
        """Mostra a aba do Dashboard Executivo para admins após login"""
        try:
            for i in range(self.main_notebook.index("end")):
                tab_text = self.main_notebook.tab(i, "text")
                if tab_text == "Dashboard Executivo":
                    if self.check_admin_access():
                        self.main_notebook.tab(i, state="normal")
                    else:
                        self.main_notebook.tab(i, state="hidden")
                    break
        except Exception as e:
            print(f"Erro ao mostrar dashboard: {e}")

    def create_calendar_tab(self, parent):
        """Cria a aba de calendário com integração Google Calendar"""
        # Main container
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Top control panel
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Google Calendar connection status
        self.calendar_status_var = tk.StringVar(value="Desconectado")
        status_frame = ttk.LabelFrame(control_frame, text="Status do Google Calendar", padding=5)
        status_frame.pack(side=tk.LEFT, padx=(0, 10))
        
        ttk.Label(status_frame, textvariable=self.calendar_status_var).pack(side=tk.LEFT, padx=5)
        ttk.Button(status_frame, text="Conectar", command=self.connect_google_calendar).pack(side=tk.LEFT, padx=5)
        ttk.Button(status_frame, text="Sincronizar", command=self.sync_calendar_events).pack(side=tk.LEFT, padx=5)
        
        # Calendar controls
        calendar_controls = ttk.Frame(control_frame)
        calendar_controls.pack(side=tk.RIGHT)
        
        ttk.Button(calendar_controls, text="Hoje", command=self.go_to_today).pack(side=tk.LEFT, padx=2)
        ttk.Button(calendar_controls, text="◀", command=self.prev_month).pack(side=tk.LEFT, padx=2)
        ttk.Button(calendar_controls, text="▶", command=self.next_month).pack(side=tk.LEFT, padx=2)
        
        # Calendar display - ocupando toda a largura na parte superior
        calendar_display_frame = ttk.Frame(main_frame)
        calendar_display_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Calendar widget - ocupando toda a largura
        self.calendar_widget = Calendar(
            calendar_display_frame,
            selectmode='day',
            year=datetime.now().year,
            month=datetime.now().month,
            day=datetime.now().day,
            locale='pt_BR'
        )
        self.calendar_widget.pack(fill=tk.X, expand=True)
        
        # Events panel - na parte inferior, ocupando toda a largura
        events_frame = ttk.LabelFrame(main_frame, text="Eventos do Dia", padding=10)
        events_frame.pack(fill=tk.BOTH, expand=True)
        
        # Events list com coluna para tarefas Boodesk
        self.events_tree = ttk.Treeview(events_frame, columns=("Hora", "Evento", "Tarefa Boodesk", "Tipo"), show="headings", height=8)
        self.events_tree.heading("Hora", text="Hora")
        self.events_tree.heading("Evento", text="Evento")
        self.events_tree.heading("Tarefa Boodesk", text="Tarefa Boodesk")
        self.events_tree.heading("Tipo", text="Tipo")
        self.events_tree.column("Hora", width=80)
        self.events_tree.column("Evento", width=300)
        self.events_tree.column("Tarefa Boodesk", width=200)
        self.events_tree.column("Tipo", width=100)
        self.events_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Event actions
        event_actions = ttk.Frame(events_frame)
        event_actions.pack(fill=tk.X)
        
        ttk.Button(event_actions, text="Novo Evento", command=self.create_calendar_event).pack(side=tk.LEFT, padx=2)
        ttk.Button(event_actions, text="Editar", command=self.edit_calendar_event).pack(side=tk.LEFT, padx=2)
        ttk.Button(event_actions, text="Excluir", command=self.delete_calendar_event).pack(side=tk.LEFT, padx=2)
        
        # Bind calendar selection
        self.calendar_widget.bind("<<CalendarSelected>>", self.on_calendar_date_selected)
        
        # Load initial events (sem carregar eventos automaticamente para evitar erros)
        self.mark_due_dates_on_calendar()

    def connect_google_calendar(self):
        """Conecta ao Google Calendar"""
        try:
            if self.google_calendar.authenticate():
                self.calendar_status_var.set("Conectado")
                messagebox.showinfo("Sucesso", "Conectado ao Google Calendar com sucesso!")
                self.load_calendar_events()
            else:
                self.calendar_status_var.set("Erro na conexão")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao conectar ao Google Calendar:\n{e}")

    def sync_calendar_events(self):
        """Sincroniza eventos do Google Calendar"""
        try:
            if self.calendar_status_var.get() == "Conectado":
                events = self.google_calendar.get_upcoming_events(30)  # Próximos 30 dias
                self.load_calendar_events()
                messagebox.showinfo("Sucesso", f"Sincronizados {len(events)} eventos!")
            else:
                messagebox.showwarning("Aviso", "Conecte-se ao Google Calendar primeiro!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao sincronizar eventos:\n{e}")

    def go_to_today(self):
        """Vai para a data de hoje no calendário"""
        today = datetime.now()
        self.calendar_widget.selection_set(today.date())
        self.on_calendar_date_selected()

    def prev_month(self):
        """Mês anterior"""
        current_date = self.calendar_widget.get_date()
        if current_date:
            year, month, day = current_date.split('-')
            prev_month = datetime(int(year), int(month), 1) - timedelta(days=1)
            self.calendar_widget.selection_set(prev_month.date())
            self.on_calendar_date_selected()

    def next_month(self):
        """Próximo mês"""
        current_date = self.calendar_widget.get_date()
        if current_date:
            year, month, day = current_date.split('-')
            next_month = datetime(int(year), int(month), 28) + timedelta(days=4)
            self.calendar_widget.selection_set(next_month.date())
            self.on_calendar_date_selected()

    def on_calendar_date_selected(self, event=None):
        """Chamado quando uma data é selecionada no calendário"""
        try:
            selected_date = self.calendar_widget.get_date()
            if selected_date:
                self.load_events_for_date(selected_date)
        except Exception as e:
            print(f"Erro ao selecionar data no calendário: {e}")

    def load_calendar_events(self):
        """Carrega eventos do calendário"""
        try:
            if self.calendar_status_var.get() == "Conectado":
                events = self.google_calendar.get_upcoming_events(7)  # Próximos 7 dias
                # Aqui você pode processar e exibir os eventos
                pass
            
            # Marcar datas de vencimento dos cards
            self.mark_due_dates_on_calendar()
            
        except Exception as e:
            print(f"Erro ao carregar eventos do calendário: {e}")

    def mark_due_dates_on_calendar(self):
        """Marca as datas de vencimento dos cards no calendário com cores baseadas na importância"""
        try:
            if not hasattr(self, 'calendar_widget') or not self.calendar_widget:
                return
                
            # Limpar eventos existentes de vencimento
            self.calendar_widget.calevent_remove('all')
            
            # Obter cores de importância
            importance_colors = self.settings.get("importance_colors", {})
            
            # Adicionar eventos para cada card com data de vencimento
            for board_name, lists in self.boodesk_data["boards"].items():
                if isinstance(lists, dict):
                    for list_name, cards in lists.items():
                        if isinstance(cards, list):
                            for card in cards:
                                if card.get("due_date") and not card.get("is_archived", False):
                                    try:
                                        # Usar função auxiliar para processar data brasileira
                                        due_date_obj = self.parse_brazilian_date(card["due_date"])
                                        if due_date_obj:
                                            # Obter importância do card
                                            importance = card.get("importance", "Normal")
                                            
                                            # Criar evento no calendário com tag baseada na importância
                                            event_text = f"📋 {card['title']}"
                                            tag_name = f'due_date_{importance.lower().replace(" ", "_")}'
                                            self.calendar_widget.calevent_create(due_date_obj.date(), event_text, tag_name)
                                            
                                            # Configurar cor baseada na importância
                                            bg_color = importance_colors.get(importance, "#FF6B6B")
                                            self.calendar_widget.tag_config(tag_name, background=bg_color, foreground='black')
                                    
                                    except Exception as e:
                                        print(f"Erro ao processar data do card {card.get('title', '')}: {e}")
                                        continue
            
        except Exception as e:
            print(f"Erro ao marcar datas de vencimento no calendário: {e}")

    def load_events_for_date(self, date_str):
        """Carrega eventos para uma data específica"""
        try:
            # Limpar lista atual
            for item in self.events_tree.get_children():
                self.events_tree.delete(item)
            
            # Converter string para datetime usando função auxiliar
            date_obj = self.parse_brazilian_date(date_str)
            if not date_obj:
                print(f"Formato de data inválido: {date_str}")
                return
            
            # Buscar eventos do Google Calendar (apenas se estiver conectado)
            if hasattr(self, 'calendar_status_var') and self.calendar_status_var.get() == "Conectado":
                try:
                    events = self.google_calendar.get_upcoming_events(1)  # Apenas o dia selecionado
                    
                    for event in events:
                        start = event.get('start', {}).get('dateTime', '')
                        if start:
                            try:
                                start_time = datetime.fromisoformat(start.replace('Z', '+00:00'))
                                if start_time.date() == date_obj.date():
                                    self.events_tree.insert("", "end", values=(
                                        start_time.strftime("%H:%M"),
                                        event.get('summary', 'Sem título'),
                                        "Google Calendar"
                                    ))
                            except Exception as e:
                                print(f"Erro ao processar evento do Google Calendar: {e}")
                                continue
                except Exception as e:
                    print(f"Erro ao buscar eventos do Google Calendar: {e}")
            
            # Buscar tarefas do Boodesk para esta data
            if hasattr(self, 'boodesk_data') and self.boodesk_data:
                importance_colors = self.settings.get("importance_colors", {})
                
                for board_name, board_data in self.boodesk_data.get('boards', {}).items():
                    if isinstance(board_data, dict):
                        for list_name, cards in board_data.items():
                            if list_name != 'workflow' and isinstance(cards, list):
                                for card in cards:
                                    due_date = card.get('due_date', '')
                                    if due_date:
                                        try:
                                            # Usar função auxiliar para processar data brasileira
                                            card_date = self.parse_brazilian_date(due_date)
                                            
                                            if card_date and card_date.date() == date_obj.date():
                                                # Determinar horário para exibição
                                                display_time = "09:00"  # Horário padrão
                                                if ' ' in due_date and len(due_date.split(' ')) > 1:
                                                    time_part = due_date.split(' ')[1]
                                                    if ':' in time_part:
                                                        display_time = time_part[:5]  # HH:MM
                                                
                                                # Obter importância do card
                                                importance = card.get("importance", "Normal")
                                                
                                                # Inserir item na treeview
                                                item_id = self.events_tree.insert("", "end", values=(
                                                    display_time,
                                                    f"[{board_name}] {card['title']}",
                                                    card.get('title', ''),
                                                    "Tarefa Boodesk"
                                                ))
                                                
                                                # Aplicar cor baseada na importância
                                                bg_color = importance_colors.get(importance, "#FFFFFF")
                                                self.events_tree.tag_configure(f"importance_{importance.lower().replace(' ', '_')}", background=bg_color)
                                                self.events_tree.item(item_id, tags=(f"importance_{importance.lower().replace(' ', '_')}",))
                                                
                                        except Exception as e:
                                            print(f"Erro ao processar data do card {card.get('title', '')}: {e}")
                                            continue
                                    
        except Exception as e:
            print(f"Erro ao carregar eventos para a data: {e}")

    def create_calendar_event(self):
        """Cria um novo evento no calendário"""
        try:
            selected_date = self.calendar_widget.get_date()
            if not selected_date:
                messagebox.showwarning("Aviso", "Selecione uma data primeiro!")
                return
            
            # Abrir janela de criação de evento
            self.open_event_creation_window(selected_date)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao criar evento:\n{e}")

    def edit_calendar_event(self):
        """Edita um evento selecionado"""
        try:
            selected_item = self.events_tree.selection()
            if not selected_item:
                messagebox.showwarning("Aviso", "Selecione um evento para editar!")
                return
            
            # Implementar edição de evento
            messagebox.showinfo("Info", "Funcionalidade de edição será implementada em breve!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao editar evento:\n{e}")

    def delete_calendar_event(self):
        """Exclui um evento selecionado"""
        try:
            selected_item = self.events_tree.selection()
            if not selected_item:
                messagebox.showwarning("Aviso", "Selecione um evento para excluir!")
                return
            
            if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir este evento?"):
                # Implementar exclusão de evento
                self.events_tree.delete(selected_item)
                messagebox.showinfo("Sucesso", "Evento excluído com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao excluir evento:\n{e}")

    def open_event_creation_window(self, date_str):
        """Abre janela para criar novo evento"""
        try:
            event_window = CalendarEventWindow(self, date_str)
            event_window.grab_set()
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir janela de evento:\n{e}")

    def create_dashboard_tab(self, parent):
        """Cria a aba do Dashboard Executivo com métricas avançadas (apenas para administradores)"""
        # Verificar se já foi criado para evitar duplicação
        if hasattr(self, 'dashboard_created') and self.dashboard_created:
            return
            
        # Verificar se o usuário é administrador
        if not self.check_admin_access():
            # Se não for admin, mostrar mensagem de acesso negado
            access_denied_frame = ttk.Frame(parent)
            access_denied_frame.pack(fill=tk.BOTH, expand=True)
            
            ttk.Label(access_denied_frame, 
                     text="🔒 Acesso Restrito", 
                     font=("Arial", 24, "bold"),
                     foreground="red").pack(pady=50)
            
            ttk.Label(access_denied_frame, 
                     text="Esta área é restrita apenas para administradores.\n\n"
                          "O Dashboard Executivo contém métricas sensíveis e\n"
                          "análises avançadas de produtividade da equipe.",
                     font=("Arial", 12),
                     justify=tk.CENTER).pack(pady=20)
            
            ttk.Button(access_denied_frame, 
                      text="Voltar ao Menu Principal",
                      command=lambda: self.main_notebook.select(0)).pack(pady=20)
            return

        # Limpar o frame pai antes de criar o dashboard
        for widget in parent.winfo_children():
            widget.destroy()
            
        # Main container para o dashboard com estilo melhorado
        main_frame = ttk.Frame(parent, style="Dashboard.TFrame")
        main_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=15)
        
        # Título do dashboard com estilo moderno
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 25))
        
        # Título com ícone e estilo melhorado
        title_label = ttk.Label(title_frame, 
                 text="📊 Dashboard Executivo", 
                               font=("Arial", 24, "bold"),
                               foreground="#2c3e50")
        title_label.pack(side=tk.LEFT)
        
        # Botões de controle com ícones
        control_frame = ttk.Frame(title_frame)
        control_frame.pack(side=tk.RIGHT)
        
        # Botão Atualizar com ícone
        refresh_btn = ttk.Button(control_frame, 
                                text="Atualizar", 
                                image=self.icons.get('refresh_icon_32'), 
                                compound=tk.LEFT,
                                command=self.refresh_dashboard)
        refresh_btn.pack(side=tk.LEFT, padx=5)
        
        # Botão Exportar com ícone
        export_btn = ttk.Button(control_frame, 
                               text="Exportar Relatório", 
                               image=self.icons.get('export_icon_32'), 
                               compound=tk.LEFT,
                               command=self.export_dashboard_report)
        export_btn.pack(side=tk.LEFT, padx=5)
        
        # Notebook para organizar as seções do dashboard
        dashboard_notebook = ttk.Notebook(main_frame)
        dashboard_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Aba 1: Métricas Gerais com ícone
        metrics_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(metrics_frame, 
                              text="Métricas Gerais", 
                              image=self.icons.get('chart_icon_32'), 
                              compound=tk.LEFT)
        self.create_metrics_tab(metrics_frame)
        
        # Aba 2: Performance da Equipe com ícone
        team_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(team_frame, 
                              text="Performance da Equipe", 
                              image=self.icons.get('team_icon_32'), 
                              compound=tk.LEFT)
        self.create_team_performance_tab(team_frame)
        
        # Aba 3: Análise de Tempo com ícone
        time_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(time_frame, 
                              text="Análise de Tempo", 
                              image=self.icons.get('clock_icon_32'), 
                              compound=tk.LEFT)
        self.create_time_analysis_tab(time_frame)
        
        # Aba 4: Gráficos de Burndown com ícone
        burndown_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(burndown_frame, 
                              text="Gráficos de Burndown", 
                              image=self.icons.get('burndown_icon_32'), 
                              compound=tk.LEFT)
        self.create_burndown_tab(burndown_frame)
        
        # Aba 5: Previsões IA com ícone
        predictions_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(predictions_frame, 
                              text="Previsões IA", 
                              image=self.icons.get('ai_icon_32'), 
                              compound=tk.LEFT)
        self.create_predictions_tab(predictions_frame)
        
        # Aba 6: Próximas Reuniões com ícone
        meetings_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(meetings_frame, 
                              text="Próximas Reuniões", 
                              image=self.icons.get('meeting_icon_32'), 
                              compound=tk.LEFT)
        self.create_meetings_tab(meetings_frame)
        
        # Marcar como criado para evitar duplicação
        self.dashboard_created = True

    def check_admin_access(self):
        """Verifica se o usuário atual tem acesso de administrador"""
        if not hasattr(self, 'current_user') or not self.current_user:
            return False
        
        # Verificar se o usuário tem role de administrador
        user_role = getattr(self.current_user, 'role', None)
        if user_role in ['admin', 'Administrador', 'manager']:
            return True
        
        # Verificar se o usuário tem cargo de administrador
        user_cargo = getattr(self.current_user, 'cargo', None)
        if user_cargo in ['Administrador', 'Gerente', 'Manager']:
            return True
        
        # Verificar se o username é 'admin' (fallback)
        username = getattr(self.current_user, 'username', None)
        if username == 'admin':
            return True
        
        return False

    def create_metrics_tab(self, parent):
        """Cria a aba de métricas gerais com design moderno"""
        # Frame principal com scroll e estilo melhorado
        canvas = tk.Canvas(parent, bg="#f8f9fa", highlightthickness=0)
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Métricas em tempo real com estilo moderno
        metrics_frame = ttk.LabelFrame(scrollable_frame, text="📊 Métricas em Tempo Real", padding=15)
        metrics_frame.pack(fill=tk.X, pady=15, padx=15)
        
        # Grid para métricas com espaçamento melhorado
        metrics_frame.columnconfigure(0, weight=1)
        metrics_frame.columnconfigure(1, weight=1)
        metrics_frame.columnconfigure(2, weight=1)
        metrics_frame.columnconfigure(3, weight=1)
        
        # Métricas calculadas
        total_cards, completed_cards, pending_cards, overdue_cards = self.calculate_card_metrics()
        total_members = len(self.members)
        avg_completion_time = self.calculate_avg_completion_time()
        productivity_score = self.calculate_productivity_score()
        
        # Exibir métricas com ícones
        self.create_metric_card(metrics_frame, "📋 Total de Tarefas", total_cards, 0, 0, "#3498db")
        self.create_metric_card(metrics_frame, "✅ Concluídas", completed_cards, 0, 1, "#27ae60")
        self.create_metric_card(metrics_frame, "⏳ Pendentes", pending_cards, 0, 2, "#f39c12")
        self.create_metric_card(metrics_frame, "⚠️ Vencidas", overdue_cards, 0, 3, "#e74c3c")
        
        self.create_metric_card(metrics_frame, "👥 Membros Ativos", total_members, 1, 0, "#9b59b6")
        self.create_metric_card(metrics_frame, "⏱️ Tempo Médio", f"{avg_completion_time:.1f}h", 1, 1, "#34495e")
        self.create_metric_card(metrics_frame, "📈 Produtividade", f"{productivity_score:.1f}%", 1, 2, "#1abc9c")
        self.create_metric_card(metrics_frame, "🎯 Taxa de Sucesso", f"{(completed_cards/total_cards*100):.1f}%" if total_cards > 0 else "0%", 1, 3, "#e67e22")
        
        # Gráfico de pizza para distribuição de tarefas
        chart_frame = ttk.LabelFrame(scrollable_frame, text="📊 Distribuição por Status", padding=15)
        chart_frame.pack(fill=tk.X, pady=15, padx=15)
        
        self.create_pie_chart(chart_frame, completed_cards, pending_cards, overdue_cards)
        
        # Botões de ação com estilo moderno
        button_frame = ttk.Frame(scrollable_frame)
        button_frame.pack(fill=tk.X, pady=15, padx=15)
        
        # Botões com ícones e cores
        refresh_btn = ttk.Button(button_frame, 
                                text="Atualizar Dados", 
                                image=self.icons.get('refresh_icon_32'), 
                                compound=tk.LEFT, 
                                command=self.refresh_dashboard)
        refresh_btn.pack(side=tk.LEFT, padx=8)
        
        export_btn = ttk.Button(button_frame, 
                               text="Exportar Relatório", 
                               image=self.icons.get('export_icon_32'), 
                               compound=tk.LEFT, 
                               command=self.export_dashboard_report)
        export_btn.pack(side=tk.LEFT, padx=8)
        
        chart_btn = ttk.Button(button_frame, 
                              text="Gerar Gráfico", 
                              image=self.icons.get('chart_xy_icon_32'), 
                              compound=tk.LEFT, 
                              command=self.generate_metrics_chart)
        chart_btn.pack(side=tk.LEFT, padx=8)

    def create_metric_card(self, parent, title, value, row, col, color="#3498db"):
        """Cria um card de métrica com design moderno"""
        # Frame principal do card com estilo moderno
        card_frame = tk.Frame(parent, bg=color, relief="flat", bd=0, highlightthickness=1, highlightbackground="#bdc3c7")
        card_frame.grid(row=row, column=col, padx=8, pady=8, sticky="nsew")
        
        # Configurar peso das colunas para distribuição uniforme
        parent.columnconfigure(col, weight=1)
        parent.rowconfigure(row, weight=1)
        
        # Frame interno com padding
        inner_frame = tk.Frame(card_frame, bg="white", relief="flat", bd=0)
        inner_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        # Título com estilo moderno
        title_label = tk.Label(inner_frame, 
                              text=title, 
                              font=("Arial", 11, "bold"),
                              bg="white",
                              fg="#2c3e50",
                              wraplength=120,
                              justify=tk.CENTER)
        title_label.pack(pady=(12, 8))
        
        # Valor com estilo destacado
        value_label = tk.Label(inner_frame, 
                              text=str(value), 
                              font=("Arial", 20, "bold"),
                              bg="white",
                              fg=color)
        value_label.pack(pady=(0, 12))
        
        # Efeito hover (opcional)
        def on_enter(e):
            card_frame.configure(highlightbackground=color, highlightthickness=2)
            
        def on_leave(e):
            card_frame.configure(highlightbackground="#bdc3c7", highlightthickness=1)
            
        card_frame.bind("<Enter>", on_enter)
        card_frame.bind("<Leave>", on_leave)
        title_label.bind("<Enter>", on_enter)
        title_label.bind("<Leave>", on_leave)
        value_label.bind("<Enter>", on_enter)
        value_label.bind("<Leave>", on_leave)

    def calculate_card_metrics(self):
        """Calcula métricas básicas dos cards"""
        total_cards = 0
        completed_cards = 0
        pending_cards = 0
        overdue_cards = 0
        
        today = datetime.now().date()
        
        for board_name, lists in self.boodesk_data["boards"].items():
            for list_name, cards in lists.items():
                for card in cards:
                    if not card.get("is_archived", False):
                        total_cards += 1
                        
                        # Verificar status baseado na lista
                        if list_name in ["Concluído", "Done", "Finalizado"]:
                            completed_cards += 1
                        else:
                            pending_cards += 1
                            
                            # Verificar se está vencido
                            due_date = card.get("due_date", "")
                            if due_date:
                                try:
                                    due_date_obj = self.parse_brazilian_date(due_date)
                                    if due_date_obj and due_date_obj.date() < today:
                                        overdue_cards += 1
                                except:
                                    pass
        
        return total_cards, completed_cards, pending_cards, overdue_cards

    def calculate_avg_completion_time(self):
        """Calcula tempo médio de conclusão (simulado)"""
        # Simulação baseada em dados históricos
        return 4.5  # horas

    def calculate_productivity_score(self):
        """Calcula score de produtividade"""
        total_cards, completed_cards, pending_cards, overdue_cards = self.calculate_card_metrics()
        
        if total_cards == 0:
            return 0
        
        # Score baseado em conclusões vs vencimentos
        completion_rate = completed_cards / total_cards * 100
        overdue_penalty = (overdue_cards / total_cards * 100) if total_cards > 0 else 0
        
        return max(0, completion_rate - overdue_penalty)

    def create_pie_chart(self, parent, completed, pending, overdue):
        """Cria gráfico de pizza moderno com barras horizontais"""
        # Frame para o gráfico com estilo moderno
        chart_frame = tk.Frame(parent, bg="white", relief="flat", bd=0)
        chart_frame.pack(fill=tk.X, pady=15)
        
        # Dados para o gráfico
        data = [completed, pending, overdue]
        labels = ["✅ Concluídas", "⏳ Pendentes", "⚠️ Vencidas"]
        colors = ["#27ae60", "#f39c12", "#e74c3c"]
        
        # Criar representação visual moderna
        total = sum(data)
        if total == 0:
            no_data_frame = tk.Frame(chart_frame, bg="white")
            no_data_frame.pack(fill=tk.X, pady=20)
            
            no_data_label = tk.Label(no_data_frame, 
                                   text="📊 Nenhum dado disponível", 
                                   font=("Arial", 14, "bold"),
                                   bg="white",
                                   fg="#7f8c8d")
            no_data_label.pack()
            return
        
        # Criar barras horizontais modernas
        for i, (value, label, color) in enumerate(zip(data, labels, colors)):
            if value > 0:
                percentage = (value / total) * 100
                
                # Container para cada barra
                bar_container = tk.Frame(chart_frame, bg="white", relief="flat", bd=0)
                bar_container.pack(fill=tk.X, pady=8)
                
                # Frame para label e valor
                label_frame = tk.Frame(bar_container, bg="white")
                label_frame.pack(fill=tk.X, pady=(0, 5))
                
                # Label com ícone
                label_widget = tk.Label(label_frame, 
                                       text=f"{label}: {value} ({percentage:.1f}%)", 
                                       font=("Arial", 11, "bold"),
                                       bg="white",
                                       fg="#2c3e50",
                                       anchor="w")
                label_widget.pack(side=tk.LEFT)
                
                # Frame para a barra
                bar_frame = tk.Frame(bar_container, bg="#ecf0f1", relief="flat", bd=0, height=25)
                bar_frame.pack(fill=tk.X)
                bar_frame.pack_propagate(False)
                
                # Barra colorida com bordas arredondadas
                bar_width = int((percentage / 100) * 400)  # Largura máxima de 400px
                bar = tk.Frame(bar_frame, bg=color, relief="flat", bd=0, width=bar_width, height=20)
                bar.pack(side=tk.LEFT, padx=2, pady=2)
                
                # Efeito hover na barra
                def on_enter(e, bar=bar, color=color):
                    bar.configure(bg=self.lighten_color(color))
                    
                def on_leave(e, bar=bar, color=color):
                    bar.configure(bg=color)
                    
                bar.bind("<Enter>", on_enter)
                bar.bind("<Leave>", on_leave)
                label_widget.bind("<Enter>", on_enter)
                label_widget.bind("<Leave>", on_leave)
    
    def lighten_color(self, color):
        """Clareia uma cor para efeito hover"""
        # Converter cor hex para RGB
        color = color.lstrip('#')
        r, g, b = tuple(int(color[i:i+2], 16) for i in (0, 2, 4))
        
        # Clarear a cor
        r = min(255, int(r * 1.2))
        g = min(255, int(g * 1.2))
        b = min(255, int(b * 1.2))
        
        # Converter de volta para hex
        return f"#{r:02x}{g:02x}{b:02x}"

    def create_team_performance_tab(self, parent):
        """Cria a aba de performance da equipe"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Título
        ttk.Label(main_frame, text="👥 Performance Individual da Equipe", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Treeview para performance dos membros
        columns = ("Membro", "Tarefas Concluídas", "Tarefas Pendentes", "Taxa de Conclusão", "Tempo Médio", "Score")
        self.team_tree = ttk.Treeview(main_frame, columns=columns, show="headings", height=10)
        
        for col in columns:
            self.team_tree.heading(col, text=col)
            self.team_tree.column(col, width=150, anchor="center")
        
        self.team_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=self.team_tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.team_tree.configure(yscrollcommand=scrollbar.set)
        
        # Botões de ação
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(button_frame, text="Atualizar Dados", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_team_performance).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(button_frame, text="Gerar Relatório", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.generate_team_report).pack(side=tk.LEFT, padx=5)
        
        # Carregar dados iniciais
        self.load_team_performance_data()

    def load_team_performance_data(self):
        """Carrega dados de performance da equipe"""
        # Limpar dados existentes
        for item in self.team_tree.get_children():
            self.team_tree.delete(item)
        
        # Calcular performance para cada membro
        for member in self.members:
            member_name = member['Membro']
            completed, pending, avg_time, completion_rate = self.calculate_member_performance(member_name)
            
            # Calcular score baseado em performance
            score = self.calculate_member_score(completed, pending, completion_rate)
            
            self.team_tree.insert("", "end", values=(
                member_name,
                completed,
                pending,
                f"{completion_rate:.1f}%",
                f"{avg_time:.1f}h",
                f"{score:.1f}"
            ))

    def calculate_member_performance(self, member_name):
        """Calcula performance de um membro específico"""
        completed = 0
        pending = 0
        total_time = 0
        completed_tasks = 0
        
        for board_name, lists in self.boodesk_data["boards"].items():
            for list_name, cards in lists.items():
                for card in cards:
                    if not card.get("is_archived", False):
                        card_members = card.get("members", [])
                        if member_name in card_members:
                            if list_name in ["Concluído", "Done", "Finalizado"]:
                                completed += 1
                                completed_tasks += 1
                                # Simular tempo de conclusão
                                total_time += 4.5  # horas médias
                            else:
                                pending += 1
        
        avg_time = total_time / completed_tasks if completed_tasks > 0 else 0
        completion_rate = (completed / (completed + pending)) * 100 if (completed + pending) > 0 else 0
        
        return completed, pending, avg_time, completion_rate

    def calculate_member_score(self, completed, pending, completion_rate):
        """Calcula score de um membro"""
        base_score = completion_rate
        efficiency_bonus = min(completed * 2, 20)  # Bônus por tarefas concluídas
        return min(100, base_score + efficiency_bonus)

    def create_time_analysis_tab(self, parent):
        """Cria a aba de análise de tempo"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Título
        ttk.Label(main_frame, text="Análise de Tempo por Categoria/Projeto", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(control_frame, text="Período:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.time_period_var = tk.StringVar(value="Últimos 30 dias")
        period_combo = ttk.Combobox(control_frame, 
                                   textvariable=self.time_period_var,
                                   values=["Últimos 7 dias", "Últimos 30 dias", "Últimos 90 dias", "Este ano"],
                                   state="readonly")
        period_combo.pack(side=tk.LEFT, padx=(0, 20))
        period_combo.bind("<<ComboboxSelected>>", lambda e: self.refresh_time_analysis())
        
        ttk.Button(control_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_time_analysis).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Exportar Dados", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.export_time_analysis).pack(side=tk.LEFT, padx=5)
        
        # Notebook para diferentes visualizações
        time_notebook = ttk.Notebook(main_frame)
        time_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Aba 1: Tempo por Categoria
        category_frame = ttk.Frame(time_notebook)
        time_notebook.add(category_frame, text="Por Categoria")
        self.create_time_category_view(category_frame)
        
        # Aba 2: Tempo por Projeto
        project_frame = ttk.Frame(time_notebook)
        time_notebook.add(project_frame, text="Por Projeto")
        self.create_time_project_view(project_frame)
        
        # Aba 3: Tendências
        trends_frame = ttk.Frame(time_notebook)
        time_notebook.add(trends_frame, text="Tendências")
        self.create_time_trends_view(trends_frame)

    def create_time_category_view(self, parent):
        """Cria visualização de tempo por categoria"""
        # Treeview para categorias
        columns = ("Categoria", "Tempo Total (h)", "Tarefas", "Tempo Médio", "Porcentagem")
        self.category_tree = ttk.Treeview(parent, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.category_tree.heading(col, text=col)
            self.category_tree.column(col, width=150, anchor="center")
        
        self.category_tree.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Carregar dados
        self.load_time_category_data()

    def load_time_category_data(self):
        """Carrega dados de tempo por categoria"""
        # Limpar dados existentes
        for item in self.category_tree.get_children():
            self.category_tree.delete(item)
        
        # Calcular tempo por categoria (simulado)
        categories = {}
        total_time = 0
        
        for board_name, lists in self.boodesk_data["boards"].items():
            for list_name, cards in lists.items():
                for card in cards:
                    if not card.get("is_archived", False):
                        category = card.get("subject", "Sem categoria")
                        if category not in categories:
                            categories[category] = {"time": 0, "tasks": 0}
                        
                        # Simular tempo baseado na importância
                        importance = card.get("importance", "Normal")
                        time_multiplier = {"Crítica": 8, "Alta": 6, "Normal": 4, "Baixa": 2}
                        estimated_time = time_multiplier.get(importance, 4)
                        
                        categories[category]["time"] += estimated_time
                        categories[category]["tasks"] += 1
                        total_time += estimated_time
        
        # Inserir dados na treeview
        for category, data in categories.items():
            percentage = (data["time"] / total_time * 100) if total_time > 0 else 0
            avg_time = data["time"] / data["tasks"] if data["tasks"] > 0 else 0
            
            self.category_tree.insert("", "end", values=(
                category,
                f"{data['time']:.1f}",
                data["tasks"],
                f"{avg_time:.1f}h",
                f"{percentage:.1f}%"
            ))

    def create_time_project_view(self, parent):
        """Cria visualização de tempo por projeto"""
        # Treeview para projetos
        columns = ("Projeto", "Tempo Total (h)", "Tarefas", "Progresso", "Prazo")
        self.project_tree = ttk.Treeview(parent, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.project_tree.heading(col, text=col)
            self.project_tree.column(col, width=150, anchor="center")
        
        self.project_tree.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Carregar dados
        self.load_time_project_data()

    def load_time_project_data(self):
        """Carrega dados de tempo por projeto"""
        # Limpar dados existentes
        for item in self.project_tree.get_children():
            self.project_tree.delete(item)
        
        # Calcular tempo por projeto (baseado nos quadros)
        projects = {}
        
        for board_name, lists in self.boodesk_data["boards"].items():
            if board_name not in projects:
                projects[board_name] = {"time": 0, "tasks": 0, "completed": 0, "total": 0}
            
            for list_name, cards in lists.items():
                for card in cards:
                    if not card.get("is_archived", False):
                        projects[board_name]["total"] += 1
                        
                        if list_name in ["Concluído", "Done", "Finalizado"]:
                            projects[board_name]["completed"] += 1
                        
                        # Simular tempo
                        importance = card.get("importance", "Normal")
                        time_multiplier = {"Crítica": 8, "Alta": 6, "Normal": 4, "Baixa": 2}
                        estimated_time = time_multiplier.get(importance, 4)
                        
                        projects[board_name]["time"] += estimated_time
                        projects[board_name]["tasks"] += 1
        
        # Inserir dados na treeview
        for project, data in projects.items():
            progress = (data["completed"] / data["total"] * 100) if data["total"] > 0 else 0
            
            self.project_tree.insert("", "end", values=(
                project,
                f"{data['time']:.1f}",
                data["tasks"],
                f"{progress:.1f}%",
                "Em andamento"
            ))

    def create_time_trends_view(self, parent):
        """Cria visualização de tendências de tempo"""
        # Frame para gráfico de tendências
        trends_frame = ttk.Frame(parent)
        trends_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        ttk.Label(trends_frame, text="📈 Tendências de Produtividade", 
                 font=("Arial", 14, "bold")).pack(pady=(0, 20))
        
        # Simular dados de tendência
        weeks = ["Semana 1", "Semana 2", "Semana 3", "Semana 4"]
        productivity = [75, 82, 78, 85]
        
        # Criar gráfico simples
        chart_frame = ttk.Frame(trends_frame)
        chart_frame.pack(fill=tk.BOTH, expand=True)
        
        # Criar barras para cada semana
        for i, (week, prod) in enumerate(zip(weeks, productivity)):
            week_frame = ttk.Frame(chart_frame)
            week_frame.pack(fill=tk.X, pady=5)
            
            ttk.Label(week_frame, text=week, width=15).pack(side=tk.LEFT)
            
            # Barra de produtividade
            bar = tk.Frame(week_frame, bg="#4CAF50", height=20)
            bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(10, 0))
            
            # Configurar largura baseada na produtividade
            bar.configure(width=int(prod * 3))
            
            ttk.Label(week_frame, text=f"{prod}%", width=8).pack(side=tk.LEFT, padx=(10, 0))

    def create_burndown_tab(self, parent):
        """Cria a aba de gráficos de burndown"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Título
        ttk.Label(main_frame, text="Gráficos de Burndown - Metodologia Ágil", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(control_frame, text="Sprint:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.sprint_var = tk.StringVar(value="Sprint Atual")
        sprint_combo = ttk.Combobox(control_frame, 
                                   textvariable=self.sprint_var,
                                   values=["Sprint Atual", "Sprint Anterior", "Próximo Sprint"],
                                   state="readonly")
        sprint_combo.pack(side=tk.LEFT, padx=(0, 20))
        sprint_combo.bind("<<ComboboxSelected>>", lambda e: self.refresh_burndown())
        
        ttk.Button(control_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_burndown).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Gerar Relatório", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT,
                  command=self.generate_burndown_report).pack(side=tk.LEFT, padx=5)
        
        # Frame para o gráfico
        chart_frame = ttk.LabelFrame(main_frame, text="Gráfico de Burndown", padding=10)
        chart_frame.pack(fill=tk.BOTH, expand=True)
        
        # Criar gráfico de burndown simples
        self.create_burndown_chart(chart_frame)

    def create_burndown_chart(self, parent):
        """Cria gráfico de burndown"""
        # Frame para o gráfico
        chart_frame = ttk.Frame(parent)
        chart_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Dados simulados para burndown
        days = ["Dia 1", "Dia 2", "Dia 3", "Dia 4", "Dia 5", "Dia 6", "Dia 7", "Dia 8", "Dia 9", "Dia 10"]
        ideal = [100, 90, 80, 70, 60, 50, 40, 30, 20, 10]  # Linha ideal
        actual = [100, 95, 85, 75, 70, 60, 50, 45, 35, 25]  # Linha real
        
        # Criar representação visual
        for i, (day, ideal_val, actual_val) in enumerate(zip(days, ideal, actual)):
            day_frame = ttk.Frame(chart_frame)
            day_frame.pack(fill=tk.X, pady=2)
            
            ttk.Label(day_frame, text=day, width=10).pack(side=tk.LEFT)
            
            # Linha ideal (verde)
            ideal_bar = tk.Frame(day_frame, bg="#4CAF50", height=15)
            ideal_bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 2))
            ideal_bar.configure(width=int(ideal_val * 2))
            
            # Linha real (azul)
            actual_bar = tk.Frame(day_frame, bg="#2196F3", height=15)
            actual_bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(2, 5))
            actual_bar.configure(width=int(actual_val * 2))
            
            # Valores
            ttk.Label(day_frame, text=f"I: {ideal_val}%", width=8).pack(side=tk.LEFT, padx=(5, 0))
            ttk.Label(day_frame, text=f"R: {actual_val}%", width=8).pack(side=tk.LEFT, padx=(5, 0))
        
        # Legenda
        legend_frame = ttk.Frame(chart_frame)
        legend_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(legend_frame, text="Legenda:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        
        ideal_legend = tk.Frame(legend_frame, bg="#4CAF50", width=20, height=15)
        ideal_legend.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Label(legend_frame, text="Ideal").pack(side=tk.LEFT, padx=(0, 20))
        
        actual_legend = tk.Frame(legend_frame, bg="#2196F3", width=20, height=15)
        actual_legend.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Label(legend_frame, text="Real").pack(side=tk.LEFT)

    def create_predictions_tab(self, parent):
        """Cria a aba de previsões IA"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Título
        ttk.Label(main_frame, text="Previsões de IA - Estimativas Inteligentes", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Button(control_frame, text="Gerar Previsões", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT,
                  command=self.generate_ai_predictions).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Atualizar Modelo", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.update_ai_model).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Exportar Previsões", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.export_ai_predictions).pack(side=tk.LEFT, padx=5)
        
        # Frame para previsões
        predictions_frame = ttk.LabelFrame(main_frame, text="Previsões de Conclusão", padding=10)
        predictions_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para previsões
        columns = ("Projeto", "Tarefas Restantes", "Tempo Estimado", "Data Prevista", "Confiança", "Risco")
        self.predictions_tree = ttk.Treeview(predictions_frame, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.predictions_tree.heading(col, text=col)
            self.predictions_tree.column(col, width=120, anchor="center")
        
        self.predictions_tree.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Carregar previsões iniciais
        self.load_ai_predictions()

    def load_ai_predictions(self):
        """Carrega previsões de IA"""
        # Limpar dados existentes
        for item in self.predictions_tree.get_children():
            self.predictions_tree.delete(item)
        
        # Gerar previsões simuladas
        predictions = self.generate_simulated_predictions()
        
        for prediction in predictions:
            self.predictions_tree.insert("", "end", values=prediction)

    def generate_simulated_predictions(self):
        """Gera previsões simuladas baseadas nos dados atuais"""
        predictions = []
        
        for board_name, lists in self.boodesk_data["boards"].items():
            pending_tasks = 0
            total_estimated_time = 0
            
            for list_name, cards in lists.items():
                if list_name not in ["Concluído", "Done", "Finalizado"]:
                    for card in cards:
                        if not card.get("is_archived", False):
                            pending_tasks += 1
                            
                            # Estimativa baseada na importância
                            importance = card.get("importance", "Normal")
                            time_multiplier = {"Crítica": 8, "Alta": 6, "Normal": 4, "Baixa": 2}
                            estimated_time = time_multiplier.get(importance, 4)
                            total_estimated_time += estimated_time
            
            if pending_tasks > 0:
                # Calcular data prevista
                avg_time_per_task = total_estimated_time / pending_tasks
                days_to_complete = (total_estimated_time / 8)  # 8 horas por dia
                
                from datetime import timedelta
                predicted_date = datetime.now() + timedelta(days=days_to_complete)
                
                # Calcular confiança baseada na consistência dos dados
                confidence = min(95, 70 + (pending_tasks * 2))  # Mais tarefas = mais dados = mais confiança
                
                # Determinar risco
                if days_to_complete > 30:
                    risk = "Alto"
                elif days_to_complete > 15:
                    risk = "Médio"
                else:
                    risk = "Baixo"
                
                predictions.append((
                    board_name,
                    pending_tasks,
                    f"{total_estimated_time:.1f}h",
                    predicted_date.strftime("%d/%m/%Y"),
                    f"{confidence:.0f}%",
                    risk
                ))
    
    def create_meetings_tab(self, parent):
        """Cria a aba de próximas reuniões"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Título
        ttk.Label(main_frame, text="Próximas Reuniões - Agendamento e Links", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Button(control_frame, text="Nova Reunião", image=self.icons.get('add_icon'), compound=tk.LEFT,
                  command=self.create_new_meeting).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_meetings).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Exportar Agenda", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.export_meetings_agenda).pack(side=tk.LEFT, padx=5)
        
        # Frame para reuniões
        meetings_frame = ttk.LabelFrame(main_frame, text="Reuniões Agendadas", padding=10)
        meetings_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para reuniões
        columns = ("Data", "Hora", "Título", "Projeto", "Plataforma", "Criado por", "Link")
        self.meetings_tree = ttk.Treeview(meetings_frame, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.meetings_tree.heading(col, text=col)
            self.meetings_tree.column(col, width=100, anchor="center")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(meetings_frame, orient="vertical", command=self.meetings_tree.yview)
        self.meetings_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.meetings_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Frame para ações
        actions_frame = ttk.Frame(main_frame)
        actions_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(actions_frame, text="Copiar Link", image=self.icons.get('copy_icon'), compound=tk.LEFT,
                  command=self.copy_meeting_link_dashboard).pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(actions_frame, text="Excluir Reunião", image=self.icons.get('delete_icon'), compound=tk.LEFT,
                  command=self.delete_meeting_dashboard).pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(actions_frame, text="Abrir Reunião", image=self.icons.get('forward_icon'), compound=tk.LEFT,
                  command=self.open_meeting_link).pack(side=tk.LEFT)
        
        # Carregar reuniões iniciais
        self.load_dashboard_meetings()
    
    def load_dashboard_meetings(self):
        """Carrega reuniões no dashboard"""
        # Limpar dados existentes
        for item in self.meetings_tree.get_children():
            self.meetings_tree.delete(item)
        
        # Carregar próximas reuniões
        upcoming_meetings = self.meeting_integration.get_upcoming_meetings()
        
        for meeting in upcoming_meetings:
            # Converter nome da plataforma para exibição
            platform = meeting.get('platform', '')
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(platform, platform.upper())
            
            self.meetings_tree.insert("", "end", values=(
                meeting.get('date', ''),
                meeting.get('time', ''),
                meeting.get('title', ''),
                meeting.get('project', 'Geral'),
                platform_display,
                meeting.get('created_by', ''),
                meeting.get('link', '')[:50] + "..." if len(meeting.get('link', '')) > 50 else meeting.get('link', '')
            ), tags=(meeting['id'],))
    
    def create_new_meeting(self):
        """Abre janela para criar nova reunião"""
        MeetingWindow(self.root, self)
    
    def refresh_meetings(self):
        """Atualiza lista de reuniões"""
        self.load_dashboard_meetings()
    
    def copy_meeting_link_dashboard(self):
        """Copia link da reunião selecionada no dashboard"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reunião!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        
        if meeting_id in self.meeting_integration.meeting_data:
            meeting = self.meeting_integration.meeting_data[meeting_id]
            link = meeting['link']
            
            # Copiar para área de transferência
            self.root.clipboard_clear()
            self.root.clipboard_append(link)
            
            messagebox.showinfo("Link Copiado", f"Link copiado para a área de transferência:\n{link}")
    
    def delete_meeting_dashboard(self):
        """Exclui reunião selecionada no dashboard"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reunião!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        meeting_title = item['values'][2]
        
        if messagebox.askyesno("Confirmar Exclusão", 
                              f"Tem certeza que deseja excluir a reunião '{meeting_title}'?\n\n"
                              f"Isso também cancelará a reunião no Google Calendar."):
            if meeting_id in self.meeting_integration.meeting_data:
                meeting = self.meeting_integration.meeting_data[meeting_id]
                
                # Tentar cancelar no Google Calendar se for Google Meet
                google_canceled = False
                if meeting.get('platform') == 'google_meet' and meeting.get('google_event_id'):
                    try:
                        if not hasattr(self, 'google_calendar_manager'):
                            self.google_calendar_manager = GoogleCalendarManager()
                        
                        google_canceled = self.google_calendar_manager.cancel_meeting(
                            meeting.get('google_event_id')
                        )
                    except Exception as e:
                        print(f"Erro ao cancelar no Google Calendar: {e}")
                
                # Remover do sistema local
                del self.meeting_integration.meeting_data[meeting_id]
                self.meeting_integration.save_meeting_data()
                self.load_dashboard_meetings()
                
                # Mostrar resultado
                if google_canceled:
                    messagebox.showinfo("Sucesso", 
                                      f"Reunião '{meeting_title}' excluída com sucesso!\n"
                                      f"✅ Também cancelada no Google Calendar.")
                elif meeting.get('platform') == 'google_meet':
                    messagebox.showwarning("Parcialmente Bem-sucedido", 
                                         f"Reunião '{meeting_title}' excluída do sistema.\n"
                                         f"⚠️ Não foi possível cancelar no Google Calendar.\n"
                                         f"Cancele manualmente no Google Calendar.")
                else:
                    messagebox.showinfo("Sucesso", f"Reunião '{meeting_title}' excluída com sucesso!")
    
    def open_meeting_link(self):
        """Abre link da reunião no navegador"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reunião!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        
        if meeting_id in self.meeting_integration.meeting_data:
            meeting = self.meeting_integration.meeting_data[meeting_id]
            link = meeting['link']
            
            try:
                import webbrowser
                webbrowser.open(link)
                messagebox.showinfo("Reunião Aberta", f"Link da reunião aberto no navegador!")
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao abrir link: {e}")
    
    def export_meetings_agenda(self):
        """Exporta agenda de reuniões"""
        try:
            upcoming_meetings = self.meeting_integration.get_upcoming_meetings()
            
            if not upcoming_meetings:
                messagebox.showinfo("Agenda Vazia", "Não há reuniões agendadas para exportar.")
                return
            
            # Criar conteúdo da agenda
            agenda_content = "AGENDA DE REUNIÕES\n"
            agenda_content += "=" * 50 + "\n\n"
            
            for meeting in upcoming_meetings:
                # Converter nome da plataforma para exibição
                platform = meeting.get('platform', '')
                platform_display = {
                    'zoom': 'ZOOM',
                    'teams': 'TEAMS', 
                    'google_meet': 'GOOGLE MEET'
                }.get(platform, platform.upper())
                
                agenda_content += f"📅 {meeting['title']}\n"
                agenda_content += f"   Data: {meeting['date']} às {meeting['time']}\n"
                agenda_content += f"   Duração: {meeting['duration']} minutos\n"
                agenda_content += f"   Plataforma: {platform_display}\n"
                agenda_content += f"   Link: {meeting['link']}\n"
                if meeting.get('project'):
                    agenda_content += f"   Projeto: {meeting['project']}\n"
                agenda_content += f"   Criado por: {meeting['created_by']}\n"
                agenda_content += "\n"
            
            # Salvar arquivo
            filename = f"agenda_reunioes_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(agenda_content)
            
            messagebox.showinfo("Agenda Exportada", f"Agenda salva como '{filename}'")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar agenda: {e}")
        
        return predictions

    def refresh_dashboard(self):
        """Atualiza todos os dados do dashboard"""
        try:
            # Atualizar métricas gerais
            if hasattr(self, 'category_tree'):
                self.load_time_category_data()
            
            if hasattr(self, 'project_tree'):
                self.load_time_project_data()
            
            if hasattr(self, 'team_tree'):
                self.load_team_performance_data()
            
            if hasattr(self, 'predictions_tree'):
                self.load_ai_predictions()
            
            messagebox.showinfo("Sucesso", "Dashboard atualizado com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao atualizar dashboard:\n{e}")

    def refresh_team_performance(self):
        """Atualiza dados de performance da equipe"""
        self.load_team_performance_data()

    def refresh_time_analysis(self):
        """Atualiza análise de tempo"""
        if hasattr(self, 'category_tree'):
            self.load_time_category_data()
        if hasattr(self, 'project_tree'):
            self.load_time_project_data()

    def refresh_burndown(self):
        """Atualiza gráfico de burndown"""
        # Recriar o gráfico
        pass

    def generate_ai_predictions(self):
        """Gera novas previsões de IA"""
        self.load_ai_predictions()
        messagebox.showinfo("Sucesso", "Previsões de IA geradas com sucesso!")

    def update_ai_model(self):
        """Atualiza o modelo de IA"""
        messagebox.showinfo("Info", "Modelo de IA atualizado com dados mais recentes!")

    def generate_team_report(self):
        """Gera relatório de performance da equipe"""
        try:
            # Simular geração de relatório
            report_content = "Relatório de Performance da Equipe\n"
            report_content += "=" * 40 + "\n\n"
            
            for member in self.members:
                completed, pending, avg_time, completion_rate = self.calculate_member_performance(member['Membro'])
                report_content += f"Membro: {member['Membro']}\n"
                report_content += f"Tarefas Concluídas: {completed}\n"
                report_content += f"Tarefas Pendentes: {pending}\n"
                report_content += f"Taxa de Conclusão: {completion_rate:.1f}%\n"
                report_content += f"Tempo Médio: {avg_time:.1f}h\n\n"
            
            # Salvar relatório
            filename = f"relatorio_equipe_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            messagebox.showinfo("Sucesso", f"Relatório gerado com sucesso!\nArquivo: {filename}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar relatório:\n{e}")

    def export_dashboard_report(self):
        """Exporta relatório completo do dashboard"""
        try:
            # Gerar relatório completo
            report_content = "Dashboard Executivo - Relatório Completo\n"
            report_content += "=" * 50 + "\n\n"
            
            # Métricas gerais
            total_cards, completed_cards, pending_cards, overdue_cards = self.calculate_card_metrics()
            report_content += "MÉTRICAS GERAIS:\n"
            report_content += f"Total de Tarefas: {total_cards}\n"
            report_content += f"Concluídas: {completed_cards}\n"
            report_content += f"Pendentes: {pending_cards}\n"
            report_content += f"Vencidas: {overdue_cards}\n"
            report_content += f"Taxa de Sucesso: {(completed_cards/total_cards*100):.1f}%\n\n"
            
            # Performance da equipe
            report_content += "PERFORMANCE DA EQUIPE:\n"
            for member in self.members:
                completed, pending, avg_time, completion_rate = self.calculate_member_performance(member['Membro'])
                report_content += f"{member['Membro']}: {completion_rate:.1f}% de conclusão\n"
            
            # Salvar relatório
            filename = f"dashboard_executivo_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            messagebox.showinfo("Sucesso", f"Relatório exportado com sucesso!\nArquivo: {filename}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar relatório:\n{e}")

    def generate_metrics_chart(self):
        """Gera gráfico detalhado das métricas"""
        try:
            messagebox.showinfo("Gráfico", "Gráfico detalhado das métricas gerado com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar gráfico: {e}")

    def export_time_analysis(self):
        """Exporta análise de tempo"""
        try:
            messagebox.showinfo("Exportar", "Análise de tempo exportada com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar análise: {e}")

    def generate_burndown_report(self):
        """Gera relatório de burndown"""
        try:
            messagebox.showinfo("Relatório", "Relatório de burndown gerado com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar relatório: {e}")

    def export_ai_predictions(self):
        """Exporta previsões de IA"""
        try:
            messagebox.showinfo("Exportar", "Previsões de IA exportadas com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar previsões: {e}")

    def create_boards_tab(self, parent):
        board_management_frame = ttk.Frame(parent)
        board_management_frame.pack(fill=tk.X, pady=5, padx=5)

        # Re-insert buttons for board management with icons
        ttk.Button(board_management_frame, text="Novo Quadro", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_board).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Renomear Quadro", image=self.icons.get('pencil_icon'), compound=tk.LEFT, command=self.rename_current_board).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Excluir Quadro", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.delete_current_board).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Criar Reunião", image=self.icons.get('reuniao_icon'), compound=tk.LEFT, command=self.open_meeting_window).pack(side=tk.LEFT, padx=5)

        # --- Filter Toggle Button ---
        self.filter_visible = tk.BooleanVar(value=False)
        # Use self.search_icon for the filter button
        self.toggle_filter_button = ttk.Button(board_management_frame, text="Mostrar Filtros", image=self.icons.get('search_icon'), compound=tk.LEFT, command=self.toggle_filter_visibility)
        self.toggle_filter_button.pack(side=tk.LEFT, padx=5)

        # --- Card Filtering UI (initially hidden) ---
        self.filter_container_frame = ttk.Frame(parent) # Container to hide/show
        # self.filter_container_frame.pack(fill=tk.X, pady=5, padx=5) # Don't pack initially

        filter_frame = ttk.LabelFrame(self.filter_container_frame, text="Filtrar Cartões", padding=10)
        filter_frame.pack(fill=tk.X, expand=True)

        filter_frame.columnconfigure(1, weight=1) # Make the entry/combobox columns expandable

        ttk.Label(filter_frame, text="Assunto:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.filter_subject_var = tk.StringVar()
        self.filter_subject_combo = ttk.Combobox(filter_frame, textvariable=self.filter_subject_var, state="readonly")
        self.filter_subject_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        self.filter_subject_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Objetivo:").grid(row=0, column=2, sticky="w", padx=5, pady=2)
        self.filter_goal_var = tk.StringVar()
        self.filter_goal_combo = ttk.Combobox(filter_frame, textvariable=self.filter_goal_var, state="readonly")
        self.filter_goal_combo.grid(row=0, column=3, sticky="ew", padx=5, pady=2)
        self.filter_goal_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Membro:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.filter_member_var = tk.StringVar()
        self.filter_member_combo = ttk.Combobox(filter_frame, textvariable=self.filter_member_var, state="readonly")
        self.filter_member_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        self.filter_member_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())
        self.filter_member_combo['values'] = ["Todos"] + sorted([member['Membro'] for member in self.members])

        ttk.Label(filter_frame, text="Prazo:").grid(row=1, column=2, sticky="w", padx=5, pady=2)
        self.filter_due_date_var = tk.StringVar()
        self.filter_due_date_options = ["Todos", "Hoje", "Próximos 7 dias", "Vencidos"]
        self.filter_due_date_combo = ttk.Combobox(filter_frame, textvariable=self.filter_due_date_var, values=self.filter_due_date_options, state="readonly")
        self.filter_due_date_combo.grid(row=1, column=3, sticky="ew", padx=5, pady=2)
        # Não definir valor padrão - deixar vazio
        self.filter_due_date_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Importância:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        self.filter_importance_var = tk.StringVar()
        self.filter_importance_combo = ttk.Combobox(filter_frame, textvariable=self.filter_importance_var, state="readonly")
        self.filter_importance_combo.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        self.filter_importance_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Recorrência:").grid(row=2, column=2, sticky="w", padx=5, pady=2)
        self.filter_recurrence_var = tk.StringVar()
        self.filter_recurrence_options = ["Todos", "Nenhuma", "Diariamente", "Semanalmente", "Mensalmente", "Anualmente"]
        self.filter_recurrence_combo = ttk.Combobox(filter_frame, textvariable=self.filter_recurrence_var, values=self.filter_recurrence_options, state="readonly")
        self.filter_recurrence_combo.grid(row=2, column=3, sticky="ew", padx=5, pady=2)
        # Não definir valor padrão - deixar vazio
        self.filter_recurrence_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Palavra-chave:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.filter_keyword_var = tk.StringVar()
        self.filter_keyword_entry = ttk.Entry(filter_frame, textvariable=self.filter_keyword_var)
        self.filter_keyword_entry.grid(row=3, column=1, columnspan=3, sticky="ew", padx=5, pady=2)
        self.filter_keyword_entry.bind("<KeyRelease>", lambda e: self.apply_card_filter())

        filter_buttons_frame = ttk.Frame(filter_frame)
        filter_buttons_frame.grid(row=4, column=0, columnspan=4, sticky="e", padx=5, pady=2)

        # Filter management UI
        filter_management_frame = ttk.Frame(filter_frame)
        filter_management_frame.grid(row=5, column=0, columnspan=4, sticky="ew", padx=5, pady=2)
        filter_management_frame.columnconfigure(0, weight=1)

        self.saved_filters_combo = ttk.Combobox(filter_management_frame, state="readonly")
        self.saved_filters_combo.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        self.saved_filters_combo.bind("<<ComboboxSelected>>", self.load_filter)

        ttk.Button(filter_management_frame, text="Salvar Filtro", image=self.icons.get('save_icon'), compound=tk.LEFT, command=self.save_filter).grid(row=0, column=1, padx=2)
        ttk.Button(filter_management_frame, text="Excluir Filtro", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.delete_filter).grid(row=0, column=2, padx=2)

        ttk.Button(filter_buttons_frame, text="Limpar Filtros", image=self.icons.get('clear_icon'), compound=tk.LEFT, command=self.clear_card_filter).pack(side=tk.RIGHT, padx=2)
        ttk.Button(filter_buttons_frame, text="Aplicar Filtro", image=self.icons.get('apply_icon'), compound=tk.LEFT, command=self.apply_card_filter).pack(side=tk.RIGHT, padx=2)

        self.board_notebook = ttk.Notebook(parent)
        self.board_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Bind right-click to the notebook itself to identify the tab
        self.board_notebook.bind("<Button-3>", self.show_board_tab_context_menu)
        # Bind drag-and-drop for tabs
        self.board_notebook.bind("<ButtonPress-1>", self.on_tab_drag_start)
        self.board_notebook.bind("<B1-Motion>", self.on_tab_drag_motion)
        self.board_notebook.bind("<ButtonRelease-1>", self.on_tab_drag_release)

        self._drag_data = {"item": None, "x": 0, "y": 0, "tab_index": -1}

        # Card details frame (initially hidden)
        self.card_details_frame = ttk.Frame(parent, relief="solid", borderwidth=1)
        self.create_card_details_widgets()

        # Add a small legend for importance colors at the bottom of the boards tab
        self.legend_frame = ttk.Frame(parent)
        self.legend_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=5)
        self.update_legend()

    def create_card_details_widgets(self):
        """Cria os widgets para exibir detalhes do cartão selecionado"""
        # Basic info frame
        basic_frame = ttk.Frame(self.card_details_frame)
        basic_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Row 1: Title and Due Date
        title_frame = ttk.Frame(basic_frame)
        title_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(title_frame, text="Título:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_title_label = ttk.Label(title_frame, text="", font=("Helvetica", 9))
        self.card_title_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(title_frame, text="Prazo:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_due_date_label = ttk.Label(title_frame, text="", font=("Helvetica", 9))
        self.card_due_date_label.pack(side=tk.LEFT)
        
        # Row 2: Members and Creation Date
        info_frame = ttk.Frame(basic_frame)
        info_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(info_frame, text="Membros:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_members_label = ttk.Label(info_frame, text="", font=("Helvetica", 9))
        self.card_members_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(info_frame, text="Criado em:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_creation_date_label = ttk.Label(info_frame, text="", font=("Helvetica", 9))
        self.card_creation_date_label.pack(side=tk.LEFT)
        
        # Row 3: Buttons
        button_frame = ttk.Frame(basic_frame)
        button_frame.pack(fill=tk.X, pady=2)
        
        self.ver_mais_button = ttk.Button(button_frame, text="Ver Mais", 
                                         command=self.toggle_detailed_view)
        self.ver_mais_button.pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(button_frame, text="Editar", 
                  command=self.edit_selected_card).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(button_frame, text="Comentários", 
                  command=self.open_card_comments).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(button_frame, text="Limpar", 
                  command=self.clear_card_selection).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(button_frame, text="Fechar", 
                  command=self.hide_card_details).pack(side=tk.RIGHT, padx=2)
        
        # Detailed info frame (initially hidden)
        self.detailed_frame = ttk.LabelFrame(self.card_details_frame, text="Informações Detalhadas", padding=5)
        
        # Subject and Importance
        detail_row1 = ttk.Frame(self.detailed_frame)
        detail_row1.pack(fill=tk.X, pady=2)
        
        ttk.Label(detail_row1, text="Assunto:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_subject_label = ttk.Label(detail_row1, text="", font=("Helvetica", 8))
        self.card_subject_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(detail_row1, text="Importância:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_importance_label = ttk.Label(detail_row1, text="", font=("Helvetica", 8))
        self.card_importance_label.pack(side=tk.LEFT)
        
        # Goal and Recurrence
        detail_row2 = ttk.Frame(self.detailed_frame)
        detail_row2.pack(fill=tk.X, pady=2)
        
        ttk.Label(detail_row2, text="Objetivo:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_goal_label = ttk.Label(detail_row2, text="", font=("Helvetica", 8))
        self.card_goal_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(detail_row2, text="Recorrência:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_recurrence_label = ttk.Label(detail_row2, text="", font=("Helvetica", 8))
        self.card_recurrence_label.pack(side=tk.LEFT)
        
        # Description
        detail_row3 = ttk.Frame(self.detailed_frame)
        detail_row3.pack(fill=tk.X, pady=2)
        
        ttk.Label(detail_row3, text="Descrição:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W, padx=(0, 5))
        
        # Advanced text editor for description
        desc_frame = ttk.Frame(self.detailed_frame)
        desc_frame.pack(fill=tk.X, pady=2)
        
        # Import advanced text editor
        try:
            from advanced_text_editor import AdvancedTextEditor
            self.card_description_editor = AdvancedTextEditor(desc_frame, height=8, width=50)
            self.card_description_editor.pack(fill=tk.BOTH, expand=True)
            self.card_description_text = self.card_description_editor.text_widget
        except ImportError:
            # Fallback to simple text widget if advanced editor is not available
            self.card_description_text = tk.Text(desc_frame, height=3, wrap=tk.WORD, font=("Helvetica", 8))
            desc_scrollbar = ttk.Scrollbar(desc_frame, orient="vertical", command=self.card_description_text.yview)
            self.card_description_text.configure(yscrollcommand=desc_scrollbar.set)
            
            self.card_description_text.pack(side=tk.LEFT, fill=tk.X, expand=True)
            desc_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Additional info frame
        info_frame = ttk.LabelFrame(self.detailed_frame, text="Informações Adicionais", padding=5)
        info_frame.pack(fill=tk.X, pady=2)
        
        # Subtasks
        subtasks_frame = ttk.Frame(info_frame)
        subtasks_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(subtasks_frame, text="Subtarefas:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W)
        self.card_subtasks_text = tk.Text(subtasks_frame, height=2, wrap=tk.WORD, font=("Helvetica", 8))
        self.card_subtasks_text.pack(fill=tk.X, expand=True)
        
        # Dependencies
        deps_frame = ttk.Frame(info_frame)
        deps_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(deps_frame, text="Dependências:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W)
        self.card_dependencies_text = tk.Text(deps_frame, height=2, wrap=tk.WORD, font=("Helvetica", 8))
        self.card_dependencies_text.pack(fill=tk.X, expand=True)
        
        # Git info
        git_frame = ttk.Frame(info_frame)
        git_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(git_frame, text="Git:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W)
        self.card_git_text = tk.Text(git_frame, height=2, wrap=tk.WORD, font=("Helvetica", 8))
        self.card_git_text.pack(fill=tk.X, expand=True)

    def show_card_details(self, card_data):
        """Exibe os detalhes do cartão selecionado"""
        self.card_details_frame.pack(before=self.legend_frame, fill=tk.X, pady=2)
        
        # Update basic info
        self.card_title_label.config(text=card_data.get('title', ''))
        
        due_date = card_data.get('due_date', '')
        if due_date:
            try:
                due_date_obj = datetime.strptime(due_date, '%Y-%m-%d %H:%M')
                formatted_due_date = due_date_obj.strftime('%d/%m/%Y %H:%M')
            except ValueError:
                formatted_due_date = due_date
        else:
            formatted_due_date = 'Não definido'
        self.card_due_date_label.config(text=formatted_due_date)
        
        members = card_data.get('members', [])
        self.card_members_label.config(text=', '.join(members) if members else 'Nenhum')
        
        creation_date = card_data.get('creation_date', '')
        if creation_date:
            try:
                # Verificar se já é um objeto datetime
                if isinstance(creation_date, datetime):
                    creation_date_obj = creation_date
                else:
                    creation_date_obj = datetime.strptime(creation_date, '%Y-%m-%d %H:%M:%S')
                formatted_creation_date = creation_date_obj.strftime('%d/%m/%Y %H:%M')
            except (ValueError, TypeError):
                formatted_creation_date = str(creation_date) if creation_date else 'Não disponível'
        else:
            formatted_creation_date = 'Não disponível'
        self.card_creation_date_label.config(text=formatted_creation_date)
        
        # Update additional info
        self.update_additional_info(card_data)
        
        # Store current card data
        self.current_card_data = card_data

    def hide_card_details(self):
        """Esconde o frame de detalhes do cartão"""
        self.card_details_frame.pack_forget()
        self.current_card_data = None

    def toggle_detailed_view(self):
        """Alterna a visibilidade da view detalhada"""
        if self.detailed_frame.winfo_ismapped():
            self.detailed_frame.pack_forget()
            self.ver_mais_button.config(text="Ver Mais")
        else:
            self.detailed_frame.pack(fill=tk.X, padx=5, pady=5)
            self.ver_mais_button.config(text="Ver Menos")

    def update_additional_info(self, card_data):
        """Atualiza as informações adicionais do cartão"""
        # Subject and Importance
        self.card_subject_label.config(text=card_data.get('subject', 'Não definido'))
        self.card_importance_label.config(text=card_data.get('importance', 'Normal'))
        
        # Goal and Recurrence
        self.card_goal_label.config(text=card_data.get('goal', 'Não definido'))
        self.card_recurrence_label.config(text=card_data.get('recurrence', 'Nenhuma'))
        
        # Description
        self.card_description_text.delete('1.0', tk.END)
        self.card_description_text.insert('1.0', card_data.get('desc', ''))
        
        # Subtasks
        self.card_subtasks_text.delete('1.0', tk.END)
        subtasks = card_data.get('subtasks', [])
        if subtasks:
            subtasks_text = '\n'.join([f"• {subtask}" for subtask in subtasks])
            self.card_subtasks_text.insert('1.0', subtasks_text)
        
        # Dependencies
        self.card_dependencies_text.delete('1.0', tk.END)
        dependencies = card_data.get('dependencies', [])
        if dependencies:
            deps_text = '\n'.join([f"• {dep}" for dep in dependencies])
            self.card_dependencies_text.insert('1.0', deps_text)
        
        # Git info
        self.card_git_text.delete('1.0', tk.END)
        git_info = card_data.get('git_info', {})
        if git_info:
            git_text = f"Branch: {git_info.get('branch', 'N/A')}\n"
            git_text += f"Status: {git_info.get('status', 'N/A')}"
            self.card_git_text.insert('1.0', git_text)

    def clear_card_selection(self):
        """Limpa a seleção do cartão e esconde os detalhes"""
        # Clear selection in all treeviews
        for board_name in self.boodesk_data["boards"]:
            if board_name != "workflow":
                treeview = self.listbox_refs.get(board_name)
                if treeview:
                    treeview.selection_remove(treeview.selection())
        
        self.hide_card_details()

    def edit_selected_card(self):
        """Abre a janela de edição do cartão selecionado"""
        if hasattr(self, 'current_card_data') and self.current_card_data:
            # Find the card in the data structure
            card_id = self.current_card_data.get('card_id')
            if card_id:
                for board_name, board_data in self.boodesk_data["boards"].items():
                    for list_name, cards in board_data.items():
                        if list_name != "workflow":
                            for card in cards:
                                if card.get('card_id') == card_id:
                                    # Open card window for editing
                                    CardWindow(self.root, self, board_name, list_name, card, 
                                             lambda saved=False: self.update_card_details_if_visible())
                                    return
            
            messagebox.showwarning("Aviso", "Cartão não encontrado para edição.")
    
    def open_card_comments(self):
        """Abre a janela de comentários do cartão selecionado"""
        if hasattr(self, 'current_card_data') and self.current_card_data:
            card_id = self.current_card_data.get('card_id')
            card_title = self.current_card_data.get('title', 'Cartão')
            if card_id:
                self.chat_system.open_card_comments(card_id, card_title)
            else:
                messagebox.showwarning("Aviso", "Cartão não encontrado para comentários.")
        else:
            messagebox.showwarning("Aviso", "Nenhum cartão selecionado!")

    def update_card_details_if_visible(self):
        """Atualiza os detalhes do cartão se estiverem visíveis"""
        if hasattr(self, 'current_card_data') and self.current_card_data:
            # Refresh the current card data
            card_id = self.current_card_data.get('card_id')
            if card_id:
                for board_name, board_data in self.boodesk_data["boards"].items():
                    for list_name, cards in board_data.items():
                        if list_name != "workflow":
                            for card in cards:
                                if card.get('card_id') == card_id:
                                    self.show_card_details(card)
                                    return

    def update_legend(self):
        for widget in self.legend_frame.winfo_children():
            widget.destroy()

        ttk.Label(self.legend_frame, text="Legenda Importância:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=5)
        for imp, color in self.settings["importance_colors"].items():
            ttk.Label(self.legend_frame, text=imp, background=color, font=("Helvetica", 8)).pack(side=tk.LEFT, padx=2)

    # Função create_calendar_tab removida - integração com Google Calendar desabilitada

    # Funções relacionadas ao calendário removidas - integração com Google Calendar desabilitada
    
    def get_all_cards(self):
        all_cards = []
        for board_name, lists in self.boodesk_data["boards"].items():
            # Verificar se lists é um dicionário ou lista
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    for card in cards:
                        if not card.get("is_archived", False):
                            all_cards.append({
                                "board_name": board_name,
                                "list_name": list_name,
                                "card": card
                            })
        return all_cards

    def create_gantt_chart_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        self.gantt_canvas_frame = ttk.Frame(main_frame)
        self.gantt_canvas_frame.pack(fill=tk.BOTH, expand=True)

        self.update_gantt_chart()

    def update_gantt_chart(self):
        # Clear previous chart
        for widget in self.gantt_canvas_frame.winfo_children():
            widget.destroy()

        fig, ax = plt.subplots(figsize=(10, 6))

        tasks = []
        for board_name, lists in self.boodesk_data["boards"].items():
            # Verificar se lists é um dicionário ou lista
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    for card in cards:
                        if not card.get("is_archived", False) and card.get("due_date"):
                            try:
                                # Corrigir tratamento da data de criação
                                creation_date = card.get("creation_date")
                                if isinstance(creation_date, str):
                                    start_date = datetime.strptime(creation_date.split(' ')[0], "%Y-%m-%d")
                                elif hasattr(creation_date, 'strftime'):
                                    start_date = creation_date
                                else:
                                    start_date = datetime.now()
                                end_date = datetime.strptime(card["due_date"].split(' ')[0], "%Y-%m-%d")
                                duration = (end_date - start_date).days
                                if duration < 0: # Handle cases where due date is before creation date
                                    duration = 0
                                tasks.append({
                                    "task": card["title"],
                                    "start": start_date,
                                    "end": end_date,
                                    "duration": duration,
                                    "list": list_name
                                })
                            except ValueError:
                                continue # Skip cards with invalid date formats

        if not tasks:
            ax.text(0.5, 0.5, "Nenhum cartão com prazo definido para exibir no Gráfico de Gantt.",
                    horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=12, color='gray')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            # Sort tasks by start date
            tasks.sort(key=lambda x: x["start"])

            # Create a mapping for task names to y-axis positions
            task_names = [task["task"] for task in tasks]
            y_pos = range(len(task_names))

            # Plot bars
            for i, task in enumerate(tasks):
                color = 'skyblue'
                if task["list"] == "Concluído":
                    color = 'lightgreen'
                elif task["end"].date() < datetime.now().date():
                    color = 'lightcoral' # Overdue
                
                ax.barh(i, task["duration"], left=task["start"], height=0.8, align='center', color=color)
                
                # Add task name and dates
                ax.text(task["start"], i, f" {task['task']}", va='center', ha='left', fontsize=8)
                ax.text(task["end"], i, f" {task['end'].strftime('%Y-%m-%d')}", va='center', ha='left', fontsize=8)


            ax.set_yticks(y_pos)
            ax.set_yticklabels(task_names, fontsize=8)
            ax.set_xlabel("Data")
            ax.set_title("Gráfico de Gantt dos Cartões")
            ax.grid(True, linestyle='--', alpha=0.7)
            fig.autofmt_xdate() # Rotate x-axis labels for better readability

        canvas = FigureCanvasTkAgg(fig, master=self.gantt_canvas_frame)
        canvas_widget = canvas.get_tk_widget()
        canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        canvas.draw()

    def create_chat_tab(self, parent):
        """Cria a aba principal de chat com interface melhorada"""
        main_frame = ttk.Frame(parent, padding="5")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Frame principal com layout horizontal
        content_frame = ttk.Frame(main_frame)
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        # ===== COLUNA ESQUERDA - NAVEGAÇÃO E CONTROLES =====
        left_panel = ttk.Frame(content_frame, width=300)
        left_panel.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 5))
        left_panel.pack_propagate(False)  # Manter largura fixa
        
        # Título do painel esquerdo
        title_frame = ttk.Frame(left_panel)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text="Chat", image=self.icons.get('chat_icon'), 
                 compound=tk.LEFT, font=("Arial", 14, "bold")).pack(side=tk.LEFT)
        
        # Botão de atualizar
        refresh_btn = ttk.Button(title_frame, image=self.icons.get('refresh_icon'), 
                                width=3, command=self.refresh_chat_data)
        refresh_btn.pack(side=tk.RIGHT)
        
        # Tooltip para o botão de atualizar
        # self.create_tooltip(refresh_btn, "Atualizar dados do chat")
        
        # ===== ABAS DE NAVEGAÇÃO =====
        # Notebook para abas
        self.chat_notebook = ttk.Notebook(left_panel)
        self.chat_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Aba 1: Meus Chats
        self.create_my_chats_tab()
        
        # Aba 2: Quadros
        self.create_chat_boards_tab()
        
        # Aba 3: Usuários
        self.create_chat_users_tab()
        
        # Aba 4: Notificações
        self.create_chat_notifications_tab()
        
        # ===== COLUNA DIREITA - ÁREA DE CHAT =====
        right_panel = ttk.Frame(content_frame)
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        
        # Cabeçalho da área de chat
        chat_header = ttk.Frame(right_panel)
        chat_header.pack(fill=tk.X, pady=(0, 5))
        
        self.chat_title_label = ttk.Label(chat_header, text="Selecione um chat para começar", 
                                         font=("Arial", 12, "bold"))
        self.chat_title_label.pack(side=tk.LEFT)
        
        # Botões de ação do chat
        chat_actions_frame = ttk.Frame(chat_header)
        chat_actions_frame.pack(side=tk.RIGHT)
        
        self.search_btn = ttk.Button(chat_actions_frame, image=self.icons.get('search_icon'), 
                                    width=3, command=self.search_chat_messages)
        self.search_btn.pack(side=tk.LEFT, padx=(0, 5))
        # self.create_tooltip(self.search_btn, "Buscar mensagens no chat")
        
        self.participants_btn = ttk.Button(chat_actions_frame, image=self.icons.get('objects_icon'), 
                                          width=3, command=self.show_chat_participants)
        self.participants_btn.pack(side=tk.LEFT)
        self.create_tooltip(self.participants_btn, "Ver participantes do chat")
        
        # Área de mensagens
        messages_frame = ttk.Frame(right_panel)
        messages_frame.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbar para mensagens
        messages_scrollbar = ttk.Scrollbar(messages_frame)
        messages_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Text widget para mensagens
        self.messages_text = tk.Text(messages_frame, wrap=tk.WORD, state=tk.DISABLED,
                                    font=("Arial", 10), yscrollcommand=messages_scrollbar.set,
                                    bg="white", relief=tk.SUNKEN, borderwidth=1)
        self.messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        messages_scrollbar.config(command=self.messages_text.yview)
        
        # Área de entrada de mensagem
        input_frame = ttk.Frame(right_panel)
        input_frame.pack(fill=tk.X, pady=(5, 0))
        
        # Frame para entrada e botões
        entry_frame = ttk.Frame(input_frame)
        entry_frame.pack(fill=tk.X)
        
        # Campo de entrada
        self.message_entry = ttk.Entry(entry_frame, font=("Arial", 10))
        self.message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
        self.message_entry.bind("<Return>", self.send_message_from_main)
        
        # Botão de enviar
        send_btn = ttk.Button(entry_frame, text="Enviar", 
                             image=self.icons.get('forward_icon'), compound=tk.LEFT,
                             command=self.send_message_from_main)
        send_btn.pack(side=tk.RIGHT)
        self.create_tooltip(send_btn, "Enviar mensagem")
        
        # Carregar dados iniciais
        self.load_chat_data()
        
        # Configurar atualizações automáticas
        self.schedule_chat_updates()
    
    def create_my_chats_tab(self):
        """Cria a aba 'Meus Chats'"""
        my_chats_frame = ttk.Frame(self.chat_notebook)
        self.chat_notebook.add(my_chats_frame, text="Meus Chats", 
                              image=self.icons.get('chat_icon'), compound=tk.LEFT)
        
        # Frame para lista de chats
        chats_container = ttk.Frame(my_chats_frame)
        chats_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Scrollbar para lista de chats
        chats_scrollbar = ttk.Scrollbar(chats_container)
        chats_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de chats
        self.chats_listbox = tk.Listbox(chats_container, yscrollcommand=chats_scrollbar.set,
                                       font=("Arial", 10), selectmode=tk.SINGLE,
                                       bg="white", relief=tk.SUNKEN, borderwidth=1)
        self.chats_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        chats_scrollbar.config(command=self.chats_listbox.yview)
        
        # Bind para seleção de chat
        self.chats_listbox.bind("<Double-Button-1>", self.on_chat_selected)
        self.chats_listbox.bind("<ButtonRelease-1>", self.on_chat_selected)
        
        # Botões de ação
        buttons_frame = ttk.Frame(my_chats_frame)
        buttons_frame.pack(fill=tk.X, padx=5, pady=(0, 5))
        
        novo_chat_btn = ttk.Button(buttons_frame, text="Novo Chat Direto", 
                                  image=self.icons.get('add_icon'), compound=tk.LEFT,
                                  command=self.create_direct_chat)
        novo_chat_btn.pack(side=tk.LEFT)
        self.create_tooltip(novo_chat_btn, "Criar novo chat direto com usuário")
        
        limpar_btn = ttk.Button(buttons_frame, text="Limpar Histórico", 
                               image=self.icons.get('clear_icon'), compound=tk.LEFT,
                               command=self.clear_chat_history)
        limpar_btn.pack(side=tk.RIGHT)
        self.create_tooltip(limpar_btn, "Limpar histórico do chat selecionado")
    
    def create_chat_boards_tab(self):
        """Cria a aba 'Quadros' no chat"""
        boards_frame = ttk.Frame(self.chat_notebook)
        self.chat_notebook.add(boards_frame, text="Quadros", 
                              image=self.icons.get('folder_icon'), compound=tk.LEFT)
        
        # Frame para lista de quadros
        boards_container = ttk.Frame(boards_frame)
        boards_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Scrollbar para lista de quadros
        boards_scrollbar = ttk.Scrollbar(boards_container)
        boards_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de quadros
        self.boards_listbox = tk.Listbox(boards_container, yscrollcommand=boards_scrollbar.set,
                                        font=("Arial", 10), selectmode=tk.SINGLE,
                                        bg="white", relief=tk.SUNKEN, borderwidth=1)
        self.boards_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        boards_scrollbar.config(command=self.boards_listbox.yview)
        
        # Bind para seleção de quadro
        self.boards_listbox.bind("<Double-Button-1>", self.open_board_chat)
        
        # Botões de ação
        buttons_frame = ttk.Frame(boards_frame)
        buttons_frame.pack(fill=tk.X, padx=5, pady=(0, 5))
        
        abrir_chat_btn = ttk.Button(buttons_frame, text="Abrir Chat do Quadro", 
                                   image=self.icons.get('chat_icon'), compound=tk.LEFT,
                                   command=self.open_board_chat)
        abrir_chat_btn.pack(fill=tk.X)
        self.create_tooltip(abrir_chat_btn, "Abrir chat do quadro selecionado")
    
    def create_chat_users_tab(self):
        """Cria a aba 'Usuários' no chat"""
        users_frame = ttk.Frame(self.chat_notebook)
        self.chat_notebook.add(users_frame, text="Usuários", 
                              image=self.icons.get('objects_icon'), compound=tk.LEFT)
        
        # Frame para lista de usuários
        users_container = ttk.Frame(users_frame)
        users_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Scrollbar para lista de usuários
        users_scrollbar = ttk.Scrollbar(users_container)
        users_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de usuários
        self.users_listbox = tk.Listbox(users_container, yscrollcommand=users_scrollbar.set,
                                       font=("Arial", 10), selectmode=tk.SINGLE,
                                       bg="white", relief=tk.SUNKEN, borderwidth=1)
        self.users_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        users_scrollbar.config(command=self.users_listbox.yview)
        
        # Bind para seleção de usuário
        self.users_listbox.bind("<Double-Button-1>", self.start_direct_chat)
        self.users_listbox.bind("<<ListboxSelect>>", self.on_user_selected)
        
        # Botões de ação
        buttons_frame = ttk.Frame(users_frame)
        buttons_frame.pack(fill=tk.X, padx=5, pady=(0, 5))
        
        iniciar_chat_btn = ttk.Button(buttons_frame, text="Iniciar Chat Direto", 
                                     image=self.icons.get('chat_icon'), compound=tk.LEFT,
                                     command=self.start_direct_chat)
        iniciar_chat_btn.pack(fill=tk.X)
        self.create_tooltip(iniciar_chat_btn, "Iniciar chat direto com usuário selecionado")
    
    def create_chat_notifications_tab(self):
        """Cria a aba 'Notificações' no chat"""
        notifications_frame = ttk.Frame(self.chat_notebook)
        self.chat_notebook.add(notifications_frame, text="Notificações", 
                              image=self.icons.get('info_icon'), compound=tk.LEFT)
        
        # Label para status das notificações
        self.notifications_label = tk.Label(notifications_frame, text="Nenhuma notificação", 
                                           font=("Arial", 10), foreground="gray")
        self.notifications_label.pack(anchor="w", padx=5, pady=(5, 0))
        
        # Frame para lista de notificações
        notifications_container = ttk.Frame(notifications_frame)
        notifications_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Scrollbar para lista de notificações
        notifications_scrollbar = ttk.Scrollbar(notifications_container)
        notifications_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de notificações
        self.notifications_listbox = tk.Listbox(notifications_container, 
                                               yscrollcommand=notifications_scrollbar.set,
                                               font=("Arial", 10), selectmode=tk.SINGLE,
                                               bg="white", relief=tk.SUNKEN, borderwidth=1)
        self.notifications_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        notifications_scrollbar.config(command=self.notifications_listbox.yview)
        
        # Botões de ação
        buttons_frame = ttk.Frame(notifications_frame)
        buttons_frame.pack(fill=tk.X, padx=5, pady=(0, 5))
        
        ver_todas_btn = ttk.Button(buttons_frame, text="Ver Todas", 
                                  image=self.icons.get('info_icon'), compound=tk.LEFT,
                                  command=self.show_all_notifications)
        ver_todas_btn.pack(side=tk.LEFT)
        self.create_tooltip(ver_todas_btn, "Ver todas as notificações")
        
        marcar_lidas_btn = ttk.Button(buttons_frame, text="Marcar como Lidas", 
                                     image=self.icons.get('ok_icon'), compound=tk.LEFT,
                                     command=self.mark_all_notifications_read)
        marcar_lidas_btn.pack(side=tk.RIGHT)
        self.create_tooltip(marcar_lidas_btn, "Marcar todas as notificações como lidas")
    
    def load_chat_data(self):
        """Carrega dados iniciais da aba de chat"""
        try:
            # Carregar lista de chats do usuário
            self.refresh_chats_list()
            
            # Carregar lista de quadros
            self.load_boards_list()
            
            # Carregar lista de usuários
            self.load_users_list()
            
            # Carregar notificações
            self.update_notifications()
        except Exception as e:
            print(f"Erro ao carregar dados do chat: {e}")

    def load_chat_in_main_interface(self, chat, title):
        """Carrega um chat na interface principal"""
        try:
            # Atualizar título
            self.chat_title_label.config(text=title)
            
            # Armazenar chat atual
            self.current_chat = chat
            self.current_chat_id = chat['id']
            
            # Limpar mensagens anteriores
            self.messages_text.config(state=tk.NORMAL)
            self.messages_text.delete(1.0, tk.END)
            self.messages_text.config(state=tk.DISABLED)
            
            # Carregar mensagens do chat
            messages = self.chat_system.get_chat_messages(chat['id'])
            self.display_messages(messages)
            
            # Marcar mensagens como lidas
            self.chat_system.mark_chat_as_read(chat['id'])
            
            # Focar no campo de entrada
            self.message_entry.focus()
            
        except Exception as e:
            print(f"Erro ao carregar chat na interface principal: {e}")
            messagebox.showerror("Erro", f"Erro ao carregar chat: {e}")

    def display_messages(self, messages):
        """Exibe mensagens na interface principal"""
        try:
            self.messages_text.config(state=tk.NORMAL)
            self.messages_text.delete(1.0, tk.END)  # Limpar mensagens anteriores
            
            # Ordenar mensagens por data (mais recentes primeiro para exibição)
            sorted_messages = sorted(messages, key=lambda x: x.get('created_at', ''), reverse=True)
            
            for message in sorted_messages:
                # Formatar mensagem
                sender_name = message.get('sender_name', 'Usuário')
                timestamp = message.get('created_at', '')
                content = message.get('message', '')
                
                # Converter timestamp se necessário
                if isinstance(timestamp, str):
                    try:
                        from datetime import datetime
                        timestamp = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                    except:
                        timestamp = timestamp
                
                if isinstance(timestamp, datetime):
                    timestamp_str = timestamp.strftime("%d/%m/%Y %H:%M")
                else:
                    timestamp_str = str(timestamp)
                
                # Inserir mensagem formatada
                message_text = f"[{timestamp_str}] {sender_name}: {content}\n\n"
                self.messages_text.insert(tk.END, message_text)
            
            # Rolar para o final
            self.messages_text.see(tk.END)
            self.messages_text.config(state=tk.DISABLED)
            
        except Exception as e:
            print(f"Erro ao exibir mensagens: {e}")

    def send_message_from_main(self, event=None):
        """Envia mensagem a partir da interface principal"""
        try:
            if not hasattr(self, 'current_chat_id') or not self.current_chat_id:
                messagebox.showwarning("Aviso", "Selecione um chat primeiro")
                return
            
            message = self.message_entry.get().strip()
            if not message:
                return
            
            # Enviar mensagem
            current_user_id = getattr(self.current_user, 'id', 1)
            success = self.chat_system.send_message(
                chat_id=self.current_chat_id,
                sender_id=current_user_id,
                message=message
            )
            
            if success:
                # Limpar campo de entrada
                self.message_entry.delete(0, tk.END)
                
                # Atualizar mensagens
                messages = self.chat_system.get_chat_messages(self.current_chat_id)
                self.display_messages(messages)
                
                # Marcar como lida
                self.chat_system.mark_chat_as_read(self.current_chat_id)
            else:
                messagebox.showerror("Erro", "Não foi possível enviar a mensagem")
                
        except Exception as e:
            print(f"Erro ao enviar mensagem: {e}")
            messagebox.showerror("Erro", f"Erro ao enviar mensagem: {e}")
            self.load_notifications_list()
            
        except Exception as e:
            print(f"Erro ao carregar dados do chat: {e}")
    
    def refresh_chat_data(self):
        """Atualiza todos os dados do chat"""
        try:
            self.refresh_chats_list()
            self.load_boards_list()
            self.load_users_list()
            self.update_notifications()
            self.load_notifications_list()
            print("✅ Dados do chat atualizados")
        except Exception as e:
            print(f"Erro ao atualizar dados do chat: {e}")
    
    def load_notifications_list(self):
        """Carrega lista de notificações na aba de notificações"""
        try:
            if hasattr(self, 'notifications_listbox'):
                self.notifications_listbox.delete(0, tk.END)
                
                if hasattr(self, 'chat_system') and self.chat_system:
                    notifications = self.chat_system.get_unread_notifications()
                    
                    for notification in notifications:
                        notification_text = f"📢 {notification.get('sender_name', 'Sistema')}: {notification.get('message', 'Nova mensagem')}"
                        self.notifications_listbox.insert(tk.END, notification_text)
                        
        except Exception as e:
            print(f"Erro ao carregar notificações: {e}")
    

    
    def load_chat_messages(self):
        """Carrega mensagens do chat atual"""
        try:
            if not hasattr(self, 'current_chat_id') or not self.current_chat_id:
                return
            
            # Limpar área de mensagens
            self.messages_text.config(state=tk.NORMAL)
            self.messages_text.delete(1.0, tk.END)
            
            # Buscar mensagens do chat
            if hasattr(self, 'chat_system') and self.chat_system:
                messages = self.chat_system.get_chat_messages(self.current_chat_id)
                
                for message in messages:
                    # Formatar mensagem
                    timestamp = message.get('created_at', '')
                    sender = message.get('sender_name', 'Desconhecido')
                    content = message.get('message', '')
                    
                    # Adicionar mensagem formatada
                    message_text = f"[{timestamp}] {sender}: {content}\n\n"
                    self.messages_text.insert(tk.END, message_text)
                
                # Rolar para o final
                self.messages_text.see(tk.END)
            
            self.messages_text.config(state=tk.DISABLED)
            
        except Exception as e:
            print(f"Erro ao carregar mensagens: {e}")
    
    def search_chat_messages(self):
        """Busca mensagens no chat atual"""
        try:
            if not hasattr(self, 'current_chat_id') or not self.current_chat_id:
                messagebox.showwarning("Aviso", "Selecione um chat primeiro.")
                return
            
            search_term = simpledialog.askstring("Buscar Mensagens", "Digite o termo de busca:")
            if not search_term:
                return
            
            # Buscar mensagens
            if hasattr(self, 'chat_system') and self.chat_system:
                results = self.chat_system.search_chat_history(self.current_chat_id, search_term)
                
                if results:
                    # Mostrar resultados em nova janela
                    self.show_search_results(results, search_term)
                else:
                    messagebox.showinfo("Busca", "Nenhuma mensagem encontrada.")
                    
        except Exception as e:
            print(f"Erro na busca: {e}")
    
    def show_search_results(self, results, search_term):
        """Mostra resultados da busca"""
        try:
            # Criar janela de resultados
            results_window = tk.Toplevel(self.root)
            results_window.title(f"Resultados da busca: '{search_term}'")
            results_window.geometry("600x400")
            
            # Frame principal
            main_frame = ttk.Frame(results_window, padding="10")
            main_frame.pack(fill=tk.BOTH, expand=True)
            
            # Título
            ttk.Label(main_frame, text=f"Resultados para '{search_term}':", 
                     font=("Arial", 12, "bold")).pack(pady=(0, 10))
            
            # Lista de resultados
            results_frame = ttk.Frame(main_frame)
            results_frame.pack(fill=tk.BOTH, expand=True)
            
            # Scrollbar
            scrollbar = ttk.Scrollbar(results_frame)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # Listbox para resultados
            results_listbox = tk.Listbox(results_frame, yscrollcommand=scrollbar.set,
                                        font=("Arial", 10))
            results_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            scrollbar.config(command=results_listbox.yview)
            
            # Adicionar resultados
            for result in results:
                timestamp = result.get('created_at', '')
                sender = result.get('sender_name', 'Desconhecido')
                content = result.get('message', '')
                
                result_text = f"[{timestamp}] {sender}: {content}"
                results_listbox.insert(tk.END, result_text)
            
            # Botão fechar
            ttk.Button(main_frame, text="Fechar", 
                      command=results_window.destroy).pack(pady=(10, 0))
            
        except Exception as e:
            print(f"Erro ao mostrar resultados: {e}")
    
    def show_chat_participants(self):
        """Mostra participantes do chat atual"""
        try:
            if not hasattr(self, 'current_chat_id') or not self.current_chat_id:
                messagebox.showwarning("Aviso", "Selecione um chat primeiro.")
                return
            
            # Buscar participantes
            if hasattr(self, 'chat_system') and self.chat_system:
                participants = self.chat_system.get_chat_participants(self.current_chat_id)
                
                if participants:
                    # Criar janela de participantes
                    participants_window = tk.Toplevel(self.root)
                    participants_window.title("Participantes do Chat")
                    participants_window.geometry("400x300")
                    
                    # Frame principal
                    main_frame = ttk.Frame(participants_window, padding="10")
                    main_frame.pack(fill=tk.BOTH, expand=True)
                    
                    # Título
                    ttk.Label(main_frame, text="Participantes:", 
                             font=("Arial", 12, "bold")).pack(pady=(0, 10))
                    
                    # Lista de participantes
                    participants_frame = ttk.Frame(main_frame)
                    participants_frame.pack(fill=tk.BOTH, expand=True)
                    
                    # Scrollbar
                    scrollbar = ttk.Scrollbar(participants_frame)
                    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                    
                    # Listbox para participantes
                    participants_listbox = tk.Listbox(participants_frame, 
                                                     yscrollcommand=scrollbar.set,
                                                     font=("Arial", 10))
                    participants_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                    scrollbar.config(command=participants_listbox.yview)
                    
                    # Adicionar participantes
                    for participant in participants:
                        username = participant.get('username', 'Desconhecido')
                        role = participant.get('role', 'Usuário')
                        is_admin = participant.get('is_admin', False)
                        
                        admin_icon = "👑" if is_admin else ""
                        participant_text = f"{admin_icon} {username} ({role})"
                        participants_listbox.insert(tk.END, participant_text)
                    
                    # Botão fechar
                    ttk.Button(main_frame, text="Fechar", 
                              command=participants_window.destroy).pack(pady=(10, 0))
                else:
                    messagebox.showinfo("Participantes", "Nenhum participante encontrado.")
                    
        except Exception as e:
            print(f"Erro ao mostrar participantes: {e}")
    
    def clear_chat_history(self):
        """Limpa histórico do chat selecionado"""
        try:
            if not hasattr(self, 'current_chat_id') or not self.current_chat_id:
                messagebox.showwarning("Aviso", "Selecione um chat primeiro.")
                return
            
            # Confirmar ação
            confirm = messagebox.askyesno("Confirmar", 
                                        "Tem certeza que deseja limpar o histórico deste chat?")
            if not confirm:
                return
            
            # Limpar histórico (implementar no chat_system)
            if hasattr(self, 'chat_system') and self.chat_system:
                # TODO: Implementar método para limpar histórico
                messagebox.showinfo("Info", "Funcionalidade em desenvolvimento.")
            
        except Exception as e:
            print(f"Erro ao limpar histórico: {e}")
    
    def mark_all_notifications_read(self):
        """Marca todas as notificações como lidas"""
        try:
            if hasattr(self, 'chat_system') and self.chat_system:
                # TODO: Implementar método para marcar todas como lidas
                messagebox.showinfo("Info", "Funcionalidade em desenvolvimento.")
            
        except Exception as e:
            print(f"Erro ao marcar notificações: {e}")
    
    def schedule_chat_updates(self):
        """Agenda atualizações automáticas do chat"""
        try:
            # Atualizar dados a cada 5 segundos
            self.root.after(5000, self.update_chat_interface)
        except Exception as e:
            print(f"Erro ao agendar atualizações: {e}")
    
    def update_chat_interface(self):
        """Atualiza interface do chat"""
        try:
            # Atualizar mensagens se houver chat ativo
            if hasattr(self, 'current_chat_id') and self.current_chat_id:
                self.load_chat_messages()
            
            # Atualizar notificações
            self.update_notifications()
            self.load_notifications_list()
            
            # Agendar próxima atualização
            self.schedule_chat_updates()
            
        except Exception as e:
            print(f"Erro ao atualizar interface: {e}")
    
    def on_chat_selected(self, event):
        """Chamado quando um chat é selecionado na lista"""
        try:
            selection = self.chats_listbox.curselection()
            if selection:
                index = selection[0]
                chats = self.chat_system.get_user_chats()
                
                if index < len(chats):
                    chat = chats[index]
                    # Carregar chat na interface principal
                    self.load_chat_in_main_interface(chat, f"💬 {chat['name']}")
                    
        except Exception as e:
            print(f"Erro ao selecionar chat: {e}")
    
    def refresh_chats_list(self):
        """Atualiza a lista de chats do usuário"""
        try:
            self.chats_listbox.delete(0, tk.END)
            
            if hasattr(self, 'chat_system') and self.chat_system:
                chats = self.chat_system.get_user_chats()
                
                for chat in chats:
                    chat_name = chat['name']
                    chat_type = chat['chat_type']
                    
                    # Adicionar ícone baseado no tipo
                    if chat_type == 'board':
                        icon = "🏢"
                    elif chat_type == 'card':
                        icon = "📋"
                    elif chat_type == 'direct':
                        icon = "💬"
                    else:
                        icon = "💬"
                    
                    self.chats_listbox.insert(tk.END, f"{icon} {chat_name}")
                    
        except Exception as e:
            print(f"Erro ao atualizar lista de chats: {e}")
    
    def load_boards_list(self):
        """Carrega lista de quadros disponíveis"""
        try:
            self.boards_listbox.delete(0, tk.END)
            
            if hasattr(self, 'boodesk_data') and 'boards' in self.boodesk_data:
                for board_name in self.boodesk_data['boards'].keys():
                    if board_name != "Vazio":
                        self.boards_listbox.insert(tk.END, board_name)
                        
        except Exception as e:
            print(f"Erro ao carregar lista de quadros: {e}")
    
    def load_users_list(self):
        """Carrega lista de usuários"""
        try:
            self.users_listbox.delete(0, tk.END)
            
            if hasattr(self, 'db') and self.db:
                users = self.db.get_all_users()
                
                for user in users:
                    if user['id'] != getattr(self.current_user, 'id', None):
                        self.users_listbox.insert(tk.END, f"{user['username']} ({user['role']})")
                        
        except Exception as e:
            print(f"Erro ao carregar lista de usuários: {e}")
    
    def update_notifications(self):
        """Atualiza notificações"""
        try:
            if hasattr(self, 'chat_system') and self.chat_system:
                unread_notifications = self.chat_system.get_unread_notifications()
                
                if unread_notifications:
                    count = len(unread_notifications)
                    self.notifications_label.config(
                        text=f"{count} notificação(s) não lida(s)",
                        foreground="red"
                    )
                else:
                    self.notifications_label.config(
                        text="Nenhuma notificação",
                        foreground="gray"
                    )
                    
        except Exception as e:
            print(f"Erro ao atualizar notificações: {e}")
    
    def on_chat_selected(self, event):
        """Chamado quando um chat é selecionado na lista"""
        try:
            selection = self.chats_listbox.curselection()
            if selection:
                index = selection[0]
                chats = self.chat_system.get_user_chats()
                
                if index < len(chats):
                    chat = chats[index]
                    self.open_chat_window(chat)
                    
        except Exception as e:
            print(f"Erro ao selecionar chat: {e}")
    
    def open_chat_window(self, chat):
        """Abre janela de chat"""
        try:
            chat_type = chat['chat_type']
            
            if chat_type == 'board':
                # Buscar nome do quadro
                board_name = "Quadro"
                if chat.get('board_id'):
                    boards = self.db.get_boards()
                    for board in boards:
                        if board['id'] == chat['board_id']:
                            board_name = board['name']
                            break
                
                self.chat_system.open_project_chat(board_name)
                
            elif chat_type == 'card':
                # Buscar título do cartão
                card_title = chat['name'].replace("Chat - ", "")
                card_id = chat.get('card_id', 0)
                
                self.chat_system.open_card_comments(card_id, card_title)
                
            elif chat_type == 'direct':
                # Extrair username do nome do chat
                username = chat['name'].replace("Chat com ", "")
                
                # Buscar user_id pelo username
                users = self.db.get_all_users()
                target_user_id = None
                
                for user in users:
                    if user['username'] == username:
                        target_user_id = user['id']
                        break
                
                if target_user_id:
                    self.chat_system.open_direct_chat(target_user_id, username)
                    
        except Exception as e:
            print(f"Erro ao abrir chat: {e}")
    
    def open_board_chat(self):
        """Abre chat de um quadro selecionado"""
        try:
            selection = self.boards_listbox.curselection()
            if selection:
                board_name = self.boards_listbox.get(selection[0])
                self.chat_system.open_project_chat(board_name)
            else:
                messagebox.showwarning("Aviso", "Selecione um quadro primeiro.")
                
        except Exception as e:
            print(f"Erro ao abrir chat do quadro: {e}")
    
    def start_direct_chat(self, event=None):
        """Inicia chat direto com usuário selecionado"""
        try:
            selection = self.users_listbox.curselection()
            if selection:
                user_info = self.users_listbox.get(selection[0])
                username = user_info.split(" (")[0]  # Extrair username
                
                # Buscar user_id pelo username
                users = self.db.get_all_users()
                target_user_id = None
                
                for user in users:
                    if user['username'] == username:
                        target_user_id = user['id']
                        break
                
                if target_user_id:
                    self.chat_system.open_direct_chat(target_user_id, username)
                else:
                    messagebox.showerror("Erro", "Usuário não encontrado.")
            else:
                messagebox.showwarning("Aviso", "Selecione um usuário primeiro.")
                
        except Exception as e:
            print(f"Erro ao iniciar chat direto: {e}")

    def on_user_selected(self, event=None):
        """Chamado quando um usuário é selecionado na lista"""
        try:
            selection = self.users_listbox.curselection()
            if selection:
                user_info = self.users_listbox.get(selection[0])
                username = user_info.split(" (")[0]  # Extrair username
                
                # Buscar user_id pelo username
                users = self.db.get_all_users()
                target_user_id = None
                
                for user in users:
                    if user['username'] == username:
                        target_user_id = user['id']
                        break
                
                if target_user_id:
                    # Criar ou obter chat direto
                    direct_chat = self.chat_system.get_or_create_direct_chat(target_user_id)
                    if direct_chat:
                        self.load_chat_in_main_interface(direct_chat, f"Chat com {username}")
                    else:
                        messagebox.showerror("Erro", "Não foi possível criar o chat direto.")
                else:
                    messagebox.showerror("Erro", "Usuário não encontrado.")
                    
        except Exception as e:
            print(f"Erro ao selecionar usuário: {e}")
    
    def create_direct_chat(self):
        """Cria novo chat direto"""
        try:
            # Mostrar diálogo para selecionar usuário
            users = self.db.get_all_users()
            user_names = [f"{user['username']} ({user['role']})" for user in users 
                         if user['id'] != getattr(self.current_user, 'id', None)]
            
            if user_names:
                selected_user = simpledialog.askstring(
                    "Novo Chat Direto",
                    "Digite o nome do usuário para iniciar um chat:"
                )
                
                if selected_user:
                    # Extrair username
                    username = selected_user.split(" (")[0]
                    
                    # Buscar user_id
                    target_user_id = None
                    for user in users:
                        if user['username'] == username:
                            target_user_id = user['id']
                            break
                    
                    if target_user_id:
                        self.chat_system.open_direct_chat(target_user_id, username)
                    else:
                        messagebox.showerror("Erro", "Usuário não encontrado.")
            else:
                messagebox.showinfo("Info", "Não há outros usuários disponíveis.")
                
        except Exception as e:
            print(f"Erro ao criar chat direto: {e}")
    
    def show_all_notifications(self):
        """Mostra todas as notificações"""
        try:
            if hasattr(self, 'chat_system') and self.chat_system:
                unread_notifications = self.chat_system.get_unread_notifications()
                
                if unread_notifications:
                    notification_text = "Notificações não lidas:\n\n"
                    for notification in unread_notifications:
                        notification_text += f"• {notification['sender_name']}: {notification['chat_name']}\n"
                    
                    messagebox.showinfo("Notificações", notification_text)
                else:
                    messagebox.showinfo("Notificações", "Nenhuma notificação não lida.")
                    
        except Exception as e:
            print(f"Erro ao mostrar notificações: {e}")
    
    def get_unread_notifications(self):
        """Retorna notificações não lidas (método de compatibilidade)"""
        try:
            if hasattr(self, 'chat_system') and self.chat_system:
                return self.chat_system.get_unread_notifications()
            return []
        except Exception as e:
            print(f"Erro ao obter notificações: {e}")
            return []

    def check_deadlines(self):
        overdue_cards = []
        due_soon_cards = []
        today = datetime.now().date()
        tomorrow = today + timedelta(days=1)

        all_cards = self.get_all_cards()
        for card_info in all_cards:
            card = card_info['card']
            if card.get("due_date"):
                try:
                    due_date = datetime.strptime(card["due_date"].split(" ")[0], "%Y-%m-%d").date()
                    if due_date < today:
                        overdue_cards.append(card['title'])
                    elif due_date == today or due_date == tomorrow:
                        due_soon_cards.append(card['title'])
                except (ValueError, TypeError):
                    continue

        notification_message = ""
        if overdue_cards:
            notification_message += "Cartões Vencidos:\n" + "\n".join(f"- {title}" for title in overdue_cards) + "\n\n"
        
        if due_soon_cards:
            notification_message += "Cartões Vencendo Hoje ou Amanhã:\n" + "\n".join(f"- {title}" for title in due_soon_cards)

        if notification_message:
            messagebox.showwarning("Notificação de Prazos", notification_message, parent=self.root)
    
    def show_deadline_notifications(self):
        """Mostra notificações de prazos após o login"""
        print("DEBUG: Verificando notificações de prazos...")
        self.check_deadlines()

    def on_card_select_treeview(self, board_name, list_name, event):
        treeview = event.widget
        selected_item_id = treeview.focus() # Get the ID of the selected item

        if not selected_item_id:
            return

        # Get the card_id from the tags of the selected item
        card_id = treeview.item(selected_item_id, "tags")[0]
        
        # Find the actual card object using its card_id
        selected_card = None
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card.get('card_id') == card_id:
                selected_card = card
                break
        
        if not selected_card:
            return

        # Clear any previously expanded details for this treeview
        for child in treeview.get_children(selected_item_id): # Only clear children of the selected item
            treeview.delete(child)

        if self.settings.get('show_card_details_on_board', False):
            # If details are already expanded, collapse them
            if treeview.item(selected_item_id, 'open'):
                treeview.item(selected_item_id, open=False)
            else:
                # Expand details
                treeview.item(selected_item_id, open=True)

                # Add description
                desc = selected_card.get('desc', 'Sem descrição')
                treeview.insert(selected_item_id, "end", text="", values=("Descrição:", desc, "", ""), tags=("detail_row",))

                # Add members
                members = ", ".join(selected_card.get('members', []))
                if not members: members = "Nenhum membro atribuído"
                treeview.insert(selected_item_id, "end", text="", values=("Membros:", members, "", ""), tags=("detail_row",))

                # Add creation date
                creation_date = selected_card.get('creation_date', 'N/A')
                treeview.insert(selected_item_id, "end", text="", values=("Criação:", creation_date, "", ""), tags=("detail_row",))

                # Add subtasks
                subtasks = selected_card.get('subtasks', [])
                if subtasks:
                    subtask_summary = f"{sum(1 for s in subtasks if s['completed'])}/{len(subtasks)} subtarefas concluídas"
                    treeview.insert(selected_item_id, "end", text="", values=("Subtarefas:", subtask_summary, "", ""), tags=("detail_row",))
                    for subtask in subtasks:
                        status = "[X]" if subtask['completed'] else "[ ]"
                        treeview.insert(selected_item_id, "end", text="", values=("", f"{status} {subtask['text']}", "", ""), tags=("subtask_row",))
                else:
                    treeview.insert(selected_item_id, "end", text="", values=("Subtarefas:", "Nenhuma subtarefa", "", ""), tags=("detail_row",))

                # Add dependencies
                dependencies = selected_card.get('dependencies', [])
                if dependencies:
                    dep_status = self.get_card_dependency_status(selected_card)
                    dep_summary = f"{dep_status['completed']}/{dep_status['total']} dependências concluídas"
                    treeview.insert(selected_item_id, "end", text="", values=("Dependências:", dep_summary, "", ""), tags=("detail_row",))
                    for dep in dependencies:
                        is_completed = self._is_card_completed(dep)
                        status = "[X]" if is_completed else "[ ]"
                        treeview.insert(selected_item_id, "end", text="", values=("", f"{status} {dep}", "", ""), tags=("dependency_row",))
                else:
                    treeview.insert(selected_item_id, "end", text="", values=("Dependências:", "Nenhuma dependência", "", ""), tags=("detail_row",))

                # Add History
                history = selected_card.get('history', [])
                print(f"DEBUG: History for card {selected_card.get('title')}: {history}")
                if history:
                    treeview.insert(selected_item_id, "end", text="", values=("Histórico:", "", "", ""), tags=("detail_row",))
                    for entry in history:
                        timestamp = entry.get('timestamp', 'N/A')
                        action = entry.get('action', 'Ação desconhecida')
                        user = entry.get('user', 'Sistema')
                        treeview.insert(selected_item_id, "end", text="", values=("", f"{timestamp} - {action} (por {user})", "", ""), tags=("history_row",))
                else:
                    treeview.insert(selected_item_id, "end", text="", values=("Histórico:", "Nenhum histórico de atividade", "", ""), tags=("detail_row",))

        # Apply styling for detail rows
        treeview.tag_configure("detail_row", background="#e0e0e0", foreground="#333333")
        treeview.tag_configure("subtask_row", background="#f0f0f0", foreground="#555555")
        treeview.tag_configure("dependency_row", background="#f0f0f0", foreground="#555555")
        treeview.tag_configure("history_row", background="#f0f0f0", foreground="#555555")

        treeview.bind("<Double-1>", lambda event, c=selected_card: self.on_detail_treeview_double_click(event, c))

    def on_detail_treeview_double_click(self, event, card):
        treeview = event.widget
        item_id = treeview.identify_row(event.y)
        if not item_id:
            return

        # A simple way to check if it's a subtask row
        if treeview.item(item_id, "tags")[0] == "subtask_row":
            # This is tricky because we don't have the subtask ID here directly.
            # We'll have to find it by its text, which is not ideal but works for now.
            subtask_text_with_status = treeview.item(item_id, "values")[1]
            subtask_text = subtask_text_with_status.split("] ", 1)[1]
            
            subtask_to_edit = None
            for subtask in card.get("subtasks", []):
                if subtask["text"] == subtask_text:
                    subtask_to_edit = subtask
                    break
            
            if subtask_to_edit:
                SubtaskEditorWindow(self.root, self, card, subtask_to_edit)

    def on_tab_drag_start(self, event):
        try:
            tab_index = self.board_notebook.index(f"@{event.x},{event.y}")
            if tab_index != "": # Check if a tab was actually clicked
                self._drag_data["item"] = self.board_notebook.tabs()[tab_index]
                self._drag_data["x"] = event.x
                self._drag_data["y"] = event.y
                self._drag_data["tab_index"] = tab_index
        except tk.TclError:
            pass # No tab clicked

    def on_tab_drag_motion(self, event):
        if self._drag_data["item"]:
            # This part is for visual feedback, not actual reordering yet
            # For a simple visual, we don't need complex logic here
            pass

    def on_tab_drag_release(self, event):
        if self._drag_data["item"]:
            try:
                # Get the new tab index where the mouse was released
                new_tab_index = self.board_notebook.index(f"@{event.x},{event.y}")
                if new_tab_index == "": # Dropped outside a tab, or on empty space
                    new_tab_index = len(self.board_notebook.tabs()) -1 # Move to end
                
                old_tab_index = self._drag_data["tab_index"]

                if old_tab_index != new_tab_index:
                    # Get the actual board name from the old position
                    board_name_to_move = self.board_notebook.tab(old_tab_index, "text")
                    
                    # Reorder the internal data model (self.boodesk_data["boards"])
                    # Convert dict to ordered list of (name, data) pairs
                    ordered_boards = list(self.boodesk_data["boards"].items())
                    
                    # Find and remove the board to move
                    board_data_to_move = None
                    for i, (name, data) in enumerate(ordered_boards):
                        if name == board_name_to_move:
                            board_data_to_move = ordered_boards.pop(i)
                            break
                    
                    if board_data_to_move:
                        # Insert the board at the new position
                        ordered_boards.insert(new_tab_index, board_data_to_move)
                        
                        # Reconstruct the boards dictionary to maintain order
                        self.boodesk_data["boards"] = {name: data for name, data in ordered_boards}
                        self.save_trello_data()
                        self.populate_boards() # Refresh UI
                        self.board_notebook.select(new_tab_index) # Select the moved tab

            except tk.TclError:
                pass # Invalid drop target
            finally:
                self._drag_data = {"item": None, "x": 0, "y": 0, "tab_index": -1}

    def rename_current_board(self):
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado para renomear.", parent=self.root)
                return
            old_name = self.board_notebook.tab(current_tab_index, "text")
            if old_name == "Vazio": # Cannot rename empty tab
                messagebox.showwarning("Aviso", "Não é possível renomear o quadro vazio.", parent=self.root)
                return
            self.rename_board(old_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado para renomear.", parent=self.root)

    def delete_current_board(self):
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado para excluir.", parent=self.root)
                return
            board_name = self.board_notebook.tab(current_tab_index, "text")
            if board_name == "Vazio": # Cannot delete empty tab
                messagebox.showwarning("Aviso", "Não é possível excluir o quadro vazio.", parent=self.root)
                return
            self.delete_board(board_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado para excluir.", parent=self.root)
    
    def open_project_chat(self):
        """Abre o chat do projeto atual (seleciona a aba de chat no quadro)"""
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)
                return
            board_name = self.board_notebook.tab(current_tab_index, "text")
            if board_name == "Vazio": # Cannot chat empty tab
                messagebox.showwarning("Aviso", "Não é possível abrir chat para o quadro vazio.", parent=self.root)
                return
            
            # Selecionar a aba de chat no quadro atual
            board_frame = self.board_notebook.select()
            board_widget = self.board_notebook.nametowidget(board_frame)
            
            # Encontrar o notebook interno e selecionar a aba de chat
            for child in board_widget.winfo_children():
                if isinstance(child, ttk.Notebook):
                    child.select(1)  # Selecionar a segunda aba (Chat)
                    break
                    
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)
    
    def open_meeting_window(self):
        """Abre a janela de criação de reuniões"""
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)
                return
            board_name = self.board_notebook.tab(current_tab_index, "text")
            if board_name == "Vazio": # Cannot create meeting for empty tab
                messagebox.showwarning("Aviso", "Não é possível criar reunião para o quadro vazio.", parent=self.root)
                return
            MeetingWindow(self.root, self, board_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)

    def show_board_tab_context_menu(self, event):
        try:
            tab_id = self.board_notebook.identify(event.x, event.y)
            if tab_id and tab_id != "":
                tab_name = self.board_notebook.tab(tab_id, "text")
                if tab_name == "Vazio":
                    return

                board_context_menu = tk.Menu(self.root, tearoff=0)
                board_context_menu.add_command(label=f"Renomear Quadro: {tab_name}", image=self.icons.get('pencil_icon'), compound=tk.LEFT, command=partial(self.rename_board, tab_name))
                board_context_menu.add_command(label=f"Excluir Quadro: {tab_name}", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=partial(self.delete_board, tab_name))
                board_context_menu.post(event.x_root, event.y_root)
        except tk.TclError:
            pass

    def create_productivity_sub_tabs(self, parent):
        self.productivity_notebook = ttk.Notebook(parent)
        self.productivity_notebook.pack(fill=tk.BOTH, expand=True)

        pomodoro_timer_frame = ttk.Frame(self.productivity_notebook)
        my_activities_frame = ttk.Frame(self.productivity_notebook)
        my_subtasks_frame = ttk.Frame(self.productivity_notebook)

        # Adicionar abas com ícones (ordem alterada)
        if hasattr(self, 'icons') and self.icons.get('minhas_atividades_icon'):
            self.productivity_notebook.add(my_activities_frame, text='Minhas Atividades', image=self.icons['minhas_atividades_icon'], compound=tk.LEFT)
        else:
            self.productivity_notebook.add(my_activities_frame, text='Minhas Atividades')
            
        if hasattr(self, 'icons') and self.icons.get('pomodoro_icon'):
            self.productivity_notebook.add(pomodoro_timer_frame, text='Timer Pomodoro', image=self.icons['pomodoro_icon'], compound=tk.LEFT)
        else:
            self.productivity_notebook.add(pomodoro_timer_frame, text='Timer Pomodoro')
        
        # Nova aba para subtarefas delegadas
        if hasattr(self, 'icons') and self.icons.get('subtask_icon'):
            self.productivity_notebook.add(my_subtasks_frame, text='Minhas Subtarefas', image=self.icons['subtask_icon'], compound=tk.LEFT)
        else:
            self.productivity_notebook.add(my_subtasks_frame, text='Minhas Subtarefas')

        # Create a new notebook for the Pomodoro Timer and History
        pomodoro_notebook = ttk.Notebook(pomodoro_timer_frame)
        pomodoro_notebook.pack(fill=tk.BOTH, expand=True)

        timer_tab_frame = ttk.Frame(pomodoro_notebook)
        history_tab_frame = ttk.Frame(pomodoro_notebook)

        pomodoro_notebook.add(timer_tab_frame, text='Timer')
        pomodoro_notebook.add(history_tab_frame, text='Histórico')

        self.create_pomodoro_timer_tab(timer_tab_frame)
        self.create_my_activities_tab(my_activities_frame)
        self.create_my_subtasks_tab(my_subtasks_frame)
        self.create_history_tab(history_tab_frame)
    
    def create_my_subtasks_tab(self, parent):
        """Cria aba para mostrar subtarefas delegadas ao usuário"""
        # Frame principal
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text="📋 Minhas Subtarefas Delegadas", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        # Botões de ação
        btn_frame = ttk.Frame(title_frame)
        btn_frame.pack(side=tk.RIGHT)
        
        ttk.Button(btn_frame, text="🔄 Atualizar", 
                  command=self.refresh_my_subtasks).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(btn_frame, text="📊 Relatório", 
                  command=self.show_subtasks_report).pack(side=tk.LEFT, padx=5)
        
        # Frame para filtros
        filters_frame = ttk.LabelFrame(main_frame, text="Filtros", padding="10")
        filters_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Filtro por status
        ttk.Label(filters_frame, text="Status:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.subtask_status_filter = ttk.Combobox(filters_frame, 
                                                values=["Todas", "Pendentes", "Em Progresso", "Concluídas"],
                                                state="readonly", width=15)
        self.subtask_status_filter.set("Todas")
        self.subtask_status_filter.grid(row=0, column=1, sticky="w", padx=5, pady=2)
        self.subtask_status_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_my_subtasks())
        
        # Filtro por prioridade
        ttk.Label(filters_frame, text="Prioridade:").grid(row=0, column=2, sticky="w", padx=5, pady=2)
        self.subtask_priority_filter = ttk.Combobox(filters_frame, 
                                                  values=["Todas", "Baixa", "Normal", "Alta", "Crítica"],
                                                  state="readonly", width=15)
        self.subtask_priority_filter.set("Todas")
        self.subtask_priority_filter.grid(row=0, column=3, sticky="w", padx=5, pady=2)
        self.subtask_priority_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_my_subtasks())
        
        # Treeview para subtarefas
        tree_frame = ttk.Frame(main_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbars
        tree_scrollbar_y = ttk.Scrollbar(tree_frame)
        tree_scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        
        tree_scrollbar_x = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL)
        tree_scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Treeview
        columns = ("ID", "Título", "Card Pai", "Status", "Prioridade", "Data Criação", "Responsável")
        self.my_subtasks_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", 
                                           yscrollcommand=tree_scrollbar_y.set,
                                           xscrollcommand=tree_scrollbar_x.set)
        
        # Configurar colunas
        self.my_subtasks_tree.heading("ID", text="ID")
        self.my_subtasks_tree.heading("Título", text="Título da Subtarefa")
        self.my_subtasks_tree.heading("Card Pai", text="Card Pai")
        self.my_subtasks_tree.heading("Status", text="Status")
        self.my_subtasks_tree.heading("Prioridade", text="Prioridade")
        self.my_subtasks_tree.heading("Data Criação", text="Data Criação")
        self.my_subtasks_tree.heading("Responsável", text="Responsável")
        
        self.my_subtasks_tree.column("ID", width=80, anchor="center")
        self.my_subtasks_tree.column("Título", width=200, anchor="w")
        self.my_subtasks_tree.column("Card Pai", width=150, anchor="w")
        self.my_subtasks_tree.column("Status", width=100, anchor="center")
        self.my_subtasks_tree.column("Prioridade", width=100, anchor="center")
        self.my_subtasks_tree.column("Data Criação", width=120, anchor="center")
        self.my_subtasks_tree.column("Responsável", width=120, anchor="w")
        
        self.my_subtasks_tree.pack(fill=tk.BOTH, expand=True)
        
        # Configurar scrollbars
        tree_scrollbar_y.config(command=self.my_subtasks_tree.yview)
        tree_scrollbar_x.config(command=self.my_subtasks_tree.xview)
        
        # Bind eventos
        self.my_subtasks_tree.bind("<Double-1>", self.open_subtask_from_tree)
        self.my_subtasks_tree.bind("<Delete>", lambda e: self.delete_subtask_from_tree())
        
        # Frame para estatísticas
        stats_frame = ttk.LabelFrame(main_frame, text="Estatísticas", padding="10")
        stats_frame.pack(fill=tk.X, pady=(10, 0))
        
        # Estatísticas
        self.subtask_total_label = ttk.Label(stats_frame, text="Total: 0", font=("Arial", 12, "bold"))
        self.subtask_total_label.pack(side=tk.LEFT, padx=10)
        
        self.subtask_pending_label = ttk.Label(stats_frame, text="Pendentes: 0", font=("Arial", 10))
        self.subtask_pending_label.pack(side=tk.LEFT, padx=10)
        
        self.subtask_in_progress_label = ttk.Label(stats_frame, text="Em Progresso: 0", font=("Arial", 10))
        self.subtask_in_progress_label.pack(side=tk.LEFT, padx=10)
        
        self.subtask_completed_label = ttk.Label(stats_frame, text="Concluídas: 0", font=("Arial", 10))
        self.subtask_completed_label.pack(side=tk.LEFT, padx=10)
        
        # Carregar dados iniciais
        self.load_my_subtasks()
    
    def create_integrated_chat(self, parent_frame, board_name):
        """Cria chat integrado dentro do quadro"""
        try:
            # Frame principal do chat
            chat_main_frame = ttk.Frame(parent_frame)
            chat_main_frame.pack(fill=tk.BOTH, expand=True)
            
            # Título do chat
            title_frame = ttk.Frame(chat_main_frame)
            title_frame.pack(fill=tk.X, pady=(0, 10))
            
            ttk.Label(title_frame, text=f"Chat - {board_name}", 
                     font=("Arial", 12, "bold")).pack(side=tk.LEFT)
            
            # Botões de ação
            ttk.Button(title_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                      command=lambda: self.open_chat_search(board_name)).pack(side=tk.RIGHT, padx=5)
            ttk.Button(title_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                      command=lambda: self.refresh_integrated_chat(board_name)).pack(side=tk.RIGHT, padx=5)
            
            # Frame para mensagens
            messages_frame = ttk.LabelFrame(chat_main_frame, text="Mensagens", padding="10")
            messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
            
            # Text widget para mensagens
            messages_text = tk.Text(messages_frame, wrap=tk.WORD, state=tk.DISABLED, height=15)
            messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Scrollbar
            scrollbar = ttk.Scrollbar(messages_frame, orient="vertical", command=messages_text.yview)
            messages_text.configure(yscrollcommand=scrollbar.set)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # Frame para entrada de mensagem
            input_frame = ttk.Frame(chat_main_frame)
            input_frame.pack(fill=tk.X)
            
            # Campo de entrada
            message_var = tk.StringVar()
            message_entry = ttk.Entry(input_frame, textvariable=message_var, font=("Arial", 10))
            message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
            message_entry.bind("<Return>", lambda e: self.send_integrated_chat_message(board_name, message_var, message_entry))
            
            # Contador de caracteres
            char_count_label = ttk.Label(input_frame, text="0/1000", font=("Arial", 8), foreground="gray")
            char_count_label.pack(side=tk.LEFT, padx=(0, 10))
            
            # Botão enviar
            ttk.Button(input_frame, text="Enviar", image=self.icons.get('forward_icon'), compound=tk.LEFT,
                      command=lambda: self.send_integrated_chat_message(board_name, message_var, message_entry)).pack(side=tk.RIGHT)
            
            # Configurar tags para formatação
            messages_text.tag_config("timestamp", foreground="gray")
            messages_text.tag_config("username", foreground="blue", font=("Arial", 10, "bold"))
            messages_text.tag_config("message", font=("Arial", 10))
            
            # Armazenar referências para uso posterior
            chat_widgets = {
                'messages_text': messages_text,
                'message_var': message_var,
                'message_entry': message_entry,
                'char_count_label': char_count_label
            }
            
            # Armazenar widgets do chat para este quadro
            if not hasattr(self, 'integrated_chat_widgets'):
                self.integrated_chat_widgets = {}
            self.integrated_chat_widgets[board_name] = chat_widgets
            
            # Bind para contador de caracteres
            message_entry.bind("<KeyRelease>", lambda e: self.update_integrated_char_count(board_name))
            
            # Carregar mensagens existentes
            self.load_integrated_chat_messages(board_name)
            
            # Focar no campo de entrada
            message_entry.focus()
            
        except Exception as e:
            print(f"Erro ao criar chat integrado: {e}")
            ttk.Label(parent_frame, text=f"Erro ao carregar chat: {e}", foreground="red").pack()
    
    def send_integrated_chat_message(self, board_name, message_var, message_entry):
        """Envia mensagem no chat integrado"""
        message = message_var.get().strip()
        if not message:
            return
        
        # Verificar limite de caracteres (1000 caracteres)
        MAX_MESSAGE_LENGTH = 1000
        if len(message) > MAX_MESSAGE_LENGTH:
            messagebox.showwarning("Limite Excedido", 
                                 f"A mensagem deve ter no máximo {MAX_MESSAGE_LENGTH} caracteres.\n"
                                 f"Sua mensagem tem {len(message)} caracteres.")
            return
        
        # Verificar se há usuário logado
        if not hasattr(self, 'current_user') or not self.current_user:
            messagebox.showwarning("Aviso", "Você precisa estar logado para enviar mensagens!")
            return
        
        username = self.current_user.username
        
        # Adicionar mensagem ao sistema de chat
        self.chat_system.add_chat_message(board_name, username, message)
        
        # Limpar campo de entrada
        message_var.set("")
        
        # Atualizar contador
        self.update_integrated_char_count(board_name)
        
        # Recarregar mensagens
        self.load_integrated_chat_messages(board_name)
        
        # Focar novamente no campo
        message_entry.focus()
    
    def update_integrated_char_count(self, board_name):
        """Atualiza contador de caracteres do chat integrado"""
        if board_name in self.integrated_chat_widgets:
            widgets = self.integrated_chat_widgets[board_name]
            current_length = len(widgets['message_var'].get())
            max_length = 1000
            
            # Atualizar contador
            widgets['char_count_label'].config(text=f"{current_length}/{max_length}")
            
            # Mudar cor baseado no limite
            if current_length > max_length * 0.9:  # 90% do limite
                widgets['char_count_label'].config(foreground="orange")
            elif current_length > max_length:
                widgets['char_count_label'].config(foreground="red")
            else:
                widgets['char_count_label'].config(foreground="gray")
    
    def load_integrated_chat_messages(self, board_name):
        """Carrega mensagens do chat integrado"""
        if board_name in self.integrated_chat_widgets:
            widgets = self.integrated_chat_widgets[board_name]
            messages_text = widgets['messages_text']
            
            messages_text.config(state=tk.NORMAL)
            messages_text.delete(1.0, tk.END)
            
            if board_name in self.chat_system.chat_data:
                for message in self.chat_system.chat_data[board_name]:
                    self.display_integrated_message(messages_text, message)
            
            messages_text.config(state=tk.DISABLED)
            messages_text.see(tk.END)
    
    def display_integrated_message(self, messages_text, message):
        """Exibe uma mensagem no chat integrado"""
        # Formatar mensagem
        timestamp = message['timestamp']
        username = message['username']
        text = message['message']
        
        # Adicionar timestamp
        messages_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
        
        # Adicionar username
        messages_text.insert(tk.END, f"{username}: ", "username")
        
        # Adicionar mensagem
        messages_text.insert(tk.END, f"{text}\n", "message")
    
    def refresh_integrated_chat(self, board_name):
        """Atualiza o chat integrado"""
        self.load_integrated_chat_messages(board_name)
    
    def open_chat_search(self, board_name):
        """Abre busca no chat integrado"""
        ChatSearchWindow(self.root, self, board_name)
    
    def open_chat_tab(self, board_name):
        """Abre a aba de chat do quadro especificado"""
        try:
            # Encontrar o quadro no notebook
            for i, tab in enumerate(self.board_notebook.tabs()):
                if self.board_notebook.tab(i, "text") == board_name:
                    # Selecionar o quadro
                    self.board_notebook.select(i)
                    
                    # Obter o widget do quadro
                    board_frame = self.board_notebook.select()
                    board_widget = self.board_notebook.nametowidget(board_frame)
                    
                    # Encontrar o notebook interno e selecionar a aba de chat
                    for child in board_widget.winfo_children():
                        if isinstance(child, ttk.Notebook):
                            child.select(1)  # Selecionar a segunda aba (Chat)
                            break
                    break
                    
        except Exception as e:
            print(f"Erro ao abrir aba de chat: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir chat: {e}", parent=self.root)

    def create_finance_sub_tabs(self, parent):
        """Cria as abas do sistema financeiro empresarial"""
        self.finance_notebook = ttk.Notebook(parent)
        self.finance_notebook.pack(fill=tk.BOTH, expand=True)

        # Visão Geral Financeira
        overview_frame = ttk.Frame(self.finance_notebook)
        self.create_overview_tab(overview_frame)
        self.finance_notebook.add(overview_frame, text="📊 Visão Geral")

        # Gestão de Clientes
        clients_frame = ttk.Frame(self.finance_notebook)
        self.create_clients_management_tab(clients_frame)
        self.finance_notebook.add(clients_frame, text="👥 Clientes")

        # Gestão de Fornecedores
        suppliers_frame = ttk.Frame(self.finance_notebook)
        self.create_suppliers_management_tab(suppliers_frame)
        self.finance_notebook.add(suppliers_frame, text="🏭 Fornecedores")

        # Contas a Receber
        receivables_frame = ttk.Frame(self.finance_notebook)
        self.create_receivables_management_tab(receivables_frame)
        self.finance_notebook.add(receivables_frame, text="📥 Contas a Receber")

        # Contas a Pagar
        payables_frame = ttk.Frame(self.finance_notebook)
        self.create_payables_management_tab(payables_frame)
        self.finance_notebook.add(payables_frame, text="📤 Contas a Pagar")

        # Faturas/Notas Fiscais
        invoices_frame = ttk.Frame(self.finance_notebook)
        self.create_invoices_management_tab(invoices_frame)
        self.finance_notebook.add(invoices_frame, text="🧾 Faturas")

        # Fluxo de Caixa
        cashflow_frame = ttk.Frame(self.finance_notebook)
        self.create_cashflow_management_tab(cashflow_frame)
        self.finance_notebook.add(cashflow_frame, text="💼 Fluxo de Caixa")

        # Orçamentos
        budgets_frame = ttk.Frame(self.finance_notebook)
        self.create_budgets_management_tab(budgets_frame)
        self.finance_notebook.add(budgets_frame, text="📊 Orçamentos")

        # Relatórios Empresariais
        reports_frame = ttk.Frame(self.finance_notebook)
        self.create_enterprise_reports_tab(reports_frame)
        self.finance_notebook.add(reports_frame, text="📈 Relatórios")

        # Registro (Contas, Categorias, Meios de Pagamento)
        registration_frame = ttk.Frame(self.finance_notebook)
        self.create_registration_tab(registration_frame)
        self.finance_notebook.add(registration_frame, text="📝 Registro")

        # Entradas
        incomes_frame = ttk.Frame(self.finance_notebook)
        self.create_incomes_tab(incomes_frame)
        self.finance_notebook.add(incomes_frame, text="💰 Entradas")

        # Saídas
        expenses_frame = ttk.Frame(self.finance_notebook)
        self.create_expenses_tab(expenses_frame)
        self.finance_notebook.add(expenses_frame, text="💸 Saídas")

        # Configurações
        config_frame = ttk.Frame(self.finance_notebook)
        self.create_finance_config_tab(config_frame)
        self.finance_notebook.add(config_frame, text="⚙️ Configurações")

    def select_tab_by_text(self, tab_text):
        """Seleciona uma aba do notebook principal pelo seu texto."""
        for i, tab in enumerate(self.main_notebook.tabs()):
            if self.main_notebook.tab(i, "text") == tab_text:
                self.main_notebook.select(i)
                return

    def update_dashboard_widgets(self):
        """Atualiza todos os widgets no dashboard."""
        # Update overview
        self.update_main_menu_overview()
        
        # Update urgent tasks
        self.update_urgent_tasks_widget()
        
        # Update upcoming deadlines
        self.update_upcoming_deadlines_widget()
        
        # Update recent activities
        self.update_recent_activities_widget()

    def update_dashboard_activities_widget(self):
        """Atualiza o widget 'Minhas Atividades' no dashboard."""
        if not hasattr(self, 'dashboard_activities_tree'):
            return

        for i in self.dashboard_activities_tree.get_children():
            self.dashboard_activities_tree.delete(i)

        if not self.current_user:
            return
        
        user_name = self.current_user.username
        all_cards = self.get_all_cards()
        user_cards = [
            card_info for card_info in all_cards 
            if user_name in card_info['card'].get("members", []) and 
               "concluído" not in card_info['list_name'].lower()
        ]

        importance_order = {level: i for i, level in enumerate(self.settings["importance_colors"].keys())}
        
        def sort_key(card_info):
            card = card_info['card']
            due_date_str = card.get("due_date", "")
            due_date = datetime.max
            if due_date_str:
                try:
                    due_date = datetime.strptime(due_date_str.split(' ')[0], "%Y-%m-%d")
                except ValueError:
                    pass
            importance_level = card.get("importance", "Normal")
            importance_val = importance_order.get(importance_level, 99)
            return (due_date, importance_val)

        user_cards.sort(key=sort_key)

        for card_info in user_cards:
            card = card_info['card']
            # Adiciona card_id às tags. A primeira tag é para a cor.
            tags = (card.get("importance", "Normal"), card.get('card_id'))
            self.dashboard_activities_tree.insert("", "end", values=(
                card['title'],
                card_info['board_name'],
                card.get("due_date", "N/A")
            ), tags=tags)

        # Apply colors based on importance tags
        for importance, color in self.settings["importance_colors"].items():
            self.dashboard_activities_tree.tag_configure(importance, background=color)

    def on_dashboard_activity_double_click(self, event):
        item_id = self.dashboard_activities_tree.focus()
        if not item_id:
            return

        tags = self.dashboard_activities_tree.item(item_id, "tags")
        if len(tags) < 2:
            return # Should have importance and card_id

        card_id = tags[1]

        # Find the card, its list and board
        found_card = None
        for board_name, lists in self.boodesk_data["boards"].items():
            if board_name == "workflow": continue
            for list_name, cards in lists.items():
                for card in cards:
                    if card.get("card_id") == card_id:
                        found_card = card
                        # Find the card_id for the found card
                        card_id = found_card.get('card_id')
                        if card_id:
                            # Dynamically get the class from the module to avoid NameError at definition time
                            CardDetailsWindow = getattr(sys.modules[__name__], 'CardDetailsWindow')
                            CardDetailsWindow(self.root, self, board_name, list_name, card_id, self.current_user)
                        else:
                            messagebox.showerror("Erro", "ID do cartão não encontrado.")
                        return

    def create_main_menu_tab(self, parent):
        # Main frame for the dashboard
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- Widgets ---
        # This frame will hold the widgets and allow for a grid layout
        widgets_frame = ttk.Frame(main_frame)
        widgets_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure grid for 2 columns and 2 rows
        widgets_frame.columnconfigure(0, weight=1)
        widgets_frame.columnconfigure(1, weight=1)
        widgets_frame.rowconfigure(0, weight=1)
        widgets_frame.rowconfigure(1, weight=1)

        # Store widget references for visibility control
        self.dashboard_widgets = {}

        # Create all widgets
        self.create_overview_widget(widgets_frame, 0, 0)
        self.create_urgent_tasks_widget(widgets_frame, 0, 1)
        self.create_upcoming_deadlines_widget(widgets_frame, 1, 0)
        self.create_recent_activities_widget(widgets_frame, 1, 1)
        self.create_quick_links_widget(widgets_frame, 2, 0)
        self.create_quick_actions_widget(widgets_frame, 2, 1)
        
        # Criar widget de reuniões se habilitado (após a visão geral)
        if self.notification_manager.notification_settings['show_widget']:
            # Criar o widget após a visão geral ser criada
            self.meeting_widget = None  # Será criado após os widgets principais

        # Apply widget visibility settings
        self.apply_dashboard_widget_settings()

        # --- Update call ---
        self.update_dashboard_widgets()

    def create_overview_widget(self, parent, row, col):
        """Cria o widget de visão geral"""
        overview_frame = ttk.LabelFrame(parent, text="Visão Geral", padding="10")
        overview_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        self.dashboard_widgets['overview'] = overview_frame

        # Título com ícone
        title_frame = ttk.Frame(overview_frame)
        title_frame.pack(fill=tk.X, pady=5)
        
        if hasattr(self, 'icons') and self.icons.get('dashboard_icon'):
            ttk.Label(title_frame, text="Bem-vindo ao seu Dashboard!", image=self.icons['dashboard_icon'], compound=tk.LEFT).pack(anchor="w")
        else:
            ttk.Label(title_frame, text="Bem-vindo ao seu Dashboard!").pack(anchor="w")
        
        # Estatísticas com ícones
        if hasattr(self, 'icons') and self.icons.get('folder_icon'):
            self.total_boards_label = ttk.Label(overview_frame, text="Total de Quadros: 0", image=self.icons['folder_icon'], compound=tk.LEFT)
        else:
            self.total_boards_label = ttk.Label(overview_frame, text="Total de Quadros: 0")
        self.total_boards_label.pack(pady=2, anchor="w")
        
        if hasattr(self, 'icons') and self.icons.get('pomodoro_icon'):
            self.total_tasks_label = ttk.Label(overview_frame, text="Total de Tarefas Pomodoro: 0", image=self.icons['pomodoro_icon'], compound=tk.LEFT)
        else:
            self.total_tasks_label = ttk.Label(overview_frame, text="Total de Tarefas Pomodoro: 0")
        self.total_tasks_label.pack(pady=2, anchor="w")
        
        if hasattr(self, 'icons') and self.icons.get('team_icon_32'):
            self.total_members_label = ttk.Label(overview_frame, text="Total de Membros: 0", image=self.icons['team_icon_32'], compound=tk.LEFT)
        else:
            self.total_members_label = ttk.Label(overview_frame, text="Total de Membros: 0")
        self.total_members_label.pack(pady=2, anchor="w")
        
        # Criar widget de reuniões discreto abaixo da visão geral
        if self.notification_manager.notification_settings['show_widget']:
            self.meeting_widget = MeetingWidget(self, overview_frame)

    def create_urgent_tasks_widget(self, parent, row, col):
        """Cria o widget de tarefas urgentes"""
        urgent_frame = ttk.LabelFrame(parent, text="Tarefas Urgentes", padding="10")
        urgent_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        urgent_frame.rowconfigure(0, weight=1)
        urgent_frame.columnconfigure(0, weight=1)
        self.dashboard_widgets['urgent_tasks'] = urgent_frame

        # Treeview for urgent tasks
        self.urgent_tasks_tree = ttk.Treeview(urgent_frame, columns=("Tarefa", "Quadro", "Importância"), show="headings", height=6)
        self.urgent_tasks_tree.heading("Tarefa", text="Tarefa")
        self.urgent_tasks_tree.heading("Quadro", text="Quadro")
        self.urgent_tasks_tree.heading("Importância", text="Importância")

        self.urgent_tasks_tree.column("Tarefa", width=200)
        self.urgent_tasks_tree.column("Quadro", width=100)
        self.urgent_tasks_tree.column("Importância", width=80, anchor="center")
        
        self.urgent_tasks_tree.bind("<Double-1>", self.on_urgent_task_double_click)

        # Add a scrollbar
        scrollbar = ttk.Scrollbar(urgent_frame, orient="vertical", command=self.urgent_tasks_tree.yview)
        self.urgent_tasks_tree.configure(yscrollcommand=scrollbar.set)
        
        self.urgent_tasks_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def create_upcoming_deadlines_widget(self, parent, row, col):
        """Cria o widget de prazos próximos"""
        deadlines_frame = ttk.LabelFrame(parent, text="Próximos Prazos", padding="10")
        deadlines_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        deadlines_frame.rowconfigure(0, weight=1)
        deadlines_frame.columnconfigure(0, weight=1)
        self.dashboard_widgets['upcoming_deadlines'] = deadlines_frame

        # Treeview for upcoming deadlines
        self.deadlines_tree = ttk.Treeview(deadlines_frame, columns=("Tarefa", "Prazo", "Dias"), show="headings", height=6)
        self.deadlines_tree.heading("Tarefa", text="Tarefa")
        self.deadlines_tree.heading("Prazo", text="Prazo")
        self.deadlines_tree.heading("Dias", text="Dias")

        self.deadlines_tree.column("Tarefa", width=200)
        self.deadlines_tree.column("Prazo", width=100)
        self.deadlines_tree.column("Dias", width=60, anchor="center")
        
        self.deadlines_tree.bind("<Double-1>", self.on_deadline_double_click)

        # Add a scrollbar
        scrollbar = ttk.Scrollbar(deadlines_frame, orient="vertical", command=self.deadlines_tree.yview)
        self.deadlines_tree.configure(yscrollcommand=scrollbar.set)
        
        self.deadlines_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def create_recent_activities_widget(self, parent, row, col):
        """Cria o widget de atividades recentes"""
        activities_frame = ttk.LabelFrame(parent, text="Atividades Recentes", padding="10")
        activities_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        activities_frame.rowconfigure(0, weight=1)
        activities_frame.columnconfigure(0, weight=1)
        self.dashboard_widgets['recent_activities'] = activities_frame

        # Treeview for recent activities
        self.recent_activities_tree = ttk.Treeview(activities_frame, columns=("Ação", "Data"), show="headings", height=6)
        self.recent_activities_tree.heading("Ação", text="Ação")
        self.recent_activities_tree.heading("Data", text="Data")

        self.recent_activities_tree.column("Ação", width=250)
        self.recent_activities_tree.column("Data", width=100)
        
        self.recent_activities_tree.bind("<Double-1>", self.on_activity_double_click)

        # Add a scrollbar
        scrollbar = ttk.Scrollbar(activities_frame, orient="vertical", command=self.recent_activities_tree.yview)
        self.recent_activities_tree.configure(yscrollcommand=scrollbar.set)
        
        self.recent_activities_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def create_quick_links_widget(self, parent, row, col):
        """Cria o widget de links rápidos"""
        links_frame = ttk.LabelFrame(parent, text="Links Frequentes", padding="10")
        links_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        self.dashboard_widgets['quick_links'] = links_frame

        ttk.Button(links_frame, text="Quadros", image=self.icons.get('folder_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Quadros')).pack(fill=tk.X, pady=2)
        ttk.Button(links_frame, text="Produtividade", image=self.icons.get('play_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Produtividade')).pack(fill=tk.X, pady=2)
        ttk.Button(links_frame, text="Finanças", image=self.icons.get('money_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Finanças')).pack(fill=tk.X, pady=2)
        ttk.Button(links_frame, text="Relatórios", image=self.icons.get('pie_chart_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Relatórios')).pack(fill=tk.X, pady=2)

    def create_quick_actions_widget(self, parent, row, col):
        """Cria o widget de ações rápidas"""
        actions_frame = ttk.LabelFrame(parent, text="Ações Rápidas", padding="10")
        actions_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        self.dashboard_widgets['quick_actions'] = actions_frame

        ttk.Button(actions_frame, text="Adicionar Quadro", image=self.icons.get('add_folder_icon'), compound=tk.LEFT, 
                  command=self.add_board).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Iniciar Pomodoro", image=self.icons.get('play_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Produtividade')).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Nova Transação", image=self.icons.get('add_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Finanças')).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Gerenciar Usuários", image=self.icons.get('key_icon'), compound=tk.LEFT, 
                  command=self.open_user_management).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Configurar Notificações", image=self.icons.get('settings_icon'), compound=tk.LEFT, 
                  command=self.open_notification_settings).pack(fill=tk.X, pady=2)
        
        # Botão para alternar widget de reuniões será movido para configurações do dashboard
        
        # Widget de reuniões será criado no método create_main_menu_tab
        ttk.Button(actions_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT, 
                  command=self.update_dashboard_widgets).pack(fill=tk.X, pady=2)

    def apply_dashboard_widget_settings(self):
        """Aplica as configurações de visibilidade dos widgets"""
        widget_settings = self.settings.get('dashboard_widgets', {})
        
        # Converter string JSON para dicionário se necessário
        if isinstance(widget_settings, str):
            try:
                import json
                widget_settings = json.loads(widget_settings)
            except:
                widget_settings = {}
        
        for widget_name, frame in self.dashboard_widgets.items():
            if widget_settings.get(widget_name, True):
                frame.grid()
            else:
                frame.grid_remove()

    def on_urgent_task_double_click(self, event):
        """Handler para duplo clique em tarefa urgente"""
        selection = self.urgent_tasks_tree.selection()
        if selection:
            item = self.urgent_tasks_tree.item(selection[0])
            task_title = item['values'][0]
            # Aqui você pode implementar a navegação para o cartão específico
            self.select_tab_by_text('Quadros')
            messagebox.showinfo("Navegação", f"Navegando para a tarefa: {task_title}")

    def on_deadline_double_click(self, event):
        """Handler para duplo clique em prazo"""
        selection = self.deadlines_tree.selection()
        if selection:
            item = self.deadlines_tree.item(selection[0])
            task_title = item['values'][0]
            # Aqui você pode implementar a navegação para o cartão específico
            self.select_tab_by_text('Quadros')
            messagebox.showinfo("Navegação", f"Navegando para a tarefa: {task_title}")

    def on_activity_double_click(self, event):
        """Handler para duplo clique em atividade"""
        selection = self.recent_activities_tree.selection()
        if selection:
            item = self.recent_activities_tree.item(selection[0])
            activity = item['values'][0]
            messagebox.showinfo("Atividade", f"Detalhes da atividade: {activity}")

    def update_main_menu_overview(self):
        # Update the quick overview labels
        total_boards = len(self.boodesk_data["boards"])
        total_tasks = len(self.pomodoro_tasks_df)
        total_members = len(self.members_df)

        self.total_boards_label.config(text=f"Total de Quadros: {total_boards}")
        self.total_tasks_label.config(text=f"Total de Tarefas Pomodoro: {total_tasks}")
        self.total_members_label.config(text=f"Total de Membros: {total_members}")

    def update_urgent_tasks_widget(self):
        """Atualiza o widget de tarefas urgentes com isolamento por usuário (membros + criador)"""
        if not hasattr(self, 'urgent_tasks_tree'):
            return
            
        self.urgent_tasks_tree.delete(*self.urgent_tasks_tree.get_children())
        
        # Obter ID do usuário atual
        current_user_id = self.get_current_user_id()
        if not current_user_id:
            print("⚠️ Usuário atual não identificado")
            return
        
        urgent_tasks = []
        
        try:
            # Buscar cards urgentes onde o usuário participa (via PostgreSQL)
            from supabase_setup import supabase_config
            conn = supabase_config.get_connection()
            if conn:
                cursor = conn.cursor()
                
                # Query com isolamento por quadros (mostra todos os cards críticos/altos dos quadros do usuário)
                cursor.execute("""
                    SELECT c.id, c.title, c.importance, c.priority, b.name as board_name, c.list_name
                    FROM cards c
                    LEFT JOIN card_members cm ON c.id = cm.card_id
                    LEFT JOIN boards b ON c.board_id = b.board_id
                    WHERE b.board_id IN (
                        SELECT DISTINCT b2.board_id
                        FROM boards b2
                        LEFT JOIN board_members bm ON b2.board_id = bm.board_id
                        WHERE b2.owner_id = %s OR bm.user_id = %s
                    )
                    AND (c.importance IN ('Alta', 'Crítica') OR c.priority IN ('Alta', 'Crítica'))
                    AND NOT c.is_archived
                    ORDER BY 
                        CASE 
                            WHEN c.importance = 'Crítica' THEN 0
                            WHEN c.importance = 'Alta' THEN 1
                            WHEN c.priority = 'Crítica' THEN 2
                            WHEN c.priority = 'Alta' THEN 3
                            ELSE 4
                        END,
                        c.title
                    LIMIT 5
                """, (current_user_id, current_user_id))
                
                cards_urgentes = cursor.fetchall()
                
                for card in cards_urgentes:
                    card_id, title, importance, priority, board_name, list_name = card
                    
                    # Determinar a importância mais alta
                    final_importance = importance if importance in ['Alta', 'Crítica'] else priority
                    
                    urgent_tasks.append({
                        "title": title,
                        "board": board_name,  # Usar nome do quadro
                        "importance": final_importance,
                        "card": {"id": card_id}
                    })
                
                conn.close()
                
        except Exception as e:
            print(f"❌ Erro ao buscar tarefas urgentes: {e}")
            # Fallback para o método antigo (sem isolamento)
            for board_name, board_data in self.boodesk_data["boards"].items():
                if isinstance(board_data, dict):
                    for list_name, cards in board_data.items():
                        if list_name != "workflow":
                            for card in cards:
                                if not card.get("is_archived", False):
                                    importance = card.get("importance", "Normal")
                                    if importance in ["Alta", "Crítica"]:
                                        urgent_tasks.append({
                                            "title": card.get("title", ""),
                                            "board": board_name,
                                            "importance": importance,
                                            "card": card
                                        })
        
        # Sort by importance (Crítica first, then Alta)
        importance_order = {"Crítica": 0, "Alta": 1}
        urgent_tasks.sort(key=lambda x: importance_order.get(x["importance"], 2))
        
        # Add to treeview (top 5)
        for i, task in enumerate(urgent_tasks[:5]):
            item = self.urgent_tasks_tree.insert("", "end", values=(
                task["title"],
                task["board"],
                task["importance"]
            ))
            
            # Apply background color based on importance
            if task["importance"] == "Crítica":
                self.urgent_tasks_tree.tag_configure("critical", background="#FFCCCC")
                self.urgent_tasks_tree.item(item, tags=("critical",))
            elif task["importance"] == "Alta":
                self.urgent_tasks_tree.tag_configure("high", background="#FFE5CC")
                self.urgent_tasks_tree.item(item, tags=("high",))

    def update_upcoming_deadlines_widget(self):
        """Atualiza o widget de prazos próximos com isolamento por usuário (quadros onde é participante/criador)"""
        if not hasattr(self, 'deadlines_tree'):
            return
            
        self.deadlines_tree.delete(*self.deadlines_tree.get_children())
        
        current_user_id = self.get_current_user_id()
        if not current_user_id:
            print("⚠️ Usuário atual não identificado")
            return
        
        deadline_tasks = []
        try:
            from supabase_setup import supabase_config
            conn = supabase_config.get_connection()
            if conn:
                cursor = conn.cursor()
                # Query com isolamento por quadros (mostra todos os cards com prazo dos quadros do usuário)
                cursor.execute("""
                    SELECT c.id, c.title, c.due_date, b.name as board_name, c.list_name
                    FROM cards c
                    LEFT JOIN card_members cm ON c.id = cm.card_id
                    LEFT JOIN boards b ON c.board_id = b.board_id
                    WHERE b.board_id IN (
                        SELECT DISTINCT b2.board_id
                        FROM boards b2
                        LEFT JOIN board_members bm ON b2.board_id = bm.board_id
                        WHERE b2.owner_id = %s OR bm.user_id = %s
                    )
                    AND c.due_date IS NOT NULL
                    AND c.due_date::text != ''
                    AND c.due_date::text != 'None'
                    AND c.due_date > CURRENT_TIMESTAMP
                    AND NOT c.is_archived
                    ORDER BY c.due_date
                    LIMIT 5
                """, (current_user_id, current_user_id))
                
                cards_prazos = cursor.fetchall()
                for card in cards_prazos:
                    card_id, title, due_date, board_name, list_name = card
                    if due_date:
                        try:
                            from datetime import datetime
                            due_date_obj = datetime.strptime(str(due_date), '%Y-%m-%d %H:%M:%S')
                            today = datetime.now()
                            days_until = (due_date_obj - today).days
                            deadline_tasks.append({
                                "title": title,
                                "due_date": str(due_date),
                                "days": days_until,
                                "board_name": board_name
                            })
                        except ValueError:
                            continue
                conn.close()
        except Exception as e:
            print(f"❌ Erro ao buscar prazos próximos: {e}")
            # Fallback to old logic if DB query fails
            from datetime import datetime
            today = datetime.now()
            for board_name, board_data in self.boodesk_data["boards"].items():
                if isinstance(board_data, dict):
                    for list_name, cards in board_data.items():
                        if list_name != "workflow":
                            for card in cards:
                                if not card.get("is_archived", False):
                                    due_date_str = card.get("due_date", "")
                                    if due_date_str:
                                        try:
                                            due_date = datetime.strptime(due_date_str, '%Y-%m-%d %H:%M')
                                            if due_date > today:
                                                days_until = (due_date - today).days
                                                deadline_tasks.append({
                                                    "title": card.get("title", ""),
                                                    "due_date": due_date_str,
                                                    "days": days_until,
                                                    "board_name": board_name
                                                })
                                        except ValueError:
                                            continue
        
        # Sort by days until deadline
        deadline_tasks.sort(key=lambda x: x["days"])
        
        # Add to treeview (top 5)
        for i, task in enumerate(deadline_tasks[:5]):
            item = self.deadlines_tree.insert("", "end", values=(
                task["title"],
                task["due_date"],
                f"{task['days']} dias"
            ))
            
            # Aplicar cor baseada na urgência
            if task["days"] <= 1:
                self.deadlines_tree.tag_configure("urgent", background="#FFCCCC")
                self.deadlines_tree.item(item, tags=("urgent",))
            elif task["days"] <= 3:
                self.deadlines_tree.tag_configure("soon", background="#FFE5CC")
                self.deadlines_tree.item(item, tags=("soon",))

    def update_recent_activities_widget(self):
        """Atualiza o widget de atividades recentes"""
        if not hasattr(self, 'recent_activities_tree'):
            return
            
        self.recent_activities_tree.delete(*self.recent_activities_tree.get_children())
        
        activities = []
        
        # Collect activities from card history
        for board_name, board_data in self.boodesk_data["boards"].items():
            # Verificar se board_data é um dicionário ou lista
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                    if list_name != "workflow":
                        for card in cards:
                            history = card.get("history", [])
                            for entry in history[-3:]:  # Last 3 entries per card
                                activities.append({
                                    "action": entry.get("action", ""),
                                    "timestamp": entry.get("timestamp", ""),
                                    "user": entry.get("user", "")
                                })
        
        # Sort by timestamp (most recent first)
        activities.sort(key=lambda x: x["timestamp"], reverse=True)
        
        # Add to treeview (top 10)
        for activity in activities[:10]:
            self.recent_activities_tree.insert("", "end", values=(
                activity["action"],
                activity["timestamp"]
            ))

    def open_user_management_window(self):
        """Abre a janela de gerenciamento de usuários (alias para open_user_management)"""
        # Usar a função principal que já está implementada e funcionando
        self.open_user_management()

    def open_management_reports(self):
        # Placeholder for Management Reports
        messagebox.showinfo("Relatórios Gerenciais", "Funcionalidade de Relatórios Gerenciais em desenvolvimento!")

    def create_accounts_registration_tab(self, parent):
        # Accounts Section
        accounts_frame = ttk.Frame(parent, padding="10")
        accounts_frame.pack(fill=tk.BOTH, expand=True)
        accounts_frame.columnconfigure(1, weight=1)

        ttk.Label(accounts_frame, text="Nome da Conta:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.account_name_entry = ttk.Entry(accounts_frame, width=40)
        self.account_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        button_frame_acc = ttk.Frame(accounts_frame)
        button_frame_acc.grid(row=1, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame_acc, text="Adicionar Conta", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_account).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_acc, text="Remover Selecionada", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_account).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_acc, text="Atualizar Saldo", image=self.icons.get('refresh_icon'), compound=tk.LEFT, command=self.update_selected_account_balance).pack(side=tk.LEFT, padx=5)

        accounts_list_frame = ttk.LabelFrame(accounts_frame, text="Contas Existentes", padding="10")
        accounts_list_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=10)
        accounts_list_frame.columnconfigure(0, weight=1)
        accounts_list_frame.rowconfigure(0, weight=1)

        self.accounts_listbox = tk.Listbox(accounts_list_frame, selectmode=tk.SINGLE, height=5)
        self.accounts_listbox.grid(row=0, column=0, sticky="nsew", pady=5)
        self.accounts_listbox.bind("<<ListboxSelect>>", self.on_account_select)
        acc_scrollbar = ttk.Scrollbar(accounts_list_frame, orient="vertical", command=self.accounts_listbox.yview)
        acc_scrollbar.grid(row=0, column=1, sticky="ns")
        self.accounts_listbox.config(yscrollcommand=acc_scrollbar.set)

    def create_categories_registration_tab(self, parent):
        # Categories Section
        categories_frame = ttk.Frame(parent, padding="10")
        categories_frame.pack(fill=tk.BOTH, expand=True)
        categories_frame.columnconfigure(1, weight=1)

        ttk.Label(categories_frame, text="Nome da Categoria:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.category_name_entry = ttk.Entry(categories_frame, width=40)
        self.category_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        button_frame_cat = ttk.Frame(categories_frame)
        button_frame_cat.grid(row=1, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame_cat, text="Adicionar Categoria", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_cat, text="Remover Selecionada", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_category).pack(side=tk.LEFT, padx=5)

        categories_list_frame = ttk.LabelFrame(categories_frame, text="Categorias Existentes", padding="10")
        categories_list_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=10)
        categories_list_frame.columnconfigure(0, weight=1)
        categories_list_frame.rowconfigure(0, weight=1)

        self.categories_listbox = tk.Listbox(categories_list_frame, selectmode=tk.SINGLE, height=5)
        self.categories_listbox.grid(row=0, column=0, sticky="nsew", pady=5)
        cat_scrollbar = ttk.Scrollbar(categories_list_frame, orient="vertical", command=self.categories_listbox.yview)
        cat_scrollbar.grid(row=0, column=1, sticky="ns")
        self.categories_listbox.config(yscrollcommand=cat_scrollbar.set)

    def create_payment_methods_registration_tab(self, parent):
        # Payment Methods Section
        payment_methods_frame = ttk.Frame(parent, padding="10")
        payment_methods_frame.pack(fill=tk.BOTH, expand=True)
        payment_methods_frame.columnconfigure(1, weight=1)

        ttk.Label(payment_methods_frame, text="Nome do Meio de Pagamento:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.payment_method_name_entry = ttk.Entry(payment_methods_frame, width=40)
        self.payment_method_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        button_frame_pm = ttk.Frame(payment_methods_frame)
        button_frame_pm.grid(row=1, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame_pm, text="Adicionar Meio de Pagamento", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_payment_method).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_pm, text="Remover Selecionado", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_payment_method).pack(side=tk.LEFT, padx=5)

        payment_methods_list_frame = ttk.LabelFrame(payment_methods_frame, text="Meios de Pagamento Existentes", padding="10")
        payment_methods_list_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=10)
        payment_methods_list_frame.columnconfigure(0, weight=1)
        payment_methods_list_frame.rowconfigure(0, weight=1)

        self.payment_methods_listbox = tk.Listbox(payment_methods_list_frame, selectmode=tk.SINGLE, height=5)
        self.payment_methods_listbox.grid(row=0, column=0, sticky="nsew", pady=5)
        pm_scrollbar = ttk.Scrollbar(payment_methods_list_frame, orient="vertical", command=self.payment_methods_listbox.yview)
        pm_scrollbar.grid(row=0, column=1, sticky="ns")
        self.payment_methods_listbox.config(yscrollcommand=pm_scrollbar.set)

    def create_incomes_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Input fields for new income transaction
        input_frame = ttk.LabelFrame(main_frame, text="Registrar Nova Entrada", padding="10")
        input_frame.pack(fill=tk.X, pady=10)

        input_frame.columnconfigure(1, weight=1)

        ttk.Label(input_frame, text="Descrição:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.income_description_entry = ttk.Entry(input_frame, width=40)
        self.income_description_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(input_frame, text="Valor:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.income_amount_entry = NumericEntryWithButtons(input_frame, self.icons)
        self.income_amount_entry.grid(row=1, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Data:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        income_date_frame = ttk.Frame(input_frame)
        income_date_frame.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        self.income_date_entry = ttk.Entry(income_date_frame, width=15, state="readonly")
        self.income_date_entry.pack(side=tk.LEFT)
        ttk.Button(income_date_frame, image=self.icons.get('time_icon'), width=3, command=partial(self._open_finance_date_picker, self.income_date_entry)).pack(side=tk.LEFT, padx=2)
        self.income_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d")) # Default to today

        ttk.Label(input_frame, text="Categoria:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.income_category_combo = ttk.Combobox(input_frame, state="readonly")
        self.income_category_combo.grid(row=3, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Meio de Pagamento:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.income_payment_method_combo = ttk.Combobox(input_frame, state="readonly")
        self.income_payment_method_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Conta Bancária:").grid(row=5, column=0, sticky="w", padx=5, pady=2)
        self.income_account_combo = ttk.Combobox(input_frame, state="readonly")
        self.income_account_combo.grid(row=5, column=1, sticky="w", padx=5, pady=2)

        ttk.Button(input_frame, text="Registrar Entrada", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.register_income).grid(row=6, column=0, columnspan=2, pady=10)

        # Treeview for displaying income transactions
        incomes_treeview_frame = ttk.LabelFrame(main_frame, text="Entradas Registradas", padding="10")
        incomes_treeview_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.incomes_treeview = ttk.Treeview(incomes_treeview_frame, columns=("Data", "Descrição", "Valor", "Categoria", "Meio de Pagamento", "Conta"), show="headings")
        self.incomes_treeview.heading("Data", text="Data")
        self.incomes_treeview.heading("Descrição", text="Descrição")
        self.incomes_treeview.heading("Valor", text="Valor")
        self.incomes_treeview.heading("Categoria", text="Categoria")
        self.incomes_treeview.heading("Meio de Pagamento", text="Meio de Pagamento")
        self.incomes_treeview.heading("Conta", text="Conta")

        self.incomes_treeview.column("Data", width=100, anchor="center")
        self.incomes_treeview.column("Descrição", width=200, anchor="w")
        self.incomes_treeview.column("Valor", width=100, anchor="e")
        self.incomes_treeview.column("Categoria", width=120, anchor="w")
        self.incomes_treeview.column("Meio de Pagamento", width=120, anchor="w")
        self.incomes_treeview.column("Conta", width=120, anchor="w")

        self.incomes_treeview.pack(fill=tk.BOTH, expand=True)

    def register_income(self):
        description = self.income_description_entry.get().strip()
        amount = self.income_amount_entry.get()
        date = self.income_date_entry.get()
        category = self.income_category_combo.get()
        payment_method = self.income_payment_method_combo.get()
        account = self.income_account_combo.get()

        if not description or amount <= 0 or not date or not category or not payment_method or not account:
            messagebox.showwarning("Campos Obrigatórios", "Por favor, preencha todos os campos da entrada e o valor deve ser positivo.")
            return

        new_transaction = {
            "descricao": description,
            "valor": amount,
            "tipo": "Entrada",
            "data": date,
            "categoria": category,
            "meio_pagamento": payment_method,
            "conta_bancaria": account,
            "timestamp": datetime.now().isoformat()
        }

        self.boodesk_data["finances"]["transacoes"].append(new_transaction)
        
        for acc in self.boodesk_data['finances']['contas_bancarias']:
            if acc['name'] == account:
                acc['balance'] += amount
                break
        
        self.save_trello_data()
        self.update_transactions_treeview()
        self.update_incomes_treeview()
        self.update_accounts_listbox()
        self.update_total_balance_display()

        self.income_description_entry.delete(0, tk.END)
        self.income_amount_entry.set(0.00)
        self.income_date_entry.delete(0, tk.END)
        self.income_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.income_category_combo.set("")
        self.income_payment_method_combo.set("")
        self.income_account_combo.set("")
        messagebox.showinfo("Sucesso", "Entrada registrada com sucesso!")
        self._show_chart(self.current_chart_type)

    def update_incomes_treeview(self):
        for i in self.incomes_treeview.get_children():
            self.incomes_treeview.delete(i)
        for transaction in self.boodesk_data["finances"]["transacoes"]:
            if transaction["tipo"] == "Entrada":
                self.incomes_treeview.insert("", "end", values=(
                    transaction["data"],
                    transaction["descricao"],
                    f"{transaction["valor"]:.2f}",
                    transaction["categoria"],
                    transaction["meio_pagamento"],
                    transaction["conta_bancaria"]
                ))

    def create_expenses_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Input fields for new expense transaction
        input_frame = ttk.LabelFrame(main_frame, text="Registrar Nova Saída", padding="10")
        input_frame.pack(fill=tk.X, pady=10)

        input_frame.columnconfigure(1, weight=1)

        ttk.Label(input_frame, text="Descrição:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.expense_description_entry = ttk.Entry(input_frame, width=40)
        self.expense_description_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(input_frame, text="Valor:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.expense_amount_entry = NumericEntryWithButtons(input_frame, self.icons)
        self.expense_amount_entry.grid(row=1, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Data:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        expense_date_frame = ttk.Frame(input_frame)
        expense_date_frame.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        self.expense_date_entry = ttk.Entry(expense_date_frame, width=15, state="readonly")
        self.expense_date_entry.pack(side=tk.LEFT)
        ttk.Button(expense_date_frame, image=self.icons.get('time_icon'), width=3, command=partial(self._open_finance_date_picker, self.expense_date_entry)).pack(side=tk.LEFT, padx=2)
        self.expense_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d")) # Default to today

        ttk.Label(input_frame, text="Categoria:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.expense_category_combo = ttk.Combobox(input_frame, state="readonly")
        self.expense_category_combo.grid(row=3, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Meio de Pagamento:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.expense_payment_method_combo = ttk.Combobox(input_frame, state="readonly")
        self.expense_payment_method_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Conta Bancária:").grid(row=5, column=0, sticky="w", padx=5, pady=2)
        self.expense_account_combo = ttk.Combobox(input_frame, state="readonly")
        self.expense_account_combo.grid(row=5, column=1, sticky="w", padx=5, pady=2)

        ttk.Button(input_frame, text="Registrar Saída", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.register_expense).grid(row=6, column=0, columnspan=2, pady=10)

        # Treeview for displaying expense transactions
        expenses_treeview_frame = ttk.LabelFrame(main_frame, text="Saídas Registradas", padding="10")
        expenses_treeview_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.expenses_treeview = ttk.Treeview(expenses_treeview_frame, columns=("Data", "Descrição", "Valor", "Categoria", "Meio de Pagamento", "Conta"), show="headings")
        self.expenses_treeview.heading("Data", text="Data")
        self.expenses_treeview.heading("Descrição", text="Descrição")
        self.expenses_treeview.heading("Valor", text="Valor")
        self.expenses_treeview.heading("Categoria", text="Categoria")
        self.expenses_treeview.heading("Meio de Pagamento", text="Meio de Pagamento")
        self.expenses_treeview.heading("Conta", text="Conta")

        self.expenses_treeview.column("Data", width=100, anchor="center")
        self.expenses_treeview.column("Descrição", width=200, anchor="w")
        self.expenses_treeview.column("Valor", width=100, anchor="e")
        self.expenses_treeview.column("Categoria", width=120, anchor="w")
        self.expenses_treeview.column("Meio de Pagamento", width=120, anchor="w")
        self.expenses_treeview.column("Conta", width=120, anchor="w")

        self.expenses_treeview.pack(fill=tk.BOTH, expand=True)

    def register_expense(self):
        description = self.expense_description_entry.get().strip()
        amount = self.expense_amount_entry.get()
        date = self.expense_date_entry.get()
        category = self.expense_category_combo.get()
        payment_method = self.expense_payment_method_combo.get()
        account = self.expense_account_combo.get()

        if not description or amount <= 0 or not date or not category or not payment_method or not account:
            messagebox.showwarning("Campos Obrigatórios", "Por favor, preencha todos os campos da saída e o valor deve ser positivo.")
            return

        new_transaction = {
            "descricao": description,
            "valor": amount,
            "tipo": "Saída",
            "data": date,
            "categoria": category,
            "meio_pagamento": payment_method,
            "conta_bancaria": account,
            "timestamp": datetime.now().isoformat()
        }

        self.boodesk_data["finances"]["transacoes"].append(new_transaction)
        
        for acc in self.boodesk_data['finances']['contas_bancarias']:
            if acc['name'] == account:
                acc['balance'] -= amount
                break
        
        self.save_trello_data()
        self.update_transactions_treeview()
        self.update_expenses_treeview()
        self.update_accounts_listbox()
        self.update_total_balance_display()

        self.expense_description_entry.delete(0, tk.END)
        self.expense_amount_entry.set(0.00)
        self.expense_date_entry.delete(0, tk.END)
        self.expense_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.expense_category_combo.set("")
        self.expense_payment_method_combo.set("")
        self.expense_account_combo.set("")
        messagebox.showinfo("Sucesso", "Saída registrada com sucesso!")
        self._show_chart(self.current_chart_type)

    def update_expenses_treeview(self):
        for i in self.expenses_treeview.get_children():
            self.expenses_treeview.delete(i)
        for transaction in self.boodesk_data["finances"]["transacoes"]:
            if transaction["tipo"] == "Saída":
                self.expenses_treeview.insert("", "end", values=(
                    transaction["data"],
                    transaction["descricao"],
                    f"{transaction["valor"]:.2f}",
                    transaction["categoria"],
                    transaction["meio_pagamento"],
                    transaction["conta_bancaria"]
                ))

    def create_transactions_history_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Treeview for displaying all transactions
        transactions_frame = ttk.LabelFrame(main_frame, text="Histórico de Transações", padding="10")
        transactions_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.transactions_treeview = ttk.Treeview(transactions_frame, columns=("Data", "Descrição", "Tipo", "Valor", "Categoria", "Meio de Pagamento", "Conta"), show="headings")
        self.transactions_treeview.heading("Data", text="Data")
        self.transactions_treeview.heading("Descrição", text="Descrição")
        self.transactions_treeview.heading("Tipo", text="Tipo")
        self.transactions_treeview.heading("Valor", text="Valor")
        self.transactions_treeview.heading("Categoria", text="Categoria")
        self.transactions_treeview.heading("Meio de Pagamento", text="Meio de Pagamento")
        self.transactions_treeview.heading("Conta", text="Conta")

        self.transactions_treeview.column("Data", width=100, anchor="center")
        self.transactions_treeview.column("Descrição", width=200, anchor="w")
        self.transactions_treeview.column("Tipo", width=80, anchor="center")
        self.transactions_treeview.column("Valor", width=100, anchor="e")
        self.transactions_treeview.column("Categoria", width=120, anchor="w")
        self.transactions_treeview.column("Meio de Pagamento", width=120, anchor="w")
        self.transactions_treeview.column("Conta", width=120, anchor="w")

        self.transactions_treeview.pack(fill=tk.BOTH, expand=True)

    def _open_finance_date_picker(self, entry_widget):
        current_date_str = entry_widget.get()
        dialog = DatePickerDialog(self.root, current_date=current_date_str, icons=self.icons)
        self.root.wait_window(dialog)
        if dialog.result_date:
            entry_widget.config(state="normal")
            entry_widget.delete(0, tk.END)
            entry_widget.insert(0, dialog.result_date.strftime("%Y-%m-%d"))
            entry_widget.config(state="readonly")

    def update_transactions_treeview(self):
        try:
            if hasattr(self, 'transactions_treeview'):
                for i in self.transactions_treeview.get_children():
                    self.transactions_treeview.delete(i)
                for transaction in self.boodesk_data["finances"]["transacoes"]:
                    self.transactions_treeview.insert("", "end", values=(
                        transaction["data"],
                        transaction["descricao"],
                        transaction["tipo"],
                        transaction["valor"], # No f-string here, it's already a float
                        transaction["categoria"],
                        transaction["meio_pagamento"],
                        transaction["conta_bancaria"]
                    ))
        except Exception as e:
            print(f"Erro ao atualizar transactions_treeview: {e}")

    def populate_finance_comboboxes(self):
        try:
            if hasattr(self, 'income_category_combo'):
                self.income_category_combo['values'] = self.boodesk_data["finances"]["categorias_gasto"]
            if hasattr(self, 'expense_category_combo'):
                self.expense_category_combo['values'] = self.boodesk_data["finances"]["categorias_gasto"]
            if hasattr(self, 'income_payment_method_combo'):
                self.income_payment_method_combo['values'] = self.boodesk_data["finances"]["meios_pagamento"]
            if hasattr(self, 'expense_payment_method_combo'):
                self.expense_payment_method_combo['values'] = self.boodesk_data["finances"]["meios_pagamento"]
            if hasattr(self, 'income_account_combo'):
                self.income_account_combo['values'] = [acc['name'] for acc in self.boodesk_data["finances"]["contas_bancarias"]]
            if hasattr(self, 'expense_account_combo'):
                self.expense_account_combo['values'] = [acc['name'] for acc in self.boodesk_data["finances"]["contas_bancarias"]]
        except Exception as e:
            print(f"Erro ao popular comboboxes financeiros: {e}")

    def create_registration_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Frame para os botões de navegação
        button_nav_frame = ttk.Frame(main_frame)
        button_nav_frame.pack(pady=10)

        ttk.Button(button_nav_frame, text="Cadastrar Contas", image=self.icons.get('add_folder_icon'), compound=tk.LEFT, command=lambda: self.registration_notebook.select(0)).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_nav_frame, text="Cadastrar Categorias", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.registration_notebook.select(1)).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_nav_frame, text="Cadastrar Meios de Pagamento", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.registration_notebook.select(2)).pack(side=tk.LEFT, padx=5)

        self.registration_notebook = ttk.Notebook(main_frame)
        self.registration_notebook.pack(fill=tk.BOTH, expand=True)

        accounts_frame = ttk.Frame(self.registration_notebook)
        categories_frame = ttk.Frame(self.registration_notebook)
        payment_methods_frame = ttk.Frame(self.registration_notebook)

        self.registration_notebook.add(accounts_frame, text='Contas Bancárias')
        self.registration_notebook.add(categories_frame, text='Categorias de Gasto')
        self.registration_notebook.add(payment_methods_frame, text='Meios de Pagamento')

        self.create_accounts_registration_tab(accounts_frame)
        self.create_categories_registration_tab(categories_frame)
        self.create_payment_methods_registration_tab(payment_methods_frame)

    def add_account(self):
        name = self.account_name_entry.get().strip()

        if not name:
            messagebox.showwarning("Campo Obrigatório", "Por favor, insira o nome da conta.")
            return

        if any(acc['name'] == name for acc in self.boodesk_data['finances']['contas_bancarias']):
            messagebox.showwarning("Conta Existente", f"Uma conta com o nome '{name}' já existe.")
            return

        self.boodesk_data['finances']['contas_bancarias'].append({"name": name, "balance": 0.00})
        self.save_trello_data()
        self.update_accounts_listbox()
        self.populate_finance_comboboxes()
        self.update_total_balance_display()
        self.account_name_entry.delete(0, tk.END)
        messagebox.showinfo("Sucesso", f"Conta '{name}' adicionada com sucesso!")
        self._show_chart(self.current_chart_type)

    def remove_account(self):
        selected_index = self.accounts_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione uma conta para remover.")
            return

        account_name_display = self.accounts_listbox.get(selected_index[0])
        account_name = account_name_display.split(" (R$")[0]

        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover a conta '{account_name}'?"):
            self.boodesk_data['finances']['contas_bancarias'] = [
                acc for acc in self.boodesk_data['finances']['contas_bancarias'] if acc['name'] != account_name
            ]
            self.save_trello_data()
            self.update_accounts_listbox()
            self.populate_finance_comboboxes()
            self.update_total_balance_display()
            messagebox.showinfo("Sucesso", f"Conta '{account_name}' removida com sucesso!")
            self._show_chart(self.current_chart_type)

    def update_selected_account_balance(self):
        selected_index = self.accounts_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione uma conta para atualizar o saldo.")
            return

        account_name_display = self.accounts_listbox.get(selected_index[0])
        account_name = account_name_display.split(" (R$")[0]

        new_balance_str = simpledialog.askstring("Atualizar Saldo", f"Digite o novo saldo para '{account_name}':", parent=self.root)
        if new_balance_str is None:
            return

        try:
            new_balance = float(new_balance_str.replace(",", "."))
        except ValueError:
            messagebox.showwarning("Entrada Inválida", "O saldo deve ser um número válido.")
            return

        found = False
        for account in self.boodesk_data['finances']['contas_bancarias']:
            if acc['name'] == account_name: # Bug in original code: 'acc' instead of 'account'
                account['balance'] = new_balance
                found = True
                break
        
        if found:
            self.save_trello_data()
            self.update_accounts_listbox()
            self.update_total_balance_display()
            messagebox.showinfo("Sucesso", f"Saldo da conta '{account_name}' atualizado para R$ {new_balance:.2f}.")
        else:
            messagebox.showerror("Erro", "Conta não encontrada. Por favor, selecione uma conta válida.")

    def update_accounts_listbox(self):
        self.accounts_listbox.delete(0, tk.END)
        for account in self.boodesk_data['finances']['contas_bancarias']:
            self.accounts_listbox.insert(tk.END, f"{account['name']} (R$ {account['balance']:.2f})")

    def on_account_select(self, event):
        selected_index = self.accounts_listbox.curselection()
        if selected_index:
            account_name_display = self.accounts_listbox.get(selected_index[0])
            account_name = account_name_display.split(" (R$")[0]
            
            for account in self.boodesk_data['finances']['contas_bancarias']:
                if account['name'] == account_name:
                    self.account_name_entry.delete(0, tk.END)
                    self.account_name_entry.insert(0, account['name'])
                    break

    def add_category(self):
        name = self.category_name_entry.get().strip()
        if not name:
            messagebox.showwarning("Campo Obrigatório", "Por favor, insira o nome da categoria.")
            return

        if name in self.boodesk_data['finances']['categorias_gasto']:
            messagebox.showwarning("Categoria Existente", f"A categoria '{name}' já existe.")
            return

        self.boodesk_data['finances']['categorias_gasto'].append(name)
        self.save_trello_data()
        self.update_categories_listbox()
        self.populate_finance_comboboxes()
        self.category_name_entry.delete(0, tk.END)
        messagebox.showinfo("Sucesso", f"Categoria '{name}' adicionada com sucesso!")

    def remove_category(self):
        selected_index = self.categories_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione uma categoria para remover.")
            return

        category_name = self.categories_listbox.get(selected_index[0])

        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover a categoria '{category_name}'?"):
            self.boodesk_data['finances']['categorias_gasto'].remove(category_name)
            self.save_trello_data()
            self.update_categories_listbox()
            self.populate_finance_comboboxes()
            messagebox.showinfo("Sucesso", f"Categoria '{category_name}' removida com sucesso!")

    def update_categories_listbox(self):
        self.categories_listbox.delete(0, tk.END)
        for category in self.boodesk_data['finances']['categorias_gasto']:
            self.categories_listbox.insert(tk.END, category)

    def add_payment_method(self):
        name = self.payment_method_name_entry.get().strip()
        if not name:
            messagebox.showwarning("Campo Obrigatório", "Por favor, insira o nome do meio de pagamento.")
            return

        if name in self.boodesk_data['finances']['meios_pagamento']:
            messagebox.showwarning("Meio de Pagamento Existente", f"O meio de pagamento '{name}' já existe.")
            return

        self.boodesk_data['finances']['meios_pagamento'].append(name)
        self.save_trello_data()
        self.update_payment_methods_listbox()
        self.populate_finance_comboboxes()
        self.payment_method_name_entry.delete(0, tk.END)
        messagebox.showinfo("Sucesso", f"Meio de pagamento '{name}' adicionado com sucesso!")

    def remove_payment_method(self):
        selected_index = self.payment_methods_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um meio de pagamento para remover.")
            return

        payment_method_name = self.payment_methods_listbox.get(selected_index[0])

        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover o meio de pagamento '{payment_method_name}'?"):
            self.boodesk_data['finances']['meios_pagamento'].remove(payment_method_name)
            self.save_trello_data()
            self.update_payment_methods_listbox()
            self.populate_finance_comboboxes()
            messagebox.showinfo("Sucesso", f"Meio de pagamento '{payment_method_name}' removido com sucesso!")

    def update_payment_methods_listbox(self):
        self.payment_methods_listbox.delete(0, tk.END)
        for method in self.boodesk_data['finances']['meios_pagamento']:
            self.payment_methods_listbox.insert(tk.END, method)

    def create_overview_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        overview_label_frame = ttk.LabelFrame(main_frame, text="Visão Geral Financeira", padding="10")
        overview_label_frame.pack(fill=tk.X, pady=10)

        self.total_balance_label = ttk.Label(overview_label_frame, text="Saldo Total: R$ 0.00", font=("Helvetica", 16, "bold"))
        self.total_balance_label.pack(pady=10)

        # Menu de Relatórios
        reports_menu_frame = ttk.Frame(main_frame)
        reports_menu_frame.pack(pady=5)

        reports_menubutton = ttk.Menubutton(reports_menu_frame, text="Relatórios Financeiros", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT, direction="below")
        reports_menubutton.pack()

        reports_menu = tk.Menu(reports_menubutton, tearoff=0)
        reports_menubutton["menu"] = reports_menu

        reports_menu.add_command(label="Relatório de Entradas (Em Breve)", command=lambda: messagebox.showinfo("Relatório", "Funcionalidade de Relatório de Entradas em desenvolvimento!"))
        reports_menu.add_command(label="Relatório de Saídas (Em Breve)", command=lambda: messagebox.showinfo("Relatório", "Funcionalidade de Relatório de Saídas em desenvolvimento!"))
        reports_menu.add_command(label="Relatório por Categoria (Em Breve)", command=lambda: messagebox.showinfo("Relatório", "Funcionalidade de Relatório por Categoria em desenvolvimento!"))
        reports_menu.add_command(label="Relatório de Contas (Em Breve)", command=lambda: messagebox.showinfo("Relatório", "Funcionalidade de Relatório de Contas em desenvolvimento!"))

        # Chart display area
        self.chart_frame = ttk.Frame(main_frame)
        self.chart_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        # Chart selection buttons
        chart_buttons_frame = ttk.Frame(main_frame)
        chart_buttons_frame.pack(pady=5)

        ttk.Button(chart_buttons_frame, text="Entradas vs Saídas", image=self.icons.get('pie_chart_icon'), compound=tk.LEFT, command=lambda: self._show_chart("income_vs_expense")).pack(side=tk.LEFT, padx=5)
        ttk.Button(chart_buttons_frame, text="Entradas por Categoria", image=self.icons.get('bar_chart_icon'), compound=tk.LEFT, command=lambda: self._show_chart("income_by_category")).pack(side=tk.LEFT, padx=5)
        ttk.Button(chart_buttons_frame, text="Saídas por Categoria", image=self.icons.get('bar_chart_icon'), compound=tk.LEFT, command=lambda: self._show_chart("expense_by_category")).pack(side=tk.LEFT, padx=5)

        self.current_chart_canvas = None
        self.current_chart_toolbar = None

        # Initial chart display
        self._show_chart("income_vs_expense")

    def update_total_balance_display(self):
        try:
            total_balance = sum(account['balance'] for account in self.boodesk_data['finances']['contas_bancarias'])
            if hasattr(self, 'total_balance_label'):
                self.total_balance_label.config(text=f"Saldo Total: R$ {total_balance:.2f}")
        except Exception as e:
            print(f"Erro ao atualizar saldo total: {e}")

    def _show_chart(self, chart_type):
        # Clear previous chart
        if self.current_chart_canvas:
            self.current_chart_canvas.get_tk_widget().destroy()
        if self.current_chart_toolbar:
            self.current_chart_toolbar.destroy()

        fig = None
        if chart_type == "income_vs_expense":
            fig = self._create_income_vs_expense_pie_chart()
        elif chart_type == "income_by_category":
            fig = self._create_income_by_category_bar_chart()
        elif chart_type == "expense_by_category":
            fig = self._create_expense_by_category_bar_chart()

        if fig:
            canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
            canvas_widget = canvas.get_tk_widget()
            canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
            self.current_chart_canvas = canvas

            toolbar = NavigationToolbar2Tk(canvas, self.chart_frame)
            toolbar.update()
            toolbar.pack(side=tk.BOTTOM, fill=tk.X)
            self.current_chart_toolbar = toolbar
            canvas.draw()

    def _create_income_vs_expense_pie_chart(self):
        incomes = sum(t['valor'] for t in self.boodesk_data['finances']['transacoes'] if t['tipo'] == 'Entrada')
        expenses = sum(t['valor'] for t in self.boodesk_data['finances']['transacoes'] if t['tipo'] == 'Saída')

        labels = ['Entradas', 'Saídas']
        sizes = [incomes, expenses]
        colors = ['#4CAF50', '#F44336'] # Green for income, Red for expenses
        explode = (0.1, 0)  # explode 1st slice

        fig, ax = plt.subplots(figsize=(5, 4))

        if sum(sizes) == 0:
            ax.text(0.5, 0.5, "Sem dados para exibir", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=14, color='gray')
            ax.set_title('Entradas vs Saídas')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            # Ensure sizes are not zero to prevent RuntimeWarning: invalid value encountered in divide
            # if sum(sizes) is 0.0, the warning occurs. Already handled by `if sum(sizes) == 0:`
            ax.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%',
                   shadow=True, startangle=140)
            ax.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
            ax.set_title('Entradas vs Saídas')
        return fig

    def _create_income_by_category_bar_chart(self):
        income_by_category = {}
        for t in self.boodesk_data['finances']['transacoes']:
            if t['tipo'] == 'Entrada':
                category = t.get('categoria', 'Outros')
                income_by_category[category] = income_by_category.get(category, 0) + t['valor']

        categories = list(income_by_category.keys())
        values = list(income_by_category.values())

        fig, ax = plt.subplots(figsize=(7, 5))
        if not categories:
            ax.text(0.5, 0.5, "Sem dados de entrada por categoria", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=12, color='gray')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            ax.bar(categories, values, color='#4CAF50')
            ax.set_ylabel('Valor (R$)')
            ax.set_title('Entradas por Categoria')
            ax.tick_params(axis='x', rotation=45)
        plt.tight_layout()
        return fig

    def _create_expense_by_category_bar_chart(self):
        expense_by_category = {}
        for t in self.boodesk_data['finances']['transacoes']:
            if t['tipo'] == 'Saída':
                category = t.get('categoria', 'Outros')
                expense_by_category[category] = expense_by_category.get(category, 0) + t['valor']

        categories = list(expense_by_category.keys())
        values = list(expense_by_category.values())

        fig, ax = plt.subplots(figsize=(7, 5))
        if not categories:
            ax.text(0.5, 0.5, "Sem dados de saída por categoria", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=12, color='gray')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            ax.bar(categories, values, color='#F44336')
            ax.set_ylabel('Valor (R$)')
            ax.set_title('Saídas por Categoria')
            ax.tick_params(axis='x', rotation=45)
        plt.tight_layout()
        return fig

    def create_pomodoro_timer_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        top_frame = ttk.Frame(main_frame)
        top_frame.pack(fill=tk.X, pady=10)

        timer_frame = ttk.Frame(top_frame)
        timer_frame.pack(side=tk.LEFT, expand=True, fill=tk.X)
        self.pomodoro_timer_label = ttk.Label(timer_frame, text="", font=("Helvetica", 48))
        self.pomodoro_timer_label.pack()
        self.pomodoro_cycle_label = ttk.Label(timer_frame, text="", font=("Helvetica", 14))
        self.pomodoro_cycle_label.pack()

        stats_frame = ttk.LabelFrame(top_frame, text="Estatísticas do Pomodoro")
        stats_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
        self.pomodoro_completed_label = ttk.Label(stats_frame, text="", font=("Helvetica", 12))
        self.pomodoro_completed_label.pack(padx=10, pady=5)
        self.pomodoro_pending_label = ttk.Label(stats_frame, text="", font=("Helvetica", 12))
        self.pomodoro_pending_label.pack(padx=10, pady=5)

        self.message_label = ttk.Label(main_frame, text="", font=("Helvetica", 12, "italic"))
        self.message_label.pack(pady=10)

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=10)
        self.start_button = ttk.Button(button_frame, text="Iniciar", image=self.icons.get('play_icon'), compound=tk.LEFT, command=self.start_timer)
        self.start_button.pack(side=tk.LEFT, padx=5)
        self.pause_button = ttk.Button(button_frame, text="Pausar", image=self.icons.get('stop_icon'), compound=tk.LEFT, command=self.pause_timer, state=tk.DISABLED)
        self.pause_button.pack(side=tk.LEFT, padx=5)
        self.reset_button = ttk.Button(button_frame, text="Reiniciar", image=self.icons.get('refresh_icon'), compound=tk.LEFT, command=self.reset_timer)
        self.reset_button.pack(side=tk.LEFT, padx=5)
        self.skip_button = ttk.Button(button_frame, text="Pular", image=self.icons.get('forward_icon'), compound=tk.LEFT, command=self.skip_cycle)
        self.skip_button.pack(side=tk.LEFT, padx=5)

        task_frame = ttk.LabelFrame(main_frame, text="Tarefas do Pomodoro")
        task_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        self.pomodoro_task_list = ttk.Treeview(task_frame, columns=("Tarefa", "Status", "Assunto", "Objetivo"), show="headings")
        self.pomodoro_task_list.heading("Tarefa", text="Tarefa")
        self.pomodoro_task_list.heading("Status", text="Status")
        self.pomodoro_task_list.heading("Assunto", text="Assunto")
        self.pomodoro_task_list.heading("Objetivo", text="Objetivo")
        self.pomodoro_task_list.column("Tarefa", width=250, anchor="w")
        self.pomodoro_task_list.column("Status", width=100, anchor="center")
        self.pomodoro_task_list.column("Assunto", width=150, anchor="w")
        self.pomodoro_task_list.column("Objetivo", width=150, anchor="w")
        self.pomodoro_task_list.pack(fill=tk.BOTH, expand=True)
        self.pomodoro_task_list.bind("<<TreeviewSelect>>", self.on_pomodoro_task_select)

        task_button_frame = ttk.Frame(task_frame)
        task_button_frame.pack(pady=5)
        self.add_task_entry = ttk.Entry(task_button_frame, width=40)
        self.add_task_entry.pack(side=tk.LEFT, padx=5)
        ttk.Button(task_button_frame, text="Adicionar Tarefa", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_pomodoro_task).pack(side=tk.LEFT, padx=5)
        ttk.Button(task_button_frame, text="Remover Selecionada", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_pomodoro_task).pack(side=tk.LEFT, padx=5)
        ttk.Button(task_button_frame, text="Concluir Selecionada", image=self.icons.get('ok_icon'), compound=tk.LEFT, command=self.complete_pomodoro_task).pack(side=tk.LEFT, padx=5)

    def create_my_activities_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # PanedWindow para dividir a tela elegantemente
        paned_window = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        paned_window.pack(fill=tk.BOTH, expand=True)

        # Frame da esquerda para a tabela
        left_frame = ttk.Frame(paned_window, padding="5")
        paned_window.add(left_frame, weight=2)

        # Frame da direita para as informações
        right_frame = ttk.LabelFrame(paned_window, text="Detalhes da Atividade", padding="10")
        paned_window.add(right_frame, weight=1)

        # Tabela de atividades (esquerda) - exatamente como no app23a copy 13.py
        self.activities_tree = ttk.Treeview(left_frame, columns=("Tipo", "Título", "Sub"), show="headings")
        self.activities_tree.heading("Tipo", text="Tipo")
        self.activities_tree.heading("Título", text="Título")
        self.activities_tree.heading("Sub", text="Sub")
        self.activities_tree.column("Tipo", width=80, anchor="w")
        self.activities_tree.column("Título", width=250, anchor="w")
        self.activities_tree.column("Sub", width=40, anchor="center")

        # Configurar tags de cor para importância
        for importance, color in self.settings.get("importance_colors", {}).items():
            self.activities_tree.tag_configure(importance, background=color)

        self.activities_tree.pack(fill=tk.BOTH, expand=True)

        self.activities_tree.bind("<<TreeviewSelect>>", self.on_activity_select)
        self.activities_tree.bind("<Double-1>", self.on_activity_double_click)

        bold_font = ("Helvetica", 9, "bold")

        # === WIDGETS PARA DETALHES (baseado no app23a copy 13.py) ===
        # Labels para informações (direita)
        ttk.Label(right_frame, text="Descrição:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_desc_text = tk.Text(right_frame, height=5, wrap=tk.WORD, state="disabled")
        self.activity_desc_text.pack(fill=tk.X, pady=2)

        ttk.Label(right_frame, text="Prazo:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_due_date_label = ttk.Label(right_frame, text="-")
        self.activity_due_date_label.pack(anchor="w", pady=2)

        ttk.Label(right_frame, text="Membros:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_members_label = ttk.Label(right_frame, text="-")
        self.activity_members_label.pack(anchor="w", pady=2)

        ttk.Label(right_frame, text="Dependências:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_dependencies_label = ttk.Label(right_frame, text="-")
        self.activity_dependencies_label.pack(anchor="w", pady=2)

        ttk.Label(right_frame, text="Subtarefas:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_subtasks_text = tk.Text(right_frame, height=5, wrap=tk.WORD, state="disabled")
        self.activity_subtasks_text.pack(fill=tk.X, pady=2)

        # Botões de Ação
        action_frame = ttk.Frame(right_frame)
        action_frame.pack(fill=tk.X, pady=10)
        ttk.Button(action_frame, text="Ir para o Quadro", image=self.icons.get('forward_icon_32'), compound=tk.LEFT, command=self.go_to_board_from_activity, style='Uniform.TButton').pack(side=tk.LEFT, padx=5)
        ttk.Button(action_frame, text="Abrir Card", image=self.icons.get('open_file_icon_32'), compound=tk.LEFT, command=self.open_card_from_activity, style='Uniform.TButton').pack(side=tk.LEFT, padx=5)
        ttk.Button(action_frame, text="Anotações", image=self.icons.get('save_icon_32'), compound=tk.LEFT, command=self.open_notes_editor, style='Uniform.TButton').pack(side=tk.LEFT, padx=5)
        
        # Botão para detalhes da subtarefa (visível apenas quando uma subtarefa está selecionada)
        self.subtask_details_button = ttk.Button(action_frame, text="Detalhes da Subtarefa", image=self.icons.get('ai_icon_32'), compound=tk.LEFT, command=self.show_subtask_detailed_info, style='Uniform.TButton')
        self.subtask_details_button.pack(side=tk.LEFT, padx=5)
        self.subtask_details_button.pack_forget()  # Inicialmente oculto
        
        # Botão para concluir subtarefa (visível apenas quando uma subtarefa está selecionada)
        self.complete_subtask_button = ttk.Button(action_frame, text="Concluir Subtarefa", image=self.icons.get('check_white_icon_32'), compound=tk.LEFT, command=self.complete_selected_subtask, style='Uniform.TButton')
        self.complete_subtask_button.pack(side=tk.LEFT, padx=5)
        self.complete_subtask_button.pack_forget()  # Inicialmente oculto

        # Botão para atualizar
        ttk.Button(main_frame, text="Atualizar", image=self.icons.get('refresh_icon_32'), compound=tk.LEFT, command=self.update_my_activities_tab).pack(pady=5)

        # Legenda de Cores
        legend_frame = ttk.Frame(main_frame)
        legend_frame.pack(fill=tk.X, pady=5, side=tk.BOTTOM)
        ttk.Label(legend_frame, text="Legenda:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=5)
        for imp, color in self.settings.get("importance_colors", {}).items():
            ttk.Label(legend_frame, text=imp, background=color, font=("Helvetica", 8)).pack(side=tk.LEFT, padx=2)

        self.update_my_activities_tab()

    def update_my_activities_tab(self):
        """Atualiza a aba 'Minhas Atividades' com os cards e subtarefas do usuário logado"""
        for i in self.activities_tree.get_children():
            self.activities_tree.delete(i)

        if not self.current_user:
            return

        # Obter o membro associado ao usuário logado
        current_user_member = self._get_current_user_member()
        
        all_cards = self.get_all_cards()

        # Filtrar cards baseado no papel do usuário
        if self.check_admin_access():
            # Administradores veem todos os cards
            user_cards = all_cards
        else:
            # Usuários normais veem apenas cards onde são membros
            if current_user_member:
                user_cards = [
                    card_info for card_info in all_cards
                    if current_user_member in card_info['card'].get('members', []) and
                    not card_info['card'].get("is_archived", False)
                ]
            else:
                # Se não tem membro associado, não mostra nenhum card
                user_cards = []

        row_count = 0

        for card_info in user_cards:
            card = card_info['card']
            card_id = card.get('card_id')
            if not card_id:
                continue

            importance_tag = card.get("importance", "Normal")
            
            # Buscar subtarefas do banco de dados para este card
            subtasks = self.get_subtasks_for_card(card_id)
            has_subtasks_indicator = f"({len(subtasks)})" if subtasks else ""

            # Definir tags para linha alternada
            row_tag = "evenrow" if row_count % 2 == 0 else "oddrow"

            # Insert the parent card, using its card_id as the iid and in the tags
            self.activities_tree.insert(
                "", "end",
                iid=card_id,
                values=("Tarefa", card['title'], has_subtasks_indicator),
                tags=(card_id, importance_tag, row_tag)
            )
            row_count += 1

            # Add subtasks from database, also tagging them with the parent card_id
            if subtasks:
                for subtask in subtasks:
                    subtask_id = subtask.get('id')
                    if subtask_id:
                        # Determinar status da subtarefa
                        status_icon = "✓" if subtask.get('completed') else "○"
                        subtask_text = f"{status_icon} {subtask.get('text', '')}"
                        
                        # Tag para subtarefa
                        subtask_row_tag = "evenrow" if row_count % 2 == 0 else "oddrow"
                        
                        self.activities_tree.insert(
                            card_id, "end",
                            iid=f"subtask_{subtask_id}",
                            values=("Subtarefa", subtask_text, ""),
                            tags=(card_id, "subtask", subtask_row_tag)
                        )
                        row_count += 1

        # Adicionar subtarefas individuais do usuário (não apenas as dos cards)
        user_subtasks = self.get_user_subtasks()
        if user_subtasks:
            # Adicionar um separador visual
            self.activities_tree.insert(
                "", "end",
                iid="separator_subtasks",
                values=("", "--- Subtarefas Individuais ---", ""),
                tags=("separator",)
            )
            row_count += 1
            
            for subtask in user_subtasks:
                subtask_id = subtask.get('id')
                if subtask_id:
                    # Determinar status da subtarefa
                    status_icon = "✓" if subtask.get('completed') else "○"
                    subtask_text = f"{status_icon} {subtask.get('text', '')}"
                    
                    # Tag para subtarefa individual
                    subtask_row_tag = "evenrow" if row_count % 2 == 0 else "oddrow"
                    
                    self.activities_tree.insert(
                        "", "end",
                        iid=f"subtask_{subtask_id}",
                        values=("Subtarefa", subtask_text, ""),
                        tags=("individual_subtask", "subtask", subtask_row_tag)
                    )
                    row_count += 1



    def on_activity_double_click(self, event):
        item_id = self.activities_tree.identify_row(event.y)
        if not item_id:
            return

        item_type = self.activities_tree.item(item_id, "values")[0]
        if item_type == "Subtarefa":
            # Extrair o ID da subtarefa do item_id (formato: "subtask_123")
            if item_id.startswith("subtask_"):
                subtask_id = int(item_id.split("_")[1])
                subtask = self.get_subtask_by_id(subtask_id)
                if subtask:
                    # Alternar status da subtarefa (marcar/desmarcar como concluída)
                    self.toggle_subtask_completion(subtask_id, subtask)
                    return
            else:
                # Fallback para o método antigo
                parent_id = self.activities_tree.parent(item_id)
    
    def toggle_subtask_completion(self, subtask_id, subtask):
        """Alterna o status de conclusão de uma subtarefa"""
        try:
            # Alternar o status
            new_status = not subtask.get('completed', False)
            
            # Atualizar no banco de dados
            conn = self.db.get_connection()
            if conn:
                cursor = conn.cursor()
                cursor.execute(
                    "UPDATE subtasks SET completed = %s, updated_at = NOW() WHERE id = %s",
                    (new_status, subtask_id)
                )
                conn.commit()
                cursor.close()
                
                # Atualizar a interface
                self.update_my_activities_tab()
                
                # Mostrar mensagem de confirmação
                status_text = "concluída" if new_status else "desmarcada como concluída"
                messagebox.showinfo("Sucesso", f"Subtarefa '{subtask.get('title', '')}' foi {status_text}!")
            else:
                messagebox.showerror("Erro", "Não foi possível conectar ao banco de dados")
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao atualizar subtarefa: {e}")
            print(f"Erro ao alternar conclusão da subtarefa: {e}")
    
    def get_user_subtasks(self):
        """Busca subtarefas individuais do usuário logado"""
        try:
            if not self.current_user:
                return []
            
            user_id = self.get_current_user_id()
            if not user_id:
                return []
            
            conn = self.db.get_connection()
            if not conn:
                return []
            
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id, title, completed, created_at, updated_at, card_id
                FROM subtasks 
                WHERE created_by = %s
                ORDER BY created_at DESC
            """, (user_id,))
            
            subtasks = []
            for row in cursor.fetchall():
                subtask = {
                    'id': row[0],
                    'text': row[1],
                    'completed': row[2],
                    'created_at': row[3],
                    'updated_at': row[4],
                    'card_id': row[5]
                }
                subtasks.append(subtask)
            
            cursor.close()
            return subtasks
            
        except Exception as e:
            print(f"Erro ao buscar subtarefas do usuário: {e}")
            return []

    def go_to_board_from_activity(self):
        """Navega para o quadro da atividade selecionada"""
        selected_item_id = self.activities_tree.selection()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Seleção", "Selecione uma atividade para navegar.", parent=self.root)
            return

        item_id = selected_item_id[0]
        
        # If it's a subtask, get the parent card's ID
        parent_id = self.activities_tree.parent(item_id)
        if parent_id:
            item_id = parent_id

        card_info = self.find_card_and_board_by_id(item_id)
        if card_info:
            board_name = card_info["board_name"]
            
            # Find the index of the 'Quadros' tab in the main notebook
            boards_tab_index = -1
            for i, tab in enumerate(self.main_notebook.tabs()):
                if self.main_notebook.tab(i, "text") == 'Quadros':
                    boards_tab_index = i
                    break
            
            if boards_tab_index != -1:
                self.main_notebook.select(boards_tab_index)
                
                # Now find and select the specific board's tab
                for i, tab in enumerate(self.board_notebook.tabs()):
                    if self.board_notebook.tab(i, "text") == board_name:
                        self.board_notebook.select(i)
                        break

    def open_card_from_activity(self, event=None):
        """Abre o card da atividade selecionada"""
        selected_item_id = self.activities_tree.selection()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Seleção", "Selecione uma atividade para abrir.", parent=self.root)
            return

        item_id = selected_item_id[0]
        tags = self.activities_tree.item(item_id, "tags")

        if not tags:
            messagebox.showerror("Erro", "O item selecionado não tem um ID de cartão associado.", parent=self.root)
            return

        card_id = tags[0]  # The card_id is the first tag
        card_info = self.find_card_and_board_by_id(card_id)

        if card_info:
            CardWindow(self.root, self, card_info["board_name"], card_info["list_name"], card_info["card"], self.current_user)
        else:
            messagebox.showerror("Erro", f"Cartão com ID '{card_id}' não encontrado. Pode ter sido movido ou removido.", parent=self.root)

    def on_activity_select(self, event):
        selected_item = self.activities_tree.selection()
        if not selected_item:
            return

        item_id = selected_item[0]
        item_values = self.activities_tree.item(item_id, "values")
        item_type = item_values[0] if item_values else ""
        item_tags = self.activities_tree.item(item_id, "tags")
        
        # Verificar se é uma subtarefa
        if item_type == "Subtarefa":
            # Extrair o ID da subtarefa do item_id (formato: "subtask_123")
            if item_id.startswith("subtask_"):
                subtask_id = int(item_id.split("_")[1])
                subtask = self.get_subtask_by_id(subtask_id)
                if subtask:
                    self.show_subtask_details_for_selection(subtask)
                    return
        
        # Verificar se é um separador
        if "separator" in item_tags:
            return
        
        # Se não é subtarefa, tratar como card (comportamento original)
        card_id = item_tags[0]
        card_info = self.find_card_and_board_by_id(card_id)

        if not card_info:
            return

        card = card_info['card']
        self.show_card_details_in_activity_panel(card)

    def show_subtask_details_for_selection(self, subtask):
        """Mostra os detalhes de uma subtarefa no painel direito quando selecionada"""
        # --- Clear and prepare the details view ---
        self.activity_desc_text.config(state="normal")
        self.activity_desc_text.delete("1.0", tk.END)
        self.activity_subtasks_text.config(state="normal")
        self.activity_subtasks_text.delete("1.0", tk.END)

        # --- Configure fonts ---
        bold_font = ("Helvetica", 9, "bold")
        normal_font = ("Helvetica", 9)

        # --- Populate subtask details ---
        self.activity_due_date_label.config(text="-")  # Subtarefas não têm prazo próprio
        self.activity_members_label.config(text="-")   # Subtarefas não têm membros próprios
        self.activity_dependencies_label.config(text="-")  # Subtarefas não têm dependências próprias

        # Mostrar descrição da subtarefa
        self.activity_desc_text.insert("1.0", subtask.get("desc", "Sem descrição."))

        # Mostrar informações da subtarefa
        self.activity_subtasks_text.tag_configure("bold", font=bold_font)
        
        # Status da subtarefa
        status = "✓ Concluída" if subtask.get('completed') else "○ Pendente"
        self.activity_subtasks_text.insert(tk.END, f"Status: {status}\n\n", "bold")
        
        # Título da subtarefa
        self.activity_subtasks_text.insert(tk.END, f"Título: {subtask.get('text', '')}\n", "bold")
        
        # Data de criação se disponível
        if subtask.get('created_at'):
            self.activity_subtasks_text.insert(tk.END, f"Criada em: {subtask.get('created_at')}\n")
        
        # Informações do card pai
        card = self.find_card_by_id(subtask.get('card_id'))
        if card:
            self.activity_subtasks_text.insert(tk.END, f"\nCard pai: {card.get('title', '')}\n", "bold")

        # --- Set text widgets to disabled ---
        self.activity_desc_text.config(state="disabled")
        self.activity_subtasks_text.config(state="disabled")
        
        # Armazenar a subtarefa selecionada para uso nos botões
        self.selected_subtask = subtask
        
        # Sempre mostrar os botões quando uma subtarefa é selecionada
        self.subtask_details_button.pack(side=tk.LEFT, padx=5)
        self.complete_subtask_button.pack(side=tk.LEFT, padx=5)
        
        # Configurar o texto e ícone do botão baseado no status da subtarefa
        if subtask.get('completed'):
            self.complete_subtask_button.config(
                text="✓ Já Concluída", 
                state="disabled",
                image=self.icons.get('check_completed_icon_32')
            )
        else:
            self.complete_subtask_button.config(
                text="Concluir Subtarefa", 
                state="normal",
                image=self.icons.get('check_white_icon_32')
            )

    def show_card_details_in_activity_panel(self, card):
        """Mostra os detalhes de um card no painel direito (comportamento original)"""
        # --- Clear and prepare the details view ---
        self.activity_desc_text.config(state="normal")
        self.activity_desc_text.delete("1.0", tk.END)
        self.activity_subtasks_text.config(state="normal")
        self.activity_subtasks_text.delete("1.0", tk.END)

        # --- Configure fonts ---
        bold_font = ("Helvetica", 9, "bold")
        normal_font = ("Helvetica", 9)

        # --- Populate details ---
        self.activity_due_date_label.config(text=card.get("due_date", "-"))
        self.activity_members_label.config(text=", ".join(card.get("members", [])) or "-")
        self.activity_dependencies_label.config(text=", ".join(card.get("dependencies", [])) or "-")

        self.activity_desc_text.insert("1.0", card.get("desc", "Sem descrição."))

        # --- Populate Subtasks with formatting ---
        self.activity_subtasks_text.tag_configure("bold", font=bold_font)
        
        # Buscar subtarefas do banco de dados
        subtasks = self.get_subtasks_for_card(card.get('card_id'))
        if not subtasks:
            self.activity_subtasks_text.insert("1.0", "Nenhuma subtarefa.")
        else:
            # Contadores para estatísticas
            completed_count = sum(1 for s in subtasks if s.get('completed'))
            total_count = len(subtasks)
            self.activity_subtasks_text.insert(tk.END, f"Progresso: {completed_count}/{total_count} subtarefas concluídas\n\n", "bold")
            
            for subtask in subtasks:
                status = "✓" if subtask.get('completed') else "○"
                self.activity_subtasks_text.insert(tk.END, f"{status} ")
                self.activity_subtasks_text.insert(tk.END, f"{subtask.get('text', '')}\n", "bold")
                if subtask.get('desc'):
                    self.activity_subtasks_text.insert(tk.END, f"  - {subtask.get('desc')}\n")
                # Adicionar data de criação se disponível
                if subtask.get('created_at'):
                    self.activity_subtasks_text.insert(tk.END, f"  Criada em: {subtask.get('created_at')}\n")
                self.activity_subtasks_text.insert(tk.END, "\n")

        # --- Set text widgets to disabled ---
        self.activity_desc_text.config(state="disabled")
        self.activity_subtasks_text.config(state="disabled")
        
        # Limpar subtarefa selecionada e ocultar botões de subtarefa
        self.selected_subtask = None
        self.subtask_details_button.pack_forget()
        self.complete_subtask_button.pack_forget()
    
    def show_subtask_details(self, item_id):
        """Mostra detalhes de uma subtarefa individual"""
        try:
            # Extrair o ID da subtarefa do item_id (formato: "subtask_123")
            if item_id.startswith("subtask_"):
                subtask_id = int(item_id.split("_")[1])
                subtask = self.get_subtask_by_id(subtask_id)
                
                if subtask:
                    # Limpar campos
                    self.activity_desc_text.config(state="normal")
                    self.activity_desc_text.delete("1.0", tk.END)
                    self.activity_subtasks_text.config(state="normal")
                    self.activity_subtasks_text.delete("1.0", tk.END)
                    
                    # Configurar fontes
                    bold_font = ("Helvetica", 9, "bold")
                    self.activity_subtasks_text.tag_configure("bold", font=bold_font)
                    
                    # Mostrar detalhes da subtarefa
                    self.activity_desc_text.insert("1.0", f"Subtarefa: {subtask.get('title', '')}")
                    
                    # Informações da subtarefa
                    status = "✓ Concluída" if subtask.get('completed') else "○ Pendente"
                    self.activity_subtasks_text.insert(tk.END, f"Status: {status}\n", "bold")
                    
                    if subtask.get('created_at'):
                        self.activity_subtasks_text.insert(tk.END, f"Criada em: {subtask.get('created_at')}\n")
                    
                    if subtask.get('updated_at'):
                        self.activity_subtasks_text.insert(tk.END, f"Atualizada em: {subtask.get('updated_at')}\n")
                    
                    if subtask.get('card_id'):
                        # Buscar informações do card pai
                        card = self.find_card_by_id(subtask.get('card_id'))
                        if card:
                            self.activity_subtasks_text.insert(tk.END, f"\nCard pai: {card.get('title', '')}\n", "bold")
                    
                    # Desabilitar campos
                    self.activity_desc_text.config(state="disabled")
                    self.activity_subtasks_text.config(state="disabled")
                    
                    # Limpar outros campos
                    self.activity_due_date_label.config(text="-")
                    self.activity_members_label.config(text="-")
                    self.activity_dependencies_label.config(text="-")
                    
        except Exception as e:
            print(f"Erro ao mostrar detalhes da subtarefa: {e}")
            messagebox.showerror("Erro", f"Erro ao mostrar detalhes da subtarefa: {e}")

    def complete_selected_subtask(self):
        """Marca a subtarefa selecionada como concluída"""
        if not hasattr(self, 'selected_subtask') or not self.selected_subtask:
            messagebox.showwarning("Nenhuma Subtarefa Selecionada", "Por favor, selecione uma subtarefa para concluir.", parent=self.root)
            return
        
        subtask = self.selected_subtask
        
        # Verificar se a subtarefa já está concluída
        if subtask.get('completed'):
            messagebox.showinfo("Subtarefa Já Concluída", "Esta subtarefa já está marcada como concluída.", parent=self.root)
            return
        
        try:
            # Marcar a subtarefa como concluída no banco de dados
            success = self.db.complete_subtask(subtask.get('id'))
            
            if success:
                # Atualizar a interface
                messagebox.showinfo("Sucesso", f"Subtarefa '{subtask.get('text', '')}' marcada como concluída!", parent=self.root)
                
                # Atualizar a lista de atividades
                self.update_my_activities_tab()
                
                # Atualizar os detalhes da subtarefa
                updated_subtask = self.get_subtask_by_id(subtask.get('id'))
                if updated_subtask:
                    self.selected_subtask = updated_subtask
                    self.show_subtask_details_for_selection(updated_subtask)
            else:
                messagebox.showerror("Erro", "Não foi possível marcar a subtarefa como concluída.", parent=self.root)
                
        except Exception as e:
            print(f"Erro ao concluir subtarefa: {e}")
            messagebox.showerror("Erro", f"Erro ao concluir subtarefa: {e}", parent=self.root)

    def show_subtask_detailed_info(self):
        """Abre a janela de detalhes da subtarefa (mesma tela do botão 'Abrir Subtarefa')"""
        if not hasattr(self, 'selected_subtask') or not self.selected_subtask:
            messagebox.showwarning("Nenhuma Subtarefa Selecionada", "Por favor, selecione uma subtarefa para ver os detalhes.", parent=self.root)
            return
        
        subtask = self.selected_subtask
        
        try:
            # Buscar card pai
            card = self.find_card_by_id(subtask.get('card_id'))
            if card:
                # Abrir a mesma janela que o botão "Abrir Subtarefa" usa
                SubTaskDetailWindow(self, card, subtask)
            else:
                messagebox.showerror("Erro", "Card pai não encontrado.", parent=self.root)
                
        except Exception as e:
            print(f"Erro ao abrir detalhes da subtarefa: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir detalhes da subtarefa: {e}", parent=self.root)

    def find_card_by_id(self, card_id):
        for board_name, lists in self.boodesk_data["boards"].items():
            if board_name == "workflow": continue
            for list_name, cards in lists.items():
                for card in cards:
                    if card.get('card_id') == card_id:
                        return card
        return None

    def find_subtask_by_id(self, card, subtask_id):
        if card and "subtasks" in card:
            for subtask in card["subtasks"]:
                if subtask.get("id") == subtask_id:
                    return subtask
        return None

    def get_subtasks_for_card(self, card_id):
        """Busca subtarefas do banco de dados para um card específico"""
        try:
            # Usar PostgreSQL através do self.db
            subtasks = self.db.get_subtasks_for_card(card_id)
            
            # Converter para o formato esperado pela aplicação
            formatted_subtasks = []
            for subtask in subtasks:
                try:
                    formatted_subtask = {
                        'id': subtask.get('id'),
                        'text': subtask.get('title', '') if subtask.get('title') else '',
                        'desc': subtask.get('description', '') if subtask.get('description') else '',
                        'completed': subtask.get('completed', False),
                        'position': subtask.get('position', 0),
                        'created_at': subtask.get('created_at', '') if subtask.get('created_at') else ''
                    }
                    formatted_subtasks.append(formatted_subtask)
                except Exception as e:
                    print(f"Erro ao processar subtarefa {subtask.get('id')}: {e}")
                    continue
            
            return formatted_subtasks
            
        except Exception as e:
            print(f"Erro ao buscar subtarefas para card {card_id}: {e}")
            return []

    def get_subtask_by_id(self, subtask_id):
        """Busca uma subtarefa específica do banco de dados"""
        try:
            # Usar PostgreSQL através do self.db
            subtask = self.db.get_subtask_by_id(subtask_id)
            
            if subtask:
                return {
                    'id': subtask.get('id'),
                    'card_id': subtask.get('card_id') or subtask.get('parent_card_id'),
                    'text': subtask.get('title', ''),
                    'desc': subtask.get('description', ''),
                    'completed': subtask.get('completed', False),
                    'position': subtask.get('position', 0),
                    'created_at': subtask.get('created_at', '')
                }
            return None
            
        except Exception as e:
            print(f"Erro ao buscar subtarefa {subtask_id}: {e}")
            return None

    def migrate_subtasks_to_database(self):
        """Migra subtarefas existentes do JSON para o banco de dados"""
        try:
            # Verificar se já existem subtarefas no banco
            existing_subtasks = self.db.get_subtasks_for_card("test")
            if existing_subtasks:
                print(f"Já existem subtarefas no banco de dados PostgreSQL. Pulando migração.")
                return
            
            print("Iniciando migração de subtarefas do JSON para o banco de dados PostgreSQL...")
            
            migrated_count = 0
            
            # Percorrer todos os cards e suas subtarefas
            for board_name, lists in self.boodesk_data["boards"].items():
                if board_name == "workflow": 
                    continue
                    
                for list_name, cards in lists.items():
                    for card in cards:
                        card_id = card.get('card_id')
                        if not card_id:
                            continue
                            
                        subtasks = card.get('subtasks', [])
                        if subtasks:
                            for i, subtask in enumerate(subtasks):
                                try:
                                    # Usar PostgreSQL através do self.db
                                    self.db.create_subtask(
                                        card_id=card_id,
                                        title=subtask.get('text', ''),
                                        description=subtask.get('desc', ''),
                                        completed=subtask.get('completed', False),
                                        user_id=None
                                    )
                                    migrated_count += 1
                                except Exception as e:
                                    print(f"Erro ao migrar subtarefa do card {card_id}: {e}")
            
            print(f"Migração concluída! {migrated_count} subtarefas migradas para o banco de dados PostgreSQL.")
            
        except Exception as e:
            print(f"Erro durante a migração de subtarefas: {e}")

    # Métodos para funcionalidades avançadas de subtarefas
    def get_subtask_files(self, subtask_id):
        """Busca arquivos de uma subtarefa"""
        try:
            return self.db.get_subtask_files(subtask_id)
        except Exception as e:
            print(f"Erro ao buscar arquivos da subtarefa: {e}")
            return []
    
    def add_subtask_file(self, subtask_id, file_path, user_id):
        """Adiciona arquivo a uma subtarefa"""
        try:
            return self.db.add_subtask_file(subtask_id, file_path, user_id)
        except Exception as e:
            print(f"Erro ao adicionar arquivo à subtarefa: {e}")
            raise e
    
    def get_subtask_file_by_name(self, subtask_id, filename):
        """Busca arquivo específico de uma subtarefa"""
        try:
            return self.db.get_subtask_file_by_name(subtask_id, filename)
        except Exception as e:
            print(f"Erro ao buscar arquivo da subtarefa: {e}")
            return None
    
    def remove_subtask_file(self, subtask_id, filename):
        """Remove arquivo de uma subtarefa"""
        try:
            return self.db.remove_subtask_file(subtask_id, filename)
        except Exception as e:
            print(f"Erro ao remover arquivo da subtarefa: {e}")
            raise e
    
    def get_subtask_comments(self, subtask_id):
        """Busca comentários de uma subtarefa"""
        try:
            return self.db.get_subtask_comments(subtask_id)
        except Exception as e:
            print(f"Erro ao buscar comentários da subtarefa: {e}")
            return []
    
    def add_subtask_comment(self, subtask_id, comment_text, user_id):
        """Adiciona comentário a uma subtarefa"""
        try:
            return self.db.add_subtask_comment(subtask_id, comment_text, user_id)
        except Exception as e:
            print(f"Erro ao adicionar comentário à subtarefa: {e}")
            raise e
    
    def get_subtask_history(self, subtask_id):
        """Busca histórico de uma subtarefa"""
        try:
            return self.db.get_subtask_history(subtask_id)
        except Exception as e:
            print(f"Erro ao buscar histórico da subtarefa: {e}")
            return []
    
    def update_subtask_description(self, subtask_id, description):
        """Atualiza descrição de uma subtarefa"""
        try:
            return self.db.update_subtask_description(subtask_id, description)
        except Exception as e:
            print(f"Erro ao atualizar descrição da subtarefa: {e}")
            raise e
    
    def update_subtask_title(self, subtask_id, title):
        """Atualiza título de uma subtarefa"""
        try:
            return self.db.update_subtask_title(subtask_id, title)
        except Exception as e:
            print(f"Erro ao atualizar título da subtarefa: {e}")
            raise e
    
    def update_subtask_responsible(self, subtask_id, responsible):
        """Atualiza responsável de uma subtarefa"""
        try:
            return self.db.update_subtask_responsible(subtask_id, responsible)
        except Exception as e:
            print(f"Erro ao atualizar responsável da subtarefa: {e}")
            raise e
    
    def update_subtask_priority(self, subtask_id, priority):
        """Atualiza prioridade de uma subtarefa"""
        try:
            return self.db.update_subtask_priority(subtask_id, priority)
        except Exception as e:
            print(f"Erro ao atualizar prioridade da subtarefa: {e}")
            raise e
    
    # Métodos para gerenciar subtarefas na aba de produtividade
    def load_my_subtasks(self):
        """Carrega subtarefas delegadas ao usuário atual"""
        try:
            # Limpar treeview
            for item in self.my_subtasks_tree.get_children():
                self.my_subtasks_tree.delete(item)
            
            if not self.current_user:
                return
            
            # Obter membro do usuário atual
            current_user_member = self._get_current_user_member()
            if not current_user_member:
                return
            
            # Buscar todas as subtarefas do banco
            all_subtasks = []
            all_cards = self.get_all_cards()
            
            for card_info in all_cards:
                card = card_info['card']
                card_id = card.get('card_id')
                if card_id:
                    subtasks = self.get_subtasks_for_card(card_id)
                    for subtask in subtasks:
                        # Verificar se a subtarefa foi delegada para o usuário atual
                        assigned_member = subtask.get('assigned_member')
                        if assigned_member == current_user_member:
                            # Adicionar informações do card pai
                            subtask['card_title'] = card.get('title', '')
                            subtask['board_name'] = card_info.get('board_name', '')
                            subtask['list_name'] = card_info.get('list_name', '')
                            all_subtasks.append(subtask)
            
            # Inserir no treeview
            for subtask in all_subtasks:
                status = "Concluída" if subtask.get('completed') else "Pendente"
                priority = subtask.get('priority', 'Normal')
                created_at = subtask.get('created_at', '')
                if created_at:
                    # Formatar data se necessário
                    if isinstance(created_at, str) and len(created_at) > 10:
                        created_at = created_at[:10]
                
                self.my_subtasks_tree.insert("", "end", values=(
                    subtask.get('id', ''),
                    subtask.get('text', ''),
                    subtask.get('card_title', ''),
                    status,
                    priority,
                    created_at,
                    subtask.get('assigned_member', '')
                ))
            
            # Atualizar estatísticas
            self.update_subtask_statistics(all_subtasks)
            
        except Exception as e:
            print(f"Erro ao carregar subtarefas: {e}")
    
    def filter_my_subtasks(self):
        """Filtra subtarefas baseado nos filtros selecionados"""
        try:
            status_filter = self.subtask_status_filter.get()
            priority_filter = self.subtask_priority_filter.get()
            
            # Ocultar todas as linhas
            for item in self.my_subtasks_tree.get_children():
                self.my_subtasks_tree.detach(item)
            
            # Recarregar dados
            if not self.current_user:
                return
            
            current_user_member = self._get_current_user_member()
            if not current_user_member:
                return
            
            all_subtasks = []
            all_cards = self.get_all_cards()
            
            for card_info in all_cards:
                card = card_info['card']
                card_id = card.get('card_id')
                if card_id:
                    subtasks = self.get_subtasks_for_card(card_id)
                    for subtask in subtasks:
                        assigned_member = subtask.get('assigned_member')
                        if assigned_member == current_user_member:
                            # Aplicar filtros
                            status = "Concluída" if subtask.get('completed') else "Pendente"
                            priority = subtask.get('priority', 'Normal')
                            
                            # Verificar filtro de status
                            if status_filter != "Todas":
                                if status_filter == "Pendentes" and status != "Pendente":
                                    continue
                                elif status_filter == "Concluídas" and status != "Concluída":
                                    continue
                                elif status_filter == "Em Progresso" and status != "Em Progresso":
                                    continue
                            
                            # Verificar filtro de prioridade
                            if priority_filter != "Todas" and priority != priority_filter:
                                continue
                            
                            subtask['card_title'] = card.get('title', '')
                            subtask['board_name'] = card_info.get('board_name', '')
                            subtask['list_name'] = card_info.get('list_name', '')
                            all_subtasks.append(subtask)
            
            # Inserir no treeview
            for subtask in all_subtasks:
                status = "Concluída" if subtask.get('completed') else "Pendente"
                priority = subtask.get('priority', 'Normal')
                created_at = subtask.get('created_at', '')
                if created_at and isinstance(created_at, str) and len(created_at) > 10:
                    created_at = created_at[:10]
                
                self.my_subtasks_tree.insert("", "end", values=(
                    subtask.get('id', ''),
                    subtask.get('text', ''),
                    subtask.get('card_title', ''),
                    status,
                    priority,
                    created_at,
                    subtask.get('assigned_member', '')
                ))
            
            # Atualizar estatísticas
            self.update_subtask_statistics(all_subtasks)
            
        except Exception as e:
            print(f"Erro ao filtrar subtarefas: {e}")
    
    def update_subtask_statistics(self, subtasks):
        """Atualiza estatísticas das subtarefas"""
        try:
            total = len(subtasks)
            pending = sum(1 for s in subtasks if not s.get('completed'))
            completed = sum(1 for s in subtasks if s.get('completed'))
            in_progress = sum(1 for s in subtasks if s.get('status') == 'Em Progresso')
            
            self.subtask_total_label.config(text=f"Total: {total}")
            self.subtask_pending_label.config(text=f"Pendentes: {pending}")
            self.subtask_completed_label.config(text=f"Concluídas: {completed}")
            self.subtask_in_progress_label.config(text=f"Em Progresso: {in_progress}")
            
        except Exception as e:
            print(f"Erro ao atualizar estatísticas: {e}")
    
    def refresh_my_subtasks(self):
        """Atualiza a lista de subtarefas"""
        self.load_my_subtasks()
        messagebox.showinfo("Atualizado", "Lista de subtarefas atualizada!")
    
    def open_subtask_from_tree(self, event):
        """Abre subtarefa selecionada no treeview"""
        selected_item = self.my_subtasks_tree.selection()
        if not selected_item:
            return
        
        try:
            # Obter dados da subtarefa
            item_data = self.my_subtasks_tree.item(selected_item[0])
            subtask_id = item_data['values'][0]
            
            # Buscar subtarefa no banco
            subtask = self.get_subtask_by_id(subtask_id)
            if subtask:
                # Buscar card pai
                card = self.find_card_by_id(subtask['card_id'])
                if card:
                    # Abrir janela de detalhes
                    SubTaskDetailWindow(self, card, subtask)
            
        except Exception as e:
            print(f"Erro ao abrir subtarefa: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir subtarefa: {e}")
    
    def delete_subtask_from_tree(self):
        """Remove subtarefa selecionada"""
        selected_item = self.my_subtasks_tree.selection()
        if not selected_item:
            messagebox.showwarning("Seleção", "Por favor, selecione uma subtarefa para remover.")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja remover esta subtarefa?"):
            try:
                item_data = self.my_subtasks_tree.item(selected_item[0])
                subtask_id = item_data['values'][0]
                
                # Remover do banco
                self.db.delete_subtask(subtask_id)
                
                # Recarregar lista
                self.load_my_subtasks()
                
                messagebox.showinfo("Sucesso", "Subtarefa removida com sucesso!")
                
            except Exception as e:
                print(f"Erro ao remover subtarefa: {e}")
                messagebox.showerror("Erro", f"Erro ao remover subtarefa: {e}")
    
    def show_subtasks_report(self):
        """Mostra relatório de subtarefas"""
        try:
            if not self.current_user:
                messagebox.showwarning("Usuário", "Usuário não logado.")
                return
            
            current_user_member = self._get_current_user_member()
            if not current_user_member:
                messagebox.showwarning("Membro", "Membro não encontrado.")
                return
            
            # Buscar todas as subtarefas do usuário
            all_subtasks = []
            all_cards = self.get_all_cards()
            
            for card_info in all_cards:
                card = card_info['card']
                card_id = card.get('card_id')
                if card_id:
                    subtasks = self.get_subtasks_for_card(card_id)
                    for subtask in subtasks:
                        assigned_member = subtask.get('assigned_member')
                        if assigned_member == current_user_member:
                            subtask['card_title'] = card.get('title', '')
                            all_subtasks.append(subtask)
            
            # Calcular estatísticas
            total = len(all_subtasks)
            completed = sum(1 for s in all_subtasks if s.get('completed'))
            pending = total - completed
            completion_rate = (completed / total * 100) if total > 0 else 0
            
            # Criar janela de relatório
            report_window = tk.Toplevel(self.root)
            report_window.title(f"Relatório de Subtarefas - {current_user_member}")
            report_window.geometry("600x400")
            report_window.transient(self.root)
            report_window.grab_set()
            
            # Conteúdo do relatório
            report_text = tk.Text(report_window, wrap=tk.WORD, padx=20, pady=20)
            report_text.pack(fill=tk.BOTH, expand=True)
            
            report_text.insert(tk.END, f"📊 RELATÓRIO DE SUBTAREFAS\n")
            report_text.insert(tk.END, f"Membro: {current_user_member}\n")
            report_text.insert(tk.END, f"Data: {datetime.now().strftime('%d/%m/%Y %H:%M')}\n\n")
            
            report_text.insert(tk.END, f"📈 ESTATÍSTICAS GERAIS\n")
            report_text.insert(tk.END, f"Total de Subtarefas: {total}\n")
            report_text.insert(tk.END, f"Concluídas: {completed}\n")
            report_text.insert(tk.END, f"Pendentes: {pending}\n")
            report_text.insert(tk.END, f"Taxa de Conclusão: {completion_rate:.1f}%\n\n")
            
            report_text.insert(tk.END, f"📋 LISTA DE SUBTAREFAS\n")
            for i, subtask in enumerate(all_subtasks, 1):
                status = "✓" if subtask.get('completed') else "○"
                report_text.insert(tk.END, f"{i}. {status} {subtask.get('text', '')} - {subtask.get('card_title', '')}\n")
            
            report_text.config(state=tk.DISABLED)
            
            # Botão para fechar
            ttk.Button(report_window, text="Fechar", 
                      command=report_window.destroy).pack(pady=10)
            
        except Exception as e:
            print(f"Erro ao gerar relatório: {e}")
            messagebox.showerror("Erro", f"Erro ao gerar relatório: {e}")

    def go_to_board_from_activity(self):
        selected_item_id = self.activities_tree.selection()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Seleção", "Selecione uma atividade para navegar.", parent=self.root)
            return

        item_id = selected_item_id[0]
        
        # If it's a subtask, get the parent card's ID
        parent_id = self.activities_tree.parent(item_id)
        if parent_id:
            item_id = parent_id

        card_info = self.find_card_and_board_by_id(item_id)
        if card_info:
            board_name = card_info["board_name"]
            
            # Find the index of the 'Quadros' tab in the main notebook
            boards_tab_index = -1
            for i, tab in enumerate(self.main_notebook.tabs()):
                if self.main_notebook.tab(i, "text") == 'Quadros':
                    boards_tab_index = i
                    break
            
            if boards_tab_index != -1:
                self.main_notebook.select(boards_tab_index)
                
                # Now find and select the specific board's tab
                for i, tab in enumerate(self.board_notebook.tabs()):
                    if self.board_notebook.tab(i, "text") == board_name:
                        self.board_notebook.select(i)
                        break

    def open_card_from_activity(self, event=None):
        selected_item_id = self.activities_tree.selection()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Seleção", "Selecione uma atividade para abrir.", parent=self.root)
            return

        item_id = selected_item_id[0]
        tags = self.activities_tree.item(item_id, "tags")

        if not tags:
            messagebox.showerror("Erro", "O item selecionado não tem um ID de cartão associado.", parent=self.root)
            return

        card_id = tags[0]  # The card_id is the first tag
        card_info = self.find_card_and_board_by_id(card_id)

        if card_info:
            CardWindow(self.root, self, card_info["board_name"], card_info["list_name"], card_info["card"], self.current_user)
        else:
            messagebox.showerror("Erro", f"Cartão com ID '{card_id}' não encontrado. Pode ter sido movido ou removido.", parent=self.root)

    def find_card_and_board_by_id(self, card_id):
        for board_name, board_content in self.boodesk_data.get("boards", {}).items():
            if isinstance(board_content, dict):
                for list_name, cards in board_content.items():
                    if isinstance(cards, list):
                        for card in cards:
                            if card.get("card_id") == card_id:
                                return {"board_name": board_name, "list_name": list_name, "card": card}
        return None

    def create_history_tab(self, parent):
        history_frame = ttk.LabelFrame(parent, text="Histórico de Estudos")
        history_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.log_list = ttk.Treeview(history_frame, columns=("Data e Hora", "Assunto", "Duração (min)"), show="headings")
        self.log_list.heading("Data e Hora", text="Data e Hora")
        self.log_list.heading("Assunto", text="Assunto")
        self.log_list.heading("Duração (min)", text="Duração (min)")
        self.log_list.column("Data e Hora", width=200, anchor="center")
        self.log_list.column("Assunto", width=200, anchor="w")
        self.log_list.column("Duração (min)", width=150, anchor="center")
        scrollbar = ttk.Scrollbar(history_frame, orient="vertical", command=self.log_list.yview)
        self.log_list.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        self.log_list.pack(fill=tk.BOTH, expand=True)

    def on_card_select_treeview(self, board_name, list_name, event):
        """Handler para seleção de cartão no treeview"""
        treeview = event.widget
        selection = treeview.selection()
        
        if selection:
            item = treeview.item(selection[0])
            card_id = item['tags'][0] if item['tags'] else None
            
            if card_id:
                # Find the card data
                for card in self.boodesk_data["boards"][board_name][list_name]:
                    if card.get('card_id') == card_id:
                        self.show_card_details(card)
                        break

    def get_boards_for_member(self, member_name):
        """Retorna apenas os quadros onde o membro participa de cards"""
        boards = []
        for board_name, board_data in self.boodesk_data['boards'].items():
            for list_name, cards in board_data.items():
                if list_name == 'workflow':  # Ignorar metadados
                    continue
                for card in cards:
                    if member_name in card.get('members', []):
                        boards.append(board_name)
                        break  # Uma vez encontrado, não precisa verificar mais cards
        return list(set(boards))  # Remove duplicatas

    def _should_show_board_for_user(self, board_name, current_user_member):
        """Versão melhorada do filtro de quadros - mostra apenas quadros relevantes ao membro"""
        try:
            # Administradores veem todos os quadros
            if hasattr(self, 'current_user') and getattr(self.current_user, 'role', None) in ['admin', 'Administrador']:
                return True
            
            # Se não há membro associado, mostrar apenas quadros principais
            if not current_user_member:
                return board_name in ["Quadro Principal", "Quadro Geral"]
            
            # Verificar se o membro participa de algum card no quadro
            board_data = self.boodesk_data.get("boards", {}).get(board_name, {})
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                    if list_name == 'workflow':
                        continue
                    for card in cards:
                        if current_user_member in card.get('members', []):
                            return True
            
            # Quadros especiais sempre visíveis
            if board_name in ["Quadro Principal", "Quadro Geral"]:
                return True
            
            return False
        except Exception as e:
            print(f"DEBUG: _should_show_board_for_user - Erro: {e}")
            # Em caso de erro, manter comportamento permissivo para não ocultar quadros indevidamente
            return True

    # --- UI Population and Updates ---
    def populate_boards(self):
        """Popula os quadros com otimização de performance"""
        # Usar otimizador se disponível
        if hasattr(self, 'kanban_optimizer') and self.kanban_optimizer:
            self.kanban_optimizer.optimize_populate_boards()
            return
        
        # Fallback para método original
        print(f"DEBUG: populate_boards iniciado (método original)")
        print(f"DEBUG: boodesk_data['boards'] = {self.boodesk_data['boards']}")
        print(f"DEBUG: Número de quadros: {len(self.boodesk_data['boards'])}")
        
        try:
            selected_tab_index = self.board_notebook.index(self.board_notebook.select())
        except tk.TclError:
            selected_tab_index = 0

        for i in self.board_notebook.tabs():
            self.board_notebook.forget(i)

        self.listbox_refs = {} # Clear existing references

        # Garantir que pelo menos o Quadro Principal existe
        if not self.boodesk_data["boards"] or "Quadro Principal" not in self.boodesk_data["boards"]:
            print("DEBUG: Criando Quadro Principal padrão")
            self.boodesk_data["boards"]["Quadro Principal"] = {
                "A Fazer": [],
                "Em Progresso": [],
                "Concluído": []
            }

        importance_colors = self.settings["importance_colors"]
        
        # Obter o membro do usuário atual (se método estiver disponível)
        current_user_member = None
        try:
            if hasattr(self, '_get_current_user_member'):
                current_user_member = self._get_current_user_member()
            else:
                # Se o método não existe, definir como None
                current_user_member = None
        except Exception as e:
            print(f"DEBUG: populate_boards - erro ao obter membro do usuário: {e}")
            current_user_member = None
        print(f"DEBUG: populate_boards - Usuário atual: {current_user_member}")

        print("DEBUG: Criando quadros na interface...")
        for board_name, lists in self.boodesk_data["boards"].items():
            print(f"DEBUG: Processando quadro: {board_name}")
            print(f"DEBUG: Tipo de lists: {type(lists)}")
            print(f"DEBUG: Conteúdo de lists: {lists}")
            
            # Verificar se o quadro deve ser exibido para o usuário atual
            should_show_board = self._should_show_board_for_user(board_name, current_user_member)
            print(f"DEBUG: populate_boards - Quadro '{board_name}' deve ser exibido: {should_show_board}")
            
            if not should_show_board:
                print(f"DEBUG: Quadro '{board_name}' não será exibido")
                continue
                
            print(f"DEBUG: Criando frame para quadro: {board_name}")
            board_frame = ttk.Frame(self.board_notebook, padding=5)
            self.board_notebook.add(board_frame, text=board_name)
            
            # Verificar se o quadro foi adicionado corretamente
            print(f"DEBUG: Número de abas após adicionar '{board_name}': {len(self.board_notebook.tabs())}")

            # Criar notebook interno para o quadro com abas "Cartões" e "Chat"
            board_internal_notebook = ttk.Notebook(board_frame)
            board_internal_notebook.pack(fill=tk.BOTH, expand=True)
            
            # Aba de Cartões
            cards_frame = ttk.Frame(board_internal_notebook, padding=5)
            board_internal_notebook.add(cards_frame, text="Cartões")
            
            # Aba de Chat
            chat_frame = ttk.Frame(board_internal_notebook, padding=5)
            board_internal_notebook.add(chat_frame, text="Chat")
            
            # Configurar ícones e texto nas abas (se disponíveis)
            try:
                if self.icons.get('card_icon'):
                    board_internal_notebook.tab(0, text="Cards", image=self.icons.get('card_icon'), compound=tk.LEFT)
                else:
                    board_internal_notebook.tab(0, text="Cards")
                if self.icons.get('chat_icon'):
                    board_internal_notebook.tab(1, text="Chat", image=self.icons.get('chat_icon'), compound=tk.LEFT)
                else:
                    board_internal_notebook.tab(1, text="Chat")
            except Exception as e:
                print(f"Erro ao configurar ícones nas abas: {e}")
                # Fallback para texto simples
                try:
                    board_internal_notebook.tab(0, text="Cards")
                    board_internal_notebook.tab(1, text="Chat")
                except:
                    pass
            
            # Criar chat integrado para este quadro
            self.create_integrated_chat(chat_frame, board_name)

            # Frame de gerenciamento de listas (dentro da aba de cartões)
            list_management_frame = ttk.Frame(cards_frame)
            list_management_frame.pack(fill=tk.X, pady=5)
            ttk.Button(list_management_frame, text="Adicionar Nova Lista", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_list, board_name)).pack(side=tk.LEFT)
            ttk.Button(list_management_frame, text="Chat do Projeto", image=self.icons.get('chat_icon'), compound=tk.LEFT, command=lambda: self.open_chat_tab(board_name)).pack(side=tk.LEFT, padx=(10, 0))

            list_container = ttk.Frame(cards_frame)
            list_container.pack(fill=tk.BOTH, expand=True)

            # Verificar se lists é um dicionário ou lista
            if isinstance(lists, dict):
                print(f"DEBUG: Lists é um dicionário com {len(lists)} listas")
                for list_name, cards in lists.items():
                    print(f"DEBUG: Processando lista: {list_name} com {len(cards)} cards")
                    for card in cards:
                        print(f"DEBUG: Tipo de card: {type(card)}, Conteúdo: {card}")
                    list_frame = ttk.LabelFrame(list_container, text=list_name, padding=5)
                    list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)

                    # Context menu for list management
                    list_context_menu = tk.Menu(self.root, tearoff=0)
                    list_context_menu.add_command(label="Renomear Lista", image=self.icons.get('pencil_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.rename_list(b, l))
                    list_context_menu.add_command(label="Excluir Lista", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.delete_list(b, l))
                    list_context_menu.add_separator()
                    list_context_menu.add_command(label="Mover para Esquerda", image=self.icons.get('left_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.move_list(b, l, -1))
                    list_context_menu.add_command(label="Mover para Direita", image=self.icons.get('right_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.move_list(b, l, 1))
                    
                    # Bind right-click to the LabelFrame (list header)
                    list_frame.bind("<Button-3>", lambda event, menu=list_context_menu: menu.post(event.x_root, event.y_root))

                    treeview = ttk.Treeview(list_frame, columns=("Title", "Subject", "Due Date", "Importance"), show="headings")
                    treeview.heading("Title", text="Título")
                    treeview.heading("Subject", text="Assunto")
                    treeview.heading("Due Date", text="Prazo")
                    treeview.heading("Importance", text="Importância")

                    treeview.column("Title", width=150, anchor="w")
                    treeview.column("Subject", width=100, anchor="w")
                    treeview.column("Due Date", width=100, anchor="center")
                    treeview.column("Importance", width=80, anchor="center")

                    treeview.pack(fill=tk.BOTH, expand=True, pady=5)
                    DraggableTreeview(treeview, self, board_name, list_name) # Enable drag-and-drop for Treeview
                    treeview.bind("<Double-1>", self.open_card_details) # Double-click to open card details
                    treeview.bind("<Button-3>", partial(self.show_card_context_menu, board_name, list_name)) # Right-click for card context menu
                    treeview.bind("<Key>", partial(self.handle_card_key_press, board_name, list_name)) # Keyboard shortcuts
                    treeview.bind("<<TreeviewSelect>>", partial(self.on_card_select_treeview, board_name, list_name)) # New binding for click-to-expand

                    # Store reference to treeview for target identification
                    self.listbox_refs[(board_name, list_name)] = treeview
        
        # Otimizar referências para busca rápida
        if not hasattr(self, '_listbox_refs_optimized'):
            self._listbox_refs_optimized = {}
        
        self._listbox_refs_optimized[treeview] = (board_name, list_name)
        
        # Apply filters
        filtered_cards = []
        filter_subject = self.filter_subject_var.get()
        filter_goal = self.filter_goal_var.get()
        filter_member = self.filter_member_var.get()
        filter_due_date = self.filter_due_date_var.get()
        filter_importance = self.filter_importance_var.get()
        filter_recurrence = self.filter_recurrence_var.get()
        filter_keyword = self.filter_keyword_var.get().lower()

        # Get current user's member name for filtering
        try:
            if hasattr(self, '_get_current_user_member'):
                current_user_member = self._get_current_user_member()
            else:
                current_user_member = None
        except Exception as e:
            print(f"DEBUG: Erro ao obter membro do usuário para filtro: {e}")
            current_user_member = None

        for card in cards:
            match = True

            # User-Member filter - show only cards where current user is a member
            # MODIFICAÇÃO: Tornar o filtro menos restritivo para evitar tela em branco
            if current_user_member and getattr(self.current_user, 'role', None) != 'admin':
                card_members = card.get('members', [])
                # Se o cartão não tem membros, mostrar para todos
                if card_members and current_user_member not in card_members:
                    match = False

            # Keyword filter
            if match and filter_keyword:
                card_title_lower = card.get('title', '').lower()
                card_desc_lower = card.get('desc', '').lower()
                if filter_keyword not in card_title_lower and filter_keyword not in card_desc_lower:
                    match = False

            # Subject filter - only apply if filter is not empty
            if match and filter_subject and filter_subject != "Todos" and card.get('subject') != filter_subject:
                match = False
            
            # Goal filter - only apply if filter is not empty
            if match and filter_goal and filter_goal != "Todos" and card.get('goal') != filter_goal:
                match = False

            # Member filter - only apply if filter is not empty
            if match and filter_member and filter_member.lower() != "todos":
                card_members = [m.lower() for m in card.get('members', [])]
                if filter_member.lower() not in card_members:
                    match = False

            # Due Date filter - only apply if filter is not empty
            if match and filter_due_date and filter_due_date != "Todos":
                if not self._filter_due_date(card.get('due_date', ''), filter_due_date):
                    match = False

            # Importance filter - only apply if filter is not empty
            if match and filter_importance and filter_importance != "Todos" and card.get('importance') != filter_importance:
                match = False

            # Recurrence filter - only apply if filter is not empty
            if match and filter_recurrence and filter_recurrence != "Todos" and card.get('recurrence', 'Nenhuma') != filter_recurrence:
                match = False

            if match:
                filtered_cards.append(card)

        for card in filtered_cards: # Iterate directly over filtered_cards
            if card.get('is_archived', False): # Skip archived cards
                continue

            title = card['title']
            subject = card.get('subject', '-')
            due_date = card.get('due_date', '')
            importance = card.get('importance', 'Normal')
            card_id = card.get('card_id') # Get the unique card ID for tagging

            # Insert main card row
            item_id = treeview.insert("", "end", values=(title, subject, due_date, importance), tags=(card_id,))
            
            # Apply background color based on importance
            bg_color = importance_colors.get(importance, "white")
            dependencies = card.get('dependencies', [])
            if dependencies and not self.can_start_card(card):
                # Adjust color for cards with unfulfilled dependencies
                if bg_color == "white": bg_color = "#f0f0f0"
                elif bg_color == "#ffcccc": bg_color = "#ffb3b3"
                elif bg_color == "#ffffcc": bg_color = "#ffffb3"
                elif bg_color == "#ccffcc": bg_color = "#b3ffb3"
            
            treeview.tag_configure(card_id, background=bg_color)
            treeview.item(item_id, tags=(card_id,)) # Apply the tag to the item

        treeview.filtered_cards = filtered_cards

        card_management_frame = ttk.Frame(list_frame)
        card_management_frame.pack(fill=tk.X, pady=5)
        ttk.Button(card_management_frame, text="Adicionar Cartão", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_card_ui, board_name, list_name)).pack(side=tk.LEFT, expand=True, fill=tk.X, padx=2)
            elif isinstance(lists, list):
                print(f"DEBUG: Lists é uma lista (workflow) com {len(lists)} itens: {lists}")
                # Pular quadros que são listas (como workflow)
                continue
            else:
                print(f"DEBUG: Tipo inesperado para lists: {type(lists)}")
                continue

        # Verificar se há quadros visíveis
        if not self.board_notebook.tabs():
            print("DEBUG: Nenhum quadro visível - criando quadro padrão")
            # Criar um quadro padrão se nenhum estiver visível
            default_board_frame = ttk.Frame(self.board_notebook, padding=5)
            self.board_notebook.add(default_board_frame, text="Quadro Principal")
            
            list_management_frame = ttk.Frame(default_board_frame)
            list_management_frame.pack(fill=tk.X, pady=5)
            ttk.Button(list_management_frame, text="Adicionar Nova Lista", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_list, "Quadro Principal")).pack(side=tk.LEFT)
            
            # Criar as listas padrão no quadro
            list_container = ttk.Frame(default_board_frame)
            list_container.pack(fill=tk.BOTH, expand=True)
            
            # Criar as três listas padrão
            for list_name in ["A Fazer", "Em Progresso", "Concluído"]:
                list_frame = ttk.LabelFrame(list_container, text=list_name, padding=5)
                list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
                
                treeview = ttk.Treeview(list_frame, columns=("Title", "Subject", "Due Date", "Importance"), show="headings")
                treeview.heading("Title", text="Título")
                treeview.heading("Subject", text="Assunto")
                treeview.heading("Due Date", text="Prazo")
                treeview.heading("Importance", text="Importância")
                
                treeview.column("Title", width=150, anchor="w")
                treeview.column("Subject", width=100, anchor="w")
                treeview.column("Due Date", width=100, anchor="center")
                treeview.column("Importance", width=80, anchor="center")
                
                treeview.pack(fill=tk.BOTH, expand=True, pady=5)
                self.listbox_refs[("Quadro Principal", list_name)] = treeview
                
                card_management_frame = ttk.Frame(list_frame)
                card_management_frame.pack(fill=tk.X, pady=5)
                ttk.Button(card_management_frame, text="Adicionar Cartão", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_card_ui, "Quadro Principal", list_name)).pack(side=tk.LEFT, expand=True, fill=tk.X, padx=2)
            
            # Garantir que o Quadro Principal existe nos dados
            if "Quadro Principal" not in self.boodesk_data['boards']:
                self.boodesk_data['boards']["Quadro Principal"] = {
                    "A Fazer": [],
                    "Em Progresso": [],
                    "Concluído": []
                }
        
        if self.board_notebook.tabs():
            if selected_tab_index < len(self.board_notebook.tabs()):
                self.board_notebook.select(selected_tab_index)
            else:
                self.board_notebook.select(0)
        self.update_gantt_chart()

    def show_card_context_menu(self, board_name, list_name, event):
        treeview = event.widget
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return

        # Get the card_id from the tags of the selected item
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object and its index in the boodesk_data structure
        card_index = -1
        for i, card in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if card.get('card_id') == card_id:
                card_index = i
                break

        if card_index == -1:
            return

        card_context_menu = tk.Menu(self.root, tearoff=0)
        card_context_menu.add_command(label="Abrir Detalhes do Cartão", image=self.icons.get('info_icon'), compound=tk.LEFT, command=partial(self.open_card_details_from_context, board_name, list_name, card_index))
        card_context_menu.add_command(label="Arquivar Cartão", image=self.icons.get('folder_icon'), compound=tk.LEFT, command=partial(self.archive_card_from_context, board_name, list_name, treeview, card_index))
        card_context_menu.add_command(label="Excluir Cartão (Permanente)", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=partial(self.delete_card_permanently_from_context, board_name, list_name, treeview, card_index))
        card_context_menu.post(event.x_root, event.y_root)

    def handle_card_key_press(self, board_name, list_name, event):
        """Handle keyboard shortcuts for cards"""
        treeview = event.widget
        selected_item_id = treeview.focus()
        
        if not selected_item_id:
            return

        card_id = treeview.item(selected_item_id, "tags")[0]
        card_index = -1
        for i, card in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if card.get('card_id') == card_id:
                card_index = i
                break

        if card_index == -1:
            return
            
        if event.keysym == 'Delete':
            # Delete key pressed - delete the selected card
            self.delete_card_permanently_from_context(board_name, list_name, treeview, card_index)
        elif event.keysym == 'Return':
            # Enter key pressed - open card details
            self.open_card_details_from_context(board_name, list_name, card_index)

    def open_card_details_from_context(self, board_name, list_name, card_index):
        # Get the card_id from the actual card object
        card_to_open = self.boodesk_data["boards"][board_name][list_name][card_index]
        card_id = card_to_open.get('card_id')
        if card_id:
            CardWindow(self.root, self, board_name, list_name, card_id, self.current_user)
        else:
            messagebox.showerror("Erro", "Não foi possível abrir os detalhes do cartão: ID do cartão não encontrado.")

    def open_archived_cards_window(self):
        ArchivedCardsWindow(self.root, self)

    def archive_card_from_context(self, board_name, list_name, treeview, card_index):
        # Get the card_id from the tags of the selected item
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object using its card_id
        card_to_archive = None
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card.get('card_id') == card_id:
                card_to_archive = card
                break
        
        if not card_to_archive:
            messagebox.showerror("Erro", "Cartão não encontrado.")
            return

        card_title = card_to_archive['title']
        if messagebox.askyesno("Confirmar Arquivamento", f"Tem certeza que deseja arquivar o cartão '{card_title}'?", parent=self.root):
            card_to_archive['is_archived'] = True
            self.save_trello_data()
            self.populate_boards()
            messagebox.showinfo("Cartão Arquivado", f"O cartão '{card_title}' foi arquivado.")

    def delete_card_permanently_from_context(self, board_name, list_name, treeview, card_index):
        # Get the card_id from the tags of the selected item
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object using its card_id
        card_to_delete = None
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card.get('card_id') == card_id:
                card_to_delete = card
                break
        
        if not card_to_delete:
            messagebox.showerror("Erro", "Cartão não encontrado.")
            return

        card_title = card_to_delete['title']
        if messagebox.askyesno("Confirmar Exclusão Permanente", f"Tem certeza que deseja EXCLUIR PERMANENTEMENTE o cartão '{card_title}'? Esta ação não pode ser desfeita.", parent=self.root):
            # Remove the card from the data structure by card_id
            self.boodesk_data["boards"][board_name][list_name] = [
                card for card in self.boodesk_data["boards"][board_name][list_name] if card.get('card_id') != card_id
            ]
            self.save_trello_data()
            self.populate_boards()

    def update_pomodoro_task_list(self):
        for i in self.pomodoro_task_list.get_children():
            self.pomodoro_task_list.delete(i)
        for index, row in self.pomodoro_tasks_df.iterrows():
            self.pomodoro_task_list.insert("", "end", values=(row["Tarefa"], row["Status"], row["Assunto"], row["Objetivo"]))
        self.update_pomodoro_stats()

    def update_pomodoro_stats(self):
        completed = len(self.pomodoro_tasks_df[self.pomodoro_tasks_df['Status'] == 'Concluído'])
        pending = len(self.pomodoro_tasks_df[self.pomodoro_tasks_df['Status'] == 'Pendente'])
        self.pomodoro_completed_label.config(text=f"Concluídas: {completed}")
        self.pomodoro_pending_label.config(text=f"Pendentes: {pending}")

    def update_timer_display(self):
        display_seconds = self.time_left if self.time_left > 0 else self.get_current_time_setting() * 60
        # Garantir que display_seconds seja um número
        if isinstance(display_seconds, str):
            try:
                display_seconds = int(display_seconds)
            except:
                display_seconds = 0
        minutes, secs = divmod(display_seconds, 60)
        text = f"{minutes:02d}:{secs:02d}"
        self.pomodoro_timer_label.config(text=text)
        self.pomodoro_cycle_label.config(text=f"Ciclo: {self.current_cycle}/{self.settings['cycles']}")

    def get_current_time_setting(self):
        if self.on_break:
            return self.settings['short_break'] if self.current_cycle % self.settings['cycles'] != 0 else self.settings['long_break']
        return self.settings['pomodoro']

    def on_pomodoro_task_select(self, event):
        selected_item = self.pomodoro_task_list.selection()
        if not selected_item:
            return
        
        task_name = self.pomodoro_task_list.item(selected_item, "values")[0]
        task_details = self.pomodoro_tasks_df[self.pomodoro_tasks_df['Tarefa'] == task_name].iloc[0].to_dict()
        self.active_pomodoro_task = {"source": "pomodoro_list", "details": task_details}

    def open_card_details(self, event):
        """Abre a janela de detalhes do cartão quando o usuário faz duplo clique"""
        treeview = event.widget
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return

        board_name = self.board_notebook.tab(self.board_notebook.select(), "text")
        list_name = treeview.master.cget("text")
        
        # Get the card_id from the tags of the selected item
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object and its index in the boodesk_data structure
        card_index = -1
        for i, card in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if card.get('card_id') == card_id:
                card_index = i
                break

        if card_index != -1:
            CardWindow(self.root, self, board_name, list_name, card_id, self.current_user)

    def start_pomodoro_from_card(self, board_name, list_name, card_id):
        card = None
        for c in self.boodesk_data["boards"][board_name][list_name]:
            if c.get('card_id') == card_id:
                card = c
                break
        
        if not card:
            messagebox.showerror("Erro", "Cartão não encontrado para iniciar Pomodoro.")
            return

        self.active_pomodoro_task = {"source": "boodesk", "details": card}
        messagebox.showinfo("Pomodoro Iniciado", f"Timer iniciado para a tarefa: {card['title']}")
        self.main_notebook.select(1) # Seleciona a aba Pomodoro
        self.pomodoro_notebook.select(0) # Seleciona a sub-aba Timer Pomodoro
        self.start_timer()

    def start_timer(self):
        if not self.active_pomodoro_task:
            messagebox.showwarning("Nenhuma Tarefa", "Selecione uma tarefa na lista de Pomodoro ou inicie a partir de um cartão Trello.")
            return
        if self.timer_running:
            return
        self.timer_running = True
        self.start_button.config(state=tk.DISABLED)
        self.pause_button.config(state=tk.NORMAL)
        self.reset_button.config(state=tk.NORMAL)
        self.skip_button.config(state=tk.NORMAL)
        if self.time_left == 0:
            self.time_left = self.get_current_time_setting() * 60
        self.countdown(self.time_left)

    def pause_timer(self):
        if not self.timer_running:
            return
        self.timer_running = False
        self.start_button.config(state=tk.NORMAL)
        self.pause_button.config(state=tk.DISABLED)
        if self.timer_id:
            self.root.after_cancel(self.timer_id)

    def reset_timer(self):
        if self.timer_id:
            self.root.after_cancel(self.timer_id)
        self.timer_running = False
        self.current_cycle = 0
        self.on_break = False
        self.time_left = 0
        self.update_timer_display()
        self.start_button.config(state=tk.NORMAL)
        self.pause_button.config(state=tk.DISABLED)
        self.reset_button.config(state=tk.DISABLED)
        self.skip_button.config(state=tk.DISABLED)

    def skip_cycle(self):
        if self.timer_id:
            self.root.after_cancel(self.timer_id)
        self.timer_running = False
        self.time_left = 0
        self.handle_cycle_completion()

    def countdown(self, seconds):
        if not self.timer_running:
            return
        self.time_left = seconds
        if seconds >= 0:
            minutes, secs = divmod(seconds, 60)
            self.pomodoro_timer_label.config(text=f"{minutes:02d}:{secs:02d}")
            self.timer_id = self.root.after(1000, self.countdown, seconds - 1)
        else:
            winsound.Beep(1000, 500)
            self.handle_cycle_completion()

    def handle_cycle_completion(self):
        if not self.on_break:
            self.current_cycle += 1
            self.log_pomodoro()
            if self.current_cycle % self.settings['cycles'] == 0:
                self.on_break = True
                messagebox.showinfo("Pausa Longa", "Pausa longa! Bom descanso.")
            else:
                self.on_break = True
                messagebox.showinfo("Pausa Curta", "Pausa curta! Respire fundo.")
        else:
            self.on_break = False
            messagebox.showinfo("Fim da Pausa", "Fim da pausa. Hora de voltar ao foco!")

        self.time_left = 0
        self.update_timer_display()
        self.start_timer()

    def log_pomodoro(self):
        if not self.active_pomodoro_task:
            return
        
        task_details = self.active_pomodoro_task['details']
        new_log = pd.DataFrame({
            'Data e Hora': [datetime.now().strftime('%Y-%m-%d %H:%M:%S')],
            'Assunto': [task_details.get('subject', task_details.get('Assunto', '-'))],
            'Duração (min)': [self.settings['pomodoro']]
        })
        self.log_df = pd.concat([self.log_df, new_log], ignore_index=True)
        self.save_log()
        self.update_log()

    def update_log(self):
        for i in self.log_list.get_children():
            self.log_list.delete(i)
        for index, row in self.log_df.iterrows():
            self.log_list.insert("", "end", values=(row["Data e Hora"], row["Assunto"], row["Duração (min)"]))

    # --- Board, List, and Card Management Logic ---
    def add_board(self):
        """Cria um novo quadro com opção de templates"""
        try:
            # Importar o gerenciador de templates
            from board_template_manager import BoardTemplateWindow
            BoardTemplateWindow(self.root, self, self.on_board_created_from_template)
        except ImportError:
            # Fallback para criação simples se o módulo não estiver disponível
            new_board_name = simpledialog.askstring("Novo Quadro", "Digite o nome do novo quadro:", parent=self.root)
            if new_board_name:
                self.create_simple_board(new_board_name)
    
    def create_simple_board(self, new_board_name):
        """Cria um quadro simples sem template"""
        try:
            # Get current user ID
            user_id = self.get_current_user_id()
            if not user_id:
                messagebox.showerror("Erro", "Usuário não identificado. Faça login novamente.", parent=self.root)
                return
            
            # Check if board already exists for this user
            existing_boards = self.db.get_boards(user_id)
            board_names = [board['name'] for board in existing_boards]
            
            if new_board_name in board_names:
                messagebox.showwarning("Erro", "Um quadro com este nome já existe.", parent=self.root)
                return
            
            # Create board in database
            board_id = self.db.create_board(new_board_name, owner_id=user_id)
            
            if board_id:
                # Adicionar listas padrão
                self.boodesk_data['boards'][new_board_name] = {
                    "A Fazer": [],
                    "Em Progresso": [],
                    "Concluído": []
                }
                
                # Reload data and update display
                self.load_trello_data()
                self.populate_boards()
                
                # Select the new board
                try:
                    self.board_notebook.select(len(self.board_notebook.tabs()) - 1)
                except:
                    pass
                
                messagebox.showinfo("Sucesso", f"Quadro '{new_board_name}' criado com sucesso!", parent=self.root)
            else:
                messagebox.showerror("Erro", "Não foi possível criar o quadro.", parent=self.root)
                
        except Exception as e:
            print(f"Erro ao criar quadro: {e}")
            messagebox.showerror("Erro", f"Não foi possível criar o quadro: {e}", parent=self.root)
    
    def on_board_created_from_template(self, board_name):
        """Callback chamado quando um quadro é criado via template"""
        # Atualizar interface
        self.load_trello_data()
        self.populate_boards()
        
        # Select the new board
        try:
            self.board_notebook.select(len(self.board_notebook.tabs()) - 1)
        except:
            pass

    def rename_board(self, old_name):
        new_name = simpledialog.askstring("Renomear Quadro", f"Digite o novo nome para '{old_name}':", parent=self.root)
        
        if new_name and new_name != old_name:
            try:
                # Get current user ID
                user_id = self.get_current_user_id()
                if not user_id:
                    messagebox.showerror("Erro", "Usuário não identificado. Faça login novamente.", parent=self.root)
                    return
                
                # Check if new name already exists for this user
                existing_boards = self.db.get_boards(user_id)
                board_names = [board['name'] for board in existing_boards]
                
                if new_name in board_names:
                    messagebox.showwarning("Erro", "Um quadro com este nome já existe.", parent=self.root)
                    return
                
                # Get board ID
                board_id = self.get_board_id_by_name(old_name)
                if not board_id:
                    messagebox.showerror("Erro", f"Quadro '{old_name}' não encontrado.", parent=self.root)
                    return
                
                # Update board name in database
                self.db.update_board(board_id, new_name, "", "")
                success = True
                
                if success:
                    # Reload data and update display
                    self.load_trello_data()
                    self.populate_boards()
                    messagebox.showinfo("Sucesso", f"Quadro renomeado para '{new_name}'!", parent=self.root)
                else:
                    messagebox.showerror("Erro", "Não foi possível renomear o quadro.", parent=self.root)
                    
            except Exception as e:
                print(f"Erro ao renomear quadro: {e}")
                messagebox.showerror("Erro", f"Não foi possível renomear o quadro: {e}", parent=self.root)
        elif new_name:
            messagebox.showwarning("Erro", "Não foi possível renomear. Verifique se o nome já existe ou é inválido.", parent=self.root)

    def delete_board(self, board_name):
        print(f"DEBUG: Tentando excluir quadro: '{board_name}'")
        if messagebox.askyesno("Confirmar Exclusão", f"Tem certeza que deseja excluir o quadro '{board_name}' e todos os seus conteúdos?", parent=self.root):
            try:
                # Get board ID
                print(f"DEBUG: Buscando board_id para '{board_name}'")
                board_id = self.get_board_id_by_name(board_name)
                print(f"DEBUG: board_id encontrado: {board_id}")
                
                if not board_id:
                    messagebox.showerror("Erro", f"Quadro '{board_name}' não encontrado.", parent=self.root)
                    return
                
                # Delete board from database (this will also delete all cards)
                print(f"DEBUG: Chamando delete_board no banco para board_id: {board_id}")
                self.db.delete_board(board_id)
                success = True
                print(f"DEBUG: delete_board executado com sucesso")
                
                if success:
                    # Reload data and update display
                    print(f"DEBUG: Recarregando dados após exclusão")
                    self.load_trello_data()
                    self.populate_boards()
                    messagebox.showinfo("Sucesso", f"Quadro '{board_name}' excluído com sucesso!", parent=self.root)
                else:
                    messagebox.showerror("Erro", "Não foi possível excluir o quadro.", parent=self.root)
                    
            except Exception as e:
                print(f"Erro ao excluir quadro: {e}")
                import traceback
                traceback.print_exc()
                messagebox.showerror("Erro", f"Não foi possível excluir o quadro: {e}", parent=self.root)

    def add_list(self, board_name):
        new_list_name = simpledialog.askstring("Nova Lista", "Digite o nome da nova lista:", parent=self.root)
        if new_list_name and new_list_name not in self.boodesk_data["boards"][board_name]:
            self.boodesk_data["boards"][board_name][new_list_name] = []
            self.save_trello_data()
            self.populate_boards()
        elif new_list_name:
            messagebox.showwarning("Erro", "Uma lista com este nome já existe neste quadro.", parent=self.root)

    def rename_list(self, board_name, old_list_name):
        new_list_name = simpledialog.askstring("Renomear Lista", f"Digite o novo nome para '{old_list_name}':", parent=self.root)
        if new_list_name and new_list_name != old_list_name and new_list_name not in self.boodesk_data["boards"][board_name]:
            # Recreate the dictionary with the new key in the same position
            new_lists = {}
            for name, cards in self.boodesk_data["boards"][board_name].items():
                if name == old_list_name:
                    new_lists[new_list_name] = cards
                else:
                    new_lists[name] = cards
            self.boodesk_data["boards"][board_name] = new_lists
            self.save_trello_data()
            self.populate_boards()
        elif new_list_name:
            messagebox.showwarning("Erro", "Não foi possível renomear. Verifique se o nome já existe ou é inválido.", parent=self.root)

    def delete_list(self, board_name, list_name):
        if messagebox.askyesno("Confirmar Exclusão", f"Tem certeza que deseja excluir a lista '{list_name}' e todos os seus cartões?", parent=self.root):
            del self.boodesk_data["boards"][board_name][list_name]
            self.save_trello_data()
            self.populate_boards()

    def move_list(self, board_name, list_name, direction):
        lists = list(self.boodesk_data["boards"][board_name].keys())
        try:
            current_index = lists.index(list_name)
        except ValueError:
            return

        new_index = current_index + direction
        if 0 <= new_index < len(lists):
            lists.insert(new_index, lists.pop(current_index))
            reordered_lists = {name: self.boodesk_data["boards"][board_name][name] for name in lists}
            self.boodesk_data["boards"][board_name] = reordered_lists
            self.save_trello_data()
            self.populate_boards()

    def add_card_ui(self, board_name, list_name):
        card_title = simpledialog.askstring("Novo Cartão", "Digite o título do novo cartão:", parent=self.root)
        if card_title and card_title.strip(): # Ensure title is not empty or just whitespace
            # Armazenar board e list name atuais para usar no callback
            self.current_board_name = board_name
            self.current_list_name = list_name
            
            # Abrir tela de seleção de importância
            CardImportanceWindow(self.root, self, board_name, list_name, card_title, 
                               self.create_card_with_data)
        else:
            print("❌ Criação de card cancelada - título vazio")
    
    def create_card_with_data(self, card_title, importance, description):
        """Callback para criar o card com os dados das telas de configuração"""
        try:
            print(f"🔄 Criando card: '{card_title}' com importância '{importance}'")
            
            # Get current user ID
            user_id = self.get_current_user_id()
            if not user_id:
                print("❌ ERRO: Usuário não identificado")
                return
            
            # Get board ID
            board_id = self.get_board_id_by_name(self.current_board_name)
            if not board_id:
                print(f"❌ ERRO: Board '{self.current_board_name}' não encontrado")
                return
            
            # Create card in database
            card_id = self.db.create_card(
                board_id=board_id,
                list_name=self.current_list_name,
                title=card_title,
                description=description,
                status='to_do',
                importance=importance,
                due_date="",
                subject="-",
                goal="-",
                members=[],
                git_branch="",
                git_commit="",
                recurrence="Nenhuma",
                dependencies=[],
                user_id=user_id
            )
            
            if card_id:
                print(f"✅ Card criado com sucesso: {card_id}")
                
                # Reload data and update display
                self.load_trello_data()
                self.populate_boards()
                
                # Garantir que o cartão está na estrutura em memória
                card_found_in_memory = False
                for card in self.boodesk_data["boards"][self.current_board_name][self.current_list_name]:
                    if card.get('card_id') == card_id:
                        card_found_in_memory = True
                        break
                
                if not card_found_in_memory:
                    print(f"DEBUG: Cartão {card_id} não encontrado na memória, adicionando...")
                    # Buscar dados do cartão no banco
                    card_data = self.db.get_card_by_id(card_id)
                    if card_data:
                        # Adicionar à estrutura em memória
                        self.boodesk_data["boards"][self.current_board_name][self.current_list_name].append(card_data)
                        print(f"DEBUG: Cartão adicionado à memória: {card_data.get('title', 'Sem título')}")
                
                # Email notification for card creation
                if hasattr(self, 'email_integration'):
                    card_data = {
                        "title": card_title,
                        "board": self.current_board_name,
                        "column": self.current_list_name,
                        "created_by": self.current_user.username,
                        "created_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                        "importance": importance,
                        "due_date": ""
                    }
                    self.email_integration.notify_card_created(card_data)
                
                # Open card window - the CardWindow will handle finding the card
                try:
                    print(f"DEBUG: Tentando abrir CardWindow para card_id: {card_id}")
                    CardWindow(self.root, self, self.current_board_name, self.current_list_name, card_id, self.current_user,
                               callback_on_close=partial(self.handle_card_window_closed, self.current_board_name, self.current_list_name, card_id))
                    print(f"DEBUG: CardWindow aberta com sucesso")
                except Exception as window_error:
                    print(f"DEBUG: Erro ao abrir CardWindow: {window_error}")
                    import traceback
                    traceback.print_exc()
                    raise window_error
            else:
                print("❌ ERRO: Não foi possível criar o cartão no banco de dados")
                
        except Exception as e:
            print(f"❌ ERRO ao criar cartão: {e}")
            print(f"❌ ERRO: Não foi possível criar o cartão: {e}")

    def delete_card(self, board_name, list_name, treeview):
        selected_item_id = treeview.focus()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um cartão para excluir.", parent=self.root)
            return
        
        card_id = treeview.item(selected_item_id, "tags")[0]
        card_title = treeview.item(selected_item_id, "values")[0]

        if messagebox.askyesno("Confirmar Exclusão", f"Tem certeza que deseja excluir o cartão '{card_title}'?", parent=self.root):
            # Remove the card from the data structure by card_id
            self.boodesk_data["boards"][board_name][list_name] = [
                card for card in self.boodesk_data["boards"][board_name][list_name] if card.get('card_id') != card_id
            ]
            self.save_trello_data()
            self.populate_boards()

    def move_card_data(self, source_board_name, source_list_name, card_id, target_board_name, target_list_name):
        """Move card directly in SQL database with proper list_name update and logging"""
        # Usar otimizador se disponível
        if hasattr(self, 'kanban_optimizer') and self.kanban_optimizer:
            return self.kanban_optimizer._optimized_move_card(
                card_id, source_board_name, source_list_name, target_board_name, target_list_name
            )
        
        # Fallback para método original
        try:
            print(f"SISTEMA: Iniciando movimentação de card")
            print(f"Card ID: {card_id}")
            print(f"Origem: '{source_board_name}' / '{source_list_name}'")
            print(f"Destino: '{target_board_name}' / '{target_list_name}'")
            
            # Obter board_id do quadro de destino
            target_board_id = self.get_board_id_by_name(target_board_name)
            if not target_board_id:
                print(f"ERRO: Board '{target_board_name}' não encontrado no banco")
                print(f"❌ ERRO: Quadro '{target_board_name}' não encontrado!")
                return False
            
            print(f"Board ID encontrado: {target_board_id}")
            
            # Verificar se o card existe antes de mover
            card_exists = self.db.get_card_by_id(card_id)
            if not card_exists:
                print(f"ERRO: Card {card_id} não encontrado no banco")
                print(f"❌ ERRO: Cartão não encontrado no banco de dados!")
                return False
            
            print(f"Card encontrado no banco: {card_exists.get('title', 'Sem título')}")
            
            # ATUALIZAR O CARD NO BANCO DE DADOS POSTGRESQL
            print(f"Atualizando card no PostgreSQL...")
            success = self.db.move_card(card_id, target_board_id, target_list_name)
            
            if success:
                print(f"SUCESSO: Card {card_id} movido para '{target_board_name}/{target_list_name}'")
                
                # REGISTRAR NO LOG DO SISTEMA
                try:
                    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    user_name = self.current_user.username if self.current_user else "Sistema"
                    
                    # Log detalhado da movimentação
                    log_entry = {
                        "timestamp": current_time,
                        "action": "MOVIMENTAÇÃO DE CARD",
                        "user": user_name,
                        "card_id": card_id,
                        "card_title": card_exists.get('title', 'Sem título'),
                        "source_board": source_board_name,
                        "source_list": source_list_name,
                        "target_board": target_board_name,
                        "target_list": target_list_name,
                        "target_board_id": target_board_id,
                        "status": "SUCESSO"
                    }
                    
                    print(f"LOG SISTEMA: {log_entry}")
                    
                    # Adicionar ao histórico do card
                    card_data = self.db.get_card_by_id(card_id)
                    if card_data:
                        history = card_data.get('history', [])
                        if isinstance(history, str):
                            try:
                                import json
                                history = json.loads(history)
                            except:
                                history = []
                        if not isinstance(history, list):
                            history = []
                        
                        # Adicionar entrada detalhada no histórico
                        history_entry = {
                            "timestamp": current_time,
                            "action": f"Card movido de '{source_list_name}' para '{target_list_name}'",
                            "user": user_name,
                            "source_board": source_board_name,
                            "source_list": source_list_name,
                            "target_board": target_board_name,
                            "target_list": target_list_name,
                            "list_name_updated": target_list_name,
                            "board_id_updated": target_board_id
                        }
                        
                        history.append(history_entry)
                        
                        # Atualizar histórico no banco
                        self.update_card_history(card_id, history)
                        print(f"Histórico atualizado no banco")
                
                except Exception as history_error:
                    print(f"Erro ao registrar histórico: {history_error}")
                
                # Notificação por email se habilitada
                try:
                    if hasattr(self, 'email_integration') and self.email_integration:
                        card_data = {
                            "title": card_exists.get("title", "Sem título"),
                            "board": target_board_name,
                            "column": target_list_name,
                            "modified_by": user_name,
                            "modified_date": current_time
                        }
                        changes = [f"Cartão movido de '{source_list_name}' para '{target_list_name}'"]
                        self.email_integration.notify_card_modified(card_data, changes)
                except Exception as email_error:
                    print(f"Erro ao enviar notificação por email: {email_error}")
                
                # RECARREGAR DADOS DO BANCO E ATUALIZAR INTERFACE
                print(f"Recarregando dados do banco...")
                self.load_trello_data()
                self.populate_boards()
                
                print(f"INTERFACE: Dados recarregados e interface atualizada")
                
                # Log de sucesso no terminal (sem popup)
                print(f"✅ SUCESSO: Cartão movido com sucesso para '{target_list_name}'!")
                return True
            else:
                print(f"FALHA: Não foi possível mover card {card_id} no banco")
                print(f"❌ ERRO: Falha ao mover o cartão no banco de dados!")
                return False
                
        except Exception as e:
            print(f"ERRO CRÍTICO ao mover cartão: {e}")
            print(f"❌ ERRO: Não foi possível mover o cartão: {e}")
            return False

    def handle_card_window_closed(self, board_name, list_name, card_id, saved=False):
        if not saved:
            # If the card window was closed without saving, and it was a new card,
            # remove the card that was just added to the data model.
            # This prevents empty cards from appearing if the user cancels creation.
            current_list_cards = self.boodesk_data["boards"][board_name][list_name]
            card_to_remove_index = -1
            for i, card in enumerate(current_list_cards):
                if card.get('card_id') == card_id:
                    card_to_remove_index = i
                    break

            if card_to_remove_index != -1:
                # Only remove if it's a newly added card that wasn't saved
                # and still has the default/empty title.
                if current_list_cards[card_to_remove_index].get('title') == "" or \
                   current_list_cards[card_to_remove_index].get('title') == "Sua primeira tarefa Trello":
                    self.boodesk_data["boards"][board_name][list_name].pop(card_to_remove_index)
                    self.save_trello_data()
        else:
            # Se o card foi salvo, verificar se precisa sincronizar com Google Calendar
            if self.settings.get('google_calendar_enabled', False):
                # Encontrar o card salvo
                for card in self.boodesk_data["boards"][board_name][list_name]:
                    if card.get('card_id') == card_id:
                        # Verificar se tem data de vencimento
                        if card.get('due_date'):
                            # Sincronizar com Google Calendar
                            self._sync_new_card_to_calendar(card, board_name, list_name)
                        break
        
        self.populate_boards() # Always repopulate to reflect changes or removals

    def _sync_new_card_to_calendar(self, card, board_name, list_name):
        """Sincroniza um card recém-criado com o Google Calendar"""
        try:
            # Verificar se o Google Calendar está configurado
            if not hasattr(self, 'google_calendar') or not self.google_calendar.is_authenticated:
                print("Google Calendar não está autenticado")
                return
            
            # Verificar se há data de vencimento
            if not card.get('due_date'):
                print("Card não possui data de vencimento")
                return
            
            # Usar função auxiliar para processar data brasileira
            event_datetime = self.parse_brazilian_date(card['due_date'])
            
            if not event_datetime:
                print(f"Formato de data inválido: {card['due_date']}")
                return
            
            # Criar evento no Google Calendar
            event_title = f"📋 {card['title']}"
            event_description = f"""
Card: {card['title']}
Descrição: {card.get('desc', 'Sem descrição')}
Importância: {card.get('importance', 'Normal')}
Assunto: {card.get('subject', '-')}
Objetivo: {card.get('goal', '-')}
Membros: {', '.join(card.get('members', []))}
Board: {board_name}
Lista: {list_name}
Card ID: {card.get('card_id', '')}
            """.strip()
            
            # Definir duração do evento (1 hora por padrão)
            event_duration = timedelta(hours=1)
            
            # Coletar emails para o evento
            attendees = []
            
            # Adicionar emails padrão se habilitado
            calendar_settings = self.settings.get('calendar_integration', {})
            if calendar_settings.get('include_default_emails', True):
                default_emails = calendar_settings.get('default_emails', [])
                attendees.extend(default_emails)
            
            # Adicionar membros do card se habilitado
            if calendar_settings.get('include_card_members', True):
                card_members = card.get('members', [])
                for member in card_members:
                    # Buscar email do membro no arquivo de membros
                    member_email = self._get_member_email(member)
                    if member_email:
                        attendees.append(member_email)
            
            # Remover duplicatas
            attendees = list(set(attendees))
            
            # Criar evento
            success = self.google_calendar.create_event(
                title=event_title,
                description=event_description,
                start_datetime=event_datetime,
                duration=event_duration,
                card_id=card.get('card_id', ''),
                attendees=attendees if attendees else None
            )
            
            if success:
                print(f"✅ Evento criado no Google Calendar para o card recém-criado: {card['title']}")
                # Adicionar ao histórico do card
                # Garantir que history é uma lista
                history = card.get('history', [])
                if isinstance(history, str):
                    try:
                        import json
                        history = json.loads(history)
                    except:
                        history = []
                if not isinstance(history, list):
                    history = []
                
                # Adicionar nova entrada ao histórico
                history.append({
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "action": f"Evento criado no Google Calendar",
                    "user": self.current_user.username if self.current_user else "Sistema"
                })
                card['history'] = history
                # Salvar dados atualizados
                self.save_trello_data()
            else:
                print(f"❌ Erro ao criar evento no Google Calendar para o card: {card['title']}")
                
        except Exception as e:
            print(f"❌ Erro na sincronização com Google Calendar: {e}")
            import traceback
            traceback.print_exc()

    def _get_member_email(self, member_name):
        """Busca o email de um membro no arquivo de membros"""
        try:
            if hasattr(self, 'members') and self.members:
                print(f"DEBUG: Buscando email para membro '{member_name}'")
                print(f"DEBUG: Total de membros carregados: {len(self.members)}")
                for member in self.members:
                    print(f"DEBUG: Verificando membro: {member}")
                    if member.get('Membro') == member_name:
                        email = member.get('email', '')
                        print(f"DEBUG: Email encontrado para '{member_name}': {email}")
                        return email
                print(f"DEBUG: Membro '{member_name}' não encontrado")
            else:
                print(f"DEBUG: Lista de membros não disponível ou vazia")
            return None
        except Exception as e:
            print(f"Erro ao buscar email do membro {member_name}: {e}")
            return None

    def _is_card_completed(self, card_full_title):
        # card_full_title format: "Board Name > List Name > Card Title"
        parts = card_full_title.split(' > ')
        if len(parts) != 3:
            return False # Invalid format
        
        board_name, list_name, card_title = parts

        if board_name not in self.boodesk_data["boards"]:
            return False
        if list_name not in self.boodesk_data["boards"][board_name]:
            return False
        
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card['title'] == card_title:
                # A card is considered completed if it's in the "Concluído" list
                return list_name == "Concluído"
        return False

    def _get_next_recurrence_date(self, current_date_str, recurrence_type):
        if not current_date_str:
            return ""
        
        try:
            current_date = datetime.strptime(current_date_str.split(' ')[0], "%Y-%m-%d")
        except ValueError:
            return "" # Invalid date format

        if recurrence_type == "Diariamente":
            next_date = current_date + timedelta(days=1)
        elif recurrence_type == "Semanalmente":
            next_date = current_date + timedelta(weeks=1)
        elif recurrence_type == "Mensalmente":
            # Advance by one month, handling end-of-month correctly
            year = current_date.year
            month = current_date.month + 1
            if month > 12:
                month = 1
                year += 1
            day = min(current_date.day, (datetime(year, month, 1) - timedelta(days=1)).day)
            next_date = datetime(year, month, day)
        elif recurrence_type == "Anualmente":
            next_date = current_date.replace(year=current_date.year + 1)
        else:
            return "" # No recurrence or invalid type

        return next_date.strftime("%Y-%m-%d")

    def complete_boodesk_card(self, board_name, list_name, card_id):
        card = None
        card_index = -1
        for i, c in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if c.get('card_id') == card_id:
                card = c
                card_index = i
                break
        
        if not card:
            messagebox.showerror("Erro", "Cartão não encontrado para concluir.")
            return

        recurrence = card.get('recurrence', 'Nenhuma')

        # Verificar se todas as subtarefas estão concluídas
        subtasks = card.get('subtasks', [])
        if subtasks:
            uncompleted_subtasks = [subtask for subtask in subtasks if not subtask['completed']]
            if uncompleted_subtasks:
                uncompleted_text = "\n".join([f"• {subtask['text']}" for subtask in uncompleted_subtasks])
                messagebox.showwarning(
                    "Subtarefas Pendentes", 
                    f"Não é possível concluir o cartão '{card['title']}' porque ainda existem subtarefas pendentes:\n\n{uncompleted_text}\n\nConclua todas as subtarefas antes de marcar o cartão como concluído."
                )
                return

        # Handle dependencies first
        completed_card_full_title = f"{board_name} > {list_name} > {card['title']}"
        for b_name, lists in self.boodesk_data["boards"].items():
            for l_name, cards_in_list in lists.items():
                for c in cards_in_list:
                    if completed_card_full_title in c.get('dependencies', []):
                        messagebox.showinfo("Dependência Concluída", f"O cartão '{c['title']}' agora está desbloqueado, pois sua dependência '{card['title']}' foi concluída.")

        if recurrence == "Nenhuma":
            # Move to "Concluído" list if not recurring
            if list_name != "Concluído":
                if "Concluído" in self.boodesk_data["boards"][board_name]:
                    self.boodesk_data["boards"][board_name][list_name].pop(card_index)
                    self.boodesk_data["boards"][board_name]["Concluído"].append(card)
                    self.save_trello_data()
                else:
                    messagebox.showwarning("Lista Não Encontrada", "A lista 'Concluído' não existe neste quadro.")
            else:
                messagebox.showinfo("Cartão Já Concluído", "Este cartão já está na lista 'Concluído'.")
        else:
            # Handle recurrence: Create a new instance and move the original to "Concluído"
            original_card_id = card.get('card_id')
            
            # Move original card to "Concluído"
            if list_name != "Concluído":
                if "Concluído" in self.boodesk_data["boards"][board_name]:
                    self.boodesk_data["boards"][board_name][list_name].pop(card_index)
                    self.boodesk_data["boards"][board_name]["Concluído"].append(card)
                    messagebox.showinfo("Cartão Concluído", f"Cartão '{card['title']}' concluído e movido para 'Concluído'.")
                else:
                    messagebox.showwarning("Lista Não Encontrada", "A lista 'Concluído' não existe neste quadro. O cartão original não foi movido.")
            else:
                messagebox.showinfo("Cartão Concluído", "Este cartão já está na lista 'Concluído'.")

            # Create a new recurring instance
            new_card = card.copy()
            new_card['card_id'] = str(uuid.uuid4()) # New unique ID
            new_card['parent_card_id'] = original_card_id # Link to original
            new_card['creation_date'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S") # New creation date for the instance
            new_card['is_archived'] = False # Ensure new instance is not archived

            # Calculate next due date
            original_due_date = card.get('due_date', '')
            new_card['due_date'] = self._get_next_recurrence_date(original_due_date, recurrence)

            # Place the new instance in "A Fazer"
            if "A Fazer" in self.boodesk_data["boards"][board_name]:
                self.boodesk_data["boards"][board_name]["A Fazer"].append(new_card)
                messagebox.showinfo("Cartão Recorrente Criado", f"Nova instância de '{new_card['title']}' criada e adicionada a 'A Fazer'.")
            else:
                messagebox.showwarning("Lista Não Encontrada", "A lista 'A Fazer' não existe neste quadro. A nova instância do cartão recorrente não foi adicionada.")
            self.save_trello_data()
        self.populate_boards()

    def can_start_card(self, card):
        """Check if a card can be started based on its dependencies"""
        dependencies = card.get('dependencies', [])
        if not dependencies:
            return True
        
        return all(self._is_card_completed(dep) for dep in dependencies)

    def get_card_dependency_status(self, card):
        """Get detailed dependency status for a card"""
        dependencies = card.get('dependencies', [])
        if not dependencies:
            return {"can_start": True, "completed": 0, "total": 0, "pending": []}
        
        completed = [dep for dep in dependencies if self._is_card_completed(dep)]
        pending = [dep for dep in dependencies if not self._is_card_completed(dep)]
        
        return {
            "can_start": len(pending) == 0,
            "completed": len(completed),
            "total": len(dependencies),
            "pending": pending
        }

    def add_subject_dialog(self, subject_type):
        # This method now opens the management window instead of a simple dialog
        if self.settings['unify_subjects']:
            # If subjects are unified, always manage the pomodoro list which is the master list
            SubjectManagerWindow(self.root, self, 'pomodoro')
        else:
            SubjectManagerWindow(self.root, self, subject_type)

    def add_goal(self):
        new_goal = simpledialog.askstring("Novo Objetivo", "Digite o novo objetivo:").strip()
        if new_goal and new_goal not in self.goals:
            new_goal_df = pd.DataFrame({'Objetivo': [new_goal]})
            self.goals_df = pd.concat([self.goals_df, new_goal_df], ignore_index=True)
            self.goals = self.goals_df['Objetivo'].tolist()
            self.goals_df.to_excel(self.goals_file, index=False, engine='openpyxl')
            messagebox.showinfo("Sucesso", f"Objetivo '{new_goal}' adicionado.")

    def add_pomodoro_task(self):
        task = self.add_task_entry.get().strip()
        if not task:
            messagebox.showwarning("Entrada Inválida", "Por favor, insira o nome da tarefa.")
            return

        subject = simpledialog.askstring("Assunto", "Digite o assunto da tarefa:")
        goal = simpledialog.askstring("Objetivo", "Digite o objetivo da tarefa:")

        new_task = pd.DataFrame({
            'Tarefa': [task],
            'Status': ['Pendente'],
            'Assunto': [subject if subject else '-'],
            'Objetivo': [goal if goal else '-']
        })
        self.pomodoro_tasks_df = pd.concat([self.pomodoro_tasks_df, new_task], ignore_index=True)
        self.save_pomodoro_tasks()
        self.update_pomodoro_task_list()
        self.add_task_entry.delete(0, tk.END)

    def remove_pomodoro_task(self):
        selected_item = self.pomodoro_task_list.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione uma tarefa para remover.")
            return

        task_name = self.pomodoro_task_list.item(selected_item, "values")[0]
        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover a tarefa '{task_name}'?"):
            self.pomodoro_tasks_df = self.pomodoro_tasks_df[self.pomodoro_tasks_df['Tarefa'] == task_name]
            self.save_pomodoro_tasks()
            self.update_pomodoro_task_list()

    def complete_pomodoro_task(self):
        selected_item = self.pomodoro_task_list.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione uma tarefa para concluir.")
            return

        task_name = self.pomodoro_task_list.item(selected_item, "values")[0]
        self.pomodoro_tasks_df.loc[self.pomodoro_tasks_df['Tarefa'] == task_name, 'Status'] = 'Concluído'
        self.save_pomodoro_tasks()
        self.update_pomodoro_task_list()

    def open_members_manager(self):
        MembersWindow(self.root, self)

    def open_categories_manager(self):
        """Abre o gerenciador de categorias"""
        CategoriesManagerWindow(self.root, self)

    def open_settings(self):
        SettingsWindow(self.root, self)
    
    def open_config_geral(self):
        """Abre configurações gerais"""
        try:
            from configuracoes_separadas import ConfiguracaoGeralWindow
            ConfiguracaoGeralWindow(self.root, self)
        except ImportError as e:
            messagebox.showerror("Erro", f"Erro ao importar módulo de configurações: {e}")
    
    def open_config_calendario(self):
        """Abre configurações do calendário"""
        try:
            from configuracoes_separadas import ConfiguracaoCalendarioWindow
            ConfiguracaoCalendarioWindow(self.root, self)
        except ImportError as e:
            messagebox.showerror("Erro", f"Erro ao importar módulo de configurações: {e}")
    
    def open_config_email(self):
        """Abre configurações de email"""
        try:
            from configuracoes_separadas import ConfiguracaoEmailWindow
            ConfiguracaoEmailWindow(self.root, self)
        except ImportError as e:
            messagebox.showerror("Erro", f"Erro ao importar módulo de configurações: {e}")
    
    def open_config_templates_email(self):
        """Abre configurações de templates de email"""
        try:
            from configuracoes_separadas import ConfiguracaoTemplatesEmailWindow
            ConfiguracaoTemplatesEmailWindow(self.root, self)
        except ImportError as e:
            messagebox.showerror("Erro", f"Erro ao importar módulo de configurações: {e}")

    def open_notes_editor(self):
        """Abre o editor de anotações para o card selecionado"""
        selected_item = self.activities_tree.selection()
        if not selected_item:
            messagebox.showwarning("Aviso", "Selecione uma atividade primeiro.")
            return
        
        # Obter dados do item selecionado
        item_id = selected_item[0]
        item_data = self.activities_tree.item(item_id)
        item_type = item_data.get('values', [None, None, None])[0]
        
        # Determinar o card_id baseado no tipo de item
        if item_type == "Subtarefa":
            # Para subtarefas, obter o card pai
            parent_id = self.activities_tree.parent(item_id)
            card_id = parent_id
        else:
            # Para tarefas, usar o próprio item_id
            card_id = item_id
        
        if not card_id:
            messagebox.showwarning("Aviso", "Não foi possível identificar o card selecionado.")
            return
        
        # Abrir editor de anotações
        NotesEditor(self.root, self.db, card_id, self.current_user)

    def apply_filters(self, status_filter, deadline_filter):
        """Aplica filtros aos cards"""
        # Implementar lógica de filtros aqui
        print(f"Aplicando filtros: Status={status_filter}, Prazo={deadline_filter}")
        # Atualizar display dos cards com base nos filtros

    def open_personal_dashboard(self):
        """Abre dashboard personalizado do usuário"""
        current_user_member = self._get_current_user_member()
        if not current_user_member:
            messagebox.showwarning("Aviso", "Você precisa estar logado para acessar o dashboard pessoal.")
            return
        
        dashboard_data = self.create_member_dashboard(current_user_member)
        self.show_personal_dashboard_window(dashboard_data)

    def create_tooltip(self, widget, text):
        """Cria um tooltip para um widget"""
        def show_tooltip(event):
            tooltip = tk.Toplevel()
            tooltip.wm_overrideredirect(True)
            tooltip.wm_geometry(f"+{event.x_root+10}+{event.y_root+10}")
            
            label = ttk.Label(tooltip, text=text, justify=tk.LEFT,
                             background="#ffffe0", relief=tk.SOLID, borderwidth=1,
                             font=("Arial", "8", "normal"))
            label.pack()
            
            def hide_tooltip(event):
                tooltip.destroy()
            
            widget.bind('<Leave>', hide_tooltip)
            tooltip.bind('<Leave>', hide_tooltip)
        
        widget.bind('<Enter>', show_tooltip)

    def show_kanban_performance(self):
        """Mostra janela de performance do Kanban"""
        if not hasattr(self, 'kanban_optimizer') or not self.kanban_optimizer:
            messagebox.showwarning("Aviso", "Otimizador de performance não está disponível")
            return
        
        # Criar janela de performance
        performance_window = tk.Toplevel(self.root)
        performance_window.title("Performance do Kanban")
        performance_window.geometry("400x300")
        performance_window.transient(self.root)
        performance_window.grab_set()
        
        # Frame principal
        main_frame = ttk.Frame(performance_window, padding=20)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        ttk.Label(main_frame, text="Estatísticas de Performance", 
                 font=("Arial", 14, "bold")).pack(pady=(0, 20))
        
        # Obter estatísticas
        stats = self.kanban_optimizer.get_performance_stats()
        
        # Frame para estatísticas
        stats_frame = ttk.LabelFrame(main_frame, text="Cache e Performance", padding=10)
        stats_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Exibir estatísticas
        ttk.Label(stats_frame, text=f"Widgets em cache: {stats.get('cached_widgets', 0)}").pack(anchor='w')
        ttk.Label(stats_frame, text=f"Cards em cache: {stats.get('cached_cards', 0)}").pack(anchor='w')
        ttk.Label(stats_frame, text=f"Fila de atualizações: {stats.get('update_queue_size', 0)}").pack(anchor='w')
        
        # Frame para ações
        actions_frame = ttk.Frame(main_frame)
        actions_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(actions_frame, text="Limpar Cache", 
                  command=self.clear_kanban_cache).pack(side=tk.LEFT, padx=(0, 10))
        
        ttk.Button(actions_frame, text="Recarregar Otimizador", 
                  command=self.reload_kanban_optimizer).pack(side=tk.LEFT)
    
    def clear_kanban_cache(self):
        """Limpa cache do Kanban"""
        if hasattr(self, 'kanban_optimizer') and self.kanban_optimizer:
            self.kanban_optimizer.clear_cache()
            messagebox.showinfo("Sucesso", "Cache do Kanban limpo com sucesso!")
    
    def reload_kanban_optimizer(self):
        """Recarrega o otimizador do Kanban"""
        if KANBAN_OPTIMIZER_AVAILABLE:
            self.kanban_optimizer = KanbanPerformanceOptimizer(self)
            messagebox.showinfo("Sucesso", "Otimizador do Kanban recarregado!")
        else:
            messagebox.showerror("Erro", "Otimizador não está disponível")

    def show_personal_dashboard_window(self, dashboard_data):
        """Mostra janela do dashboard pessoal"""
        dashboard_window = tk.Toplevel(self.root)
        dashboard_window.title(f"Dashboard Pessoal - {dashboard_data['my_cards'][0]['members'][0] if dashboard_data['my_cards'] else 'Usuário'}")
        dashboard_window.geometry("800x600")
        
        # Criar notebook para organizar as seções
        notebook = ttk.Notebook(dashboard_window)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Aba de Cards
        cards_frame = ttk.Frame(notebook)
        notebook.add(cards_frame, text="Meus Cards")
        
        # Lista de cards
        cards_text = tk.Text(cards_frame, wrap=tk.WORD, height=20)
        cards_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        for card in dashboard_data['my_cards']:
            status_icon = "✅" if card.get('status') == 'done' else "📋"
            card_text = f"{status_icon} {card['title']} - {card['board_name']} > {card['list_name']}\n"
            cards_text.insert(tk.END, card_text)
        
        # Aba de Métricas
        metrics_frame = ttk.Frame(notebook)
        notebook.add(metrics_frame, text="Métricas")
        
        metrics = self.get_member_metrics(dashboard_data['my_cards'][0]['members'][0] if dashboard_data['my_cards'] else 'Usuário')
        
        metrics_text = tk.Text(metrics_frame, wrap=tk.WORD, height=20)
        metrics_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        metrics_text.insert(tk.END, f"📊 MÉTRICAS DE PRODUTIVIDADE\n\n")
        metrics_text.insert(tk.END, f"Cards Criados: {metrics['cards_created']}\n")
        metrics_text.insert(tk.END, f"Cards Completados: {metrics['cards_completed']}\n")
        metrics_text.insert(tk.END, f"Tempo Médio de Conclusão: {metrics['average_completion_time']:.1f} horas\n")
        metrics_text.insert(tk.END, f"Score de Produtividade: {metrics['productivity_score']:.1f}%\n")
        metrics_text.insert(tk.END, f"Taxa de Conclusão no Prazo: {metrics['on_time_completion_rate']*100:.1f}%\n")
        metrics_text.insert(tk.END, f"Quadros Ativos: {metrics['active_boards']}\n")
        
        # Aba de Atividades
        activities_frame = ttk.Frame(notebook)
        notebook.add(activities_frame, text="Atividades Recentes")
        
        activities_text = tk.Text(activities_frame, wrap=tk.WORD, height=20)
        activities_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        for activity in dashboard_data['recent_activities']:
            activity_text = f"🕒 {activity['action']} - {activity['timestamp']}\n"
            activities_text.insert(tk.END, activity_text)

    def check_for_updates_manual(self):
        """Abre uma janela para verificar atualizações manualmente"""
        try:
            # Criar janela de atualizações
            update_window = tk.Toplevel(self.root)
            update_window.title("Verificar Atualizações - Boodesk")
            update_window.geometry("1000x900")
            update_window.resizable(True, True)
            update_window.transient(self.root)
            update_window.grab_set()
            
            # Centralizar a janela
            update_window.update_idletasks()
            x = (update_window.winfo_screenwidth() // 2) - (1000 // 2)
            y = (update_window.winfo_screenheight() // 2) - (900 // 2)
            update_window.geometry(f"1000x900+{x}+{y}")
            
            # Frame principal com scrollbar
            main_container = ttk.Frame(update_window)
            main_container.pack(fill='both', expand=True, padx=10, pady=10)
            
            # Canvas para scroll
            canvas = tk.Canvas(main_container)
            scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # Frame principal
            main_frame = ttk.Frame(scrollable_frame, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # Título principal
            title_label = ttk.Label(main_frame, text="🔄 SISTEMA DE ATUALIZAÇÕES", 
                                   font=('Segoe UI', 18, 'bold'))
            title_label.pack(pady=(0, 10))
            
            # Subtítulo
            subtitle_label = ttk.Label(main_frame, text="Gerencie as atualizações do Boodesk", 
                                     font=('Segoe UI', 12))
            subtitle_label.pack(pady=(0, 20))
            
            # Frame de status
            status_frame = ttk.LabelFrame(main_frame, text="Status da Verificação", padding=15)
            status_frame.pack(fill='x', pady=(0, 20))
            
            # Status inicial
            status_label = ttk.Label(status_frame, text="⏳ Verificando atualizações...", 
                                    font=('Segoe UI', 10))
            status_label.pack()
            
            # Frame de informações
            info_frame = ttk.LabelFrame(main_frame, text="Informações do Sistema", padding=15)
            info_frame.pack(fill='x', pady=(0, 20))
            
            # Informações do sistema
            system_info = f"""
Versão Atual: 2.4.10
Data de Compilação: {datetime.now().strftime('%d/%m/%Y')}
Sistema Operacional: {platform.system()} {platform.release()}
Python: {platform.python_version()}
Banco de Dados: PostgreSQL/Supabase
Status: Conectado ✅
            """
            
            info_text = tk.Text(info_frame, height=8, width=80, wrap=tk.WORD, 
                               font=('Consolas', 9), state='disabled')
            info_text.pack(fill='x')
            info_text.config(state='normal')
            info_text.insert('1.0', system_info.strip())
            info_text.config(state='disabled')
            
            # Frame para progresso de download
            progress_frame = ttk.LabelFrame(main_frame, text="Progresso de Download", padding=15)
            progress_frame.pack(fill='x', pady=(0, 20))
            
            # Barra de progresso
            progress_bar = ttk.Progressbar(progress_frame, mode='determinate', length=600)
            progress_bar.pack(pady=(0, 10))
            
            # Label de progresso
            progress_label = ttk.Label(progress_frame, text="Aguardando download...", 
                                     font=('Segoe UI', 9))
            progress_label.pack()
            
            # Separador visual
            separator = ttk.Separator(main_frame, orient='horizontal')
            separator.pack(fill='x', pady=(20, 20))
            
            # Título dos botões
            buttons_title = ttk.Label(main_frame, text="🎯 AÇÕES DISPONÍVEIS", 
                                     font=('Segoe UI', 14, 'bold'))
            buttons_title.pack(pady=(0, 20))
            
            # Frame de botões principais - Primeira linha
            button_frame1 = ttk.Frame(main_frame)
            button_frame1.pack(fill='x', pady=(0, 15))
            
            # Botão de verificar novamente
            check_button = ttk.Button(button_frame1, text="🔄 Verificar Novamente", 
                                     command=lambda: self.check_updates_again(status_label, progress_bar, progress_label),
                                     style='Accent.TButton', width=25)
            check_button.pack(side='left', padx=(0, 15))
            
            # Botão de download
            download_button = ttk.Button(button_frame1, text="⬇️ Download Atualização", 
                                       command=lambda: self.download_update(progress_bar, progress_label, update_window),
                                       style='Accent.TButton', width=25)
            download_button.pack(side='left', padx=(0, 15))
            
            # Botão de instalação
            install_button = ttk.Button(button_frame1, text="⚙️ Instalar Atualização", 
                                      command=lambda: self.install_update(progress_bar, progress_label),
                                      style='Accent.TButton', width=25)
            install_button.pack(side='left', padx=(0, 15))
            
            # Botão para configurar diretório de download
            configure_dir_button = ttk.Button(button_frame1, text="⚙️ Configurar Diretório", 
                                            command=lambda: self.configure_download_directory(),
                                            width=25)
            configure_dir_button.pack(side='left', padx=(0, 15))
            
            # Label para mostrar diretório atual
            download_dir_label = ttk.Label(button_frame1, text="📁 Diretório atual: Carregando...", 
                                         font=("Arial", 9))
            download_dir_label.pack(side='left', padx=(10, 0))
            
            # Botão de abrir local do executável (inicialmente desabilitado)
            open_location_button = ttk.Button(button_frame1, text="📁 Abrir Local do Executável", 
                                            command=lambda: self.open_executable_location(),
                                            state='disabled', width=25)
            open_location_button.pack(side='left', padx=(0, 15))
            
            # Armazenar referência do botão para habilitar após download
            update_window.open_location_button = open_location_button
            update_window.download_dir_label = download_dir_label
            
            # Frame de botões secundários - Segunda linha
            button_frame2 = ttk.Frame(main_frame)
            button_frame2.pack(fill='x', pady=(15, 15))
            
            # Botão de configurações avançadas
            advanced_button = ttk.Button(button_frame2, text="🔧 Configurações Avançadas", 
                                       command=lambda: self.show_advanced_update_settings(update_window),
                                       width=30)
            advanced_button.pack(side='left', padx=(0, 15))
            
            # Botão de histórico de atualizações
            history_button = ttk.Button(button_frame2, text="📋 Histórico de Atualizações", 
                                      command=lambda: self.show_update_history(update_window),
                                      width=30)
            history_button.pack(side='left', padx=(0, 15))
            
            # Frame de botão fechar - Terceira linha
            button_frame3 = ttk.Frame(main_frame)
            button_frame3.pack(fill='x', pady=(20, 0))
            
            # Botão de fechar
            close_button = ttk.Button(button_frame3, text="❌ Fechar", 
                                     command=update_window.destroy,
                                     width=20)
            close_button.pack(side='right')
            
            # Configurar scrollbar
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # Simular verificação
            self.root.after(2000, lambda: self.simulate_update_check(status_label, progress_bar, progress_label))
            self.root.after(100, lambda: self.update_download_dir_label())
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir verificação de atualizações: {e}")
    
    def check_updates_again(self, status_label, progress_bar=None, progress_label=None):
        """Verifica atualizações novamente"""
        status_label.config(text="⏳ Verificando atualizações...")
        if progress_bar and progress_label:
            progress_bar['value'] = 0
            progress_label.config(text="Verificando...")
        self.root.after(2000, lambda: self.simulate_update_check(status_label, progress_bar, progress_label))
        self.root.after(100, lambda: self.update_download_dir_label())
    
    def simulate_update_check(self, status_label, progress_bar=None, progress_label=None):
        """Simula a verificação de atualizações"""
        try:
            # Simular verificação
            import random
            has_updates = random.choice([True, False])
            
            if has_updates:
                status_label.config(text="✅ Atualizações disponíveis! Versão 2.3.2")
                if progress_bar and progress_label:
                    progress_bar['value'] = 0
                    progress_label.config(text="Atualização disponível para download")
                messagebox.showinfo("Atualizações", "Nova versão disponível: 2.3.2\n\nMelhorias:\n• Correções de bugs\n• Novas funcionalidades\n• Melhor performance")
            else:
                status_label.config(text="✅ Sistema atualizado! Você está usando a versão mais recente.")
                if progress_bar and progress_label:
                    progress_bar['value'] = 100
                    progress_label.config(text="Sistema atualizado")
                
        except Exception as e:
            status_label.config(text=f"❌ Erro na verificação: {e}")
    
    def show_about_dialog(self):
        """Mostra a janela Sobre o Boodesk"""
        try:
            about_window = tk.Toplevel(self.root)
            about_window.title("Sobre o Boodesk")
            about_window.geometry("400x300")
            about_window.resizable(False, False)
            about_window.transient(self.root)
            about_window.grab_set()
            
            # Centralizar a janela
            about_window.update_idletasks()
            x = (about_window.winfo_screenwidth() // 2) - (400 // 2)
            y = (about_window.winfo_screenheight() // 2) - (300 // 2)
            about_window.geometry(f"400x300+{x}+{y}")
            
            # Frame principal
            main_frame = ttk.Frame(about_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # Logo/Título
            title_label = ttk.Label(main_frame, text="🎯 BOODESK", 
                                   font=('Segoe UI', 20, 'bold'))
            title_label.pack(pady=(0, 10))
            
            subtitle_label = ttk.Label(main_frame, text="Sistema de Gerenciamento de Tarefas", 
                                      font=('Segoe UI', 12))
            subtitle_label.pack(pady=(0, 20))
            
            # Informações
            info_text = """
Versão: 2.3.1
Desenvolvido por: Thalles Daniel
Data: Agosto 2025

Sistema completo de gerenciamento de tarefas
com integração PostgreSQL/Supabase e
interface moderna em Tkinter.

Funcionalidades:
• Quadros Kanban
• Sistema Pomodoro
• Chat em tempo real
• Dashboard executivo
• Integração com calendário
• Upload de arquivos
• Relatórios avançados
            """
            
            info_label = ttk.Label(main_frame, text=info_text, 
                                  font=('Segoe UI', 9), justify='left')
            info_label.pack(pady=(0, 20))
            
            # Botão fechar
            close_button = ttk.Button(main_frame, text="Fechar", 
                                     command=about_window.destroy)
            close_button.pack()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir janela Sobre: {e}")

    def show_update_options(self, status_label):
        """Mostra opções de download e instalação"""
        try:
            # Criar janela de opções
            options_window = tk.Toplevel(self.root)
            options_window.title("Nova Versão Disponível - Boodesk")
            options_window.geometry("600x500")
            options_window.resizable(False, False)
            options_window.transient(self.root)
            options_window.grab_set()
            
            # Centralizar a janela
            options_window.update_idletasks()
            x = (options_window.winfo_screenwidth() // 2) - (600 // 2)
            y = (options_window.winfo_screenheight() // 2) - (500 // 2)
            options_window.geometry(f"600x500+{x}+{y}")
            
            # Frame principal
            main_frame = ttk.Frame(options_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # Título
            title_label = ttk.Label(main_frame, text="🆕 Nova Versão Disponível!", 
                                   font=('Segoe UI', 18, 'bold'))
            title_label.pack(pady=(0, 20))
            
            # Informações da versão
            version_frame = ttk.LabelFrame(main_frame, text="Detalhes da Atualização", padding=15)
            version_frame.pack(fill='x', pady=(0, 20))
            
            version_info = """
Versão Atual: 2.4.10
Nova Versão: 2.3.2
Tamanho: 15.2 MB
Data de Lançamento: 25/08/2025

Melhorias Incluídas:
• Correções de bugs críticos
• Novas funcionalidades de produtividade
• Melhor performance e estabilidade
• Interface aprimorada
• Novos temas visuais
• Integração com Google Calendar melhorada
• Sistema de backup automático
• Relatórios avançados
            """
            
            info_text = tk.Text(version_frame, height=12, width=60, wrap=tk.WORD, 
                               font=('Consolas', 9), state='disabled')
            info_text.pack(fill='x')
            info_text.config(state='normal')
            info_text.insert('1.0', version_info.strip())
            info_text.config(state='disabled')
            
            # Frame de progresso (inicialmente oculto)
            progress_frame = ttk.LabelFrame(main_frame, text="Progresso do Download", padding=15)
            
            progress_label = ttk.Label(progress_frame, text="Preparando download...", 
                                      font=('Segoe UI', 10))
            progress_label.pack(pady=(0, 10))
            
            progress_bar = ttk.Progressbar(progress_frame, length=400, mode='determinate')
            progress_bar.pack(pady=(0, 10))
            
            progress_text = ttk.Label(progress_frame, text="0%", font=('Segoe UI', 9))
            progress_text.pack()
            
            # Frame de botões
            button_frame = ttk.Frame(main_frame)
            button_frame.pack(fill='x', pady=(20, 0))
            
            # Botão de download
            download_button = ttk.Button(button_frame, text="📥 Download e Instalar", 
                                        command=lambda: self.start_download_and_install(
                                            options_window, progress_frame, progress_label, 
                                            progress_bar, progress_text, status_label
                                        ))
            download_button.pack(side='left', padx=(0, 10))
            
            # Botão de download manual
            manual_button = ttk.Button(button_frame, text="🌐 Download Manual", 
                                      command=lambda: self.open_download_page())
            manual_button.pack(side='left', padx=(0, 10))
            
            # Botão de lembrar depois
            later_button = ttk.Button(button_frame, text="⏰ Lembrar Depois", 
                                     command=options_window.destroy)
            later_button.pack(side='left', padx=(0, 10))
            
            # Botão de fechar
            close_button = ttk.Button(button_frame, text="❌ Fechar", 
                                     command=options_window.destroy)
            close_button.pack(side='right')
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao mostrar opções de atualização: {e}")
    
    def start_download_and_install(self, options_window, progress_frame, progress_label, 
                                  progress_bar, progress_text, status_label):
        """Inicia o processo de download e instalação"""
        try:
            # Mostrar frame de progresso
            progress_frame.pack(fill='x', pady=(0, 20))
            
            # Simular download
            self.simulate_download(progress_label, progress_bar, progress_text, 
                                  options_window, status_label)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao iniciar download: {e}")
    
    def simulate_download(self, progress_label, progress_bar, progress_text, 
                         options_window, status_label):
        """Simula o processo de download"""
        try:
            import time
            import threading
            
            def download_process():
                try:
                    # Simular etapas do download
                    steps = [
                        ("Conectando ao servidor...", 10),
                        ("Verificando integridade...", 20),
                        ("Baixando arquivos...", 50),
                        ("Validando arquivos...", 80),
                        ("Preparando instalação...", 90),
                        ("Instalando atualização...", 100)
                    ]
                    
                    for step_text, progress_value in steps:
                        # Atualizar interface na thread principal
                        self.root.after(0, lambda t=step_text, p=progress_value: 
                                      self.update_download_progress(progress_label, progress_bar, 
                                                                   progress_text, t, p))
                        time.sleep(1.5)  # Simular tempo de processamento
                    
                    # Download concluído
                    self.root.after(0, lambda: self.download_completed(options_window, status_label))
                    
                except Exception as e:
                    self.root.after(0, lambda: self.download_failed(e, options_window))
            
            # Executar download em thread separada
            download_thread = threading.Thread(target=download_process)
            download_thread.daemon = True
            download_thread.start()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro no download: {e}")
    
    def update_download_progress(self, progress_label, progress_bar, progress_text, 
                                step_text, progress_value):
        """Atualiza o progresso do download"""
        try:
            progress_label.config(text=step_text)
            progress_bar['value'] = progress_value
            progress_text.config(text=f"{progress_value}%")
            self.root.update_idletasks()
        except Exception as e:
            print(f"Erro ao atualizar progresso: {e}")
    
    def download_completed(self, options_window, status_label):
        """Chamado quando o download é concluído"""
        try:
            # Mostrar mensagem de sucesso
            response = messagebox.askyesno(
                "✅ Download Concluído!",
                "A atualização foi baixada e instalada com sucesso!\n\n"
                "Para aplicar as mudanças, é necessário reiniciar o Boodesk.\n\n"
                "Deseja reiniciar agora?"
            )
            
            if response:
                # Reiniciar aplicação
                self.restart_application()
            else:
                # Fechar janela de opções
                options_window.destroy()
                status_label.config(text="✅ Atualização instalada! Reinicie para aplicar.")
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao finalizar instalação: {e}")
    
    def download_failed(self, error, options_window):
        """Chamado quando o download falha"""
        try:
            messagebox.showerror(
                "❌ Erro no Download",
                f"Não foi possível baixar a atualização:\n\n{error}\n\n"
                "Tente novamente ou use o download manual."
            )
            options_window.destroy()
        except Exception as e:
            print(f"Erro ao mostrar erro de download: {e}")
    
    def open_download_page(self):
        """Abre a página de download manual"""
        try:
            import webbrowser
            
            # URL fictícia para download manual
            download_url = "https://boodesk.com/downloads"
            
            # Tentar abrir no navegador
            webbrowser.open(download_url)
            
            messagebox.showinfo(
                "🌐 Download Manual",
                f"A página de download foi aberta no seu navegador:\n\n{download_url}\n\n"
                "Baixe a versão mais recente e execute o instalador."
            )
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir página de download: {e}")
    
    def restart_application(self):
        """Reinicia a aplicação"""
        try:
            # Salvar configurações antes de reiniciar
            self.save_settings()
            
            # Mostrar mensagem de reinicialização
            messagebox.showinfo(
                "🔄 Reiniciando",
                "O Boodesk será reiniciado para aplicar as atualizações.\n\n"
                "Aguarde alguns segundos..."
            )
            
            # Fechar aplicação atual
            self.root.quit()
            
            # Em um ambiente real, aqui você executaria o novo instalador
            # Por enquanto, apenas simulamos o reinício
            import subprocess
            import sys
            
            # Reiniciar a aplicação
            subprocess.Popen([os.path.abspath(sys.argv[0]), sys.argv[0]])
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao reiniciar aplicação: {e}")

    def download_update(self, progress_bar, progress_label, update_window=None):
        """Simula o download de uma atualização"""
        try:
            progress_label.config(text="Iniciando download...")
            progress_bar['value'] = 0
            
            def update_progress():
                current = progress_bar['value']
                if current < 100:
                    progress_bar['value'] += 10
                    if current < 30:
                        progress_label.config(text="Baixando arquivos...")
                    elif current < 60:
                        progress_label.config(text="Verificando integridade...")
                    elif current < 90:
                        progress_label.config(text="Finalizando download...")
                    else:
                        progress_label.config(text="Download concluído!")
                    
                    if current < 100:
                        self.root.after(500, update_progress)
                    else:
                        messagebox.showinfo("Download Concluído", "Atualização baixada com sucesso!\nClique em 'Instalar Atualização' para aplicar.")
            
            update_progress()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro no download: {e}")
            progress_label.config(text="Erro no download")
    
    
    def get_current_version(self):
        """Retorna a versão atual do aplicativo"""
        try:
            # Tentar obter do banco de dados
            if hasattr(self, 'db') and self.db:
                conn = self.db.get_connection()
                if conn:
                    cursor = conn.cursor()
                    cursor.execute("""
                        SELECT versao FROM versoes_sistema 
                        WHERE ativo = true 
                        ORDER BY data_lancamento DESC 
                        LIMIT 1
                    """)
                    result = cursor.fetchone()
                    if result:
                        return result[0]
        except:
            pass
        
        # Fallback para versão hardcoded
        return "2.4.9"
    def install_update(self, progress_bar, progress_label):
        """Instala a atualização baixada usando script de instalação"""
        try:
            # Verificar se o download foi concluído com sucesso
            download_dir = self.get_download_directory()
            new_exe_path = os.path.join(download_dir, "boodesk_latest.exe")
            installer_script = "install_update.bat"
            
            print(f"🔍 Verificando arquivo de atualização: {new_exe_path}")
            print(f"🔍 Verificando script de instalação: {installer_script}")
            
            # Verificar se o arquivo novo existe e é válido
            if not os.path.exists(new_exe_path):
                print("❌ Arquivo de atualização não encontrado")
                messagebox.showwarning("Aviso", "Arquivo de atualização não encontrado.\n\nClique em '⬇️ Download Atualização' primeiro!")
                return
            
            # Verificar se o arquivo é válido (mínimo 50MB)
            file_size = os.path.getsize(new_exe_path)
            print(f"📦 Tamanho do arquivo: {file_size} bytes ({file_size//1024//1024}MB)")
            
            if file_size < 50*1024*1024:  # Menos de 50MB
                print("❌ Arquivo de atualização muito pequeno (possivelmente corrompido)")
                messagebox.showerror("Erro", f"Arquivo de atualização inválido ou corrompido!\n\nTamanho: {file_size//1024//1024}MB (mínimo: 50MB)\n\nTente fazer o download novamente.")
                return
            
            # Gerar script de instalação dinamicamente
            install_script_path = os.path.join(download_dir, installer_script)
            
            # Definir variáveis necessárias
            new_exe_name = "boodesk_latest.exe"
            current_exe = os.path.abspath(sys.argv[0])
            
            # Conteúdo do script de instalação robusto
            install_script_content = f"""@echo off
echo ========================================
echo    INSTALADOR DE ATUALIZACAO BOODESK
echo ========================================
echo.

echo [1/6] Verificando arquivos...
if not exist "{download_dir}\\{new_exe_name}" (
    echo ERRO: Arquivo de atualizacao nao encontrado!
    echo Caminho: {download_dir}\\{new_exe_name}
    pause
    exit /b 1
)

echo [2/6] Verificando se o arquivo e valido...
"{download_dir}\\{new_exe_name}" --help >nul 2>&1
if errorlevel 1 (
    echo AVISO: Arquivo pode nao ser um executavel valido
    echo Continuando mesmo assim...
)

echo [3/6] Criando backup do executavel atual...
if exist "{os.path.dirname(os.path.abspath(sys.argv[0]))}\\app23a.py" (
    copy "{os.path.dirname(os.path.abspath(sys.argv[0]))}\\app23a.py" "{os.path.dirname(os.path.abspath(sys.argv[0]))}\\app23a.py.backup" >nul
    echo Backup criado: app23a.py.backup
) else (
    echo Aviso: Arquivo atual nao encontrado
)

echo [4/6] Aguardando fechamento do aplicativo...
echo Aguardando 5 segundos para garantir que o aplicativo foi fechado...
timeout /t 5 /nobreak >nul

echo [5/6] Copiando nova versao...
echo Copiando {new_exe_name} para BoodeskApp.exe...
copy "{download_dir}\\{new_exe_name}" "{os.path.dirname(os.path.abspath(sys.argv[0]))}\\BoodeskApp.exe" >nul
if errorlevel 1 (
    echo ERRO: Falha ao copiar nova versao!
    echo Tentando novamente...
    copy "{download_dir}\\{new_exe_name}" "{os.path.dirname(os.path.abspath(sys.argv[0]))}\\BoodeskApp.exe" >nul
    if errorlevel 1 (
        echo ERRO: Falha ao copiar nova versao na segunda tentativa!
        pause
        exit /b 1
    )
)

echo [6/6] Limpando arquivos temporarios...
del "{download_dir}\\{new_exe_name}" >nul 2>&1
del "{download_dir}\\{installer_script}" >nul 2>&1

echo.
echo ========================================
echo    ATUALIZACAO CONCLUIDA COM SUCESSO!
echo ========================================
echo.
echo O Boodesk foi atualizado e sera iniciado.
echo Pressione qualquer tecla para continuar...
pause >nul

echo Iniciando Boodesk atualizado...
cd /d "{os.path.dirname(os.path.abspath(sys.argv[0]))}"
echo Diretorio atual: %CD%
echo Executando: BoodeskApp.exe
start "" "BoodeskApp.exe"
if errorlevel 1 (
    echo ERRO: Falha ao iniciar BoodeskApp.exe
    echo Tentando executar diretamente...
    "BoodeskApp.exe"
)
echo.
echo Se o Boodesk nao iniciou automaticamente, execute manualmente:
echo cd "{os.path.dirname(os.path.abspath(sys.argv[0]))}"
echo BoodeskApp.exe
pause
exit
"""
            
            # Salvar o script de instalação
            try:
                with open(install_script_path, 'w', encoding='utf-8') as f:
                    f.write(install_script_content)
                print(f"✅ Script de instalação criado: {install_script_path}")
            except Exception as e:
                print(f"❌ Erro ao criar script de instalação: {e}")
                messagebox.showerror("Erro", f"Erro ao criar script de instalação: {e}")
                return
            
            print("✅ Todos os arquivos necessários encontrados")
            
            progress_label.config(text="🚀 Preparando instalação...")
            progress_bar['value'] = 0
            self.root.update_idletasks()
            
            # Confirmar instalação
            result = messagebox.askyesno("Confirmar Instalação", 
                "A instalação irá:\n\n"
                "1. Fazer backup do executável atual\n"
                "2. Substituir pelo novo executável\n"
                "3. Fechar o aplicativo atual\n"
                "4. Abrir a nova versão\n\n"
                "Deseja continuar?")
            
            if not result:
                return
            
            progress_label.config(text="📝 Salvando configurações...")
            progress_bar['value'] = 20
            self.root.update_idletasks()
            
            # Salvar informações da instalação
            try:
                if hasattr(self, 'db') and self.db:
                    user_id = self.get_current_user_id() or 1
                    install_info = {
                        "install_date": datetime.now().isoformat(),
                        "version": "2.4.9",  # Versão atual
                        "source": "cloudflare_r2",
                        "installer_script": installer_script,
                        "new_exe_path": new_exe_path
                    }
                    self.db.save_setting('last_update_install', json.dumps(install_info), user_id)
                    print("✅ Informações da instalação salvas no banco")
            except Exception as save_error:
                print(f"⚠️ Erro ao salvar informações: {save_error}")
            
            progress_label.config(text="🔄 Iniciando processo de instalação...")
            progress_bar['value'] = 50
            self.root.update_idletasks()
            
            # Executar script de instalação
            try:
                import subprocess
                import platform
                
                if platform.system() == "Windows":
                    # Executar script batch
                    subprocess.Popen([installer_script], shell=True)
                    print(f"✅ Script de instalação iniciado: {installer_script}")
                else:
                    # Para outros sistemas, usar comando equivalente
                    subprocess.Popen(["bash", installer_script])
                    print(f"✅ Script de instalação iniciado: {installer_script}")
                
                progress_label.config(text="✅ Instalação iniciada!")
                progress_bar['value'] = 100
                self.root.update_idletasks()
                
                # Mostrar mensagem final
                messagebox.showinfo("Instalação Iniciada", 
                    "O processo de instalação foi iniciado!\n\n"
                    "O aplicativo será fechado automaticamente e a nova versão será aberta.\n\n"
                    "Se algo der errado, o backup será restaurado automaticamente.")
                
                # Aguardar um pouco e fechar o app
                self.root.after(3000, self.root.quit)
                
            except Exception as script_error:
                print(f"❌ Erro ao executar script: {script_error}")
                messagebox.showerror("Erro na Instalação", 
                    f"Erro ao executar script de instalação:\n{script_error}")
                progress_label.config(text="❌ Erro na instalação")
                progress_bar['value'] = 0
            
        except Exception as e:
            error_msg = f"Erro na instalação: {e}"
            print(f"❌ {error_msg}")
            messagebox.showerror("Erro na Instalação", error_msg)
            progress_label.config(text="❌ Erro na instalação")
            progress_bar['value'] = 0
    def show_advanced_update_settings(self, parent_window):
        """Mostra configurações avançadas de atualização"""
        try:
            settings_window = tk.Toplevel(parent_window)
            settings_window.title("Configurações Avançadas - Atualizações")
            settings_window.geometry("500x400")
            settings_window.transient(parent_window)
            settings_window.grab_set()
            
            # Frame principal
            main_frame = ttk.Frame(settings_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # Título
            ttk.Label(main_frame, text="🔧 Configurações Avançadas", 
                     font=('Segoe UI', 14, 'bold')).pack(pady=(0, 20))
            
            # Opções de atualização
            options_frame = ttk.LabelFrame(main_frame, text="Opções de Atualização", padding=15)
            options_frame.pack(fill='x', pady=(0, 20))
            
            # Checkboxes
            auto_check_var = tk.BooleanVar(value=True)
            ttk.Checkbutton(options_frame, text="Verificar atualizações automaticamente", 
                           variable=auto_check_var).pack(anchor='w', pady=2)
            
            backup_var = tk.BooleanVar(value=True)
            ttk.Checkbutton(options_frame, text="Fazer backup antes de atualizar", 
                           variable=backup_var).pack(anchor='w', pady=2)
            
            notifications_var = tk.BooleanVar(value=True)
            ttk.Checkbutton(options_frame, text="Mostrar notificações de atualização", 
                           variable=notifications_var).pack(anchor='w', pady=2)
            
            # Configurações de proxy
            proxy_frame = ttk.LabelFrame(main_frame, text="Configurações de Proxy", padding=15)
            proxy_frame.pack(fill='x', pady=(0, 20))
            
            ttk.Label(proxy_frame, text="Servidor Proxy:").pack(anchor='w')
            proxy_entry = ttk.Entry(proxy_frame, width=40)
            proxy_entry.pack(fill='x', pady=(0, 10))
            
            ttk.Label(proxy_frame, text="Porta:").pack(anchor='w')
            port_entry = ttk.Entry(proxy_frame, width=10)
            port_entry.pack(anchor='w', pady=(0, 10))
            
            # Botões
            button_frame = ttk.Frame(main_frame)
            button_frame.pack(fill='x', pady=(20, 0))
            
            ttk.Button(button_frame, text="Salvar", 
                      command=lambda: self.save_update_settings(settings_window, auto_check_var, 
                                                               backup_var, notifications_var, 
                                                               proxy_entry, port_entry)).pack(side='right', padx=(10, 0))
            ttk.Button(button_frame, text="Cancelar", 
                      command=settings_window.destroy).pack(side='right')
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir configurações: {e}")
    
    def save_update_settings(self, window, auto_check_var, backup_var, notifications_var, proxy_entry, port_entry):
        """Salva as configurações de atualização"""
        try:
            # Aqui você salvaria as configurações no banco de dados
            settings = {
                'auto_check': auto_check_var.get(),
                'backup_before_update': backup_var.get(),
                'show_notifications': notifications_var.get(),
                'proxy_server': proxy_entry.get(),
                'proxy_port': port_entry.get()
            }
            
            # Salvar no banco de dados
            # self.db.save_update_settings(settings)
            
            messagebox.showinfo("Sucesso", "Configurações salvas com sucesso!")
            window.destroy()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar configurações: {e}")
    
    def show_update_history(self, parent_window):
        """Mostra o histórico de atualizações"""
        try:
            history_window = tk.Toplevel(parent_window)
            history_window.title("Histórico de Atualizações")
            history_window.geometry("600x400")
            history_window.transient(parent_window)
            history_window.grab_set()
            
            # Frame principal
            main_frame = ttk.Frame(history_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # Título
            ttk.Label(main_frame, text="📋 Histórico de Atualizações", 
                     font=('Segoe UI', 14, 'bold')).pack(pady=(0, 20))
            
            # Treeview para o histórico
            columns = ('Versão', 'Data', 'Status', 'Tamanho')
            tree = ttk.Treeview(main_frame, columns=columns, show='headings', height=15)
            
            # Configurar colunas
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=120)
            
            # Adicionar dados de exemplo
            tree.insert('', 'end', values=('2.3.1', '26/08/2025', 'Instalada', '15.2 MB'))
            tree.insert('', 'end', values=('2.3.0', '20/08/2025', 'Instalada', '14.8 MB'))
            tree.insert('', 'end', values=('2.2.9', '15/08/2025', 'Instalada', '14.5 MB'))
            tree.insert('', 'end', values=('2.2.8', '10/08/2025', 'Instalada', '14.2 MB'))
            
            tree.pack(fill='both', expand=True, pady=(0, 20))
            
            # Botão fechar
            ttk.Button(main_frame, text="Fechar", command=history_window.destroy).pack()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir histórico: {e}")


class NotesEditor:
    """Editor de anotações para cards"""
    
    def __init__(self, parent, db, card_id, current_user):
        self.parent = parent
        self.db = db
        self.card_id = card_id
        self.current_user = current_user
        self.current_note_id = None
        self.is_fullscreen = False
        self.original_geometry = None
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title(f"Editor de Anotações - Card {card_id}")
        self.window.geometry("900x700")
        self.window.resizable(True, True)
        
        # Configurar grid
        self.window.grid_rowconfigure(1, weight=1)
        self.window.grid_columnconfigure(0, weight=1)
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        self.load_notes()
        
        # Centralizar janela
        self.window.transient(parent)
        self.window.grab_set()
        self.center_window()
        
        # Configurar atalhos de teclado
        self.setup_shortcuts()
    
    def create_widgets(self):
        """Cria os widgets da interface"""
        # Frame superior para controles
        top_frame = ttk.Frame(self.window)
        top_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=5)
        
        # Título
        ttk.Label(top_frame, text="Editor de Anotações", font=("Arial", 14, "bold")).pack(side=tk.LEFT)
        
        # Botões de ação
        button_frame = ttk.Frame(top_frame)
        button_frame.pack(side=tk.RIGHT)
        
        ttk.Button(button_frame, text="Nova Anotação", command=self.new_note).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="Salvar", command=self.save_note).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="Excluir", command=self.delete_note).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="Exportar PDF", command=self.export_pdf).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="🖥️ Tela Cheia", command=self.toggle_fullscreen).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="❌ Sair", command=self.close_editor).pack(side=tk.LEFT, padx=2)
        
        # Frame principal
        main_frame = ttk.Frame(self.window)
        main_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=5)
        main_frame.grid_rowconfigure(0, weight=1)
        main_frame.grid_columnconfigure(1, weight=1)
        
        # Lista de anotações (esquerda)
        notes_frame = ttk.LabelFrame(main_frame, text="Anotações", padding="5")
        notes_frame.grid(row=0, column=0, sticky="ns", padx=(0, 5))
        
        self.notes_listbox = tk.Listbox(notes_frame, width=30, height=20)
        self.notes_listbox.pack(fill=tk.BOTH, expand=True)
        self.notes_listbox.bind("<<ListboxSelect>>", self.on_note_select)
        
        # Frame do editor (direita)
        editor_frame = ttk.LabelFrame(main_frame, text="Editor", padding="5")
        editor_frame.grid(row=0, column=1, sticky="nsew")
        editor_frame.grid_rowconfigure(2, weight=1)
        editor_frame.grid_columnconfigure(1, weight=1)
        
        # Título da anotação
        ttk.Label(editor_frame, text="Título:").grid(row=0, column=0, sticky="w", pady=(0, 5))
        self.title_entry = ttk.Entry(editor_frame)
        self.title_entry.grid(row=0, column=1, sticky="ew", pady=(0, 5))
        
        # Editor avançado de texto
        try:
            from advanced_text_editor import AdvancedTextEditor
            
            # Criar editor avançado
            self.advanced_editor = AdvancedTextEditor(editor_frame, height=15, width=50)
            self.advanced_editor.grid(row=2, column=0, columnspan=2, sticky="nsew")
            self.text_widget = self.advanced_editor.text_widget
            
            # Configurar tags adicionais específicas para anotações
            self.text_widget.tag_configure("bullet", lmargin1=20, lmargin2=20)
            self.text_widget.tag_configure("number", lmargin1=20, lmargin2=20)
            self.text_widget.tag_configure("checkbox", lmargin1=20, lmargin2=20)
            
            # Configurar eventos para atualização automática
            self.text_widget.bind("<KeyRelease>", self.on_text_change)
            self.text_widget.bind("<ButtonRelease-1>", self.on_text_change)
            
            # Atualizar recursos periodicamente
            self.schedule_update()
            
        except ImportError:
            # Fallback para editor básico se o avançado não estiver disponível
            # Barra de formatação
            format_frame = ttk.Frame(editor_frame)
            format_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(0, 5))
            
            # Botões de formatação (usando tk.Button em vez de ttk.Button para suportar font)
            tk.Button(format_frame, text="B", font=("Arial", 10, "bold"), width=3, 
                      command=lambda: self.apply_format("bold")).pack(side=tk.LEFT, padx=2)
            tk.Button(format_frame, text="I", font=("Arial", 10, "italic"), width=3,
                      command=lambda: self.apply_format("italic")).pack(side=tk.LEFT, padx=2)
            tk.Button(format_frame, text="U", font=("Arial", 10, "underline"), width=3,
                      command=lambda: self.apply_format("underline")).pack(side=tk.LEFT, padx=2)
            tk.Button(format_frame, text="•", width=3,
                      command=self.insert_bullet).pack(side=tk.LEFT, padx=2)
            tk.Button(format_frame, text="1.", width=3,
                      command=self.insert_number).pack(side=tk.LEFT, padx=2)
            tk.Button(format_frame, text="☐", width=3,
                      command=self.insert_checkbox).pack(side=tk.LEFT, padx=2)
            
            # Área de texto
            text_frame = ttk.Frame(editor_frame)
            text_frame.grid(row=2, column=0, columnspan=2, sticky="nsew")
            text_frame.grid_rowconfigure(0, weight=1)
            text_frame.grid_columnconfigure(0, weight=1)
            
            self.text_widget = tk.Text(text_frame, wrap=tk.WORD, undo=True)
            self.text_widget.grid(row=0, column=0, sticky="nsew")
            
            # Scrollbar
            scrollbar = ttk.Scrollbar(text_frame, orient="vertical", command=self.text_widget.yview)
            scrollbar.grid(row=0, column=1, sticky="ns")
            self.text_widget.configure(yscrollcommand=scrollbar.set)
            
            # Configurar tags para formatação
            self.text_widget.tag_configure("bold", font=("Arial", 10, "bold"))
            self.text_widget.tag_configure("italic", font=("Arial", 10, "italic"))
            self.text_widget.tag_configure("underline", underline=True)
            self.text_widget.tag_configure("bullet", lmargin1=20, lmargin2=20)
            self.text_widget.tag_configure("number", lmargin1=20, lmargin2=20)
            self.text_widget.tag_configure("checkbox", lmargin1=20, lmargin2=20)
        
        # Status bar
        status_frame = ttk.Frame(self.window)
        status_frame.grid(row=2, column=0, sticky="ew", padx=10, pady=5)
        
        self.status_label = ttk.Label(status_frame, text="Pronto")
        self.status_label.pack(side=tk.LEFT)
        
        # Contador de caracteres
        self.char_count_label = ttk.Label(status_frame, text="0 caracteres")
        self.char_count_label.pack(side=tk.RIGHT)
        
        # Bind para contador de caracteres
        self.text_widget.bind("<KeyRelease>", self.update_char_count)
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def load_notes(self):
        """Carrega as anotações do card"""
        self.notes_listbox.delete(0, tk.END)
        self.notes = []
        
        if self.current_user:
            user_id = getattr(self.current_user, 'id', None) or getattr(self.current_user, 'user_id', None)
            notes = self.db.get_card_notes(self.card_id, user_id)
        else:
            notes = self.db.get_card_notes(self.card_id)
        
        for note in notes:
            self.notes.append(note)
            self.notes_listbox.insert(tk.END, note['title'])
        
        if notes:
            self.notes_listbox.selection_set(0)
            self.on_note_select(None)
    
    def on_note_select(self, event):
        """Chamado quando uma anotação é selecionada"""
        selection = self.notes_listbox.curselection()
        if not selection:
            return
        
        note_index = selection[0]
        note = self.notes[note_index]
        
        self.current_note_id = note['id']
        self.title_entry.delete(0, tk.END)
        self.title_entry.insert(0, note['title'])
        
        self.text_widget.delete(1.0, tk.END)
        self.text_widget.insert(1.0, note['content'])
        
        self.update_char_count()
        self.status_label.config(text=f"Carregado: {note['title']}")
        
        # Atualizar recursos de formatação
        self.update_formatting_resources()
    
    def new_note(self):
        """Cria uma nova anotação"""
        self.current_note_id = None
        self.title_entry.delete(0, tk.END)
        self.title_entry.insert(0, "Nova Anotação")
        self.text_widget.delete(1.0, tk.END)
        self.notes_listbox.selection_clear(0, tk.END)
        self.status_label.config(text="Nova anotação")
        self.update_char_count()
    
    def save_note(self):
        """Salva a anotação atual"""
        title = self.title_entry.get().strip()
        content = self.text_widget.get(1.0, tk.END).strip()
        
        if not title:
            messagebox.showwarning("Aviso", "Digite um título para a anotação.")
            return
        
        if not self.current_user:
            messagebox.showerror("Erro", "Usuário não identificado.")
            return
        
        user_id = getattr(self.current_user, 'id', None) or getattr(self.current_user, 'user_id', None)
        
        if self.current_note_id:
            # Atualizar anotação existente
            success = self.db.update_card_note(self.current_note_id, title, content)
            if success:
                self.status_label.config(text=f"Anotação atualizada: {title}")
                self.load_notes()
            else:
                messagebox.showerror("Erro", "Erro ao atualizar anotação.")
        else:
            # Criar nova anotação
            note_id = self.db.create_card_note(self.card_id, user_id, title, content)
            if note_id:
                self.status_label.config(text=f"Anotação criada: {title}")
                self.load_notes()
            else:
                messagebox.showerror("Erro", "Erro ao criar anotação.")
    
    def delete_note(self):
        """Exclui a anotação atual"""
        if not self.current_note_id:
            messagebox.showwarning("Aviso", "Selecione uma anotação para excluir.")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir esta anotação?"):
            success = self.db.delete_card_note(self.current_note_id)
            if success:
                self.status_label.config(text="Anotação excluída")
                self.load_notes()
                self.new_note()
            else:
                messagebox.showerror("Erro", "Erro ao excluir anotação.")
    
    def apply_format(self, format_type):
        """Aplica formatação ao texto selecionado"""
        try:
            selection = self.text_widget.tag_ranges(tk.SEL)
            if not selection:
                return
            
            start, end = selection
            
            if format_type == "bold":
                self.text_widget.tag_add("bold", start, end)
            elif format_type == "italic":
                self.text_widget.tag_add("italic", start, end)
            elif format_type == "underline":
                self.text_widget.tag_add("underline", start, end)
        except tk.TclError:
            pass  # Nenhuma seleção
    
    def insert_bullet(self):
        """Insere um ponto de tópico"""
        current_pos = self.text_widget.index(tk.INSERT)
        self.text_widget.insert(current_pos, "• ")
        self.text_widget.tag_add("bullet", current_pos, f"{current_pos}+2c")
    
    def insert_number(self):
        """Insere numeração"""
        current_pos = self.text_widget.index(tk.INSERT)
        self.text_widget.insert(current_pos, "1. ")
        self.text_widget.tag_add("number", current_pos, f"{current_pos}+3c")
    
    def insert_checkbox(self):
        """Insere checkbox"""
        current_pos = self.text_widget.index(tk.INSERT)
        self.text_widget.insert(current_pos, "☐ ")
        self.text_widget.tag_add("checkbox", current_pos, f"{current_pos}+2c")
    
    def update_char_count(self, event=None):
        """Atualiza o contador de caracteres"""
        content = self.text_widget.get(1.0, tk.END)
        char_count = len(content) - 1  # -1 para remover o caractere de nova linha final
        self.char_count_label.config(text=f"{char_count} caracteres")
    
    def export_pdf(self):
        """Exporta a anotação atual para PDF"""
        if not self.current_note_id:
            messagebox.showwarning("Aviso", "Selecione uma anotação para exportar.")
            return
        
        try:
            from reportlab.lib.pagesizes import letter
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            from reportlab.lib.enums import TA_LEFT, TA_CENTER
            import os
            
            # Obter dados da anotação
            note = self.db.get_note_by_id(self.current_note_id)
            if not note:
                messagebox.showerror("Erro", "Anotação não encontrada.")
                return
            
            # Solicitar local para salvar
            import tkinter.filedialog as filedialog
            filename = filedialog.asksaveasfilename(
                defaultextension=".pdf",
                filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")],
                title="Salvar anotação como PDF"
            )
            
            if not filename:
                return
            
            # Criar documento PDF
            doc = SimpleDocTemplate(filename, pagesize=letter)
            story = []
            
            # Estilos
            styles = getSampleStyleSheet()
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=16,
                spaceAfter=30,
                alignment=TA_CENTER
            )
            
            content_style = ParagraphStyle(
                'CustomContent',
                parent=styles['Normal'],
                fontSize=12,
                spaceAfter=12,
                alignment=TA_LEFT
            )
            
            # Título
            story.append(Paragraph(note['title'], title_style))
            story.append(Spacer(1, 20))
            
            # Conteúdo (processar formatação básica)
            content_lines = note['content'].split('\n')
            for line in content_lines:
                if line.strip():
                    # Processar formatação básica
                    processed_line = line.replace('•', '•').replace('☐', '☐')
                    story.append(Paragraph(processed_line, content_style))
                else:
                    story.append(Spacer(1, 6))
            
            # Gerar PDF
            doc.build(story)
            
            self.status_label.config(text=f"PDF exportado: {os.path.basename(filename)}")
            messagebox.showinfo("Sucesso", f"PDF exportado com sucesso!\n{filename}")
            
        except ImportError:
            messagebox.showerror("Erro", "Biblioteca reportlab não encontrada. Instale com: pip install reportlab")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar PDF: {str(e)}")
    
    def toggle_fullscreen(self):
        """Alterna entre tela cheia e normal"""
        if not self.is_fullscreen:
            # Salvar geometria atual
            self.original_geometry = self.window.geometry()
            # Ir para tela cheia
            self.window.state('zoomed')  # Windows
            self.is_fullscreen = True
        else:
            # Restaurar geometria original
            if self.original_geometry:
                self.window.geometry(self.original_geometry)
            else:
                self.window.geometry("900x700")
            self.window.state('normal')
            self.is_fullscreen = False
    
    def close_editor(self):
        """Fecha o editor de anotações"""
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja sair? As alterações não salvas serão perdidas."):
            self.window.destroy()
    
    def update_formatting_resources(self):
        """Atualiza os recursos de formatação do editor avançado"""
        if hasattr(self, 'advanced_editor'):
            # Atualizar fontes e tamanhos no editor avançado
            self.advanced_editor.update_status()
            
            # Forçar atualização da interface
            self.advanced_editor.text_widget.update_idletasks()
            
            # Atualizar contador de caracteres
            self.update_char_count()
    
    def on_text_change(self, event=None):
        """Chamado quando o texto é alterado"""
        # Atualizar contador de caracteres
        self.update_char_count()
        
        # Atualizar recursos de formatação se necessário
        if hasattr(self, 'advanced_editor'):
            self.advanced_editor.update_status()
    
    def schedule_update(self):
        """Agenda atualizações periódicas dos recursos"""
        try:
            if hasattr(self, 'advanced_editor'):
                self.advanced_editor.update_status()
            self.update_char_count()
            
            # Agendar próxima atualização em 1 segundo
            self.window.after(1000, self.schedule_update)
        except:
            pass  # Janela pode ter sido fechada
    
    def setup_shortcuts(self):
        """Configura atalhos de teclado"""
        self.window.bind("<F11>", lambda e: self.toggle_fullscreen())
        self.window.bind("<Escape>", lambda e: self.close_editor())
        self.window.bind("<Control-s>", lambda e: self.save_note())
        self.window.bind("<Control-n>", lambda e: self.new_note())
        self.window.bind("<Control-d>", lambda e: self.delete_note())
        self.window.bind("<Control-e>", lambda e: self.export_pdf())

class SubjectManagerWindow(tk.Toplevel):
    def __init__(self, parent, app, subject_type):
        super().__init__(parent)
        self.app = app
        self.subject_type = subject_type
        
        if self.subject_type == 'pomodoro':
            self.title("Gerenciar Assuntos do Pomodoro")
            self.subjects_df = self.app.pomodoro_subjects_df
            self.subjects_list = self.app.pomodoro_subjects
            self.file_path = self.app.pomodoro_subjects_file
        else: # boodesk
            self.title("Gerenciar Assuntos do Boodesk")
            self.subjects_df = self.app.boodesk_subjects_df
            self.subjects_list = self.app.boodesk_subjects
            self.file_path = self.app.boodesk_subjects_file

        self.geometry("450x350")
        self.transient(parent)
        self.grab_set()

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        self._populate_subjects_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Listbox Frame
        list_frame = ttk.LabelFrame(main_frame, text="Assuntos Cadastrados")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        self.subjects_listbox = tk.Listbox(list_frame, selectmode=tk.SINGLE)
        self.subjects_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.subjects_listbox.bind("<<ListboxSelect>>", self._on_subject_select)
        
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.subjects_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.subjects_listbox.config(yscrollcommand=scrollbar.set)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Assunto")
        entry_frame.pack(fill=tk.X, pady=5)
        entry_frame.columnconfigure(0, weight=1)

        self.subject_entry = ttk.Entry(entry_frame)
        self.subject_entry.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        
        self.add_edit_button = ttk.Button(entry_frame, text="Adicionar", command=self._add_subject)
        self.add_edit_button.grid(row=0, column=1, padx=5, pady=5)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Remover Selecionado", command=self._remove_subject).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", command=self.destroy).pack(side=tk.RIGHT, padx=5)

    def _populate_subjects_list(self):
        self.subjects_listbox.delete(0, tk.END)
        # Sort the list for better UX
        for subject in sorted(self.subjects_list):
            if subject != '-': # Don't show the default '-'
                self.subjects_listbox.insert(tk.END, subject)

    def _on_subject_select(self, event):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            self.subject_entry.delete(0, tk.END)
            self.add_edit_button.config(text="Adicionar", command=self._add_subject)
            return
        
        selected_subject = self.subjects_listbox.get(selected_indices[0])
        self.subject_entry.delete(0, tk.END)
        self.subject_entry.insert(0, selected_subject)
        self.add_edit_button.config(text="Salvar Edição", command=self._edit_subject)

    def _clear_selection(self):
        self.subjects_listbox.selection_clear(0, tk.END)
        self.subject_entry.delete(0, tk.END)
        self.add_edit_button.config(text="Adicionar", command=self._add_subject)
        # Manually trigger the event handler to reset the button state
        self._on_subject_select(None)


    def _add_subject(self):
        new_subject = self.subject_entry.get().strip()
        if not new_subject:
            messagebox.showwarning("Entrada Inválida", "O nome do assunto não pode estar vazio.", parent=self)
            return
        
        if new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' já existe.", parent=self)
            return

        # Update DataFrame and list
        new_subject_df = pd.DataFrame({'Assunto': [new_subject]})
        self.subjects_df = pd.concat([self.subjects_df, new_subject_df], ignore_index=True)
        self.subjects_list.append(new_subject)
        
        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{new_subject}' adicionado.", parent=self)

    def _edit_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um assunto para editar.", parent=self)
            return
            
        old_subject = self.subjects_listbox.get(selected_indices[0])
        new_subject = self.subject_entry.get().strip()

        if not new_subject:
            messagebox.showwarning("Entrada Inválida", "O nome do assunto não pode estar vazio.", parent=self)
            return

        if new_subject != old_subject and new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' já existe.", parent=self)
            return

        # Update DataFrame and list
        self.subjects_df.loc[self.subjects_df['Assunto'] == old_subject, 'Assunto'] = new_subject
        self.subjects_list[self.subjects_list.index(old_subject)] = new_subject

        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{old_subject}' atualizado para '{new_subject}'.", parent=self)

    def _remove_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um assunto para remover.", parent=self)
            return

        subject_to_remove = self.subjects_listbox.get(selected_indices[0])
        
        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover o assunto '{subject_to_remove}'?\nIsso não pode ser desfeito e não alterará os cartões existentes.", parent=self):
            # Update DataFrame and list
            self.subjects_df = self.subjects_df[self.subjects_df['Assunto'] != subject_to_remove]
            self.subjects_list.remove(subject_to_remove)
            
            # Save and refresh
            self._save_and_refresh()
            self._clear_selection()
            messagebox.showinfo("Sucesso", f"Assunto '{subject_to_remove}' removido.", parent=self)

    def _save_and_refresh(self):
        # Save the DataFrame to the Excel file
        self.subjects_df.to_excel(self.file_path, index=False)
        
        # Update the main app's data
        if self.subject_type == 'pomodoro':
            self.app.pomodoro_subjects_df = self.subjects_df
            self.app.pomodoro_subjects = self.subjects_list
        else: # boodesk
            self.app.boodesk_subjects_df = self.subjects_df
            self.app.boodesk_subjects = self.subjects_list
            
        # Reload all auxiliary data in the main app to update all UI components
        self.app.load_aux_data()
        self.app.update_all_displays() # A comprehensive update
        
        # Refresh the listbox in this window
        self._populate_subjects_list()

    def destroy(self):
        # Ensure the main app window gets focus back
        self.app.root.focus_set()
        super().destroy()

class ArchivedCardsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Cartões Arquivados")
        self.geometry("600x400")
        self.transient(parent)
        self.grab_set()

        if self.app.settings.get('open_on_current_screen', False):
            self.update_idletasks()
            parent_x = parent.winfo_x()
            parent_y = parent.winfo_y()
            parent_width = parent.winfo_width()
            parent_height = parent.winfo_height()

            x = parent_x + (parent_width // 2) - (self.winfo_width() // 2)
            y = parent_y + (parent_height // 2) - (self.winfo_height() // 2)
            self.geometry(f"+{x}+{y}")

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        self._populate_archived_cards_listbox()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Cartões Arquivados:").pack(anchor="w", pady=5)

        self.archived_listbox = tk.Listbox(main_frame, selectmode=tk.SINGLE)
        self.archived_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        self.archived_listbox.bind("<Double-1>", self._restore_card_from_double_click)

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=5)

        ttk.Button(button_frame, text="Restaurar Cartão", command=self._restore_card).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Excluir Permanentemente", command=self._delete_card_permanently).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", command=self.destroy).pack(side=tk.LEFT, padx=5)

    def _populate_archived_cards_listbox(self):
        self.archived_listbox.delete(0, tk.END)
        self.archived_cards_data = [] # Store references to actual card objects

        for board_name, lists in self.app.trello_data["boards"].items():
            for list_name, cards in lists.items():
                for card in cards:
                    if card.get("is_archived", False):
                        display_text = f"{board_name} > {list_name} > {card['title']}"
                        self.archived_listbox.insert(tk.END, display_text)
                        self.archived_cards_data.append({"board": board_name, "list": list_name, "card": card})

    def _restore_card_from_double_click(self, event):
        self._restore_card()

    def _restore_card(self):
        selected_index = self.archived_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um cartão para restaurar.")
            return

        card_info = self.archived_cards_data[selected_index[0]]
        card = card_info["card"]
        board_name = card_info["board"]
        list_name = card_info["list"] # This is the original list name

        if messagebox.askyesno("Confirmar Restauração", f"Tem certeza que deseja restaurar o cartão '{card['title']}' para o quadro '{board_name}' na lista '{list_name}'?"):
            card["is_archived"] = False

            # Remove the card from its current list (where it was archived)
            # We need to find the card by its card_id and remove it from the list it's currently in.
            # This assumes the card is still in the list it was in when it was archived.
            found_and_removed = False
            if board_name in self.app.trello_data["boards"] and list_name in self.app.trello_data["boards"][board_name]:
                original_list = self.app.trello_data["boards"][board_name][list_name]
                for i, c in enumerate(original_list):
                    if c.get("card_id") == card.get("card_id"):
                        original_list.pop(i)
                        found_and_removed = True
                        break
            
            if not found_and_removed:
                messagebox.showerror("Erro de Restauração", "Não foi possível encontrar o cartão em sua lista original para remoção.")
                return

            # Add the card to the target list
            target_list_name = list_name # Default to original list
            if list_name not in self.app.trello_data["boards"][board_name]:
                # Fallback to "A Fazer" if original list was deleted
                if "A Fazer" in self.app.trello_data["boards"][board_name]:
                    target_list_name = "A Fazer"
                    messagebox.showinfo("Restauração", f"Lista original '{list_name}' não encontrada. Cartão restaurado para 'A Fazer'.")
                else:
                    messagebox.showerror("Erro de Restauração", "Não foi possível restaurar o cartão. A lista original e 'A Fazer' não existem.")
                    return
            
            self.app.trello_data["boards"][board_name][target_list_name].append(card)
            
            self.app.save_trello_data()
            self.app.populate_boards() # Refresh main board view
            self._populate_archived_cards_listbox() # Refresh archived list
            messagebox.showinfo("Sucesso", f"Cartão '{card['title']}' restaurado com sucesso!")

    def _delete_card_permanently(self):
        selected_index = self.archived_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um cartão para excluir permanentemente.")
            return

        card_info = self.archived_cards_data[selected_index[0]]
        card = card_info["card"]
        board_name = card_info["board"]
        list_name = card_info["list"]

        if messagebox.askyesno("Confirmar Exclusão Permanente", f"Tem certeza que deseja EXCLUIR PERMANENTEMENTE o cartão '{card['title']}'? Esta ação não pode ser desfeita."):
            # Find the card in the actual data structure and remove it
            if board_name in self.app.trello_data["boards"] and list_name in self.app.trello_data["boards"][board_name]:
                # Filter out the card by its unique card_id
                self.app.trello_data["boards"][board_name][list_name] = [
                    c for c in self.app.trello_data["boards"][board_name][list_name] if c.get("card_id") != card.get("card_id")
                ]
                self.app.save_trello_data()
                self.app.populate_boards() # Refresh main board view
                self._populate_archived_cards_listbox() # Refresh archived list
                messagebox.showinfo("Sucesso", f"Cartão '{card['title']}' excluído permanentemente.")
            else:
                messagebox.showerror("Erro", "Não foi possível encontrar o cartão na estrutura de dados para exclusão.")


class CardImportanceWindow:
    def __init__(self, parent, app, board_name, list_name, card_title, callback):
        self.parent = parent
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self.card_title = card_title
        self.callback = callback
        self.selected_importance = "Normal"
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title("Selecionar Importância")
        self.window.geometry("500x400")
        self.window.resizable(False, False)
        self.window.transient(parent)
        self.window.grab_set()
        
        # Centralizar na tela
        self.window.update_idletasks()
        x = (self.window.winfo_screenwidth() // 2) - (500 // 2)
        y = (self.window.winfo_screenheight() // 2) - (400 // 2)
        self.window.geometry(f"500x400+{x}+{y}")
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        
    def create_widgets(self):
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_label = ttk.Label(main_frame, text="Selecionar Importância do Card", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Card title
        card_title_label = ttk.Label(main_frame, text=f"Título: {self.card_title}", 
                                    font=("Arial", 10))
        card_title_label.pack(pady=(0, 20))
        
        # Frame para os botões de importância
        importance_frame = ttk.Frame(main_frame)
        importance_frame.pack(pady=20)
        
        # Obter configurações de importância das configurações do app
        importance_colors = self.app.settings.get("importance_colors", {
            "Crítica": "#FFCCCC",
            "Alta": "#FFE5CC", 
            "Normal": "#FFFFCC",
            "Baixa": "#CCFFCC"
        })
        
        # Debug: imprimir as importâncias disponíveis
        print(f"DEBUG: Importâncias disponíveis: {list(importance_colors.keys())}")
        
        self.importance_var = tk.StringVar(value="Normal")
        self.importance_buttons = {}  # Para armazenar referências dos botões
        
        # Criar botões coloridos para cada nível de importância
        # Organizar em uma coluna vertical com ordem específica
        importance_order = ["Crítica", "Alta", "Normal", "Baixa"]
        
        for importance in importance_order:
            if importance in importance_colors:
                color = importance_colors[importance]
                print(f"DEBUG: Criando botão para {importance} com cor {color}")
                # Botão colorido (mais fino)
                importance_btn = tk.Button(importance_frame, 
                                         text=importance,
                                         font=("Arial", 14, "bold"),
                                         bg=color,
                                         fg="black",
                                         relief=tk.RAISED,
                                         borderwidth=1,
                                         width=25,
                                         height=1,
                                         command=lambda imp=importance: self.on_importance_selected(imp))
                importance_btn.pack(fill=tk.X, padx=30, pady=3)
                
                # Armazenar referência do botão
                self.importance_buttons[importance] = importance_btn
            else:
                print(f"DEBUG: Importância {importance} não encontrada nas configurações")
        
        # Frame para botão Cancelar (opcional)
        action_frame = ttk.Frame(main_frame)
        action_frame.pack(pady=20)
        
        # Botão Cancelar (opcional, caso o usuário queira cancelar)
        cancel_btn = ttk.Button(action_frame, text="Cancelar", 
                               command=self.cancel)
        cancel_btn.pack(side=tk.RIGHT)
        
    def on_importance_selected(self, importance):
        self.selected_importance = importance
        self.importance_var.set(importance)
        
        # Atualizar aparência dos botões (destacar o selecionado)
        for imp, btn in self.importance_buttons.items():
            if imp == importance:
                # Botão selecionado - borda mais grossa
                btn.config(relief=tk.SUNKEN, borderwidth=3)
            else:
                # Botão não selecionado - borda normal
                btn.config(relief=tk.RAISED, borderwidth=2)
        
        # Aguardar um momento para mostrar a seleção e depois avançar
        self.window.after(500, self.continue_to_description)
        
    def continue_to_description(self):
        self.window.destroy()
        # Abrir tela de descrição
        CardDescriptionWindow(self.parent, self.app, self.board_name, 
                            self.list_name, self.card_title, 
                            self.selected_importance, self.callback)
        
    def cancel(self):
        self.window.destroy()


class CardDescriptionWindow:
    def __init__(self, parent, app, board_name, list_name, card_title, 
                 importance, callback, initial_description=""):
        self.parent = parent
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self.card_title = card_title
        self.importance = importance
        self.callback = callback
        self.description = initial_description
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title("Descrição do Card")
        self.window.geometry("500x400")
        self.window.resizable(False, False)
        self.window.transient(parent)
        self.window.grab_set()
        
        # Centralizar na tela
        self.window.update_idletasks()
        x = (self.window.winfo_screenwidth() // 2) - (500 // 2)
        y = (self.window.winfo_screenheight() // 2) - (400 // 2)
        self.window.geometry(f"500x400+{x}+{y}")
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        
    def create_widgets(self):
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_label = ttk.Label(main_frame, text="Descrição do Card", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 10))
        
        # Informações do card
        info_frame = ttk.Frame(main_frame)
        info_frame.pack(fill=tk.X, pady=(0, 20))
        
        # Título do card
        card_title_label = ttk.Label(info_frame, text=f"Título: {self.card_title}", 
                                    font=("Arial", 10))
        card_title_label.pack(anchor=tk.W)
        
        # Importância
        importance_colors = self.app.settings.get("importance_colors", {
            "Crítica": "#FFCCCC",
            "Alta": "#FFE5CC", 
            "Normal": "#FFFFCC",
            "Baixa": "#CCFFCC"
        })
        
        importance_frame = ttk.Frame(info_frame)
        importance_frame.pack(anchor=tk.W, pady=(5, 0))
        
        importance_label = ttk.Label(importance_frame, text="Importância: ")
        importance_label.pack(side=tk.LEFT)
        
        color_label = tk.Label(importance_frame, text=f" {self.importance} ", 
                              bg=importance_colors.get(self.importance, "#FFFFCC"),
                              relief=tk.SOLID, borderwidth=1,
                              font=("Arial", 10, "bold"))
        color_label.pack(side=tk.LEFT)
        
        # Frame para descrição
        desc_frame = ttk.LabelFrame(main_frame, text="Descrição (opcional)", padding="10")
        desc_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Frame interno para text e scrollbar
        text_frame = ttk.Frame(desc_frame)
        text_frame.pack(fill=tk.BOTH, expand=True)
        
        # Text area para descrição
        self.desc_text = tk.Text(text_frame, height=8, wrap=tk.WORD, 
                                font=("Arial", 10))
        self.desc_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Carregar descrição inicial se existir
        if self.description:
            self.desc_text.insert("1.0", self.description)
        
        # Scrollbar para o text area
        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, 
                                 command=self.desc_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.desc_text.configure(yscrollcommand=scrollbar.set)
        
        # === BOTTOM ACTION BUTTONS (FIXED AT BOTTOM) ===
        button_frame = ttk.LabelFrame(main_frame, text="Ações", padding="10")
        button_frame.pack(fill=tk.X, side=tk.BOTTOM, pady=(10, 0))
        
        # Create buttons using pack layout
        send_btn = ttk.Button(button_frame, text="Enviar", 
                            command=self.save_card)
        send_btn.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
        
        cancel_btn = ttk.Button(button_frame, text="Cancelar", 
                              command=self.cancel)
        cancel_btn.pack(side=tk.RIGHT, fill=tk.X, expand=True)
        
    def save_card(self):
        # Obter descrição
        self.description = self.desc_text.get("1.0", tk.END).strip()
        
        # Fechar janela
        self.window.destroy()
        
        # Chamar callback com os dados do card
        self.callback(self.card_title, self.importance, self.description)
        
    def cancel(self):
        self.window.destroy()


class SubTaskDetailWindow:
    """Janela para gerenciar detalhes de uma subtarefa específica"""
    
    def __init__(self, app, card, subtask, parent=None):
        self.app = app
        self.card = card
        self.subtask = subtask
        self.parent = parent
        self.current_user = app.current_user
        
        # Criar janela
        self.window = tk.Toplevel(app.root)
        self.window.title(f"Detalhes da Subtarefa: {subtask.get('title', '')}")
        self.window.geometry("800x700")
        self.window.resizable(True, True)
        self.window.transient(app.root)
        self.window.grab_set()
        
        # Centralizar janela
        self.window.update_idletasks()
        x = (self.window.winfo_screenwidth() // 2) - (800 // 2)
        y = (self.window.winfo_screenheight() // 2) - (700 // 2)
        self.window.geometry(f"800x700+{x}+{y}")
        
        # Criar interface
        self._create_widgets()
        self._load_subtask_data()
    
    def _create_widgets(self):
        """Cria os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(title_frame, text="📋 Detalhes da Subtarefa", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        # Status da subtarefa
        self.status_var = tk.StringVar()
        status_combo = ttk.Combobox(title_frame, textvariable=self.status_var,
                                   values=["Pendente", "Em Progresso", "Concluída", "Cancelada"],
                                   state="readonly", width=15)
        status_combo.pack(side=tk.RIGHT, padx=10)
        status_combo.bind("<<ComboboxSelected>>", self._update_subtask_status)
        
        # Notebook para organizar as seções
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Aba de Informações Gerais
        self._create_general_tab()
        
        # Aba de Descrição
        self._create_description_tab()
        
        # Aba de Arquivos
        self._create_files_tab()
        
        # Aba de Comentários
        self._create_comments_tab()
        
        # Aba de Histórico
        self._create_history_tab()
        
        # Botões de ação
        self._create_action_buttons(main_frame)
    
    def _create_general_tab(self):
        """Cria aba de informações gerais"""
        general_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(general_frame, text="Informações Gerais")
        
        # Informações da subtarefa
        info_frame = ttk.LabelFrame(general_frame, text="Informações da Subtarefa", padding="10")
        info_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Título
        ttk.Label(info_frame, text="Título:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        self.title_entry = ttk.Entry(info_frame, width=50)
        self.title_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        
        # Card pai
        ttk.Label(info_frame, text="Card Pai:").grid(row=1, column=0, sticky="w", padx=5, pady=5)
        card_label = ttk.Label(info_frame, text=self.card.get('title', ''), font=("Arial", 10, "bold"))
        card_label.grid(row=1, column=1, sticky="w", padx=5, pady=5)
        
        # Responsável
        ttk.Label(info_frame, text="Responsável:").grid(row=2, column=0, sticky="w", padx=5, pady=5)
        
        # Buscar membros do banco de dados
        try:
            members = self.app.db.get_members()
            member_options = [member['Membro'] for member in members] if members else []
        except:
            member_options = []
        
        self.responsible_combo = ttk.Combobox(info_frame, values=member_options, state="readonly", width=30)
        self.responsible_combo.grid(row=2, column=1, sticky="w", padx=5, pady=5)
        self.responsible_combo.bind("<<ComboboxSelected>>", self._update_responsible)
        
        # Prioridade
        ttk.Label(info_frame, text="Prioridade:").grid(row=3, column=0, sticky="w", padx=5, pady=5)
        self.priority_var = tk.StringVar()
        priority_combo = ttk.Combobox(info_frame, textvariable=self.priority_var,
                                    values=["Baixa", "Normal", "Alta", "Crítica"], state="readonly", width=15)
        priority_combo.grid(row=3, column=1, sticky="w", padx=5, pady=5)
        priority_combo.bind("<<ComboboxSelected>>", self._update_priority)
        
        # Data de criação
        ttk.Label(info_frame, text="Criada em:").grid(row=4, column=0, sticky="w", padx=5, pady=5)
        created_label = ttk.Label(info_frame, text=self.subtask.get('created_at', ''))
        created_label.grid(row=4, column=1, sticky="w", padx=5, pady=5)
        
        # Data de conclusão
        ttk.Label(info_frame, text="Concluída em:").grid(row=5, column=0, sticky="w", padx=5, pady=5)
        completed_label = ttk.Label(info_frame, text=self.subtask.get('completed_at', 'Não concluída'))
        completed_label.grid(row=5, column=1, sticky="w", padx=5, pady=5)
        
        # Configurar grid
        info_frame.columnconfigure(1, weight=1)
    
    def _create_description_tab(self):
        """Cria aba de descrição"""
        desc_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(desc_frame, text="Descrição")
        
        # Descrição da subtarefa
        desc_label_frame = ttk.LabelFrame(desc_frame, text="Descrição Detalhada", padding="10")
        desc_label_frame.pack(fill=tk.BOTH, expand=True)
        
        # Text widget para descrição
        self.description_text = tk.Text(desc_label_frame, height=15, wrap=tk.WORD)
        self.description_text.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Scrollbar para o text widget
        desc_scrollbar = ttk.Scrollbar(desc_label_frame, orient="vertical", command=self.description_text.yview)
        desc_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.description_text.config(yscrollcommand=desc_scrollbar.set)
        
        # Botão para salvar descrição
        save_desc_btn = ttk.Button(desc_label_frame, text="Salvar Descrição", 
                                  command=self._save_description)
        save_desc_btn.pack(pady=10)
    
    def _create_files_tab(self):
        """Cria aba de arquivos"""
        files_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(files_frame, text="Arquivos")
        
        # Frame para upload de arquivos
        upload_frame = ttk.LabelFrame(files_frame, text="Upload de Arquivos", padding="10")
        upload_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Botões de upload
        btn_frame = ttk.Frame(upload_frame)
        btn_frame.pack(fill=tk.X)
        
        ttk.Button(btn_frame, text="📁 Selecionar Arquivo", 
                  command=self._upload_file).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(btn_frame, text="🖼️ Selecionar Imagem", 
                  command=self._upload_image).pack(side=tk.LEFT, padx=5)
        
        # Lista de arquivos
        files_list_frame = ttk.LabelFrame(files_frame, text="Arquivos Anexados", padding="10")
        files_list_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para arquivos
        columns = ("Nome", "Tipo", "Tamanho", "Data")
        self.files_treeview = ttk.Treeview(files_list_frame, columns=columns, show="headings", height=8)
        
        self.files_treeview.heading("Nome", text="Nome do Arquivo")
        self.files_treeview.heading("Tipo", text="Tipo")
        self.files_treeview.heading("Tamanho", text="Tamanho")
        self.files_treeview.heading("Data", text="Data de Upload")
        
        self.files_treeview.column("Nome", width=200, anchor="w")
        self.files_treeview.column("Tipo", width=100, anchor="w")
        self.files_treeview.column("Tamanho", width=100, anchor="w")
        self.files_treeview.column("Data", width=150, anchor="w")
        
        self.files_treeview.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Scrollbar para treeview
        files_scrollbar = ttk.Scrollbar(files_list_frame, orient="vertical", command=self.files_treeview.yview)
        files_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.files_treeview.config(yscrollcommand=files_scrollbar.set)
        
        # Botões de ação para arquivos
        files_btn_frame = ttk.Frame(files_list_frame)
        files_btn_frame.pack(fill=tk.X, pady=5)
        
        ttk.Button(files_btn_frame, text="📥 Baixar", 
                  command=self._download_file).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(files_btn_frame, text="🗑️ Remover", 
                  command=self._remove_file).pack(side=tk.LEFT, padx=5)
        
        # Bind duplo clique para abrir arquivo
        self.files_treeview.bind("<Double-1>", self._open_file)
    
    def _create_comments_tab(self):
        """Cria aba de comentários"""
        comments_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(comments_frame, text="Comentários")
        
        # Frame para adicionar comentário
        add_comment_frame = ttk.LabelFrame(comments_frame, text="Adicionar Comentário", padding="10")
        add_comment_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Text widget para novo comentário
        self.new_comment_text = tk.Text(add_comment_frame, height=4, wrap=tk.WORD)
        self.new_comment_text.pack(fill=tk.X, pady=5)
        
        # Botão para adicionar comentário
        add_comment_btn = ttk.Button(add_comment_frame, text="Adicionar Comentário", 
                                   command=self._add_comment)
        add_comment_btn.pack(pady=5)
        
        # Lista de comentários
        comments_list_frame = ttk.LabelFrame(comments_frame, text="Comentários", padding="10")
        comments_list_frame.pack(fill=tk.BOTH, expand=True)
        
        # Text widget para exibir comentários
        self.comments_text = tk.Text(comments_list_frame, wrap=tk.WORD, state=tk.DISABLED)
        self.comments_text.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Scrollbar para comentários
        comments_scrollbar = ttk.Scrollbar(comments_list_frame, orient="vertical", command=self.comments_text.yview)
        comments_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.comments_text.config(yscrollcommand=comments_scrollbar.set)
    
    def _create_history_tab(self):
        """Cria aba de histórico"""
        history_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(history_frame, text="Histórico")
        
        # Treeview para histórico
        columns = ("Data/Hora", "Usuário", "Ação", "Detalhes")
        self.history_treeview = ttk.Treeview(history_frame, columns=columns, show="headings", height=10)
        
        self.history_treeview.heading("Data/Hora", text="Data/Hora")
        self.history_treeview.heading("Usuário", text="Usuário")
        self.history_treeview.heading("Ação", text="Ação")
        self.history_treeview.heading("Detalhes", text="Detalhes")
        
        self.history_treeview.column("Data/Hora", width=150, anchor="w")
        self.history_treeview.column("Usuário", width=100, anchor="w")
        self.history_treeview.column("Ação", width=120, anchor="w")
        self.history_treeview.column("Detalhes", width=300, anchor="w")
        
        self.history_treeview.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Scrollbar para histórico
        history_scrollbar = ttk.Scrollbar(history_frame, orient="vertical", command=self.history_treeview.yview)
        history_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.history_treeview.config(yscrollcommand=history_scrollbar.set)
    
    def _get_user_id_safe(self):
        """Obtém o user_id de forma segura"""
        if hasattr(self.current_user, 'id'):
            return self.current_user.id
        elif hasattr(self.current_user, 'user_id'):
            return self.current_user.user_id
        elif isinstance(self.current_user, dict):
            return self.current_user.get('id') or self.current_user.get('user_id')
        else:
            # Tentar obter do banco de dados
            try:
                if hasattr(self.current_user, 'username'):
                    user_data = self.app.db.get_user_by_username(self.current_user.username)
                    return user_data.get('id') if user_data else 1
                else:
                    return 1  # Usuário padrão
            except:
                return 1  # Usuário padrão

    def _create_action_buttons(self, parent):
        """Cria botões de ação"""
        button_frame = ttk.Frame(parent)
        button_frame.pack(fill=tk.X, pady=(20, 0))
        
        ttk.Button(button_frame, text="Salvar Alterações", 
                  command=self._save_changes).pack(side=tk.RIGHT, padx=5)
        
        ttk.Button(button_frame, text="Fechar", 
                  command=self.window.destroy).pack(side=tk.RIGHT, padx=5)
    
    def _load_subtask_data(self):
        """Carrega os dados da subtarefa"""
        try:
            # Carregar dados básicos
            self.title_entry.insert(0, self.subtask.get('title', ''))
            self.description_text.insert("1.0", self.subtask.get('description', ''))
            
            # Carregar responsável
            responsible = self.subtask.get('assigned_member', '')
            if responsible:
                self.responsible_combo.set(responsible)
            
            # Carregar prioridade
            priority = self.subtask.get('priority', 'Normal')
            self.priority_var.set(priority)
            
            # Carregar status
            status = "Concluída" if self.subtask.get('completed', False) else "Pendente"
            self.status_var.set(status)
            
            # Carregar arquivos
            self._load_files()
            
            # Carregar comentários
            self._load_comments()
            
            # Carregar histórico
            self._load_history()
            
        except Exception as e:
            print(f"Erro ao carregar dados da subtarefa: {e}")
    
    def _load_files(self):
        """Carrega lista de arquivos"""
        try:
            # Limpar treeview
            for item in self.files_treeview.get_children():
                self.files_treeview.delete(item)
            
            # Buscar arquivos da subtarefa no banco
            files = self.app.db.get_subtask_files(self.subtask.get('id'))
            
            for file_data in files:
                self.files_treeview.insert("", "end", values=(
                    file_data.get('filename', ''),
                    file_data.get('file_type', ''),
                    file_data.get('file_size', ''),
                    file_data.get('upload_date', '')
                ))
        except Exception as e:
            print(f"Erro ao carregar arquivos: {e}")
    
    def _load_comments(self):
        """Carrega comentários"""
        try:
            self.comments_text.config(state=tk.NORMAL)
            self.comments_text.delete("1.0", tk.END)
            
            # Buscar comentários da subtarefa no banco
            comments = self.app.db.get_subtask_comments(self.subtask.get('id'))
            
            for comment in comments:
                timestamp = comment.get('created_at', '')
                user = comment.get('user_name', '')
                text = comment.get('comment_text', '')
                
                self.comments_text.insert(tk.END, f"[{timestamp}] {user}:\n{text}\n\n")
            
            self.comments_text.config(state=tk.DISABLED)
        except Exception as e:
            print(f"Erro ao carregar comentários: {e}")
    
    def _load_history(self):
        """Carrega histórico"""
        try:
            # Limpar treeview
            for item in self.history_treeview.get_children():
                self.history_treeview.delete(item)
            
            # Buscar histórico da subtarefa no banco
            history = self.app.db.get_subtask_history(self.subtask.get('id'))
            
            for entry in history:
                self.history_treeview.insert("", "end", values=(
                    entry.get('timestamp', ''),
                    entry.get('user_name', ''),
                    entry.get('action', ''),
                    entry.get('details', '')
                ))
        except Exception as e:
            print(f"Erro ao carregar histórico: {e}")
    
    def _upload_file(self):
        """Upload de arquivo"""
        file_path = filedialog.askopenfilename(
            title="Selecionar Arquivo",
            filetypes=[
                ("Todos os arquivos", "*.*"),
                ("Documentos", "*.pdf *.doc *.docx *.txt"),
                ("Imagens", "*.jpg *.jpeg *.png *.gif"),
                ("Vídeos", "*.mp4 *.avi *.mov")
            ]
        )
        
        if file_path:
            try:
                # Obter user_id de forma segura
                user_id = self._get_user_id_safe()
                
                # Tentar usar sistema de upload completo (Supabase + Cloudflare R2)
                if SISTEMA_UPLOAD_DISPONIVEL and hasattr(self.app, 'sistema_upload'):
                    # Upload para nuvem
                    result = self.app.sistema_upload.upload_arquivo(
                        file_path=file_path,
                        categoria="subtasks"
                    )
                    
                    if result["success"]:
                        # Salvar metadados no banco com URL da nuvem
                        self.app.db.add_subtask_file(
                            subtask_id=self.subtask.get('id'),
                            file_path=result["url"],  # URL da nuvem
                            user_id=user_id
                        )
                        
                        # Recarregar lista de arquivos
                        self._load_files()
                        
                        messagebox.showinfo("Sucesso", f"Arquivo enviado para nuvem com sucesso!\nURL: {result['url']}")
                    else:
                        # Fallback para upload local
                        self._upload_file_local(file_path, user_id)
                else:
                    # Upload local (fallback)
                    self._upload_file_local(file_path, user_id)
                
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao enviar arquivo: {e}")
    
    def _upload_file_local(self, file_path, user_id):
        """Upload local (fallback)"""
        try:
            # Salvar arquivo no banco (caminho local)
            self.app.db.add_subtask_file(
                subtask_id=self.subtask.get('id'),
                file_path=file_path,
                user_id=user_id
            )
            
            # Recarregar lista de arquivos
            self._load_files()
            
            messagebox.showinfo("Sucesso", "Arquivo enviado localmente com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao enviar arquivo local: {e}")
    
    def _upload_image(self):
        """Upload de imagem"""
        file_path = filedialog.askopenfilename(
            title="Selecionar Imagem",
            filetypes=[
                ("Imagens", "*.jpg *.jpeg *.png *.gif *.bmp"),
                ("Todos os arquivos", "*.*")
            ]
        )
        
        if file_path:
            try:
                # Obter user_id de forma segura
                user_id = self._get_user_id_safe()
                
                # Tentar usar sistema de upload completo (Supabase + Cloudflare R2)
                if SISTEMA_UPLOAD_DISPONIVEL and hasattr(self.app, 'sistema_upload'):
                    # Upload para nuvem
                    result = self.app.sistema_upload.upload_arquivo(
                        file_path=file_path,
                        categoria="subtasks_images"
                    )
                    
                    if result["success"]:
                        # Salvar metadados no banco com URL da nuvem
                        self.app.db.add_subtask_file(
                            subtask_id=self.subtask.get('id'),
                            file_path=result["url"],  # URL da nuvem
                            user_id=user_id
                        )
                        
                        # Recarregar lista de arquivos
                        self._load_files()
                        
                        messagebox.showinfo("Sucesso", f"Imagem enviada para nuvem com sucesso!\nURL: {result['url']}")
                    else:
                        # Fallback para upload local
                        self._upload_image_local(file_path, user_id)
                else:
                    # Upload local (fallback)
                    self._upload_image_local(file_path, user_id)
                
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao enviar imagem: {e}")
    
    def _upload_image_local(self, file_path, user_id):
        """Upload local de imagem (fallback)"""
        try:
            # Salvar imagem no banco (caminho local)
            self.app.db.add_subtask_file(
                subtask_id=self.subtask.get('id'),
                file_path=file_path,
                user_id=user_id
            )
            
            # Recarregar lista de arquivos
            self._load_files()
            
            messagebox.showinfo("Sucesso", "Imagem enviada localmente com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao enviar imagem local: {e}")
    
    def _download_file(self):
        """Download de arquivo"""
        selected_item = self.files_treeview.selection()
        if not selected_item:
            messagebox.showwarning("Seleção", "Por favor, selecione um arquivo para baixar.")
            return
        
        try:
            # Obter dados do arquivo
            file_data = self.files_treeview.item(selected_item[0])
            filename = file_data['values'][0]
            
            # Buscar arquivo no banco
            file_info = self.app.db.get_subtask_file_by_name(self.subtask.get('id'), filename)
            
            if file_info:
                file_path = file_info['file_path']
                
                # Salvar arquivo localmente
                save_path = filedialog.asksaveasfilename(
                    title="Salvar Arquivo Como",
                    defaultextension=os.path.splitext(filename)[1],
                    initialname=filename
                )
                
                if save_path:
                    # Verificar se é URL da nuvem ou arquivo local
                    if file_path.startswith(('http://', 'https://')):
                        # Download da nuvem
                        self._download_from_cloud(file_path, save_path)
                    else:
                        # Arquivo local
                        shutil.copy2(file_path, save_path)
                        messagebox.showinfo("Sucesso", f"Arquivo salvo em: {save_path}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao baixar arquivo: {e}")
    
    def _download_from_cloud(self, url, save_path):
        """Download de arquivo da nuvem"""
        try:
            import requests
            
            # Download do arquivo
            response = requests.get(url, stream=True)
            response.raise_for_status()
            
            with open(save_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            messagebox.showinfo("Sucesso", f"Arquivo baixado da nuvem e salvo em: {save_path}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao baixar arquivo da nuvem: {e}")
    
    def _remove_file(self):
        """Remove arquivo"""
        selected_item = self.files_treeview.selection()
        if not selected_item:
            messagebox.showwarning("Seleção", "Por favor, selecione um arquivo para remover.")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja remover este arquivo?"):
            try:
                # Obter dados do arquivo
                file_data = self.files_treeview.item(selected_item[0])
                filename = file_data['values'][0]
                
                # Remover arquivo do banco
                self.app.db.remove_subtask_file(self.subtask.get('id'), filename)
                
                # Recarregar lista de arquivos
                self._load_files()
                
                messagebox.showinfo("Sucesso", "Arquivo removido com sucesso!")
                
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao remover arquivo: {e}")
    
    def _open_file(self, event):
        """Abre arquivo"""
        selected_item = self.files_treeview.selection()
        if selected_item:
            self._download_file()
    
    def _add_comment(self):
        """Adiciona comentário"""
        comment_text = self.new_comment_text.get("1.0", tk.END).strip()
        if not comment_text:
            messagebox.showwarning("Comentário", "Por favor, digite um comentário.")
            return
        
        try:
            # Obter user_id de forma segura
            user_id = self._get_user_id_safe()
            
            # Salvar comentário no banco
            self.app.db.add_subtask_comment(
                subtask_id=self.subtask.get('id'),
                comment_text=comment_text,
                user_id=user_id
            )
            
            # Limpar campo
            self.new_comment_text.delete("1.0", tk.END)
            
            # Recarregar comentários
            self._load_comments()
            
            messagebox.showinfo("Sucesso", "Comentário adicionado com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar comentário: {e}")
    
    def _save_description(self):
        """Salva descrição"""
        try:
            description = self.description_text.get("1.0", tk.END).strip()
            
            # Atualizar descrição no banco
            self.app.db.update_subtask_description(
                subtask_id=self.subtask.get('id'),
                description=description
            )
            
            messagebox.showinfo("Sucesso", "Descrição salva com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar descrição: {e}")
    
    def _update_subtask_status(self, event=None):
        """Atualiza status da subtarefa"""
        try:
            new_status = self.status_var.get()
            completed = new_status == "Concluída"
            
            # Atualizar status no banco
            self.app.db.update_subtask_status(
                subtask_id=self.subtask.get('id'),
                completed=completed
            )
            
            # Atualizar dados locais
            self.subtask['completed'] = completed
            
            # Recarregar histórico
            self._load_history()
            
            # Notificar parent se necessário
            if self.parent:
                self.parent._populate_subtasks_listbox()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao atualizar status: {e}")
    
    def _update_responsible(self, event=None):
        """Atualiza responsável da subtarefa"""
        try:
            new_responsible = self.responsible_combo.get()
            
            # Atualizar responsável no banco
            self.app.db.update_subtask_responsible(
                subtask_id=self.subtask.get('id'),
                responsible=new_responsible
            )
            
            # Atualizar dados locais
            self.subtask['assigned_member'] = new_responsible
            
            # Recarregar histórico
            self._load_history()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao atualizar responsável: {e}")
    
    def _update_priority(self, event=None):
        """Atualiza prioridade da subtarefa"""
        try:
            new_priority = self.priority_var.get()
            
            # Atualizar prioridade no banco
            self.app.db.update_subtask_priority(
                subtask_id=self.subtask.get('id'),
                priority=new_priority
            )
            
            # Atualizar dados locais
            self.subtask['priority'] = new_priority
            
            # Recarregar histórico
            self._load_history()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao atualizar prioridade: {e}")
    
    def _save_changes(self):
        """Salva todas as alterações"""
        try:
            # Salvar título
            new_title = self.title_entry.get().strip()
            if new_title:
                self.app.db.update_subtask_title(
                    subtask_id=self.subtask.get('id'),
                    title=new_title
                )
                self.subtask['title'] = new_title
            
            # Salvar descrição
            self._save_description()
            
            # Recarregar histórico
            self._load_history()
            
            messagebox.showinfo("Sucesso", "Alterações salvas com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar alterações: {e}")


class CardWindow(tk.Toplevel):
    def __init__(self, parent, app, board_name, list_name, card_id, current_user, callback_on_close=None):
        super().__init__(parent)
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self.card_id = card_id # Now using card_id instead of card_index
        self.current_user = current_user # Store the current user
        self.callback_on_close = callback_on_close
        
        # Find the card using its card_id - try both in-memory data and database
        self.card = None
        
        # First, try to find in the in-memory data structure
        if (self.board_name in self.app.boodesk_data["boards"] and 
            self.list_name in self.app.boodesk_data["boards"][self.board_name]):
            for card_data in self.app.boodesk_data["boards"][self.board_name][self.list_name]:
                if card_data.get('card_id') == self.card_id:
                    self.card = card_data
                    break
        
        # If not found in memory, try to get from database
        if not self.card and hasattr(self.app, 'db') and self.app.db:
            try:
                card_data = self.app.db.get_card_by_id(self.card_id)
                if card_data:
                    # Convert to dictionary if needed
                    if not isinstance(card_data, dict):
                        card_data = dict(card_data)
                    
                    # Add board and list information
                    card_data['board_name'] = self.board_name
                    card_data['list_name'] = self.list_name
                    print(f"DEBUG: Type of card_data before assignment: {type(card_data)}, Content: {card_data}")
                    self.card = card_data
                    
                    # Verificar se self.card é um dicionário antes de usar .get()
                    if isinstance(self.card, dict):
                        print(f"DEBUG: Card encontrado no banco de dados: {self.card.get('title', 'Sem título')}")
                    else:
                        print(f"DEBUG: Erro - self.card não é um dicionário: {type(self.card)} - {self.card}")
                        # Tentar converter para dicionário se possível
                        if hasattr(self.card, '__dict__'):
                            self.card = self.card.__dict__
                        else:
                            print(f"DEBUG: Não foi possível converter self.card para dicionário")
                            return
            except Exception as e:
                print(f"Erro ao buscar card no banco: {e}")

        if not self.card:
            messagebox.showerror("Erro", "Cartão não encontrado. Pode ter sido excluído ou movido.")
            self.destroy()
            return

        # Verificar se self.card é um dicionário antes de acessar
        if isinstance(self.card, dict):
            title = self.card.get('title', 'Sem título')
        else:
            title = 'Sem título'
        self.title(f"Editar Tarefa: {title}")
        self.geometry("1000x700")  # Tamanho fixo que funciona bem
        self.resizable(False, False)  # Impedir redimensionamento para evitar deformação
        
        # Centralizar a janela na tela
        self.center_window()
        
        # Tornar esta janela modal (usuário deve interagir com ela antes de voltar à janela principal)
        self.transient(parent)
        self.grab_set()

        # Initialize StringVars for Git integration
        if isinstance(self.card, dict):
            self.git_branch_var = tk.StringVar(value=self.card.get('git_branch', ''))
            self.git_commit_var = tk.StringVar(value=self.card.get('git_commit', ''))
            self.git_pr_var = tk.StringVar(value=self.card.get('git_pr', ''))
        else:
            self.git_branch_var = tk.StringVar(value='')
            self.git_commit_var = tk.StringVar(value='')
            self.git_pr_var = tk.StringVar(value='')

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")

    def center_window(self):
        """Centraliza a janela na tela"""
        self.update_idletasks()
        
        # Obter dimensões da tela
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Obter dimensões da janela
        window_width = self.winfo_width()
        window_height = self.winfo_height()
        
        # Calcular posição central
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        
        # Aplicar posição
        self.geometry(f"+{x}+{y}")

    def create_widgets(self):
        # Main container with proper layout
        main_container = ttk.Frame(self)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Configure main container for proper layout
        main_container.columnconfigure(0, weight=1)
        main_container.rowconfigure(0, weight=1)
        
        # Create a frame for the scrollable content
        content_frame = ttk.Frame(main_container)
        content_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 10))
        content_frame.columnconfigure(0, weight=1)
        content_frame.rowconfigure(0, weight=1)
        
        # Create canvas and scrollbar
        canvas = tk.Canvas(content_frame)
        scrollbar = ttk.Scrollbar(content_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # Main frame inside scrollable area
        main_frame = ttk.Frame(scrollable_frame, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure grid for 2 columns with proper weights
        main_frame.columnconfigure(0, weight=1)  # Left column
        main_frame.columnconfigure(1, weight=1)  # Right column
        main_frame.rowconfigure(0, weight=1)  # Allow vertical expansion

        # === LEFT COLUMN ===
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
        left_frame.columnconfigure(1, weight=1)
        left_frame.rowconfigure(0, weight=1)  # Allow expansion

        # --- Card Details Section ---
        details_frame = ttk.LabelFrame(left_frame, text="Detalhes do Cartão", padding="10")
        details_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        details_frame.columnconfigure(1, weight=1)

        ttk.Label(details_frame, text="Título:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
        self.title_entry = ttk.Entry(details_frame)
        self.title_entry.grid(row=0, column=1, sticky="ew", pady=3, padx=5)
        # Verificar se self.card é um dicionário antes de acessar
        if isinstance(self.card, dict):
            self.title_entry.insert(0, self.card.get('title', ''))
        else:
            self.title_entry.insert(0, '')

        ttk.Label(details_frame, text="Descrição:", font=("Arial", 9, "bold")).grid(row=1, column=0, sticky="nw", pady=3, padx=5)
        self.desc_text = tk.Text(details_frame, height=4, width=35, wrap=tk.WORD)
        self.desc_text.grid(row=1, column=1, sticky="ew", pady=3, padx=5)
        if isinstance(self.card, dict):
            # Tentar carregar descrição de diferentes campos possíveis
            description = self.card.get('description', '') or self.card.get('desc', '')
            self.desc_text.insert("1.0", description)
        else:
            self.desc_text.insert("1.0", '')

        # --- Dates and Recurrence Section ---
        dates_frame = ttk.LabelFrame(left_frame, text="Datas e Recorrência", padding="10")
        dates_frame.pack(fill=tk.X, pady=(0, 10))
        dates_frame.columnconfigure(1, weight=1)

        ttk.Label(dates_frame, text="Prazo:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
        date_frame = ttk.Frame(dates_frame)
        date_frame.grid(row=0, column=1, sticky="ew", pady=3, padx=5)
        self.due_date_entry = ttk.Entry(date_frame, width=15, state="readonly")
        self.due_date_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(date_frame, image=self.app.icons.get('time_icon'), width=3, command=self.open_date_picker).pack(side=tk.LEFT, padx=2)

        self.include_time_var = tk.BooleanVar()
        self.include_time_var.set(False)
        self.include_time_check = ttk.Checkbutton(dates_frame, text="Incluir Horário", 
                                                variable=self.include_time_var, 
                                                command=self.toggle_time_fields)
        self.include_time_check.grid(row=1, column=0, sticky="w", pady=3, padx=5)

        time_frame = ttk.Frame(dates_frame)
        time_frame.grid(row=1, column=1, sticky="ew", pady=3, padx=5)
        self.hour_entry = tk.Spinbox(time_frame, from_=0, to=23, width=3, state="disabled", wrap=True)
        self.hour_entry.pack(side=tk.LEFT)
        ttk.Label(time_frame, text=":").pack(side=tk.LEFT)
        self.minute_entry = tk.Spinbox(time_frame, from_=0, to=59, width=3, state="disabled", wrap=True)
        self.minute_entry.pack(side=tk.LEFT)

        ttk.Label(dates_frame, text="Recorrência:", font=("Arial", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3, padx=5)
        self.recurrence_options = ["Nenhuma", "Diariamente", "Semanalmente", "Mensalmente", "Anualmente"]
        self.recurrence_combo = ttk.Combobox(dates_frame, values=self.recurrence_options, state="readonly")
        self.recurrence_combo.grid(row=2, column=1, sticky="ew", pady=3, padx=5)
        recurrence = self.card.get('recurrence', 'Nenhuma') if isinstance(self.card, dict) else 'Nenhuma'
        self.recurrence_combo.set(recurrence)

        # Git Integration Section (visible only in dev mode)
        if self.app.settings.get('dev_mode', False):
            git_frame = ttk.LabelFrame(left_frame, text="Integração Git", padding="10")
            git_frame.pack(fill=tk.X, pady=(0, 10))
            git_frame.columnconfigure(1, weight=1)

            # Git Status and Actions
            git_status_frame = ttk.Frame(git_frame)
            git_status_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 10))
            git_status_frame.columnconfigure(1, weight=1)

            ttk.Label(git_status_frame, text="Status Git:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
            self.git_status_label = ttk.Label(git_status_frame, text="Não configurado", foreground="gray")
            self.git_status_label.grid(row=0, column=1, sticky="w", pady=3, padx=5)

            # Git Actions Buttons
            git_actions_frame = ttk.Frame(git_frame)
            git_actions_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(0, 10))

            ttk.Button(git_actions_frame, text="Inicializar Repo", 
                      image=self.app.icons.get('add_icon'), compound=tk.LEFT,
                      command=self.init_git_repo).pack(side=tk.LEFT, padx=2)
            
            ttk.Button(git_actions_frame, text="Criar Branch", 
                      image=self.app.icons.get('add_folder_icon'), compound=tk.LEFT,
                      command=self.create_git_branch).pack(side=tk.LEFT, padx=2)
            
            ttk.Button(git_actions_frame, text="Commit", 
                      image=self.app.icons.get('save_icon'), compound=tk.LEFT,
                      command=self.make_git_commit).pack(side=tk.LEFT, padx=2)

            # Git Information Fields
            ttk.Label(git_frame, text="Branch Atual:", font=("Arial", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3, padx=5)
            self.git_branch_entry = ttk.Entry(git_frame, textvariable=self.git_branch_var)
            self.git_branch_entry.grid(row=2, column=1, sticky="ew", pady=3, padx=5)

            ttk.Label(git_frame, text="Último Commit:", font=("Arial", 9, "bold")).grid(row=3, column=0, sticky="w", pady=3, padx=5)
            self.git_commit_entry = ttk.Entry(git_frame, textvariable=self.git_commit_var)
            self.git_commit_entry.grid(row=3, column=1, sticky="ew", pady=3, padx=5)

            ttk.Label(git_frame, text="Pull Request:", font=("Arial", 9, "bold")).grid(row=4, column=0, sticky="w", pady=3, padx=5)
            self.git_pr_entry = ttk.Entry(git_frame, textvariable=self.git_pr_var)
            self.git_pr_entry.grid(row=4, column=1, sticky="ew", pady=3, padx=5)

            # Git History Section
            git_history_frame = ttk.LabelFrame(git_frame, text="Histórico Git", padding="5")
            git_history_frame.grid(row=5, column=0, columnspan=2, sticky="ew", pady=(10, 0))
            git_history_frame.columnconfigure(0, weight=1)

            self.git_history_text = tk.Text(git_history_frame, height=4, width=40, wrap=tk.WORD, state="disabled")
            self.git_history_text.pack(fill=tk.BOTH, expand=True, pady=5)
            
            # Update Git status
            self.update_git_status()

        # Populate due date and time if available
        if self.card.get('due_date'):
            try:
                # Tentar diferentes formatos de data
                due_date_str = self.card.get('due_date', '')
                dt_obj = None
                
                # Formato com data e hora: "2025-08-12 14:30"
                if ' ' in due_date_str:
                    try:
                        dt_obj = datetime.strptime(due_date_str, "%Y-%m-%d %H:%M")
                        self.include_time_var.set(True)
                        self.toggle_time_fields()
                    except ValueError:
                        try:
                            dt_obj = datetime.strptime(due_date_str, "%Y-%m-%d %H:%M:%S")
                            self.include_time_var.set(True)
                            self.toggle_time_fields()
                        except ValueError:
                            pass
                
                # Formato apenas data: "2025-08-12"
                if not dt_obj:
                    try:
                        dt_obj = datetime.strptime(due_date_str, "%Y-%m-%d")
                        self.include_time_var.set(False)
                        self.toggle_time_fields()
                    except ValueError:
                        # Formato brasileiro: "12/08/2025"
                        try:
                            dt_obj = datetime.strptime(due_date_str, "%d/%m/%Y")
                            self.include_time_var.set(False)
                            self.toggle_time_fields()
                        except ValueError:
                            pass
                
                if dt_obj:
                    self.due_date_entry.config(state="normal")
                    self.due_date_entry.delete(0, tk.END)
                    self.due_date_entry.insert(0, dt_obj.strftime("%Y-%m-%d"))
                    self.due_date_entry.config(state="readonly")
                    
                    if self.include_time_var.get():
                        self.hour_entry.config(state="normal")
                        self.minute_entry.config(state="normal")
                        self.hour_entry.delete(0, tk.END)
                        self.minute_entry.delete(0, tk.END)
                        self.hour_entry.insert(0, dt_obj.strftime("%H"))
                        self.minute_entry.insert(0, dt_obj.strftime("%M"))
                        
            except Exception as e:
                print(f"Erro ao processar data do card: {e}")
                # Se não conseguir processar, limpar os campos
                self.due_date_entry.config(state="normal")
                self.due_date_entry.delete(0, tk.END)
                self.due_date_entry.config(state="readonly")
                self.include_time_var.set(True)
            except ValueError:  # Only date available
                self.due_date_entry.config(state="normal")
                self.due_date_entry.delete(0, tk.END)
                self.due_date_entry.insert(0, self.card.get('due_date', ''))
                self.due_date_entry.config(state="readonly")
                self.include_time_var.set(False)
        self.toggle_time_fields()

        # --- Attributes Section ---
        attributes_frame = ttk.LabelFrame(left_frame, text="Atributos", padding="10")
        attributes_frame.pack(fill=tk.X, pady=(0, 10))
        attributes_frame.columnconfigure(1, weight=1)

        ttk.Label(attributes_frame, text="Importância:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
        self.importance_options = list(self.app.settings["importance_colors"].keys())
        self.importance_combo = ttk.Combobox(attributes_frame, values=self.importance_options, state="readonly")
        self.importance_combo.grid(row=0, column=1, sticky="ew", pady=3, padx=5)
        importance = self.card.get('importance', 'Normal') if isinstance(self.card, dict) else 'Normal'
        self.importance_combo.set(importance)

        ttk.Label(attributes_frame, text="Categoria:", font=("Arial", 9, "bold")).grid(row=1, column=0, sticky="w", pady=3, padx=5)
        category_options = [cat['name'] for cat in self.app.categories]
        self.category_combo = ttk.Combobox(attributes_frame, values=category_options, state="readonly")
        self.category_combo.grid(row=1, column=1, sticky="ew", pady=3, padx=5)
        category = self.card.get('category', '-') if isinstance(self.card, dict) else '-'
        self.category_combo.set(category)

        ttk.Label(attributes_frame, text="Objetivo:", font=("Arial", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3, padx=5)
        self.goal_combo = ttk.Combobox(attributes_frame, values=self.app.goals, state="readonly")
        self.goal_combo.grid(row=2, column=1, sticky="ew", pady=3, padx=5)
        goal = self.card.get('goal', '-') if isinstance(self.card, dict) else '-'
        self.goal_combo.set(goal)

        # --- Members Section ---
        members_frame = ttk.LabelFrame(left_frame, text="Membros Responsáveis", padding="10")
        members_frame.pack(fill=tk.X, pady=(0, 10))
        members_frame.columnconfigure(0, weight=1)

        # Frame for the combobox and add button
        add_member_frame = ttk.Frame(members_frame)
        add_member_frame.pack(fill=tk.X, pady=2)
        add_member_frame.columnconfigure(0, weight=1)

        self.member_suggestions_combo = ttk.Combobox(add_member_frame, values=[member['Membro'] for member in self.app.members], state="readonly")
        self.member_suggestions_combo.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        self.member_suggestions_combo.set("Selecionar Membro para Adicionar")
        
        add_member_btn = ttk.Button(add_member_frame, text="Adicionar", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_member_from_combo)
        add_member_btn.grid(row=0, column=1)

        # Listbox for assigned members
        self.assigned_members_listbox = tk.Listbox(members_frame, selectmode=tk.SINGLE, height=3)
        self.assigned_members_listbox.pack(fill=tk.BOTH, expand=True, pady=2)
        # Populate with existing members (if any)
        if isinstance(self.card, dict):
            members = self.card.get('members', [])
            if isinstance(members, list):
                for member in members:
                    self.assigned_members_listbox.insert(tk.END, member)

        # Remove button
        remove_member_btn = ttk.Button(members_frame, text="Remover Selecionado", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_assigned_member)
        remove_member_btn.pack(pady=2)

        # --- Creation Date Section ---
        creation_frame = ttk.LabelFrame(left_frame, text="Informações do Sistema", padding="10")
        creation_frame.pack(fill=tk.X)
        
        ttk.Label(creation_frame, text="Data de Criação:", font=("Arial", 9, "bold")).pack(anchor="w", padx=5, pady=2)
        creation_date = self.card.get('creation_date', 'N/A') if isinstance(self.card, dict) else 'N/A'
        self.creation_date_label = ttk.Label(creation_frame, text=creation_date)
        self.creation_date_label.pack(anchor="w", padx=5, pady=2)

        # === RIGHT COLUMN ===
        right_frame = ttk.Frame(main_frame)
        right_frame.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
        right_frame.columnconfigure(0, weight=1)
        right_frame.rowconfigure(0, weight=1)  # Allow expansion

        # --- Dependencies Section ---
        dependencies_frame = ttk.LabelFrame(right_frame, text="Dependências", padding="10")
        dependencies_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        dependencies_frame.columnconfigure(0, weight=1)
        
        # Configure the frame to expand properly
        dependencies_frame.pack_configure(fill=tk.BOTH, expand=True)

        # Dependency input area
        dependency_input_frame = ttk.Frame(dependencies_frame)
        dependency_input_frame.pack(fill=tk.X, pady=(0, 5))
        dependency_input_frame.columnconfigure(0, weight=1)
        
        self.dependency_combo = ttk.Combobox(dependency_input_frame, state="readonly")
        self.dependency_combo.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        add_dep_btn = ttk.Button(dependency_input_frame, text="Adicionar", 
                               image=self.app.icons.get('add_icon'), compound=tk.LEFT,
                               command=self._add_dependency)
        add_dep_btn.grid(row=0, column=1)

        # Dependencies list
        self.dependencies_listbox = tk.Listbox(dependencies_frame, selectmode=tk.SINGLE, height=6)
        self.dependencies_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        
        dep_scrollbar = ttk.Scrollbar(dependencies_frame, orient="vertical", command=self.dependencies_listbox.yview)
        dep_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.dependencies_listbox.config(yscrollcommand=dep_scrollbar.set)

        # Populate with existing dependencies (if any)
        if isinstance(self.card, dict):
            dependencies = self.card.get('dependencies', [])
            if isinstance(dependencies, list):
                for dependency in dependencies:
                    self.dependencies_listbox.insert(tk.END, dependency)

        # Remove dependency button
        remove_dep_btn = ttk.Button(dependencies_frame, text="Remover Dependência", 
                                  image=self.app.icons.get('delete_icon'), compound=tk.LEFT,
                                  command=self._remove_dependency)
        remove_dep_btn.pack(pady=5)

        # --- Subtasks Section ---
        subtasks_frame = ttk.LabelFrame(right_frame, text="Subtarefas/Checklist", padding="10")
        subtasks_frame.pack(fill=tk.BOTH, expand=True)
        subtasks_frame.columnconfigure(0, weight=1)
        
        # Configure the frame to expand properly
        subtasks_frame.pack_configure(fill=tk.BOTH, expand=True)

        # Subtask input area
        subtask_input_frame = ttk.Frame(subtasks_frame)
        subtask_input_frame.pack(fill=tk.X, pady=(0, 5))
        subtask_input_frame.columnconfigure(0, weight=1)
        subtask_input_frame.columnconfigure(1, weight=1)
        
        # Subtask entry
        self.subtask_entry = ttk.Entry(subtask_input_frame)
        self.subtask_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        self.subtask_entry.bind('<Return>', lambda e: self._add_subtask())
        
        # Member assignment for subtask
        member_options = [member['Membro'] for member in self.app.members]
        self.subtask_member_combo = ttk.Combobox(subtask_input_frame, values=member_options, state="readonly")
        self.subtask_member_combo.grid(row=0, column=1, sticky="ew", padx=(0, 5))
        self.subtask_member_combo.set("Delegar para...")
        
        add_subtask_btn = ttk.Button(subtask_input_frame, text="Adicionar", 
                                   image=self.app.icons.get('add_icon'), compound=tk.LEFT,
                                   command=self._add_subtask)
        add_subtask_btn.grid(row=0, column=2)

        # Subtasks list
        self.subtasks_listbox = tk.Listbox(subtasks_frame, selectmode=tk.SINGLE, height=8)
        self.subtasks_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        self.subtasks_listbox.bind("<Double-1>", self._toggle_subtask_completion)

        # Populate with existing subtasks
        if isinstance(self.card, dict):
            self.subtasks = self.app.db.get_subtasks(self.card['card_id'])
            for subtask in self.subtasks:
                status = "✓" if subtask['completed'] else "○"
                self.subtasks_listbox.insert(tk.END, f"{status} {subtask['text']}")
        
        subtask_scrollbar = ttk.Scrollbar(subtasks_frame, orient="vertical", command=self.subtasks_listbox.yview)
        subtask_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.subtasks_listbox.config(yscrollcommand=subtask_scrollbar.set)

        # Remove subtask button
        remove_subtask_btn = ttk.Button(subtasks_frame, text="Remover Subtarefa", 
                                      image=self.app.icons.get('delete_icon'), compound=tk.LEFT,
                                      command=self._remove_subtask)
        remove_subtask_btn.pack(pady=5)
        
        # Botão para abrir janela detalhada da subtarefa
        open_subtask_btn = ttk.Button(subtasks_frame, text="Abrir Subtarefa", 
                                     image=self.app.icons.get('edit_icon'), compound=tk.LEFT,
                                     command=self._open_subtask_details)
        open_subtask_btn.pack(pady=5)

        # --- Activity History Section ---
        history_frame = ttk.LabelFrame(right_frame, text="Histórico de Atividade", padding="10")
        history_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        history_frame.columnconfigure(0, weight=1)
        history_frame.rowconfigure(0, weight=1) # Allow treeview to expand

        self.history_treeview = ttk.Treeview(history_frame, columns=("Timestamp", "User", "Details"), show="headings")
        self.history_treeview.heading("Timestamp", text="Data/Hora")
        self.history_treeview.heading("User", text="Usuário")
        self.history_treeview.heading("Details", text="Detalhes")

        self.history_treeview.column("Timestamp", width=150, anchor="w")
        self.history_treeview.column("User", width=80, anchor="w")
        self.history_treeview.column("Details", width=300, anchor="w")

        self.history_treeview.grid(row=0, column=0, sticky="nsew", pady=5)

        history_scrollbar = ttk.Scrollbar(history_frame, orient="vertical", command=self.history_treeview.yview)
        history_scrollbar.grid(row=0, column=1, sticky="ns")
        self.history_treeview.config(yscrollcommand=history_scrollbar.set)

        # Pack canvas and scrollbar
        canvas.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")
        
        # Configure canvas to expand properly
        content_frame.columnconfigure(0, weight=1)
        content_frame.rowconfigure(0, weight=1)
        
        # === BOTTOM ACTION BUTTONS (FIXED AT BOTTOM) ===
        button_frame = ttk.LabelFrame(main_container, text="Ações", padding="10")
        button_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(10, 0))
        
        # Configure button frame for proper layout
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)
        button_frame.columnconfigure(4, weight=1)
        
        # Create buttons with better spacing
        save_btn = ttk.Button(button_frame, text="Salvar", 
                            image=self.app.icons.get('save_icon'), compound=tk.LEFT,
                            command=self.save_card)
        save_btn.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        cancel_btn = ttk.Button(button_frame, text="Cancelar", 
                              image=self.app.icons.get('cancel_icon'), compound=tk.LEFT,
                              command=self.destroy)
        cancel_btn.grid(row=0, column=1, sticky="ew", padx=(0, 5))
        
        pomodoro_btn = ttk.Button(button_frame, text="Iniciar Pomodoro", 
                                image=self.app.icons.get('coffee_icon'), compound=tk.LEFT,
                                command=self.start_pomodoro_action)
        pomodoro_btn.grid(row=0, column=2, sticky="ew", padx=(0, 5))
        
        complete_btn = ttk.Button(button_frame, text="Concluir Cartão", 
                                image=self.app.icons.get('ok_icon'), compound=tk.LEFT,
                                command=self.complete_card_action)
        complete_btn.grid(row=0, column=3, sticky="ew", padx=(0, 5))
        
        manage_btn = ttk.Button(button_frame, text="Gerenciar Card", 
                              image=self.app.icons.get('settings_icon'), compound=tk.LEFT,
                              command=self.open_advanced_card_manager)
        manage_btn.grid(row=0, column=4, sticky="ew")
        
        # Add keyboard shortcuts
        self.bind('<Control-s>', lambda e: self.save_card())
        self.bind('<Escape>', lambda e: self.destroy())
        self.bind('<Return>', lambda e: self.save_card())
        
        # Initialize data
        self._populate_dependency_combobox()
        self._populate_dependencies_listbox()
        self._populate_subtasks_listbox()
        self._populate_history_treeview()
        
        # Focus on title entry
        self.title_entry.focus_set()

    def _populate_history_treeview(self):
        self.history_treeview.delete(*self.history_treeview.get_children())
        history = self.card.get('history', [])
        
        # Se history é uma string JSON, converter para lista
        if isinstance(history, str):
            try:
                import json
                history = json.loads(history)
            except:
                history = []
        
        # Garantir que history é uma lista
        if not isinstance(history, list):
            history = []
        
        for entry in history:
            # Verificar se entry é um dicionário
            if isinstance(entry, dict):
                timestamp = entry.get('timestamp', 'N/A')
                user = entry.get('user', 'Sistema')
                action = entry.get('action', 'Ação desconhecida')
            else:
                # Se entry não é um dicionário, usar valores padrão
                timestamp = 'N/A'
                user = 'Sistema'
                action = 'Ação desconhecida'
            
            self.history_treeview.insert("", "end", values=(timestamp, user, action))

    def _add_member_from_combo(self):
        selected_member = self.member_suggestions_combo.get()
        if selected_member and selected_member != "Selecionar Membro para Adicionar":
            current_members = self.assigned_members_listbox.get(0, tk.END)
            if selected_member not in current_members:
                self.assigned_members_listbox.insert(tk.END, selected_member)
            self.member_suggestions_combo.set("Selecionar Membro para Adicionar")

    def _remove_assigned_member(self):
        selected_index = self.assigned_members_listbox.curselection()
        if selected_index:
            self.assigned_members_listbox.delete(selected_index)

    def _add_suggested_member(self, event):
        selected_member = self.member_suggestions_combo.get()
        current_members = [m.strip() for m in self.members_entry.get().split(',') if m.strip()]
        if selected_member and selected_member != "Selecionar Membro" and selected_member not in current_members:
            current_members.append(selected_member)
            self.members_entry.delete(0, tk.END)
            self.members_entry.insert(0, ", ".join(current_members))
        self.member_suggestions_combo.set("Selecionar Membro")

    def open_date_picker(self):
        current_date_str = self.due_date_entry.get()
        dialog = DatePickerDialog(self, current_date=current_date_str, icons=self.app.icons)
        self.wait_window(dialog)
        if dialog.result_date:
            self.due_date_entry.config(state="normal")
            self.due_date_entry.delete(0, tk.END)
            self.due_date_entry.insert(0, dialog.result_date.strftime("%Y-%m-%d"))
            self.due_date_entry.config(state="readonly")

    def toggle_time_fields(self):
        state = "normal" if self.include_time_var.get() else "disabled"
        self.hour_entry.config(state=state)
        self.minute_entry.config(state=state)

    def _open_subtask_details(self):
        """Abre janela detalhada da subtarefa selecionada"""
        selected_index = self.subtasks_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Seleção", "Por favor, selecione uma subtarefa para abrir.")
            return
        
        # Obter card_id para buscar subtarefas no banco
        card_id = self.card.get('card_id')
        if not card_id:
            messagebox.showerror("Erro", "Não foi possível identificar o cartão")
            return
        
        try:
            # Buscar subtarefas do banco
            subtasks = self.app.get_subtasks_for_card(card_id)
            
            # Filtrar subtarefas baseado no usuário logado
            filtered_subtasks = []
            current_user_member = self.app._get_current_user_member()
            
            for subtask in subtasks:
                # Administradores veem todas as subtarefas
                if hasattr(self.current_user, 'role') and self.current_user.role in ['admin', 'Administrador']:
                    filtered_subtasks.append(subtask)
                else:
                    # Usuários normais veem apenas subtarefas delegadas para eles
                    assigned_member = subtask.get('assigned_member')
                    if assigned_member == current_user_member or not assigned_member:
                        filtered_subtasks.append(subtask)
            
            # Ajustar índice para considerar cabeçalho e separador
            actual_index = selected_index[0] - 2
            if actual_index < 0 or actual_index >= len(filtered_subtasks):
                messagebox.showerror("Erro", "Índice de subtarefa inválido")
                return
            
            subtask = filtered_subtasks[actual_index]
            
            # Abrir janela detalhada da subtarefa
            SubTaskDetailWindow(self.app, self.card, subtask, self)
            
        except Exception as e:
            print(f"DEBUG: Erro ao abrir detalhes da subtarefa: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir detalhes da subtarefa: {e}")

    def _add_subtask(self):
        """Adiciona subtarefa ao banco de dados"""
        subtask_text = self.subtask_entry.get().strip()
        if subtask_text:
            # Obter membro delegado
            assigned_member = self.subtask_member_combo.get()
            if assigned_member == "Delegar para...":
                assigned_member = None
            
            # Obter card_id para salvar no banco
            card_id = self.card.get('card_id')
            if not card_id:
                messagebox.showerror("Erro", "Não foi possível identificar o cartão")
                return
            
            print(f"DEBUG: Adicionando subtarefa ao card: {card_id}")
            print(f"DEBUG: Texto: {subtask_text}, Membro: {assigned_member}")
            
            try:
                # Salvar subtarefa no banco de dados PostgreSQL
                # Buscar user_id se houver membro atribuído
                user_id = None
                if assigned_member:
                    # Buscar o user_id do membro atribuído
                    users = self.app.db.get_all_users()
                    for user in users:
                        if hasattr(user, 'cargo') and user.get('cargo') == assigned_member:
                            user_id = user.get('id')
                            break
                
                # Inserir nova subtarefa usando PostgreSQL
                subtask_id = self.app.db.create_subtask(
                    card_id=card_id,
                    title=subtask_text.upper(),
                    description='',
                    completed=False,
                    user_id=user_id
                )
                
                if not subtask_id:
                    print(f"DEBUG: Erro ao criar subtarefa no PostgreSQL")
                    messagebox.showerror("Erro", "Erro ao salvar subtarefa no banco de dados")
                    return
                
                print(f"DEBUG: Subtarefa salva com sucesso no banco")
                
                # Limpar campos
                self.subtask_entry.delete(0, tk.END)
                self.subtask_member_combo.set("Delegar para...")
                
                # Recarregar lista de subtarefas
                self._populate_subtasks_listbox()
                
            except Exception as e:
                print(f"DEBUG: Erro ao salvar subtarefa: {e}")
                messagebox.showerror("Erro", f"Erro ao salvar subtarefa: {e}")

    def _remove_subtask(self):
        """Remove subtarefa do banco de dados"""
        selected_index = self.subtasks_listbox.curselection()
        if selected_index:
            # Adjust index to account for header and separator
            actual_index = selected_index[0] - 2
            if actual_index < 0:
                return
            
            # Obter card_id para buscar subtarefas no banco
            card_id = self.card.get('card_id')
            if not card_id:
                messagebox.showerror("Erro", "Não foi possível identificar o cartão")
                return
            
            try:
                # Buscar subtarefas do banco
                subtasks = self.app.get_subtasks_for_card(card_id)
                
                # Filtrar subtarefas baseado no usuário logado
                filtered_subtasks = []
                current_user_member = self.app._get_current_user_member()
                
                for subtask in subtasks:
                    # Administradores veem todas as subtarefas
                    if hasattr(self.current_user, 'role') and self.current_user.role in ['admin', 'Administrador']:
                        filtered_subtasks.append(subtask)
                    else:
                        # Usuários normais veem apenas subtarefas delegadas para eles
                        assigned_member = subtask.get('assigned_member')
                        if assigned_member == current_user_member or not assigned_member:
                            filtered_subtasks.append(subtask)
                
                if actual_index < len(filtered_subtasks):
                    subtask_to_remove = filtered_subtasks[actual_index]
                    subtask_id = subtask_to_remove.get('id')
                    
                    if subtask_id:
                        # Remover do banco de dados PostgreSQL
                        success = self.app.db.delete_subtask(subtask_id)
                        
                        if not success:
                            print(f"DEBUG: Erro ao remover subtarefa do PostgreSQL")
                            messagebox.showerror("Erro", "Erro ao remover subtarefa do banco de dados")
                            return
                        
                        print(f"DEBUG: Subtarefa removida do banco: {subtask_to_remove.get('text', '')}")
                        
                        # Recarregar lista
                        self._populate_subtasks_listbox()
                    else:
                        print(f"DEBUG: Erro - subtarefa sem ID")
                        
            except Exception as e:
                print(f"DEBUG: Erro ao remover subtarefa: {e}")
                messagebox.showerror("Erro", f"Erro ao remover subtarefa: {e}")

    def _toggle_subtask_completion(self, event):
        """Versão corrigida para alternar status de conclusão da subtarefa"""
        selected_index = self.subtasks_listbox.nearest(event.y)
        if selected_index != -1:
            # Adjust index to account for header and separator
            actual_index = selected_index - 2
            if actual_index < 0:
                return
            
            # Obter card_id para buscar subtarefas no banco
            card_id = self.card.get('card_id')
            if not card_id:
                return
            
            try:
                # Buscar subtarefas do banco
                subtasks = self.app.get_subtasks_for_card(card_id)
                
                # Filtrar subtarefas baseado no usuário logado
                filtered_subtasks = []
                current_user_member = self.app._get_current_user_member()
                
                for subtask in subtasks:
                    # Administradores veem todas as subtarefas
                    if hasattr(self.current_user, 'role') and self.current_user.role in ['admin', 'Administrador']:
                        filtered_subtasks.append(subtask)
                    else:
                        # Usuários normais veem apenas subtarefas delegadas para eles
                        assigned_member = subtask.get('assigned_member')
                        if assigned_member == current_user_member or not assigned_member:
                            filtered_subtasks.append(subtask)
                
                if actual_index < len(filtered_subtasks):
                    subtask_to_toggle = filtered_subtasks[actual_index]
                    subtask_id = subtask_to_toggle.get('id')
                    
                    if subtask_id:
                        # Alternar status no banco de dados PostgreSQL
                        current_status = subtask_to_toggle.get('completed', False)
                        new_status = not current_status
                        
                        # Atualizar no banco com data de conclusão
                        success = self.app.db.update_subtask_completion(
                            subtask_id=subtask_id,
                            completed=new_status,
                            completed_at=datetime.now() if new_status else None
                        )
                        
                        if not success:
                            print(f"DEBUG: Erro ao atualizar status da subtarefa no PostgreSQL")
                            messagebox.showerror("Erro", "Erro ao atualizar status da subtarefa no banco de dados")
                            return
                        
                        # Atualizar dados locais
                        subtask_to_toggle['completed'] = new_status
                        if new_status:
                            subtask_to_toggle['completed_at'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        else:
                            subtask_to_toggle['completed_at'] = None
                        
                        print(f"DEBUG: Status da subtarefa alterado: {subtask_to_toggle.get('text', '')} -> {'Concluída' if new_status else 'Pendente'}")
                        
                        # Recarregar lista
                        self._populate_subtasks_listbox()
                        
                        # Notificar janelas de detalhes abertas
                        self._notify_subtask_details_windows(subtask_id, new_status)
                        
                    else:
                        print(f"DEBUG: Erro - subtarefa sem ID")
                        
            except Exception as e:
                print(f"DEBUG: Erro ao alternar status da subtarefa: {e}")
                messagebox.showerror("Erro", f"Erro ao alternar status da subtarefa: {e}")

    def _notify_subtask_details_windows(self, subtask_id, new_status):
        """Notifica janelas de detalhes abertas sobre mudança de status"""
        try:
            # Buscar janelas de detalhes abertas para esta subtarefa
            for window in self.winfo_children():
                if hasattr(window, 'subtask') and window.subtask.get('id') == subtask_id:
                    # Atualizar dados da subtarefa na janela
                    window.subtask['completed'] = new_status
                    if new_status:
                        window.subtask['completed_at'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    else:
                        window.subtask['completed_at'] = None
                    
                    # Recarregar dados na janela
                    if hasattr(window, '_load_subtask_data'):
                        window._load_subtask_data()
                    
                    print(f"DEBUG: Janela de detalhes atualizada para subtarefa {subtask_id}")
                    
        except Exception as e:
            print(f"DEBUG: Erro ao notificar janelas de detalhes: {e}")

    def _populate_subtasks_listbox(self):
        """Carrega subtarefas do banco de dados com filtragem por usuário"""
        self.subtasks_listbox.delete(0, tk.END)
        
        # Obter o card_id para buscar subtarefas no banco
        card_id = self.card.get('card_id')
        if not card_id:
            self.subtasks_listbox.insert(tk.END, "Nenhuma subtarefa adicionada")
            return
        
        print(f"DEBUG: Carregando subtarefas para card: {card_id}")
        
        # Buscar subtarefas do banco de dados
        subtasks = self.app.get_subtasks_for_card(card_id)
        print(f"DEBUG: Encontradas {len(subtasks)} subtarefas no banco")
        
        # Filtrar subtarefas baseado no usuário logado
        filtered_subtasks = []
        current_user_member = self.app._get_current_user_member()
        
        print(f"DEBUG: Usuário atual: {self.current_user.username}, Membro: {current_user_member}")
        
        for subtask in subtasks:
            # Administradores veem todas as subtarefas
            if hasattr(self.current_user, 'role') and self.current_user.role in ['admin', 'Administrador']:
                filtered_subtasks.append(subtask)
                print(f"DEBUG: Administrador - incluindo subtarefa: {subtask.get('text', '')}")
            else:
                # Usuários normais veem apenas subtarefas delegadas para eles
                assigned_member = subtask.get('assigned_member')
                if assigned_member == current_user_member or not assigned_member:
                    filtered_subtasks.append(subtask)
                    print(f"DEBUG: Usuário normal - incluindo subtarefa: {subtask.get('text', '')} (delegada para: {assigned_member})")
                else:
                    print(f"DEBUG: Usuário normal - filtrando subtarefa: {subtask.get('text', '')} (delegada para: {assigned_member})")
        
        print(f"DEBUG: Após filtragem: {len(filtered_subtasks)} subtarefas")
        
        if not filtered_subtasks:
            self.subtasks_listbox.insert(tk.END, "Nenhuma subtarefa adicionada")
            return
            
        completed_count = sum(1 for subtask in filtered_subtasks if subtask.get('completed', False))
        total_count = len(filtered_subtasks)
        
        # Add progress header
        progress_text = f"Progresso: {completed_count}/{total_count} ({completed_count/total_count*100:.0f}%)"
        self.subtasks_listbox.insert(tk.END, progress_text)
        self.subtasks_listbox.itemconfig(0, foreground='blue')
        
        # Add separator
        self.subtasks_listbox.insert(tk.END, "─" * 50)
        self.subtasks_listbox.itemconfig(1, foreground='gray')
        
        # Add subtasks
        for i, subtask in enumerate(filtered_subtasks):
            status_icon = "✓" if subtask.get('completed', False) else "○"
            display_text = f"{status_icon} {subtask.get('text', '')}"
            
            # Adicionar informação do membro delegado
            assigned_member = subtask.get('assigned_member')
            if assigned_member:
                display_text += f" → {assigned_member}"
            
            self.subtasks_listbox.insert(tk.END, display_text)
            listbox_index = i + 2  # +2 because of progress header and separator
            if subtask.get('completed', False):
                self.subtasks_listbox.itemconfig(listbox_index, foreground='gray', selectforeground='gray')
            else:
                self.subtasks_listbox.itemconfig(listbox_index, foreground='black', selectforeground='black')

    def _populate_dependency_combobox(self):
        all_cards = []
        for board_name, lists in self.app.boodesk_data["boards"].items():
            for list_name, cards in lists.items():
                for i, card_data in enumerate(cards):
                    # Don't allow a card to be a dependency of itself or an archived card
                    if card_data.get("card_id") != self.card.get("card_id") and not card_data.get("is_archived", False):
                        all_cards.append(f"{board_name} > {list_name} > {card_data['title']}")
        self.dependency_combo['values'] = sorted(list(set(all_cards)))

    def _add_dependency(self):
        selected_dependency_str = self.dependency_combo.get()
        if selected_dependency_str and selected_dependency_str not in self.card.get('dependencies', []):
            # Garantir que dependencies é uma lista
            dependencies = self.card.get('dependencies', [])
            if isinstance(dependencies, str):
                try:
                    import json
                    dependencies = json.loads(dependencies)
                except:
                    dependencies = []
            if not isinstance(dependencies, list):
                dependencies = []
            
            # Adicionar nova dependência
            dependencies.append(selected_dependency_str)
            self.card['dependencies'] = dependencies
            self._populate_dependencies_listbox()
            self.dependency_combo.set("")

    def _remove_dependency(self):
        selected_index = self.dependencies_listbox.curselection()
        if selected_index:
            # Adjust index to account for header and separator
            actual_index = selected_index[0] - 2
            if actual_index >= 0 and actual_index < len(self.card.get('dependencies', [])):
                del self.card['dependencies'][actual_index]
                self._populate_dependencies_listbox()

    def _populate_dependencies_listbox(self):
        self.dependencies_listbox.delete(0, tk.END)
        dependencies = self.card.get('dependencies', [])
        
        # Se dependencies é uma string JSON, converter para lista
        if isinstance(dependencies, str):
            try:
                import json
                dependencies = json.loads(dependencies)
            except:
                dependencies = []
        
        # Garantir que dependencies é uma lista
        if not isinstance(dependencies, list):
            dependencies = []
        
        if not dependencies:
            self.dependencies_listbox.insert(tk.END, "Nenhuma dependência adicionada")
            return
            
        # Add header with dependency status
        completed_deps = sum(1 for dep in dependencies if self.app._is_card_completed(dep))
        total_deps = len(dependencies)
        status_text = f"Dependências: {completed_deps}/{total_deps} Concluídas"
        self.dependencies_listbox.insert(tk.END, status_text)
        self.dependencies_listbox.itemconfig(0, foreground='blue')
        
        # Add separator
        self.dependencies_listbox.insert(tk.END, "─" * 50)
        self.dependencies_listbox.itemconfig(1, foreground='gray')
        
        # Add dependencies with detailed status
        for i, dep in enumerate(dependencies):
            is_completed = self.app._is_card_completed(dep)
            status = "Concluída" if is_completed else "Pendente"
            
            # Get card details for better display
            dep_parts = dep.split(" > ")
            if len(dep_parts) >= 3:
                board_name, list_name, card_title = dep_parts[0], dep_parts[1], dep_parts[2]
                # Check if card is in "Concluído" list
                if list_name == "Concluído":
                    status = "Concluída"
                else:
                    status = "Pendente"
                    
                display_text = f"{status} | {card_title} ({list_name})"
            else:
                display_text = f"{status} | {dep}"
                
            self.dependencies_listbox.insert(tk.END, display_text)
            listbox_index = i + 2  # +2 because of header and separator
            
            if is_completed:
                self.dependencies_listbox.itemconfig(listbox_index, foreground='green')
            else:
                self.dependencies_listbox.itemconfig(listbox_index, foreground='orange')
                
        # Add footer with card status
        if dependencies:
            can_start = all(self.app._is_card_completed(dep) for dep in dependencies)
            if can_start:
                self.dependencies_listbox.insert(tk.END, "Status: Card pode ser iniciado!")
                self.dependencies_listbox.itemconfig(len(dependencies) + 2, foreground='green')
            else:
                pending_count = total_deps - completed_deps
                self.dependencies_listbox.insert(tk.END, f"Status: Aguardando {pending_count} dependência(s)")
                self.dependencies_listbox.itemconfig(len(dependencies) + 2, foreground='orange')

    def save_card(self):
        # Capture original card state for history logging
        original_card = self.card.copy()
        
        # Tratar subtasks - converter string JSON para lista se necessário
        subtasks = self.card.get('subtasks', [])
        if isinstance(subtasks, str):
            try:
                import json
                subtasks = json.loads(subtasks)
            except:
                subtasks = []
        if not isinstance(subtasks, list):
            subtasks = []
        original_card['subtasks'] = [st.copy() for st in subtasks]
        
        # Tratar dependencies - converter string JSON para lista se necessário
        dependencies = self.card.get('dependencies', [])
        if isinstance(dependencies, str):
            try:
                import json
                dependencies = json.loads(dependencies)
            except:
                dependencies = []
        if not isinstance(dependencies, list):
            dependencies = []
        original_card['dependencies'] = dependencies.copy()
        
        # Tratar members - converter string JSON para lista se necessário
        members = self.card.get('members', [])
        if isinstance(members, str):
            try:
                import json
                members = json.loads(members)
            except:
                members = []
        if not isinstance(members, list):
            members = []
        original_card['members'] = members.copy()

        title = self.title_entry.get()
        desc = self.desc_text.get("1.0", tk.END).strip()
        due_date_str = self.due_date_entry.get()
        importance = self.importance_combo.get()
        category = self.category_combo.get()
        goal = self.goal_combo.get()
        members = list(self.assigned_members_listbox.get(0, tk.END)) # Convert tuple to list

        if not title:
            messagebox.showwarning("Campo Obrigatório", "O título da tarefa é obrigatório.")
            return

        full_due_date = due_date_str
        if self.include_time_var.get():
            hour = self.hour_entry.get().strip()
            minute = self.minute_entry.get().strip()
            if hour and minute:
                try:
                    h = int(hour)
                    m = int(minute)
                    if 0 <= h <= 23 and 0 <= m <= 59:
                        full_due_date = f"{due_date_str} {h:02d}:{m:02d}"
                    else:
                        messagebox.showwarning("Entrada Inválida", "Hora ou minuto inválidos.")
                        return
                except ValueError:
                    messagebox.showwarning("Entrada Inválida", "Hora e minuto devem ser números.")
                    return
            else:
                messagebox.showwarning("Entrada Inválida", "Preencha a hora e o minuto ou desmarque 'Incluir Horário'.")
                return
        
        # Update card data
        self.card['title'] = title.upper()
        self.card['desc'] = desc
        self.card['due_date'] = full_due_date
        self.card['importance'] = importance
        self.card['category'] = category
        self.card['goal'] = goal
        self.card['members'] = members
        if self.app.settings.get('dev_mode', False):
            self.card['git_branch'] = self.git_branch_var.get()
            self.card['git_commit'] = self.git_commit_var.get()
            self.card['git_pr'] = self.git_pr_var.get()
        # Subtasks and dependencies are already updated directly in self.card by their respective methods

        # Log changes to history
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        user_name = self.current_user.username

        def add_history_entry(action_desc):
            # Garantir que history é uma lista
            history = self.card.get('history', [])
            if isinstance(history, str):
                try:
                    import json
                    history = json.loads(history)
                except:
                    history = []
            if not isinstance(history, list):
                history = []
            
            # Adicionar nova entrada ao histórico
            history.append({"timestamp": current_time, "action": action_desc, "user": user_name})
            self.card['history'] = history

        # Title
        if self.card.get('title', '') != original_card.get('title', ''):
            add_history_entry(f"Título alterado de '{original_card.get('title', '')}' para '{self.card.get('title', '')}'.")

        # Description
        if self.card.get('desc', '') != original_card.get('desc', ''):
            add_history_entry(f"Descrição alterada.")

        # Due Date
        if self.card.get('due_date', '') != original_card.get('due_date', ''):
            add_history_entry(f"Prazo alterado de '{original_card.get('due_date', '')}' para '{self.card.get('due_date', '')}'.")

        # Importance
        if self.card.get('importance', '') != original_card.get('importance', ''):
            add_history_entry(f"Importância alterada de '{original_card.get('importance', '')}' para '{self.card.get('importance', '')}'.")

        # Category
        if self.card.get('category', '-') != original_card.get('category', '-'):
            add_history_entry(f"Categoria alterada de '{original_card.get('category', '-')}' para '{self.card.get('category', '-')}'.")

        # Goal
        if self.card.get('goal', '') != original_card.get('goal', ''):
            add_history_entry(f"Objetivo alterado de '{original_card.get('goal', '')}' para '{self.card.get('goal', '')}'.")

        # Members
        current_members = self.card.get('members', [])
        original_members = original_card.get('members', [])
        added_members = [m for m in current_members if m not in original_members]
        removed_members = [m for m in original_members if m not in current_members]
        for member in added_members:
            add_history_entry(f"Membro '{member}' adicionado.")
        for member in removed_members:
            add_history_entry(f"Membro '{member}' removido.")

        # Subtasks (more complex, check for additions, removals, and completion changes)
        # Garantir que subtasks são listas
        original_subtasks = original_card.get('subtasks', [])
        if isinstance(original_subtasks, str):
            try:
                import json
                original_subtasks = json.loads(original_subtasks)
            except:
                original_subtasks = []
        if not isinstance(original_subtasks, list):
            original_subtasks = []
            
        current_subtasks = self.card.get('subtasks', [])
        if isinstance(current_subtasks, str):
            try:
                import json
                current_subtasks = json.loads(current_subtasks)
            except:
                current_subtasks = []
        if not isinstance(current_subtasks, list):
            current_subtasks = []
            
        original_subtasks_map = {st['text']: st['completed'] for st in original_subtasks}
        current_subtasks_map = {st['text']: st['completed'] for st in current_subtasks}

        for subtask_text, completed_status in current_subtasks_map.items():
            if subtask_text not in original_subtasks_map:
                add_history_entry(f"Subtarefa '{subtask_text}' adicionada.")
            elif original_subtasks_map[subtask_text] != completed_status:
                status_change = "concluída" if completed_status else "reaberta"
                add_history_entry(f"Subtarefa '{subtask_text}' marcada como {status_change}.")
        
        for subtask_text in original_subtasks_map:
            if subtask_text not in current_subtasks_map:
                add_history_entry(f"Subtarefa '{subtask_text}' removida.")

        # Dependencies (check for additions and removals)
        # Garantir que dependencies são listas
        current_dependencies = self.card.get('dependencies', [])
        if isinstance(current_dependencies, str):
            try:
                import json
                current_dependencies = json.loads(current_dependencies)
            except:
                current_dependencies = []
        if not isinstance(current_dependencies, list):
            current_dependencies = []
            
        original_dependencies = original_card.get('dependencies', [])
        if isinstance(original_dependencies, str):
            try:
                import json
                original_dependencies = json.loads(original_dependencies)
            except:
                original_dependencies = []
        if not isinstance(original_dependencies, list):
            original_dependencies = []
            
        added_dependencies = [d for d in current_dependencies if d not in original_dependencies]
        removed_dependencies = [d for d in original_dependencies if d not in current_dependencies]
        for dep in added_dependencies:
            add_history_entry(f"Dependência '{dep}' adicionada.")
        for dep in removed_dependencies:
            add_history_entry(f"Dependência '{dep}' removida.")

        # Find the card in the main data structure and update it
        found_card = False
        
        for i, card_data in enumerate(self.app.boodesk_data["boards"][self.board_name][self.list_name]):
            if card_data.get('card_id') == self.card_id:
                self.app.boodesk_data["boards"][self.board_name][self.list_name][i] = self.card
                found_card = True
                break
        
        if not found_card:
            messagebox.showerror("Erro", "Não foi possível encontrar o cartão para salvar as alterações.")
            return

        self.app.save_trello_data()
        
        # Sincronizar com Google Calendar se habilitado
        if self.app.settings.get('google_calendar_enabled', False):
            self._sync_card_to_calendar()
        
        if self.callback_on_close:
            self.callback_on_close(saved=True)
        self.destroy()

    def start_pomodoro_action(self):
        # Find the card index using card_id
        card_index = -1
        for i, card_data in enumerate(self.app.boodesk_data["boards"][self.board_name][self.list_name]):
            if card_data.get('card_id') == self.card_id:
                card_index = i
                break
        
        if card_index != -1:
            self.app.start_pomodoro_from_card(self.board_name, self.list_name, card_index)
        self.destroy()

    def complete_card_action(self):
        # Find the card index using card_id
        card_index = -1
        for i, card_data in enumerate(self.app.boodesk_data["boards"][self.board_name][self.list_name]):
            if card_data.get('card_id') == self.card_id:
                card_index = i
                break
        
        if card_index != -1:
            self.app.complete_trello_card(self.board_name, self.list_name, card_index)
        self.destroy()

    def _sync_card_to_calendar(self):
        """Sincroniza o card com o Google Calendar"""
        try:
            # Verificar se o Google Calendar está configurado
            if not hasattr(self.app, 'google_calendar') or not self.app.google_calendar.is_authenticated:
                print("Google Calendar não está autenticado")
                return
            
            # Verificar se há data de vencimento
            if not self.card.get('due_date'):
                print("Card não possui data de vencimento")
                return
            
            # Usar função auxiliar para processar data brasileira
            event_datetime = self.app.parse_brazilian_date(self.card['due_date'])
            
            if not event_datetime:
                print(f"Formato de data inválido: {self.card['due_date']}")
                return
            
            # Criar evento no Google Calendar
            event_title = f"📋 {self.card['title']}"
            event_description = f"""
Card: {self.card['title']}
Descrição: {self.card.get('desc', 'Sem descrição')}
Importância: {self.card.get('importance', 'Normal')}
Assunto: {self.card.get('subject', '-')}
Objetivo: {self.card.get('goal', '-')}
Membros: {', '.join(self.card.get('members', []))}
Board: {self.board_name}
Lista: {self.list_name}
Card ID: {self.card_id}
            """.strip()
            
            # Definir duração do evento (1 hora por padrão)
            event_duration = timedelta(hours=1)
            
            # Coletar emails para o evento
            attendees = []
            
            # Adicionar emails padrão se habilitado
            calendar_settings = self.app.settings.get('calendar_integration', {})
            if calendar_settings.get('include_default_emails', True):
                default_emails = calendar_settings.get('default_emails', [])
                attendees.extend(default_emails)
            
            # Adicionar membros do card se habilitado
            if calendar_settings.get('include_card_members', True):
                card_members = self.card.get('members', [])
                for member in card_members:
                    # Buscar email do membro no arquivo de membros
                    member_email = self._get_member_email(member)
                    if member_email:
                        attendees.append(member_email)
            
            # Remover duplicatas
            attendees = list(set(attendees))
            
            # Criar evento
            success = self.app.google_calendar.create_event(
                title=event_title,
                description=event_description,
                start_datetime=event_datetime,
                duration=event_duration,
                card_id=self.card_id,
                attendees=attendees if attendees else None
            )
            
            if success:
                print(f"✅ Evento criado no Google Calendar para o card: {self.card['title']}")
                # Adicionar ao histórico do card
                # Garantir que history é uma lista
                history = self.card.get('history', [])
                if isinstance(history, str):
                    try:
                        import json
                        history = json.loads(history)
                    except:
                        history = []
                if not isinstance(history, list):
                    history = []
                
                # Adicionar nova entrada ao histórico
                history.append({
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "action": f"Evento criado no Google Calendar",
                    "user": self.current_user.username
                })
                self.card['history'] = history
            else:
                print(f"❌ Erro ao criar evento no Google Calendar para o card: {self.card['title']}")
                
        except Exception as e:
            print(f"❌ Erro na sincronização com Google Calendar: {e}")
            import traceback
            traceback.print_exc()

    def _get_member_email(self, member_name):
        """Busca o email de um membro no arquivo de membros"""
        try:
            if hasattr(self.app, 'members') and self.app.members:
                print(f"DEBUG: Buscando email para membro '{member_name}' (CardWindow)")
                print(f"DEBUG: Total de membros carregados: {len(self.app.members)}")
                for member in self.app.members:
                    print(f"DEBUG: Verificando membro: {member}")
                    if member.get('Membro') == member_name:
                        email = member.get('email', '')
                        print(f"DEBUG: Email encontrado para '{member_name}': {email}")
                        return email
                print(f"DEBUG: Membro '{member_name}' não encontrado")
            else:
                print(f"DEBUG: Lista de membros não disponível ou vazia")
            return None
        except Exception as e:
            print(f"Erro ao buscar email do membro {member_name}: {e}")
            return None

    # Git Integration Methods
    def update_git_status(self):
        """Update the Git status display"""
        if hasattr(self, 'git_status_label'):
            if self.git_branch_var.get():
                self.git_status_label.config(text="Configurado", foreground="green")
            else:
                self.git_status_label.config(text="Não configurado", foreground="gray")
            
            # Update Git history
            if hasattr(self, 'git_history_text'):
                self.update_git_history()

    def update_git_history(self):
        """Update the Git history display"""
        if hasattr(self, 'git_history_text'):
            self.git_history_text.config(state="normal")
            self.git_history_text.delete("1.0", tk.END)
            
            history_text = "Histórico Git:\n"
            if self.git_branch_var.get():
                history_text += f"Branch: {self.git_branch_var.get()}\n"
            if self.git_commit_var.get():
                history_text += f"Commit: {self.git_commit_var.get()}\n"
            if self.git_pr_var.get():
                history_text += f"PR: {self.git_pr_var.get()}\n"
            
            if not any([self.git_branch_var.get(), self.git_commit_var.get(), self.git_pr_var.get()]):
                history_text += "Nenhuma informação Git disponível"
            
            self.git_history_text.insert("1.0", history_text)
            self.git_history_text.config(state="disabled")

    def init_git_repo(self):
        """Initialize Git repository for this card"""
        try:
            import subprocess
            import os
            
            # Create a directory for this card's Git repo
            repo_dir = os.path.join(self.app.base_dir, f"git_repos/{self.card_id}")
            os.makedirs(repo_dir, exist_ok=True)
            
            # Initialize Git repository
            result = subprocess.run(['git', 'init'], cwd=repo_dir, capture_output=True, text=True)
            
            if result.returncode == 0:
                messagebox.showinfo("Git", "Repositório Git inicializado com sucesso!")
                self.git_branch_var.set("main")
                self.update_git_status()
            else:
                messagebox.showerror("Erro Git", f"Erro ao inicializar repositório: {result.stderr}")
                
        except Exception as e:
            messagebox.showerror("Erro Git", f"Erro ao inicializar repositório Git: {e}")

    def create_git_branch(self):
        """Create a new Git branch for this card"""
        branch_name = simpledialog.askstring("Criar Branch", "Nome da nova branch:", parent=self)
        if branch_name:
            try:
                import subprocess
                import os
                
                repo_dir = os.path.join(self.app.base_dir, f"git_repos/{self.card_id}")
                
                if not os.path.exists(os.path.join(repo_dir, '.git')):
                    messagebox.showerror("Erro Git", "Repositório Git não inicializado. Use 'Inicializar Repo' primeiro.")
                    return
                
                # Create and checkout new branch
                result = subprocess.run(['git', 'checkout', '-b', branch_name], cwd=repo_dir, capture_output=True, text=True)
                
                if result.returncode == 0:
                    self.git_branch_var.set(branch_name)
                    self.update_git_status()
                    messagebox.showinfo("Git", f"Branch '{branch_name}' criada e ativada!")
                else:
                    messagebox.showerror("Erro Git", f"Erro ao criar branch: {result.stderr}")
                    
            except Exception as e:
                messagebox.showerror("Erro Git", f"Erro ao criar branch Git: {e}")

    def make_git_commit(self):
        """Make a Git commit for this card"""
        commit_message = simpledialog.askstring("Commit", "Mensagem do commit:", parent=self)
        if commit_message:
            try:
                import subprocess
                import os
                
                repo_dir = os.path.join(self.app.base_dir, f"git_repos/{self.card_id}")
                
                if not os.path.exists(os.path.join(repo_dir, '.git')):
                    messagebox.showerror("Erro Git", "Repositório Git não inicializado. Use 'Inicializar Repo' primeiro.")
                    return
                
                # Add all files and commit
                subprocess.run(['git', 'add', '.'], cwd=repo_dir, capture_output=True)
                result = subprocess.run(['git', 'commit', '-m', commit_message], cwd=repo_dir, capture_output=True, text=True)
                
                if result.returncode == 0:
                    # Get the commit hash
                    commit_result = subprocess.run(['git', 'rev-parse', 'HEAD'], cwd=repo_dir, capture_output=True, text=True)
                    if commit_result.returncode == 0:
                        commit_hash = commit_result.stdout.strip()[:8]  # First 8 characters
                        self.git_commit_var.set(commit_hash)
                        self.update_git_status()
                        messagebox.showinfo("Git", f"Commit realizado com sucesso!\nHash: {commit_hash}")
                    else:
                        messagebox.showinfo("Git", "Commit realizado com sucesso!")
                else:
                    messagebox.showerror("Erro Git", f"Erro ao fazer commit: {result.stderr}")
                    
            except Exception as e:
                messagebox.showerror("Erro Git", f"Erro ao fazer commit Git: {e}")

    def destroy(self):
        if self.callback_on_close:
            self.callback_on_close(saved=False)
        super().destroy()

    def _get_current_user_member(self):
        """Retorna o nome do membro associado ao usuário logado"""
        try:
            if not self.current_user:
                return None
            
            username = self.current_user.username
            
            # Buscar o usuário no PostgreSQL
            user_data = self.db.get_user_by_username(username)
            
            if user_data and user_data.get('member_id'):
                member_id = user_data['member_id']
                # Buscar o nome do membro usando o member_id
                members = self.db.get_all_members()
                for member in members:
                    if member['id'] == member_id:
                        member_name = member['name']
                        print(f"DEBUG: Usuário {username} associado ao membro {member_name}")
                        return member_name
            
            print(f"DEBUG: Usuário {username} não tem membro associado")
            return None
            
        except Exception as e:
            print(f"DEBUG: Erro ao buscar membro do usuário: {e}")
            return None

    # Chamar update_all_displays após todos os métodos serem definidos
    def initialize_displays(self):
        """Inicializa todos os displays após a classe estar completamente definida"""
        print("DEBUG: Chamando update_all_displays")
        self.update_all_displays()
        print("DEBUG: update_all_displays concluído")

    def open_advanced_card_manager(self):
        """Abre o gerenciador avançado de cards"""
        try:
            # Criar janela do gerenciador avançado
            manager_window = tk.Toplevel(self)
            manager_window.title(f"Gerenciador Avançado - {self.card.get('title', 'Card')}")
            manager_window.geometry("1000x700")
            manager_window.transient(self)
            manager_window.grab_set()
            
            # Centralizar janela
            manager_window.update_idletasks()
            screen_width = manager_window.winfo_screenwidth()
            screen_height = manager_window.winfo_screenheight()
            window_width = 1000
            window_height = 700
            x = (screen_width - window_width) // 2
            y = (screen_height - window_height) // 2
            manager_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            # Criar notebook para organizar as seções
            notebook = ttk.Notebook(manager_window)
            notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Aba de Tags
            tags_frame = ttk.Frame(notebook)
            notebook.add(tags_frame, text="Tags")
            self._create_tags_tab(tags_frame)
            
            # Aba de Checklist
            checklist_frame = ttk.Frame(notebook)
            notebook.add(checklist_frame, text="Checklist")
            self._create_checklist_tab(checklist_frame)
            
            # Aba de Comentários
            comments_frame = ttk.Frame(notebook)
            notebook.add(comments_frame, text="Comentários")
            self._create_comments_tab(comments_frame)
            
            # Aba de Dependências
            dependencies_frame = ttk.Frame(notebook)
            notebook.add(dependencies_frame, text="Dependências")
            self._create_dependencies_tab(dependencies_frame)
            
            # Aba de Tempo
            time_frame = ttk.Frame(notebook)
            notebook.add(time_frame, text="Tempo")
            self._create_time_tab(time_frame)
            
            # Aba de Configurações
            config_frame = ttk.Frame(notebook)
            notebook.add(config_frame, text="Configurações")
            self._create_config_tab(config_frame)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir gerenciador avançado: {e}")

    def _create_tags_tab(self, parent):
        """Cria a aba de tags"""
        # Frame principal
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Tags disponíveis
        available_frame = ttk.LabelFrame(main_frame, text="Tags Disponíveis", padding="5")
        available_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Lista de tags disponíveis
        self.tags_listbox = tk.Listbox(available_frame, height=6)
        self.tags_listbox.pack(fill=tk.X, pady=5)
        
        # Botões para tags
        tags_buttons_frame = ttk.Frame(available_frame)
        tags_buttons_frame.pack(fill=tk.X)
        
        ttk.Button(tags_buttons_frame, text="Adicionar Tag", 
                  command=self._add_tag_to_card).pack(side=tk.LEFT, padx=5)
        ttk.Button(tags_buttons_frame, text="Remover Tag", 
                  command=self._remove_tag_from_card).pack(side=tk.LEFT, padx=5)
        
        # Tags do card
        card_tags_frame = ttk.LabelFrame(main_frame, text="Tags do Card", padding="5")
        card_tags_frame.pack(fill=tk.BOTH, expand=True)
        
        self.card_tags_listbox = tk.Listbox(card_tags_frame)
        self.card_tags_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Carregar tags
        self._load_tags()

    def _create_checklist_tab(self, parent):
        """Cria a aba de checklist"""
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Adicionar item
        add_frame = ttk.Frame(main_frame)
        add_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(add_frame, text="Novo item:").pack(side=tk.LEFT)
        self.checklist_entry = ttk.Entry(add_frame)
        self.checklist_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        ttk.Button(add_frame, text="Adicionar", 
                  command=self._add_checklist_item).pack(side=tk.LEFT, padx=5)
        
        # Lista de itens
        checklist_frame = ttk.LabelFrame(main_frame, text="Itens do Checklist", padding="5")
        checklist_frame.pack(fill=tk.BOTH, expand=True)
        
        self.checklist_tree = ttk.Treeview(checklist_frame, columns=("Item", "Status"), show="headings")
        self.checklist_tree.heading("Item", text="Item")
        self.checklist_tree.heading("Status", text="Status")
        self.checklist_tree.column("Item", width=300)
        self.checklist_tree.column("Status", width=100)
        self.checklist_tree.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Carregar checklist
        self._load_checklist()

    def _create_comments_tab(self, parent):
        """Cria a aba de comentários"""
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Adicionar comentário
        add_frame = ttk.Frame(main_frame)
        add_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(add_frame, text="Novo comentário:").pack(anchor=tk.W)
        self.comment_text = tk.Text(add_frame, height=4)
        self.comment_text.pack(fill=tk.X, pady=5)
        
        ttk.Button(add_frame, text="Adicionar Comentário", 
                  command=self._add_comment).pack(pady=5)
        
        # Lista de comentários
        comments_frame = ttk.LabelFrame(main_frame, text="Comentários", padding="5")
        comments_frame.pack(fill=tk.BOTH, expand=True)
        
        self.comments_tree = ttk.Treeview(comments_frame, columns=("Data", "Autor", "Comentário"), show="headings")
        self.comments_tree.heading("Data", text="Data")
        self.comments_tree.heading("Autor", text="Autor")
        self.comments_tree.heading("Comentário", text="Comentário")
        self.comments_tree.column("Data", width=150)
        self.comments_tree.column("Autor", width=100)
        self.comments_tree.column("Comentário", width=300)
        self.comments_tree.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Carregar comentários
        self._load_comments()

    def _create_dependencies_tab(self, parent):
        """Cria a aba de dependências"""
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Adicionar dependência
        add_frame = ttk.Frame(main_frame)
        add_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(add_frame, text="Card dependente:").pack(side=tk.LEFT)
        self.dependency_combo = ttk.Combobox(add_frame, state="readonly")
        self.dependency_combo.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        ttk.Button(add_frame, text="Adicionar", 
                  command=self._add_dependency).pack(side=tk.LEFT, padx=5)
        
        # Lista de dependências
        deps_frame = ttk.LabelFrame(main_frame, text="Dependências", padding="5")
        deps_frame.pack(fill=tk.BOTH, expand=True)
        
        self.dependencies_tree = ttk.Treeview(deps_frame, columns=("Card", "Status"), show="headings")
        self.dependencies_tree.heading("Card", text="Card Dependente")
        self.dependencies_tree.heading("Status", text="Status")
        self.dependencies_tree.column("Card", width=300)
        self.dependencies_tree.column("Status", width=100)
        self.dependencies_tree.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Carregar dependências
        self._load_dependencies()

    def _create_time_tab(self, parent):
        """Cria a aba de tempo"""
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Log de tempo
        time_frame = ttk.LabelFrame(main_frame, text="Log de Tempo", padding="5")
        time_frame.pack(fill=tk.BOTH, expand=True)
        
        self.time_tree = ttk.Treeview(time_frame, columns=("Data", "Tempo", "Descrição"), show="headings")
        self.time_tree.heading("Data", text="Data")
        self.time_tree.heading("Tempo", text="Tempo (min)")
        self.time_tree.heading("Descrição", text="Descrição")
        self.time_tree.column("Data", width=150)
        self.time_tree.column("Tempo", width=100)
        self.time_tree.column("Descrição", width=300)
        self.time_tree.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Carregar log de tempo
        self._load_time_log()

    def _create_config_tab(self, parent):
        """Cria a aba de configurações"""
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configurações do card
        config_frame = ttk.LabelFrame(main_frame, text="Configurações do Card", padding="5")
        config_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Prioridade
        ttk.Label(config_frame, text="Prioridade:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)
        self.priority_combo = ttk.Combobox(config_frame, values=["Baixa", "Média", "Alta", "Urgente"], state="readonly")
        self.priority_combo.grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)
        
        # Complexidade
        ttk.Label(config_frame, text="Complexidade:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)
        self.complexity_combo = ttk.Combobox(config_frame, values=["Simples", "Média", "Complexa"], state="readonly")
        self.complexity_combo.grid(row=1, column=1, sticky=tk.W, padx=5, pady=2)
        
        # Progresso
        ttk.Label(config_frame, text="Progresso (%):").grid(row=2, column=0, sticky=tk.W, padx=5, pady=2)
        self.progress_scale = ttk.Scale(config_frame, from_=0, to=100, orient=tk.HORIZONTAL)
        self.progress_scale.grid(row=2, column=1, sticky=tk.EW, padx=5, pady=2)
        
        # Botão salvar
        ttk.Button(config_frame, text="Salvar Configurações", 
                  command=self._save_card_config).grid(row=3, column=0, columnspan=2, pady=10)
        
        # Carregar configurações atuais
        self._load_card_config()

    def _load_tags(self):
        """Carrega tags disponíveis e do card"""
        try:
            # Carregar tags disponíveis
            available_tags = self.app.db.get_card_tags()
            self.tags_listbox.delete(0, tk.END)
            for tag in available_tags:
                self.tags_listbox.insert(tk.END, tag['name'])
            
            # Carregar tags do card
            card_tags = self.app.db.get_card_tags_by_card(self.card['id'])
            self.card_tags_listbox.delete(0, tk.END)
            for tag in card_tags:
                self.card_tags_listbox.insert(tk.END, tag['name'])
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar tags: {e}")

    def _add_tag_to_card(self):
        """Adiciona tag ao card"""
        try:
            selection = self.tags_listbox.curselection()
            if not selection:
                messagebox.showwarning("Aviso", "Selecione uma tag para adicionar")
                return
            
            tag_name = self.tags_listbox.get(selection[0])
            self.app.db.add_card_tag(self.card['id'], tag_name)
            self._load_tags()
            messagebox.showinfo("Sucesso", f"Tag '{tag_name}' adicionada ao card")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar tag: {e}")

    def _remove_tag_from_card(self):
        """Remove tag do card"""
        try:
            selection = self.card_tags_listbox.curselection()
            if not selection:
                messagebox.showwarning("Aviso", "Selecione uma tag para remover")
                return
            
            tag_name = self.card_tags_listbox.get(selection[0])
            self.app.db.remove_card_tag(self.card['id'], tag_name)
            self._load_tags()
            messagebox.showinfo("Sucesso", f"Tag '{tag_name}' removida do card")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao remover tag: {e}")

    def _load_checklist(self):
        """Carrega checklist do card"""
        try:
            checklists = self.app.db.get_card_checklists(self.card['id'])
            self.checklist_tree.delete(*self.checklist_tree.get_children())
            
            for checklist in checklists:
                items = self.app.db.get_checklist_items(checklist['id'])
                for item in items:
                    status = "✓" if item['completed'] else "☐"
                    self.checklist_tree.insert("", "end", values=(item['description'], status))
                    
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar checklist: {e}")

    def _add_checklist_item(self):
        """Adiciona item ao checklist"""
        try:
            description = self.checklist_entry.get().strip()
            if not description:
                messagebox.showwarning("Aviso", "Digite uma descrição para o item")
                return
            
            # Criar checklist se não existir
            checklists = self.app.db.get_card_checklists(self.card['id'])
            if not checklists:
                checklist_id = self.app.db.create_card_checklist(self.card['id'], "Checklist Principal")
            else:
                checklist_id = checklists[0]['id']
            
            # Adicionar item
            self.app.db.add_checklist_item(checklist_id, description)
            self.checklist_entry.delete(0, tk.END)
            self._load_checklist()
            messagebox.showinfo("Sucesso", "Item adicionado ao checklist")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar item: {e}")

    def _load_comments(self):
        """Carrega comentários do card"""
        try:
            comments = self.app.db.get_card_comments(self.card['id'])
            self.comments_tree.delete(*self.comments_tree.get_children())
            
            for comment in comments:
                self.comments_tree.insert("", "end", values=(
                    comment['created_at'][:10],
                    comment['author'],
                    comment['content']
                ))
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar comentários: {e}")

    def _add_comment(self):
        """Adiciona comentário ao card"""
        try:
            content = self.comment_text.get("1.0", tk.END).strip()
            if not content:
                messagebox.showwarning("Aviso", "Digite um comentário")
                return
            
            author = "Usuário"  # TODO: Pegar usuário atual
            self.app.db.add_card_comment(self.card['id'], author, content)
            self.comment_text.delete("1.0", tk.END)
            self._load_comments()
            messagebox.showinfo("Sucesso", "Comentário adicionado")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar comentário: {e}")

    def _load_dependencies(self):
        """Carrega dependências do card"""
        try:
            dependencies = self.app.db.get_card_dependencies(self.card['id'])
            self.dependencies_tree.delete(*self.dependencies_tree.get_children())
            
            for dep in dependencies:
                # Buscar informações do card dependente
                dependent_card = self.app.get_card_by_id(dep['dependent_card_id'])
                status = dependent_card.get('status', 'unknown') if dependent_card else 'unknown'
                title = dependent_card.get('title', 'Card não encontrado') if dependent_card else 'Card não encontrado'
                
                self.dependencies_tree.insert("", "end", values=(title, status))
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar dependências: {e}")

    def _add_dependency(self):
        """Adiciona dependência ao card"""
        try:
            # TODO: Implementar seleção de card dependente
            messagebox.showinfo("Info", "Funcionalidade de dependências será implementada em breve")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar dependência: {e}")

    def _load_time_log(self):
        """Carrega log de tempo do card"""
        try:
            time_logs = self.app.db.get_card_time_logs(self.card['id'])
            self.time_tree.delete(*self.time_tree.get_children())
            
            for log in time_logs:
                self.time_tree.insert("", "end", values=(
                    log['logged_at'][:10],
                    log['time_spent'],
                    log['description']
                ))
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar log de tempo: {e}")

    def _load_card_config(self):
        """Carrega configurações atuais do card"""
        try:
            # Carregar valores atuais do card
            priority = self.card.get('priority', 'Média')
            complexity = self.card.get('complexity', 'Média')
            progress = self.card.get('progress', 0)
            
            self.priority_combo.set(priority)
            self.complexity_combo.set(complexity)
            self.progress_scale.set(progress)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar configurações: {e}")

    def _save_card_config(self):
        """Salva configurações do card"""
        try:
            priority = self.priority_combo.get()
            complexity = self.complexity_combo.get()
            progress = int(self.progress_scale.get())
            
            # Atualizar card no banco
            self.app.db.update_card_progress(self.card['id'], progress, priority, complexity)
            
            # Atualizar card local
            self.card['priority'] = priority
            self.card['complexity'] = complexity
            self.card['progress'] = progress
            
            messagebox.showinfo("Sucesso", "Configurações salvas com sucesso")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar configurações: {e}")

class MembersWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Gerenciar Membros")
        self.geometry("1000x700") # Increased size for photo and additional fields
        self.resizable(True, True)  # Allow resizing
        self.minsize(900, 650)  # Minimum size
        self.transient(parent)
        self.grab_set()
        
        # Variables for edit mode
        self.edit_mode = False
        self.selected_member = None
        
        # Initialize image upload manager
        self.image_manager = ImageUploadManager()
        self.current_photo_path = None
        self.photo_preview = None

        # Center the window on screen
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 800
        window_height = 600
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        self._populate_members_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure main frame for better layout
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)  # List frame should expand
        
        # Title
        title_label = ttk.Label(main_frame, text="Gerenciamento de Membros", font=("Arial", 12, "bold"))
        title_label.grid(row=0, column=0, pady=(0, 10), sticky="w")

        # Member List Frame
        list_frame = ttk.LabelFrame(main_frame, text="Lista de Membros", padding="5")
        list_frame.grid(row=1, column=0, sticky="nsew", pady=(0, 10))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        self.members_tree = ttk.Treeview(list_frame, columns=("Membro", "Cargo", "Email"), show="headings")
        self.members_tree.heading("Membro", text="Membro")
        self.members_tree.heading("Cargo", text="Cargo")
        self.members_tree.heading("Email", text="Email")
        self.members_tree.column("Membro", width=150, anchor="w")
        self.members_tree.column("Cargo", width=100, anchor="w")
        self.members_tree.column("Email", width=200, anchor="w")
        self.members_tree.grid(row=0, column=0, sticky="nsew", pady=5)
        self.members_tree.bind("<<TreeviewSelect>>", self._on_member_select)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Membro", padding="10")
        entry_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        entry_frame.columnconfigure(1, weight=1) # Make entry expandable
        entry_frame.columnconfigure(2, weight=0) # Photo column

        # Photo upload section
        photo_frame = ttk.Frame(entry_frame)
        photo_frame.grid(row=0, column=2, rowspan=6, padx=(10, 0), sticky="n")
        
        ttk.Label(photo_frame, text="Foto de Perfil", font=("Arial", 10, "bold")).pack(pady=(0, 5))
        
        # Photo preview
        self.photo_label = ttk.Label(photo_frame, text="📷\nSem foto", 
                                   font=("Arial", 24), 
                                   relief="solid", 
                                   borderwidth=1,
                                   width=12)
        self.photo_label.pack(pady=(0, 5))
        
        # Photo buttons
        photo_buttons_frame = ttk.Frame(photo_frame)
        photo_buttons_frame.pack(fill=tk.X)
        
        ttk.Button(photo_buttons_frame, text="📁 Selecionar", 
                  command=self._select_photo).pack(side=tk.LEFT, padx=(0, 2))
        ttk.Button(photo_buttons_frame, text="🗑️ Remover", 
                  command=self._remove_photo).pack(side=tk.LEFT, padx=(2, 0))

        # Member information fields
        ttk.Label(entry_frame, text="Nome do Membro:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.member_name_entry = ttk.Entry(entry_frame)
        self.member_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(entry_frame, text="Cargo:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.role_combo = ttk.Combobox(entry_frame, values=list(self.app.settings["roles"].keys()), state="readonly")
        self.role_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        self.role_combo.set("Usuário") # Default role

        ttk.Label(entry_frame, text="Email:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        self.email_entry = ttk.Entry(entry_frame)
        self.email_entry.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        
        # Adicionar instrução sobre o email
        email_info = ttk.Label(entry_frame, text="(Opcional - usado para convites do Google Calendar)", 
                              font=("Arial", 8), foreground="gray")
        email_info.grid(row=3, column=0, columnspan=2, sticky="w", padx=5, pady=(0, 5))
        
        # Additional fields
        ttk.Label(entry_frame, text="Telefone:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.phone_entry = ttk.Entry(entry_frame)
        self.phone_entry.grid(row=4, column=1, sticky="ew", padx=5, pady=2)
        
        ttk.Label(entry_frame, text="Departamento:").grid(row=5, column=0, sticky="w", padx=5, pady=2)
        self.department_entry = ttk.Entry(entry_frame)
        self.department_entry.grid(row=5, column=1, sticky="ew", padx=5, pady=2)

        button_row = ttk.Frame(entry_frame)
        button_row.grid(row=6, column=0, columnspan=2, pady=5)
        button_row.columnconfigure(0, weight=1)
        button_row.columnconfigure(1, weight=1)
        
        ttk.Button(button_row, text="Adicionar Membro", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_member).grid(row=0, column=0, padx=2)
        ttk.Button(button_row, text="Limpar", image=self.app.icons.get('clear_icon'), compound=tk.LEFT, command=self._clear_form).grid(row=0, column=1, padx=2)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=3, column=0, pady=5, sticky="ew")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)
        
        ttk.Button(button_frame, text="Editar Membro", image=self.app.icons.get('edit_icon'), compound=tk.LEFT, command=self._edit_member).grid(row=0, column=0, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Remover Membro", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_member).grid(row=0, column=1, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Cadastrar Cargo", image=self.app.icons.get('settings_icon'), compound=tk.LEFT, command=self._open_roles_settings).grid(row=0, column=2, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Cadastrar Usuário", image=self.app.icons.get('registration_icon'), compound=tk.LEFT, command=self._open_user_registration_for_member).grid(row=0, column=3, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Fechar", image=self.app.icons.get('cancel_icon'), compound=tk.LEFT, command=self.destroy).grid(row=0, column=4, padx=5, sticky="ew")

    def _open_roles_settings(self):
        """Open SettingsWindow and navigate to the Roles tab"""
        settings_window = SettingsWindow(self.master, self.app)
        settings_window.notebook.select(settings_window.roles_tab) # Select the roles tab
        self.master.wait_window(settings_window)
        
        # Refresh the roles combo after settings window is closed
        self.role_combo['values'] = list(self.app.settings["roles"].keys())
        if self.role_combo.get() not in self.app.settings["roles"]:
            self.role_combo.set("Usuário")  # Reset to default if current role was removed
        # Também atualizar combo de cargo na janela de usuários
        try:
            if hasattr(self, 'cargo_combo') and self.cargo_combo:
                self.cargo_combo['values'] = list(self.app.settings["roles"].keys())
                if self.cargo_combo.get() not in self.cargo_combo['values'] and self.cargo_combo['values']:
                    self.cargo_combo.set(self.cargo_combo['values'][0])
        except Exception:
            pass

    def _open_user_registration_for_member(self):
        """Abre a tela de usuários já com o membro selecionado"""
        try:
            selected_item = self.members_tree.selection()
            pre_member_id = None
            if selected_item:
                values = self.members_tree.item(selected_item, "values")
                member_name = values[0]
                # Buscar ID do membro por nome
                import sqlite3
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                cursor.execute("SELECT id FROM members WHERE membro = %s", (member_name,))
                row = cursor.fetchone()
                conn.close()
                if row:
                    pre_member_id = row[0]
            # Abrir a janela de usuários passando app e o member_id
            UserRegistrationWindow(self.master, self.app.user_management if hasattr(self.app, 'user_management') else None, self.app.icons, app=self.app, preselected_member_id=pre_member_id)
        except Exception as e:
            print(f"DEBUG: Erro ao abrir cadastro de usuário a partir de membros: {e}")

    def _populate_members_list(self):
        self.members_tree.delete(*self.members_tree.get_children())
        for index, row in self.app.members_df.iterrows():
            # Verificar se a coluna email existe, senão usar string vazia
            email = row.get('email', '') if 'email' in row else ''
            self.members_tree.insert("", "end", values=(row['Membro'], row['Cargo'], email))

    def _select_photo(self):
        """Seleciona foto de perfil"""
        result = self.image_manager.select_image(self)
        if result:
            self.current_photo_path = result['processed_path']
            self._update_photo_preview()
            messagebox.showinfo("Sucesso", "Foto selecionada com sucesso!")
    
    def _remove_photo(self):
        """Remove foto de perfil"""
        if self.current_photo_path:
            # Deletar arquivo se existir
            if os.path.exists(self.current_photo_path):
                self.image_manager.delete_image(os.path.basename(self.current_photo_path))
            
            self.current_photo_path = None
            self._update_photo_preview()
            messagebox.showinfo("Sucesso", "Foto removida!")
        else:
            messagebox.showinfo("Info", "Nenhuma foto para remover.")
    
    def _update_photo_preview(self):
        """Atualiza preview da foto"""
        if self.current_photo_path and os.path.exists(self.current_photo_path):
            # Criar preview da imagem
            self.photo_preview = self.image_manager.get_image_preview(self.current_photo_path, (120, 120))
            if self.photo_preview:
                self.photo_label.configure(image=self.photo_preview, text="")
            else:
                self.photo_label.configure(image="", text="📷\nErro ao carregar")
        else:
            self.photo_label.configure(image="", text="📷\nSem foto")
    
    def _clear_form(self):
        """Limpa formulário e foto"""
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usuário")
        self.email_entry.delete(0, tk.END)
        self.phone_entry.delete(0, tk.END)
        self.department_entry.delete(0, tk.END)
        
        # Limpar foto
        if self.current_photo_path:
            self._remove_photo()
        
        self.edit_mode = False
        self.selected_member = None

    def _add_member(self):
        new_member_name = self.member_name_entry.get().strip()
        new_member_role = self.role_combo.get()
        new_member_email = self.email_entry.get().strip()
        new_member_phone = self.phone_entry.get().strip()
        new_member_department = self.department_entry.get().strip()

        if not new_member_name:
            messagebox.showwarning("Entrada Inválida", "O nome do membro não pode estar vazio.")
            return

        # Verificar se o membro já existe no banco SQLite
        try:
            import sqlite3
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM members WHERE membro = %s", (new_member_name,))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este membro já existe.")
                conn.close()
                return
            conn.close()
        except Exception as e:
            print(f"Erro ao verificar membro existente: {e}")
            messagebox.showerror("Erro", f"Não foi possível verificar se o membro existe: {e}")
            return

        # Validar email se fornecido
        if new_member_email:
            import re
            email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
            if not email_pattern.match(new_member_email):
                messagebox.showwarning("Email Inválido", "Por favor, insira um email válido ou deixe em branco.")
                return

        # Adicionar membro diretamente no banco SQLite
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Verificar se o membro já existe
            cursor.execute("SELECT id FROM members WHERE membro = %s", (new_member_name,))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este nome de membro já existe.")
                conn.close()
                return
            
            # Inserir novo membro
            cursor.execute("""
                INSERT INTO members (membro, email, cargo, phone, department, photo_path, created_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """, (new_member_name, new_member_email, new_member_role, new_member_phone, 
                  new_member_department, self.current_photo_path, datetime.now()))
            
            conn.commit()
            conn.close()
            
            # Recarregar membros na aplicação principal
            self.app.load_members()
            self._populate_members_list()
            
            # Atualizar dropdown de membros na tela de usuários
            if hasattr(self, 'populate_members_combo'):
                self.populate_members_combo()
            
        except Exception as e:
            print(f"Erro ao adicionar membro: {e}")
            messagebox.showerror("Erro", f"Não foi possível adicionar o membro: {e}")
            return
        
        # Clear form
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usuário") # Reset to default
        self.email_entry.delete(0, tk.END)
        self.phone_entry.delete(0, tk.END)
        self.department_entry.delete(0, tk.END)
        
        # Limpar foto
        if self.current_photo_path:
            self._remove_photo()
        
        self.edit_mode = False
        self.selected_member = None
        
        messagebox.showinfo("Sucesso", f"Membro '{new_member_name}' adicionado com sucesso!")
        self.app.populate_boards() # Refresh boards to update member filter options

    def _on_member_select(self, event):
        """Handle member selection in treeview"""
        selected_item = self.members_tree.selection()
        if selected_item:
            values = self.members_tree.item(selected_item, "values")
            self.selected_member = values[0]  # Member name
            
            # Buscar dados completos do membro no banco
            try:
                import sqlite3
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM members WHERE membro = %s", (values[0],))
                member_data = cursor.fetchone()
                conn.close()
                
                if member_data:
                    # Populate entry fields for editing
                    self.member_name_entry.delete(0, tk.END)
                    self.member_name_entry.insert(0, member_data[1])  # name
                    
                    self.role_combo.set(member_data[3])  # role
                    
                    self.email_entry.delete(0, tk.END)
                    self.email_entry.insert(0, member_data[2] or "")  # email
                    
                    self.phone_entry.delete(0, tk.END)
                    self.phone_entry.insert(0, member_data[4] or "")  # phone
                    
                    self.department_entry.delete(0, tk.END)
                    self.department_entry.insert(0, member_data[5] or "")  # department
                    
                    # Carregar foto se existir
                    if member_data[6]:  # photo_path
                        self.current_photo_path = member_data[6]
                        self._update_photo_preview()
                    else:
                        self.current_photo_path = None
                        self._update_photo_preview()
                
            except Exception as e:
                print(f"Erro ao carregar dados do membro: {e}")
                # Fallback para dados básicos
                self.member_name_entry.delete(0, tk.END)
                self.member_name_entry.insert(0, values[0])
                self.role_combo.set(values[1])
                if len(values) > 2:
                    self.email_entry.delete(0, tk.END)
                    self.email_entry.insert(0, values[2])
                else:
                    self.email_entry.delete(0, tk.END)
            
            self.edit_mode = True
        else:
            self.edit_mode = False
            self.selected_member = None

    def _edit_member(self):
        """Edit selected member"""
        if not self.selected_member:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um membro para editar.")
            return

        new_member_name = self.member_name_entry.get().strip()
        new_member_role = self.role_combo.get()
        new_member_email = self.email_entry.get().strip()
        new_member_phone = self.phone_entry.get().strip()
        new_member_department = self.department_entry.get().strip()

        if not new_member_name:
            messagebox.showwarning("Entrada Inválida", "O nome do membro não pode estar vazio.")
            return

        # Check if new name conflicts with existing members (excluding current member)
        try:
            import sqlite3
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM members WHERE membro = %s AND membro != %s", (new_member_name, self.selected_member))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este nome de membro já existe.")
                conn.close()
                return
            conn.close()
        except Exception as e:
            print(f"Erro ao verificar membro existente: {e}")
            messagebox.showerror("Erro", f"Não foi possível verificar se o membro existe: {e}")
            return

        # Validar email se fornecido
        if new_member_email:
            import re
            email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
            if not email_pattern.match(new_member_email):
                messagebox.showwarning("Email Inválido", "Por favor, insira um email válido ou deixe em branco.")
                return

        # Atualizar membro no banco SQLite
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Verificar se o novo nome já existe (excluindo o membro atual)
            cursor.execute("SELECT id FROM members WHERE membro = %s AND membro != %s", (new_member_name, self.selected_member))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este nome de membro já existe.")
                conn.close()
                return
            
            # Atualizar membro
            cursor.execute("""
                UPDATE members 
                SET membro = %s, email = %s, cargo = %s, phone = %s, department = %s, photo_path = %s, updated_at = %s
                WHERE membro = %s
            """, (new_member_name, new_member_email, new_member_role, new_member_phone, 
                  new_member_department, self.current_photo_path, datetime.now(), self.selected_member))
            
            conn.commit()
            conn.close()
            
            # Recarregar membros na aplicação principal
            self.app.load_members()
            self._populate_members_list()
            
            # Atualizar dropdown de membros na tela de usuários
            if hasattr(self, 'populate_members_combo'):
                self.populate_members_combo()
            
        except Exception as e:
            print(f"Erro ao atualizar membro: {e}")
            messagebox.showerror("Erro", f"Não foi possível atualizar o membro: {e}")
            return
        
        # Clear form
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usuário")
        self.email_entry.delete(0, tk.END)
        self.phone_entry.delete(0, tk.END)
        self.department_entry.delete(0, tk.END)
        
        # Limpar foto
        if self.current_photo_path:
            self._remove_photo()
        
        self.edit_mode = False
        self.selected_member = None
        
        messagebox.showinfo("Sucesso", f"Membro '{new_member_name}' atualizado com sucesso!")
        self.app.populate_boards()

    def _remove_member(self):
        selected_item = self.members_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um membro para remover.")
            return

        member_name_to_remove = self.members_tree.item(selected_item, "values")[0]
        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover '{member_name_to_remove}'?"):
            try:
                import sqlite3
                
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                
                # Remover membro do banco
                cursor.execute("DELETE FROM members WHERE membro = %s", (member_name_to_remove,))
                
                conn.commit()
                conn.close()
                
                # Recarregar membros na aplicação principal
                self.app.load_members()
                
            except Exception as e:
                print(f"Erro ao remover membro: {e}")
                messagebox.showerror("Erro", f"Não foi possível remover o membro: {e}")
                return
            self._populate_members_list()
            
            # Clear form if the removed member was selected
            if self.selected_member == member_name_to_remove:
                self.member_name_entry.delete(0, tk.END)
                self.role_combo.set("Usuário")
                self.edit_mode = False
                self.selected_member = None
            
            messagebox.showinfo("Sucesso", f"Membro '{member_name_to_remove}' removido com sucesso!")
            self.app.populate_boards() # Refresh boards to update member filter options

    def _clear_form(self):
        """Clear the form and reset to add mode"""
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usuário")
        self.email_entry.delete(0, tk.END)
        self.edit_mode = False
        self.selected_member = None
        self.members_tree.selection_remove(*self.members_tree.selection())

    def toggle_always_on_top(self):
        self.app.root.attributes("-topmost", self.always_on_top_var.get())

class SubjectManagerWindow(tk.Toplevel):
    def __init__(self, parent, app, subject_type):
        super().__init__(parent)
        self.app = app
        self.subject_type = subject_type
        
        if self.subject_type == 'pomodoro':
            self.title("Gerenciar Assuntos do Pomodoro")
            self.subjects_df = self.app.pomodoro_subjects_df
            self.subjects_list = self.app.pomodoro_subjects
            self.file_path = self.app.pomodoro_subjects_file
        else: # boodesk
            self.title("Gerenciar Assuntos do Boodesk")
            self.subjects_df = self.app.boodesk_subjects_df
            self.subjects_list = self.app.boodesk_subjects
            self.file_path = self.app.boodesk_subjects_file

        self.geometry("450x350")
        self.transient(parent)
        self.grab_set()

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        self._populate_subjects_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Listbox Frame
        list_frame = ttk.LabelFrame(main_frame, text="Assuntos Cadastrados")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        self.subjects_listbox = tk.Listbox(list_frame, selectmode=tk.SINGLE)
        self.subjects_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.subjects_listbox.bind("<<ListboxSelect>>", self._on_subject_select)
        
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.subjects_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.subjects_listbox.config(yscrollcommand=scrollbar.set)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Assunto")
        entry_frame.pack(fill=tk.X, pady=5)
        entry_frame.columnconfigure(0, weight=1)

        self.subject_entry = ttk.Entry(entry_frame)
        self.subject_entry.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        
        self.add_edit_button = ttk.Button(entry_frame, text="Adicionar", command=self._add_subject)
        self.add_edit_button.grid(row=0, column=1, padx=5, pady=5)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Remover Selecionado", command=self._remove_subject).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", command=self.destroy).pack(side=tk.RIGHT, padx=5)

    def _populate_subjects_list(self):
        self.subjects_listbox.delete(0, tk.END)
        # Sort the list for better UX
        for subject in sorted(self.subjects_list):
            if subject != '-': # Don't show the default '-'
                self.subjects_listbox.insert(tk.END, subject)

    def _on_subject_select(self, event):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            self.subject_entry.delete(0, tk.END)
            self.add_edit_button.config(text="Adicionar", command=self._add_subject)
            return
        
        selected_subject = self.subjects_listbox.get(selected_indices[0])
        self.subject_entry.delete(0, tk.END)
        self.subject_entry.insert(0, selected_subject)
        self.add_edit_button.config(text="Salvar Edição", command=self._edit_subject)

    def _clear_selection(self):
        self.subjects_listbox.selection_clear(0, tk.END)
        self.subject_entry.delete(0, tk.END)
        self.add_edit_button.config(text="Adicionar", command=self._add_subject)
        # Manually trigger the event handler to reset the button state
        self._on_subject_select(None)


    def _add_subject(self):
        new_subject = self.subject_entry.get().strip()
        if not new_subject:
            messagebox.showwarning("Entrada Inválida", "O nome do assunto não pode estar vazio.", parent=self)
            return
        
        if new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' já existe.", parent=self)
            return

        # Update DataFrame and list
        new_subject_df = pd.DataFrame({'Assunto': [new_subject]})
        self.subjects_df = pd.concat([self.subjects_df, new_subject_df], ignore_index=True)
        self.subjects_list.append(new_subject)
        
        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{new_subject}' adicionado.", parent=self)

    def _edit_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um assunto para editar.", parent=self)
            return
            
        old_subject = self.subjects_listbox.get(selected_indices[0])
        new_subject = self.subject_entry.get().strip()

        if not new_subject:
            messagebox.showwarning("Entrada Inválida", "O nome do assunto não pode estar vazio.", parent=self)
            return

        if new_subject != old_subject and new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' já existe.", parent=self)
            return

        # Update DataFrame and list
        self.subjects_df.loc[self.subjects_df['Assunto'] == old_subject, 'Assunto'] = new_subject
        self.subjects_list[self.subjects_list.index(old_subject)] = new_subject

        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{old_subject}' atualizado para '{new_subject}'.", parent=self)

    def _remove_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um assunto para remover.", parent=self)
            return

        subject_to_remove = self.subjects_listbox.get(selected_indices[0])
        
        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover o assunto '{subject_to_remove}'?\nIsso não pode ser desfeito e não alterará os cartões existentes.", parent=self):
            # Update DataFrame and list
            self.subjects_df = self.subjects_df[self.subjects_df['Assunto'] != subject_to_remove]
            self.subjects_list.remove(subject_to_remove)
            
            # Save and refresh
            self._save_and_refresh()
            self._clear_selection()
            messagebox.showinfo("Sucesso", f"Assunto '{subject_to_remove}' removido.", parent=self)

    def _save_and_refresh(self):
        # Save the DataFrame to the Excel file
        self.subjects_df.to_excel(self.file_path, index=False)
        
        # Update the main app's data
        if self.subject_type == 'pomodoro':
            self.app.pomodoro_subjects_df = self.subjects_df
            self.app.pomodoro_subjects = self.subjects_list
        else: # boodesk
            self.app.boodesk_subjects_df = self.subjects_df
            self.app.boodesk_subjects = self.subjects_list
            
        # Reload all auxiliary data in the main app to update all UI components
        self.app.load_aux_data()
        self.app.update_all_displays() # A comprehensive update
        
        # Refresh the listbox in this window
        self._populate_subjects_list()

    def destroy(self):
        # Ensure the main app window gets focus back
        self.app.root.focus_set()
        super().destroy()


class EmailManagementWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Gerenciamento de Emails")
        self.geometry("800x600")
        self.resizable(True, True)
        self.minsize(700, 500)
        self.transient(parent)
        self.grab_set()
        
        # Variables for edit mode
        self.edit_mode = False
        self.selected_email_id = None
        
        # Center the window on screen
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 800
        window_height = 600
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
        self._populate_emails_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure main frame for better layout
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)  # List frame should expand
        
        # Title
        title_label = ttk.Label(main_frame, text="Gerenciamento de Emails", font=("Arial", 12, "bold"))
        title_label.grid(row=0, column=0, pady=(0, 10), sticky="w")

        # Email List Frame
        list_frame = ttk.LabelFrame(main_frame, text="Lista de Emails", padding="5")
        list_frame.grid(row=1, column=0, sticky="nsew", pady=(0, 10))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        self.emails_tree = ttk.Treeview(list_frame, columns=("ID", "Email", "Nome", "Categoria", "Ativo"), show="headings")
        self.emails_tree.heading("ID", text="ID")
        self.emails_tree.heading("Email", text="Email")
        self.emails_tree.heading("Nome", text="Nome")
        self.emails_tree.heading("Categoria", text="Categoria")
        self.emails_tree.heading("Ativo", text="Ativo")
        self.emails_tree.column("ID", width=50, anchor="center")
        self.emails_tree.column("Email", width=200, anchor="w")
        self.emails_tree.column("Nome", width=150, anchor="w")
        self.emails_tree.column("Categoria", width=100, anchor="w")
        self.emails_tree.column("Ativo", width=80, anchor="center")
        self.emails_tree.grid(row=0, column=0, sticky="nsew", pady=5)
        self.emails_tree.bind("<<TreeviewSelect>>", self._on_email_select)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Email", padding="10")
        entry_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        entry_frame.columnconfigure(1, weight=1)

        # Email information fields
        ttk.Label(entry_frame, text="Email:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.email_entry = ttk.Entry(entry_frame)
        self.email_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(entry_frame, text="Nome:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.name_entry = ttk.Entry(entry_frame)
        self.name_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(entry_frame, text="Categoria:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        self.category_combo = ttk.Combobox(entry_frame, values=["Padrão", "Notificações", "Relatórios", "Administração", "Suporte"], state="readonly")
        self.category_combo.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        self.category_combo.set("Padrão")

        ttk.Label(entry_frame, text="Ativo:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.active_var = tk.BooleanVar(value=True)
        self.active_check = ttk.Checkbutton(entry_frame, text="Sim", variable=self.active_var)
        self.active_check.grid(row=3, column=1, sticky="w", padx=5, pady=2)

        button_row = ttk.Frame(entry_frame)
        button_row.grid(row=4, column=0, columnspan=2, pady=5)
        button_row.columnconfigure(0, weight=1)
        button_row.columnconfigure(1, weight=1)
        
        ttk.Button(button_row, text="Adicionar Email", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_email).grid(row=0, column=0, padx=2)
        ttk.Button(button_row, text="Limpar", image=self.app.icons.get('clear_icon'), compound=tk.LEFT, command=self._clear_form).grid(row=0, column=1, padx=2)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=3, column=0, pady=5, sticky="ew")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)
        
        ttk.Button(button_frame, text="Editar Email", image=self.app.icons.get('edit_icon'), compound=tk.LEFT, command=self._edit_email).grid(row=0, column=0, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Remover Email", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_email).grid(row=0, column=1, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Importar CSV", image=self.app.icons.get('import_icon'), compound=tk.LEFT, command=self._import_csv).grid(row=0, column=2, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Fechar", image=self.app.icons.get('cancel_icon'), compound=tk.LEFT, command=self.destroy).grid(row=0, column=3, padx=5, sticky="ew")

    def _populate_emails_list(self):
        """Popula a lista de emails do banco de dados"""
        self.emails_tree.delete(*self.emails_tree.get_children())
        try:
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Verificar se a tabela existe, se não, criar
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS system_emails (
                    id SERIAL PRIMARY KEY,
                    email VARCHAR(255) NOT NULL UNIQUE,
                    name VARCHAR(255),
                    category VARCHAR(100) DEFAULT 'Padrão',
                    is_active BOOLEAN DEFAULT TRUE,
                    created_at TIMESTAMP DEFAULT NOW(),
                    updated_at TIMESTAMP DEFAULT NOW()
                )
            """)
            conn.commit()
            
            # Buscar emails
            cursor.execute("SELECT id, email, name, category, is_active FROM system_emails ORDER BY email")
            emails = cursor.fetchall()
            conn.close()
            
            for email_data in emails:
                email_id, email, name, category, is_active = email_data
                active_text = "Sim" if is_active else "Não"
                self.emails_tree.insert("", "end", values=(email_id, email, name or "", category, active_text))
                
        except Exception as e:
            print(f"Erro ao carregar emails: {e}")
            messagebox.showerror("Erro", f"Erro ao carregar lista de emails: {e}")

    def _add_email(self):
        """Adiciona um novo email ao sistema"""
        email = self.email_entry.get().strip()
        name = self.name_entry.get().strip()
        category = self.category_combo.get()
        is_active = self.active_var.get()

        if not email:
            messagebox.showwarning("Entrada Inválida", "O email não pode estar vazio.")
            return

        # Validar formato do email
        import re
        email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
        if not email_pattern.match(email):
            messagebox.showwarning("Email Inválido", "Por favor, insira um email válido.")
            return

        try:
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Verificar se o email já existe
            cursor.execute("SELECT id FROM system_emails WHERE email = %s", (email,))
            if cursor.fetchone():
                messagebox.showwarning("Email Existente", "Este email já está cadastrado.")
                conn.close()
                return
            
            # Inserir novo email
            cursor.execute("""
                INSERT INTO system_emails (email, name, category, is_active)
                VALUES (%s, %s, %s, %s)
            """, (email, name, category, is_active))
            
            conn.commit()
            conn.close()
            
            self._populate_emails_list()
            self._clear_form()
            
            messagebox.showinfo("Sucesso", f"Email '{email}' adicionado com sucesso!")
            
        except Exception as e:
            print(f"Erro ao adicionar email: {e}")
            messagebox.showerror("Erro", f"Não foi possível adicionar o email: {e}")

    def _on_email_select(self, event):
        """Handle email selection in treeview"""
        selected_item = self.emails_tree.selection()
        if selected_item:
            values = self.emails_tree.item(selected_item, "values")
            self.selected_email_id = values[0]
            
            # Buscar dados completos do email no banco
            try:
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                cursor.execute("SELECT email, name, category, is_active FROM system_emails WHERE id = %s", (values[0],))
                email_data = cursor.fetchone()
                conn.close()
                
                if email_data:
                    # Populate entry fields for editing
                    self.email_entry.delete(0, tk.END)
                    self.email_entry.insert(0, email_data[0])
                    
                    self.name_entry.delete(0, tk.END)
                    self.name_entry.insert(0, email_data[1] or "")
                    
                    self.category_combo.set(email_data[2])
                    self.active_var.set(email_data[3])
                
            except Exception as e:
                print(f"Erro ao carregar dados do email: {e}")
            
            self.edit_mode = True
        else:
            self.edit_mode = False
            self.selected_email_id = None

    def _edit_email(self):
        """Edita o email selecionado"""
        if not self.selected_email_id:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um email para editar.")
            return

        email = self.email_entry.get().strip()
        name = self.name_entry.get().strip()
        category = self.category_combo.get()
        is_active = self.active_var.get()

        if not email:
            messagebox.showwarning("Entrada Inválida", "O email não pode estar vazio.")
            return

        # Validar formato do email
        import re
        email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
        if not email_pattern.match(email):
            messagebox.showwarning("Email Inválido", "Por favor, insira um email válido.")
            return

        try:
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Verificar se o novo email já existe (excluindo o atual)
            cursor.execute("SELECT id FROM system_emails WHERE email = %s AND id != %s", (email, self.selected_email_id))
            if cursor.fetchone():
                messagebox.showwarning("Email Existente", "Este email já está cadastrado.")
                conn.close()
                return
            
            # Atualizar email
            cursor.execute("""
                UPDATE system_emails 
                SET email = %s, name = %s, category = %s, is_active = %s, updated_at = NOW()
                WHERE id = %s
            """, (email, name, category, is_active, self.selected_email_id))
            
            conn.commit()
            conn.close()
            
            self._populate_emails_list()
            self._clear_form()
            
            messagebox.showinfo("Sucesso", f"Email '{email}' atualizado com sucesso!")
            
        except Exception as e:
            print(f"Erro ao atualizar email: {e}")
            messagebox.showerror("Erro", f"Não foi possível atualizar o email: {e}")

    def _remove_email(self):
        """Remove o email selecionado"""
        selected_item = self.emails_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Seleção", "Por favor, selecione um email para remover.")
            return

        email_to_remove = self.emails_tree.item(selected_item, "values")[1]  # Email está na coluna 1
        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover '{email_to_remove}'?"):
            try:
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                
                # Remover email do banco
                cursor.execute("DELETE FROM system_emails WHERE id = %s", (self.selected_email_id,))
                
                conn.commit()
                conn.close()
                
                self._populate_emails_list()
                self._clear_form()
                
                messagebox.showinfo("Sucesso", f"Email '{email_to_remove}' removido com sucesso!")
                
            except Exception as e:
                print(f"Erro ao remover email: {e}")
                messagebox.showerror("Erro", f"Não foi possível remover o email: {e}")

    def _import_csv(self):
        """Importa emails de um arquivo CSV"""
        file_path = filedialog.askopenfilename(
            title="Selecionar arquivo CSV",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        
        if not file_path:
            return
            
        try:
            import pandas as pd
            df = pd.read_csv(file_path)
            
            # Verificar colunas necessárias
            required_columns = ['email']
            if not all(col in df.columns for col in required_columns):
                messagebox.showerror("Erro", "O arquivo CSV deve ter pelo menos uma coluna 'email'")
                return
            
            # Processar emails
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            imported_count = 0
            skipped_count = 0
            
            for index, row in df.iterrows():
                email = str(row['email']).strip()
                
                # Validar email
                import re
                email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
                if not email_pattern.match(email):
                    skipped_count += 1
                    continue
                
                # Verificar se já existe
                cursor.execute("SELECT id FROM system_emails WHERE email = %s", (email,))
                if cursor.fetchone():
                    skipped_count += 1
                    continue
                
                # Inserir email
                name = str(row.get('name', '')).strip() if 'name' in row else ''
                category = str(row.get('category', 'Padrão')).strip() if 'category' in row else 'Padrão'
                is_active = bool(row.get('is_active', True)) if 'is_active' in row else True
                
                cursor.execute("""
                    INSERT INTO system_emails (email, name, category, is_active)
                    VALUES (%s, %s, %s, %s)
                """, (email, name, category, is_active))
                
                imported_count += 1
            
            conn.commit()
            conn.close()
            
            self._populate_emails_list()
            
            messagebox.showinfo("Importação Concluída", 
                              f"Importação concluída!\n"
                              f"Emails importados: {imported_count}\n"
                              f"Emails ignorados: {skipped_count}")
            
        except Exception as e:
            print(f"Erro ao importar CSV: {e}")
            messagebox.showerror("Erro", f"Erro ao importar arquivo CSV: {e}")

    def _clear_form(self):
        """Limpa o formulário"""
        self.email_entry.delete(0, tk.END)
        self.name_entry.delete(0, tk.END)
        self.category_combo.set("Padrão")
        self.active_var.set(True)
        
        self.edit_mode = False
        self.selected_email_id = None
        self.emails_tree.selection_remove(*self.emails_tree.selection())

    def get_active_emails(self, category=None):
        """Retorna lista de emails ativos, opcionalmente filtrados por categoria"""
        try:
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            if category:
                cursor.execute("SELECT email FROM system_emails WHERE is_active = TRUE AND category = %s ORDER BY email", (category,))
            else:
                cursor.execute("SELECT email FROM system_emails WHERE is_active = TRUE ORDER BY email")
            
            emails = [row[0] for row in cursor.fetchall()]
            conn.close()
            return emails
            
        except Exception as e:
            print(f"Erro ao buscar emails ativos: {e}")
            return []


class SettingsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Configurações")
        self.geometry("1200x800")  # Tamanho maior para acomodar scrollbars
        self.resizable(True, True)  # Permitir redimensionamento
        self.transient(parent)
        self.grab_set()
        
        # Centralizar a janela na tela
        self.center_window()
        
        # Criar estilo vermelho para destacar a seção de ações
        style = ttk.Style()
        style.configure('Red.TFrame', background='#ffcccc')

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")

    def center_window(self):
        """Centraliza a janela na tela - igual ao CardWindow"""
        self.update_idletasks()
        
        # Obter dimensões da tela
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Obter dimensões da janela
        window_width = self.winfo_width()
        window_height = self.winfo_height()
        
        # Calcular posição central
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        
        # Aplicar posição
        self.geometry(f"+{x}+{y}")

    def create_widgets(self):
        # Main container with proper layout - igual à tela de cards
        main_container = ttk.Frame(self)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Configure main container for proper layout
        main_container.columnconfigure(0, weight=1)
        main_container.rowconfigure(0, weight=1)
        
        # === CONTENT FRAME (TOP) ===
        content_frame = ttk.Frame(main_container)
        content_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 10))
        content_frame.columnconfigure(0, weight=1)
        content_frame.rowconfigure(0, weight=1)
        
        # Configure grid for 2 columns
        content_frame.columnconfigure(0, weight=1)  # Left column
        content_frame.columnconfigure(1, weight=1)  # Right column
        content_frame.rowconfigure(0, weight=1)

        # === LEFT COLUMN ===
        left_frame = ttk.Frame(content_frame)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
        
        # Notebook principal
        self.notebook = ttk.Notebook(left_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)

        # Create tabs with scrollbars and icons
        self.geral_tab = self.create_scrollable_tab("Geral", "settings_icon")
        self.quadros_tab = self.create_scrollable_tab("Quadros", "folder_icon")
        self.pomodoro_tab = self.create_scrollable_tab("Pomodoro", "time_icon")
        self.roles_tab = self.create_scrollable_tab("Cargos", "key_icon")
        self.dashboard_tab = self.create_scrollable_tab("Dashboard", "dashboard_icon")
        self.calendar_tab = self.create_scrollable_tab("Calendário", "calendar_icon")
        self.email_tab = self.create_scrollable_tab("Email", "info_icon")
        self.email_templates_tab = self.create_scrollable_tab("Templates de Email", "registration_icon")

        # Create tab contents
        self.create_geral_tab()
        self.create_quadros_tab()
        self.create_pomodoro_tab()
        self.create_roles_tab()
        self.create_dashboard_settings_tab()
        self.create_calendar_tab()
        self.create_email_tab()
        self.create_email_templates_tab()

        # === RIGHT COLUMN ===
        right_frame = ttk.Frame(content_frame)
        right_frame.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
        
        # Adicionar informações extras na coluna direita
        info_frame = ttk.LabelFrame(right_frame, text="Informações do Sistema", padding="10")
        info_frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(info_frame, text="Versão do Sistema: 2.0", font=("Arial", 10, "bold")).pack(anchor="w", pady=5)
        ttk.Label(info_frame, text="Status: Ativo", font=("Arial", 9)).pack(anchor="w", pady=2)
        ttk.Label(info_frame, text="Última Atualização: Hoje", font=("Arial", 9)).pack(anchor="w", pady=2)
        ttk.Label(info_frame, text="Configurações Salvas: Sim", font=("Arial", 9)).pack(anchor="w", pady=2)
        
        # === BOTTOM ACTION BUTTONS (FIXED AT BOTTOM) ===
        # Botões fixos na parte inferior - igual à tela de cards
        button_frame = ttk.LabelFrame(main_container, text="Ações", padding="10")
        button_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(10, 0))
        
        # Configure button frame for proper layout
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        
        # Create buttons with better spacing and icons like in CardWindow
        restore_btn = ttk.Button(button_frame, text="Restaurar Padrões", 
                                image=self.app.icons.get('refresh_icon'), compound=tk.LEFT,
                                command=self.restore_defaults)
        restore_btn.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        cancel_btn = ttk.Button(button_frame, text="Cancelar", 
                              image=self.app.icons.get('cancel_icon'), compound=tk.LEFT,
                              command=self.destroy)
        cancel_btn.grid(row=0, column=1, sticky="ew", padx=(0, 5))
        
        save_btn = ttk.Button(button_frame, text="Salvar", 
                            image=self.app.icons.get('save_icon'), compound=tk.LEFT,
                            command=self.save_settings)
        save_btn.grid(row=0, column=2, sticky="ew")
        
        # Add keyboard shortcuts
        self.bind('<Control-s>', lambda e: self.save_settings())
        self.bind('<Escape>', lambda e: self.destroy())
        self.bind('<Return>', lambda e: self.save_settings())
        
        # Focus on save button
        save_btn.focus_set()
        
        # Forçar atualização da interface
        self.update_idletasks()
        
        # Debug: verificar se os botões foram criados
        print(f"DEBUG: Botões criados - Restaurar: {restore_btn.winfo_exists()}, Cancelar: {cancel_btn.winfo_exists()}, Salvar: {save_btn.winfo_exists()}")
        print(f"DEBUG: Layout igual à tela de cards - Botões fixos na parte inferior")

    def create_scrollable_tab(self, tab_name, icon_name=None):
        """Cria uma aba com scrollbar vertical e horizontal e ícone opcional"""
        # Frame principal da aba
        tab_frame = ttk.Frame(self.notebook)
        
        # Canvas para scroll
        canvas = tk.Canvas(tab_frame, bg='white')
        scrollbar_y = ttk.Scrollbar(tab_frame, orient="vertical", command=canvas.yview)
        scrollbar_x = ttk.Scrollbar(tab_frame, orient="horizontal", command=canvas.xview)
        
        # Frame interno para o conteúdo
        content_frame = ttk.Frame(canvas)
        
        # Configurar scroll
        canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        # Layout dos widgets
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar_y.pack(side="right", fill="y")
        scrollbar_x.pack(side="bottom", fill="x")
        
        # Criar janela no canvas
        canvas_window = canvas.create_window((0, 0), window=content_frame, anchor="nw")
        
        # Configurar redimensionamento
        def configure_scroll_region(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
        
        def configure_canvas_window(event):
            canvas.itemconfig(canvas_window, width=event.width)
        
        content_frame.bind("<Configure>", configure_scroll_region)
        canvas.bind("<Configure>", configure_canvas_window)
        
        # Adicionar aba ao notebook
        self.notebook.add(tab_frame, text=tab_name)
        
        # Configurar ícone na aba se fornecido
        if icon_name and hasattr(self.app, 'icons') and self.app.icons.get(icon_name):
            try:
                # Obter o índice da aba recém-adicionada
                tab_index = len(self.notebook.tabs()) - 1
                self.notebook.tab(tab_index, image=self.app.icons.get(icon_name), compound=tk.LEFT)
            except Exception as e:
                print(f"Erro ao configurar ícone {icon_name} na aba {tab_name}: {e}")
        
        # Retornar o frame de conteúdo para ser usado pelas funções de criação
        return content_frame

    def create_geral_tab(self):
        frame = self.geral_tab
        frame.grid_columnconfigure(0, weight=1)

        ttk.Label(frame, text="Tema do Aplicativo:").pack(anchor="w", padx=10, pady=(10, 0))
        self.theme_combo = ttk.Combobox(frame, values=self.app.root.get_themes(), state="readonly")
        self.theme_combo.pack(fill="x", padx=10, pady=5)
        self.theme_combo.set(self.app.settings.get('theme', 'aquativo'))
        # Aplicar tema imediatamente quando o usuário seleciona um tema
        self.theme_combo.bind('<<ComboboxSelected>>', self._on_theme_selected)

        self.always_on_top_var = tk.BooleanVar()
        self.always_on_top_var.set(self.app.root.attributes("-topmost"))
        ttk.Checkbutton(frame, text="Sempre no topo", variable=self.always_on_top_var, command=self.toggle_always_on_top).pack(anchor="w", padx=10, pady=5)

        self.dev_mode_var = tk.BooleanVar()
        self.dev_mode_var.set(self.app.settings.get('dev_mode', False))
        ttk.Checkbutton(frame, text="Modo Desenvolvedor (Recursos Ágeis)", variable=self.dev_mode_var).pack(anchor="w", padx=10, pady=5)

        self.git_integration_enabled_var = tk.BooleanVar()
        self.git_integration_enabled_var.set(self.app.settings.get('git_integration_enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integração Git (Modo Dev)", variable=self.git_integration_enabled_var).pack(anchor="w", padx=10, pady=5)


    def _on_theme_selected(self, event=None):
        """Aplica o tema imediatamente quando selecionado no combobox"""
        try:
            selected_theme = self.theme_combo.get()
            if selected_theme:
                print(f"🎨 Aplicando tema imediatamente: {selected_theme}")
                self.app.change_theme(selected_theme)
        except Exception as e:
            print(f"❌ Erro ao aplicar tema: {e}")
    def create_quadros_tab(self):
        frame = self.quadros_tab
        frame.grid_columnconfigure(1, weight=1)
        frame.grid_rowconfigure(2, weight=1)

        self.unify_subjects_var = tk.BooleanVar()
        self.unify_subjects_var.set(self.app.settings.get('unify_subjects', False))
        ttk.Checkbutton(frame, text="Unificar Assuntos (Boodesk e Pomodoro)", variable=self.unify_subjects_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)

        self.show_card_details_on_board_var = tk.BooleanVar()
        self.show_card_details_on_board_var.set(self.app.settings.get('show_card_details_on_board', False))
        ttk.Checkbutton(frame, text="Mostrar Detalhes do Cartão no Quadro (Responsável, Criação)", variable=self.show_card_details_on_board_var).grid(row=1, column=0, columnspan=2, sticky="w", padx=10, pady=5)

        # Importance Levels Management
        importance_frame = ttk.LabelFrame(frame, text="Gerenciar Níveis de Importância", padding=10)
        importance_frame.grid(row=2, column=0, columnspan=3, sticky="nsew", padx=10, pady=(15, 5))
        importance_frame.grid_columnconfigure(0, weight=1)

        # Verificar se o usuário é administrador
        is_admin = self._check_admin_permissions()
        
        if not is_admin:
            # Mostrar aviso para usuários não-admin
            warning_label = ttk.Label(importance_frame, 
                text="⚠️ Apenas administradores podem modificar as cores de importância", 
                foreground="red", font=("Arial", 9, "bold"))
            warning_label.pack(pady=10)

        self.importance_tree = ttk.Treeview(importance_frame, columns=("Nome", "Cor"), show="headings")
        self.importance_tree.heading("Nome", text="Nome")
        self.importance_tree.heading("Cor", text="Cor")
        self.importance_tree.column("Nome", width=150, anchor="w")
        self.importance_tree.column("Cor", width=100, anchor="center")
        self.importance_tree.pack(fill="both", expand=True, pady=5)
        
        # Apenas administradores podem editar cores
        if is_admin:
            self.importance_tree.bind("<Double-1>", self._edit_importance_color)

        importance_buttons_frame = ttk.Frame(importance_frame)
        importance_buttons_frame.pack(fill="x", pady=5)

        # Botões apenas para administradores
        if is_admin:
            ttk.Button(importance_buttons_frame, text="Adicionar Nível", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_importance_level).pack(side="left", padx=5)
            ttk.Button(importance_buttons_frame, text="➖ Remover Nível", command=self._remove_importance_level).pack(side="left", padx=5)
        else:
            # Botões desabilitados para usuários não-admin
            add_button = ttk.Button(importance_buttons_frame, text="Adicionar Nível", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_importance_level, state="disabled")
            add_button.pack(side="left", padx=5)
            remove_button = ttk.Button(importance_buttons_frame, text="➖ Remover Nível", command=self._remove_importance_level, state="disabled")
            remove_button.pack(side="left", padx=5)

        self._populate_importance_treeview()

    def create_dashboard_settings_tab(self):
        """Cria a aba de configurações do dashboard"""
        frame = self.dashboard_tab
        frame.grid_columnconfigure(0, weight=1)
        
        # Widget settings
        widget_frame = ttk.LabelFrame(frame, text="Widgets do Dashboard", padding=10)
        widget_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Dashboard widget checkboxes
        self.dashboard_widget_vars = {}
        widget_settings = self.app.settings.get('dashboard_widgets', {})
        
        widgets = [
            ('overview', 'Visão Geral'),
            ('urgent_tasks', 'Tarefas Urgentes'),
            ('upcoming_deadlines', 'Próximos Prazos'),
            ('recent_activities', 'Atividades Recentes'),
            ('quick_links', 'Links Frequentes'),
            ('quick_actions', 'Ações Rápidas'),
            ('meeting_widget', 'Widget de Reuniões')
        ]
        
        for i, (widget_key, widget_name) in enumerate(widgets):
            if widget_key == 'meeting_widget':
                var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['show_widget'])
            else:
                var = tk.BooleanVar(value=widget_settings.get(widget_key, True))
            self.dashboard_widget_vars[widget_key] = var
            ttk.Checkbutton(widget_frame, text=widget_name, variable=var).pack(anchor=tk.W, pady=2)
        
        # Preview button
        ttk.Button(frame, text="Visualizar Dashboard", 
                  command=self.preview_dashboard_settings).pack(pady=10)

    def create_calendar_tab(self):
        """Cria a aba de configurações de calendário"""
        frame = self.calendar_tab
        frame.grid_columnconfigure(1, weight=1)
        
        calendar_settings = self.app.settings.get('calendar_integration', {})
        
        # Enable calendar integration
        self.calendar_enabled_var = tk.BooleanVar(value=calendar_settings.get('enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integração com Google Calendar", 
                       variable=self.calendar_enabled_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)
        
        # Tipo de autenticação
        ttk.Label(frame, text="Tipo de Autenticação:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        auth_frame = ttk.Frame(frame)
        auth_frame.grid(row=1, column=1, sticky="w", padx=10, pady=5)
        
        self.auth_type_var = tk.StringVar(value=calendar_settings.get('auth_type', 'json'))
        print(f"DEBUG: auth_type_var inicializado com: {self.auth_type_var.get()}")
        
        json_radio = ttk.Radiobutton(auth_frame, text="Arquivo JSON", 
                       variable=self.auth_type_var, value="json", 
                       command=self.toggle_auth_methods)
        json_radio.pack(side=tk.LEFT, padx=5)
        print("DEBUG: Radio button JSON criado")
        
        key_radio = ttk.Radiobutton(auth_frame, text="ID e Chave Privada", 
                       variable=self.auth_type_var, value="key", 
                       command=self.toggle_auth_methods)
        key_radio.pack(side=tk.LEFT, padx=5)
        print("DEBUG: Radio button ID/Chave criado")
        
        # Frame para arquivo JSON
        self.json_frame = ttk.LabelFrame(frame, text="Arquivo JSON de Credenciais", padding=10)
        self.json_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        self.json_frame.columnconfigure(1, weight=1)
        
        ttk.Label(self.json_frame, text="Arquivo:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        json_credentials_frame = ttk.Frame(self.json_frame)
        json_credentials_frame.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        json_credentials_frame.columnconfigure(0, weight=1)
        
        self.credentials_file_var = tk.StringVar(value=calendar_settings.get('credentials_file', ''))
        self.credentials_entry = ttk.Entry(json_credentials_frame, textvariable=self.credentials_file_var, width=50)
        self.credentials_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        ttk.Button(json_credentials_frame, text="Procurar", 
                  command=self.browse_credentials_file).grid(row=0, column=1)
        
        # Frame para ID e chave privada
        self.key_frame = ttk.LabelFrame(frame, text="ID e Chave Privada", padding=10)
        self.key_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        self.key_frame.columnconfigure(1, weight=1)
        
        ttk.Label(self.key_frame, text="Client ID:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.client_id_var = tk.StringVar(value=calendar_settings.get('client_id', ''))
        self.client_id_entry = ttk.Entry(self.key_frame, textvariable=self.client_id_var, width=50)
        self.client_id_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.key_frame, text="Client Secret:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.client_secret_var = tk.StringVar(value=calendar_settings.get('client_secret', ''))
        self.client_secret_entry = ttk.Entry(self.key_frame, textvariable=self.client_secret_var, width=50, show="*")
        self.client_secret_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        
        # Botão para mostrar/ocultar senha
        self.show_secret_var = tk.BooleanVar()
        ttk.Checkbutton(self.key_frame, text="Mostrar chave", 
                       variable=self.show_secret_var, 
                       command=self.toggle_secret_visibility).grid(row=1, column=2, padx=5, pady=2)
        
        # Instruções
        instructions_frame = ttk.LabelFrame(frame, text="Instruções Para configurar o Google Calendar:", padding=10)
        instructions_frame.grid(row=4, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        instructions = [
            "1. Acesse https://console.developers.google.com/",
            "2. Crie um novo projeto ou selecione um existente",
            "3. Ative a Google Calendar API",
            "4. Crie credenciais OAuth 2.0",
            "5. Baixe o arquivo JSON OU copie o Client ID e Secret",
            "6. Configure acima usando JSON ou ID/Chave"
        ]
        
        for instruction in instructions:
            ttk.Label(instructions_frame, text=instruction).pack(anchor="w", pady=1)
        
        # Sincronização automática
        sync_frame = ttk.LabelFrame(frame, text="Sincronização Automática", padding=10)
        sync_frame.grid(row=5, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        self.sync_auto_var = tk.BooleanVar(value=calendar_settings.get('sync_auto', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar automaticamente", 
                       variable=self.sync_auto_var).pack(anchor=tk.W, pady=2)
        
        self.sync_cards_deadline_var = tk.BooleanVar(value=calendar_settings.get('sync_cards_deadline', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar cartões com prazo", 
                       variable=self.sync_cards_deadline_var).pack(anchor=tk.W, pady=2)
        
        self.sync_calendar_events_var = tk.BooleanVar(value=calendar_settings.get('sync_calendar_events', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar eventos do calendário", 
                       variable=self.sync_calendar_events_var).pack(anchor=tk.W, pady=2)
        
        # Botões de validação e teste
        test_frame = ttk.LabelFrame(frame, text="Validação e Teste", padding=10)
        test_frame.grid(row=6, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        test_buttons_frame = ttk.Frame(test_frame)
        test_buttons_frame.pack(fill=tk.X)
        
        ttk.Button(test_buttons_frame, text="🔍 Validar Credenciais", 
                  command=self.validate_credentials).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(test_buttons_frame, text="🔄 Testar Conexão", 
                  command=self.test_calendar_connection).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(test_buttons_frame, text="📂 Configurar Credenciais", 
                  command=self.open_credentials_config).pack(side=tk.LEFT, padx=5)
        
        # Status da validação
        self.validation_status_var = tk.StringVar(value="Status: Não verificado")
        ttk.Label(test_frame, textvariable=self.validation_status_var, 
                 font=("Arial", 9)).pack(anchor="w", pady=(10, 0))
        
        # Configurar navegação com Enter
        self.setup_enter_navigation()
        
        # Inicializar visibilidade dos métodos de autenticação
        print("DEBUG: Inicializando visibilidade dos métodos de autenticação")
        self.toggle_auth_methods()
        print("DEBUG: Aba de calendário criada com sucesso")
        print("🎯 OPÇÃO 'ID E CHAVE PRIVADA' DEVE APARECER NA ABA CALENDÁRIO!")
    
    def setup_enter_navigation(self):
        """Configura navegação com Enter entre campos"""
        # Configurar Enter para navegar entre campos
        self.credentials_entry.bind('<Return>', lambda e: self.client_id_entry.focus())
        self.client_id_entry.bind('<Return>', lambda e: self.client_secret_entry.focus())
        self.client_secret_entry.bind('<Return>', lambda e: self.credentials_entry.focus())
    
    def toggle_auth_methods(self):
        """Alterna entre métodos de autenticação"""
        print(f"DEBUG: toggle_auth_methods chamado - auth_type: {self.auth_type_var.get()}")
        if self.auth_type_var.get() == 'json':
            print("DEBUG: Mostrando frame JSON, ocultando frame Key")
            self.json_frame.grid()
            self.key_frame.grid_remove()
        else:
            print("DEBUG: Mostrando frame Key, ocultando frame JSON")
            self.json_frame.grid_remove()
            self.key_frame.grid()
    
    def toggle_secret_visibility(self):
        """Alterna visibilidade da chave privada"""
        if self.show_secret_var.get():
            self.client_secret_entry.config(show="")
        else:
            self.client_secret_entry.config(show="*")
    
    def browse_credentials_file(self):
        """Abre diálogo para selecionar arquivo de credenciais"""
        from tkinter import filedialog
        file_path = filedialog.askopenfilename(
            title="Selecionar arquivo de credenciais do Google Calendar",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if file_path:
            self.credentials_file_var.set(file_path)
    
    def validate_credentials(self):
        """Valida as credenciais (JSON ou ID/Chave)"""
        auth_type = self.auth_type_var.get()
        
        if auth_type == 'json':
            self.validate_json_credentials()
        else:
            self.validate_key_credentials()
    
    def validate_json_credentials(self):
        """Valida o arquivo de credenciais JSON"""
        import json
        import os
        
        file_path = self.credentials_file_var.get()
        
        if not file_path:
            self.validation_status_var.set("Status: ❌ Nenhum arquivo selecionado")
            return
        
        if not os.path.exists(file_path):
            self.validation_status_var.set("Status: ❌ Arquivo não encontrado")
            return
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            if 'installed' in data:
                client_info = data['installed']
                project_id = client_info.get('project_id', 'N/A')
                client_id = client_info.get('client_id', 'N/A')
                
                self.validation_status_var.set(f"Status: ✅ JSON Válido - Projeto: {project_id}")
                messagebox.showinfo("Validação", 
                                  f"✅ Arquivo de credenciais válido!\n\n"
                                  f"📝 Projeto: {project_id}\n"
                                  f"🆔 Client ID: {client_id[:30]}...\n"
                                  f"📏 Tamanho: {os.path.getsize(file_path)} bytes")
                
            elif 'web' in data:
                client_info = data['web']
                project_id = client_info.get('project_id', 'N/A')
                client_id = client_info.get('client_id', 'N/A')
                
                self.validation_status_var.set(f"Status: ✅ JSON Válido (Web) - Projeto: {project_id}")
                messagebox.showinfo("Validação", 
                                  f"✅ Arquivo de credenciais válido!\n\n"
                                  f"📝 Projeto: {project_id}\n"
                                  f"🆔 Client ID: {client_id[:30]}...\n"
                                  f"📏 Tamanho: {os.path.getsize(file_path)} bytes")
                
            else:
                self.validation_status_var.set("Status: ❌ Formato inválido")
                messagebox.showerror("Erro", "❌ Arquivo não contém credenciais válidas!\n\nO arquivo deve conter 'installed' ou 'web'")
                
        except json.JSONDecodeError:
            self.validation_status_var.set("Status: ❌ JSON inválido")
            messagebox.showerror("Erro", "❌ Arquivo JSON inválido!")
        except Exception as e:
            self.validation_status_var.set("Status: ❌ Erro ao ler arquivo")
            messagebox.showerror("Erro", f"❌ Erro ao ler arquivo: {e}")
    
    def validate_key_credentials(self):
        """Valida o ID e chave privada"""
        client_id = self.client_id_var.get().strip()
        client_secret = self.client_secret_var.get().strip()
        
        if not client_id:
            self.validation_status_var.set("Status: ❌ Client ID não informado")
            messagebox.showerror("Erro", "❌ Client ID é obrigatório!")
            return
        
        if not client_secret:
            self.validation_status_var.set("Status: ❌ Client Secret não informado")
            messagebox.showerror("Erro", "❌ Client Secret é obrigatório!")
            return
        
        # Validar formato do Client ID
        if not client_id.endswith('.apps.googleusercontent.com'):
            self.validation_status_var.set("Status: ⚠️ Client ID pode estar incorreto")
            messagebox.showwarning("Aviso", "⚠️ Client ID deve terminar com '.apps.googleusercontent.com'")
            return
        
        # Validar formato do Client Secret
        if len(client_secret) < 10:
            self.validation_status_var.set("Status: ⚠️ Client Secret pode estar incorreto")
            messagebox.showwarning("Aviso", "⚠️ Client Secret parece muito curto")
            return
        
        self.validation_status_var.set("Status: ✅ ID e Chave válidos")
        messagebox.showinfo("Validação", 
                          f"✅ Credenciais válidas!\n\n"
                          f"🆔 Client ID: {client_id[:30]}...\n"
                          f"🔐 Client Secret: {client_secret[:10]}...\n"
                          f"📝 Tipo: ID e Chave Privada")
    
    def test_calendar_connection(self):
        """Testa a conexão com Google Calendar"""
        auth_type = self.auth_type_var.get()
        
        if auth_type == 'json':
            self.test_json_connection()
        else:
            self.test_key_connection()
    
    def test_json_connection(self):
        """Testa conexão usando arquivo JSON"""
        try:
            # Verificar se as bibliotecas estão instaladas
            try:
                from google.oauth2.credentials import Credentials
                from google_auth_oauthlib.flow import InstalledAppFlow
                from google.auth.transport.requests import Request
                from googleapiclient.discovery import build
                from googleapiclient.errors import HttpError
                import pickle
            except ImportError as e:
                messagebox.showerror("Erro", 
                                   f"❌ Bibliotecas não instaladas: {e}\n\n"
                                   f"💡 Execute:\n"
                                   f"pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
                return
            
            # Verificar arquivo de credenciais
            file_path = self.credentials_file_var.get()
            if not file_path or not os.path.exists(file_path):
                messagebox.showerror("Erro", "❌ Arquivo de credenciais não encontrado!\n\nSelecione um arquivo válido primeiro.")
                return
            
            # Validar formato do arquivo JSON
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    json_data = json.load(f)
                
                if 'installed' not in json_data:
                    messagebox.showerror("Erro", "❌ Formato de arquivo inválido!\n\nO arquivo deve conter credenciais OAuth 2.0 para aplicação instalada.")
                    return
                    
            except json.JSONDecodeError:
                messagebox.showerror("Erro", "❌ Arquivo JSON inválido!")
                return
            
            # Tentar autenticação
            SCOPES = ['https://www.googleapis.com/auth/calendar']
            
            creds = None
            token_file = os.path.join(self.app.base_dir, 'test_token.pickle')
            
            if os.path.exists(token_file):
                try:
                    with open(token_file, 'rb') as token:
                        creds = pickle.load(token)
                except Exception as e:
                    print(f"Erro ao carregar token de teste: {e}")
                    creds = None
            
            if not creds or not creds.valid:
                if creds and creds.expired and creds.refresh_token:
                    try:
                        creds.refresh(Request())
                    except Exception as e:
                        print(f"Erro ao renovar token: {e}")
                        creds = None
                
                if not creds:
                    try:
                        flow = InstalledAppFlow.from_client_secrets_file(file_path, SCOPES)
                        creds = flow.run_local_server(port=0)
                        
                        # Salvar token de teste
                        with open(token_file, 'wb') as token:
                            pickle.dump(creds, token)
                    except Exception as e:
                        messagebox.showerror("Erro", f"❌ Erro na autenticação OAuth:\n\n{e}")
                        return
            
            # Testar API
            service = build('calendar', 'v3', credentials=creds)
            
            try:
                calendar_list = service.calendarList().list().execute()
                calendars = calendar_list.get('items', [])
                
                if calendars:
                    self.validation_status_var.set("Status: ✅ Conectado (JSON) - Calendários disponíveis")
                    messagebox.showinfo("Sucesso", 
                                      f"🎉 Conexão bem-sucedida!\n\n"
                                      f"📅 Calendários encontrados: {len(calendars)}\n"
                                      f"📝 Primeiro calendário: {calendars[0]['summary']}\n"
                                      f"🔗 Tipo: Arquivo JSON")
                else:
                    self.validation_status_var.set("Status: ⚠️ Conectado (JSON) - Nenhum calendário")
                    messagebox.showwarning("Aviso", "⚠️ Conexão bem-sucedida, mas nenhum calendário encontrado!")
                    
            except HttpError as e:
                error_details = f"Erro {e.resp.status}: {e.content.decode()}"
                self.validation_status_var.set("Status: ❌ Erro de API (JSON)")
                messagebox.showerror("Erro de API", f"❌ Erro na API do Google Calendar:\n\n{error_details}")
                
        except Exception as e:
            self.validation_status_var.set("Status: ❌ Erro de conexão (JSON)")
            messagebox.showerror("Erro de Conexão", f"❌ Erro ao conectar com Google Calendar:\n\n{e}")
    
    def test_key_connection(self):
        """Testa conexão usando ID e chave privada"""
        try:
            # Verificar se as bibliotecas estão instaladas
            try:
                from google.oauth2.credentials import Credentials
                from google_auth_oauthlib.flow import InstalledAppFlow
                from google.auth.transport.requests import Request
                from googleapiclient.discovery import build
                from googleapiclient.errors import HttpError
                import pickle
            except ImportError as e:
                messagebox.showerror("Erro", 
                                   f"❌ Bibliotecas não instaladas: {e}\n\n"
                                   f"💡 Execute:\n"
                                   f"pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
                return
            
            # Verificar credenciais
            client_id = self.client_id_var.get().strip()
            client_secret = self.client_secret_var.get().strip()
            
            if not client_id or not client_secret:
                messagebox.showerror("Erro", "❌ Client ID e Client Secret são obrigatórios!")
                return
            
            # Validar formato do Client ID
            if not client_id.endswith('.apps.googleusercontent.com'):
                messagebox.showwarning("Aviso", "⚠️ Client ID deve terminar com '.apps.googleusercontent.com'")
            
            # Validar formato do Client Secret
            if len(client_secret) < 10:
                messagebox.showwarning("Aviso", "⚠️ Client Secret parece muito curto")
            
            # Criar arquivo temporário de credenciais
            import tempfile
            import json
            
            temp_creds = {
                "installed": {
                    "client_id": client_id,
                    "client_secret": client_secret,
                    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                    "token_uri": "https://oauth2.googleapis.com/token",
                    "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                    "redirect_uris": ["http://localhost"]
                }
            }
            
            # Criar arquivo temporário
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                json.dump(temp_creds, f)
                temp_file = f.name
            
            try:
                # Tentar autenticação
                SCOPES = ['https://www.googleapis.com/auth/calendar']
                
                creds = None
                token_file = os.path.join(self.app.base_dir, 'test_token.pickle')
                
                if os.path.exists(token_file):
                    try:
                        with open(token_file, 'rb') as token:
                            creds = pickle.load(token)
                    except Exception as e:
                        print(f"Erro ao carregar token de teste: {e}")
                        creds = None
                
                if not creds or not creds.valid:
                    if creds and creds.expired and creds.refresh_token:
                        try:
                            creds.refresh(Request())
                        except Exception as e:
                            print(f"Erro ao renovar token: {e}")
                            creds = None
                    
                    if not creds:
                        try:
                            flow = InstalledAppFlow.from_client_secrets_file(temp_file, SCOPES)
                            creds = flow.run_local_server(port=0)
                            
                            # Salvar token de teste
                            with open(token_file, 'wb') as token:
                                pickle.dump(creds, token)
                        except Exception as e:
                            messagebox.showerror("Erro", f"❌ Erro na autenticação OAuth:\n\n{e}")
                            return
                
                # Testar API
                service = build('calendar', 'v3', credentials=creds)
                
                try:
                    calendar_list = service.calendarList().list().execute()
                    calendars = calendar_list.get('items', [])
                    
                    if calendars:
                        self.validation_status_var.set("Status: ✅ Conectado (ID/Chave) - Calendários disponíveis")
                        messagebox.showinfo("Sucesso", 
                                          f"🎉 Conexão bem-sucedida!\n\n"
                                          f"📅 Calendários encontrados: {len(calendars)}\n"
                                          f"📝 Primeiro calendário: {calendars[0]['summary']}\n"
                                          f"🔗 Tipo: ID e Chave Privada")
                    else:
                        self.validation_status_var.set("Status: ⚠️ Conectado (ID/Chave) - Nenhum calendário")
                        messagebox.showwarning("Aviso", "⚠️ Conexão bem-sucedida, mas nenhum calendário encontrado!")
                        
                except HttpError as e:
                    error_details = f"Erro {e.resp.status}: {e.content.decode()}"
                    self.validation_status_var.set("Status: ❌ Erro de API (ID/Chave)")
                    messagebox.showerror("Erro de API", f"❌ Erro na API do Google Calendar:\n\n{error_details}")
                    
            finally:
                # Limpar arquivo temporário
                try:
                    os.unlink(temp_file)
                except:
                    pass
                    
        except Exception as e:
            self.validation_status_var.set("Status: ❌ Erro de conexão (ID/Chave)")
            messagebox.showerror("Erro de Conexão", f"❌ Erro ao conectar com Google Calendar:\n\n{e}")
    
    def open_credentials_config(self):
        """Abre o configurador de credenciais"""
        try:
            import subprocess
            import sys
            
            # Tentar executar o configurador
            subprocess.Popen([os.path.abspath(sys.argv[0]), "config_google_calendar.py"])
            
        except Exception as e:
            messagebox.showerror("Erro", 
                               f"❌ Erro ao abrir configurador: {e}\n\n"
                               f"💡 Execute manualmente:\n"
                               f"python config_google_calendar.py")

    def create_email_tab(self):
        """Cria a aba de configurações de email"""
        frame = self.email_tab
        frame.grid_columnconfigure(1, weight=1)
        
        email_settings = self.app.settings.get('email_integration', {})
        
        # Enable email integration
        self.email_enabled_var = tk.BooleanVar(value=email_settings.get('enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integração de Email", 
                       variable=self.email_enabled_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)
        
        # Provider selection
        ttk.Label(frame, text="Provedor:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        self.email_provider_var = tk.StringVar(value=email_settings.get('provider', 'gmail'))
        provider_frame = ttk.Frame(frame)
        provider_frame.grid(row=1, column=1, sticky="w", padx=10, pady=5)
        
        ttk.Radiobutton(provider_frame, text="Gmail", 
                       variable=self.email_provider_var, value="gmail").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(provider_frame, text="Outlook", 
                       variable=self.email_provider_var, value="outlook").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(provider_frame, text="SMTP Personalizado", 
                       variable=self.email_provider_var, value="smtp").pack(side=tk.LEFT, padx=5)
        
        # Email credentials
        ttk.Label(frame, text="Email:").grid(row=2, column=0, sticky="w", padx=10, pady=5)
        self.email_address_entry = ttk.Entry(frame, width=50)
        self.email_address_entry.grid(row=2, column=1, sticky="ew", padx=10, pady=5)
        self.email_address_entry.insert(0, email_settings.get('email_address', ''))
        
        ttk.Label(frame, text="Senha:").grid(row=3, column=0, sticky="w", padx=10, pady=5)
        self.email_password_entry = ttk.Entry(frame, width=50, show="*")
        self.email_password_entry.grid(row=3, column=1, sticky="ew", padx=10, pady=5)
        self.email_password_entry.insert(0, email_settings.get('email_password', ''))
        
        ttk.Label(frame, text="Senha do App (Gmail):").grid(row=4, column=0, sticky="w", padx=10, pady=5)
        self.app_password_entry = ttk.Entry(frame, width=50, show="*")
        self.app_password_entry.grid(row=4, column=1, sticky="ew", padx=10, pady=5)
        self.app_password_entry.insert(0, email_settings.get('app_password', ''))
        
        # SMTP settings
        ttk.Label(frame, text="Servidor SMTP:").grid(row=5, column=0, sticky="w", padx=10, pady=5)
        self.smtp_server_entry = ttk.Entry(frame, width=50)
        self.smtp_server_entry.grid(row=5, column=1, sticky="ew", padx=10, pady=5)
        self.smtp_server_entry.insert(0, email_settings.get('smtp_server', 'smtp.gmail.com'))
        
        ttk.Label(frame, text="Porta SMTP:").grid(row=6, column=0, sticky="w", padx=10, pady=5)
        self.smtp_port_entry = ttk.Entry(frame, width=50)
        self.smtp_port_entry.grid(row=6, column=1, sticky="ew", padx=10, pady=5)
        self.smtp_port_entry.insert(0, str(email_settings.get('smtp_port', 587)))
        
        # Auto notifications
        notif_frame = ttk.LabelFrame(frame, text="Notificações Automáticas", padding=10)
        notif_frame.grid(row=7, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        auto_notifications = email_settings.get('auto_notifications', {})
        
        self.notify_card_created_var = tk.BooleanVar(value=auto_notifications.get('card_created', True))
        ttk.Checkbutton(notif_frame, text="Cartão Criado", 
                       variable=self.notify_card_created_var).pack(anchor=tk.W, pady=2)
        
        self.notify_card_modified_var = tk.BooleanVar(value=auto_notifications.get('card_modified', True))
        ttk.Checkbutton(notif_frame, text="Cartão Modificado", 
                       variable=self.notify_card_modified_var).pack(anchor=tk.W, pady=2)
        
        self.notify_card_moved_var = tk.BooleanVar(value=auto_notifications.get('card_moved', True))
        ttk.Checkbutton(notif_frame, text="Cartão Movido", 
                       variable=self.notify_card_moved_var).pack(anchor=tk.W, pady=2)
        
        self.notify_deadline_reminder_var = tk.BooleanVar(value=auto_notifications.get('deadline_reminder', True))
        ttk.Checkbutton(notif_frame, text="Lembrete de Prazo", 
                       variable=self.notify_deadline_reminder_var).pack(anchor=tk.W, pady=2)
        
        self.notify_weekly_report_var = tk.BooleanVar(value=auto_notifications.get('weekly_report', True))
        ttk.Checkbutton(notif_frame, text="Relatório Semanal", 
                       variable=self.notify_weekly_report_var).pack(anchor=tk.W, pady=2)
        
        # Recipients
        ttk.Label(frame, text="Destinatários (separados por vírgula):").grid(row=8, column=0, sticky="w", padx=10, pady=5)
        self.recipients_entry = ttk.Entry(frame, width=50)
        self.recipients_entry.grid(row=8, column=1, sticky="ew", padx=10, pady=5)
        recipients = email_settings.get('notification_recipients', [])
        self.recipients_entry.insert(0, ', '.join(recipients))
        
        # Reminder settings
        reminder_frame = ttk.LabelFrame(frame, text="Configurações de Lembrete", padding=10)
        reminder_frame.grid(row=9, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        ttk.Label(reminder_frame, text="Horas antes do prazo:").pack(anchor=tk.W, pady=2)
        self.reminder_hours_var = tk.StringVar(value=str(email_settings.get('deadline_reminder_hours', 24)))
        reminder_hours_spinbox = ttk.Spinbox(reminder_frame, from_=1, to=168, textvariable=self.reminder_hours_var, width=10)
        reminder_hours_spinbox.pack(anchor=tk.W, pady=2)
        
        # Weekly report settings
        report_frame = ttk.LabelFrame(frame, text="Relatório Semanal", padding=10)
        report_frame.grid(row=10, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        ttk.Label(report_frame, text="Dia da semana:").pack(anchor=tk.W, pady=2)

    def create_calendar_tab(self):
        """Cria a aba de configurações do Google Calendar"""
        frame = self.calendar_tab
        frame.grid_columnconfigure(1, weight=1)
        
        calendar_settings = self.app.settings.get('google_calendar', {})
        
        # Enable Google Calendar integration
        self.calendar_enabled_var = tk.BooleanVar(value=calendar_settings.get('enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integração com Google Calendar", 
                       variable=self.calendar_enabled_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)
        
        # Credentials file
        ttk.Label(frame, text="Arquivo de Credenciais:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        self.credentials_file_var = tk.StringVar(value=calendar_settings.get('credentials_file', ''))
        credentials_frame = ttk.Frame(frame)
        credentials_frame.grid(row=1, column=1, sticky="ew", padx=10, pady=5)
        
        self.credentials_entry = ttk.Entry(credentials_frame, textvariable=self.credentials_file_var, width=40)
        self.credentials_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(credentials_frame, text="Procurar", command=self.browse_credentials_file).pack(side=tk.RIGHT, padx=(5, 0))
        
        # Instructions
        instructions_frame = ttk.LabelFrame(frame, text="Instruções", padding=10)
        instructions_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        instructions_text = """
Para configurar o Google Calendar:

1. Acesse https://console.developers.google.com/
2. Crie um novo projeto ou selecione um existente
3. Ative a Google Calendar API
4. Crie credenciais OAuth 2.0
5. Baixe o arquivo JSON de credenciais
6. Selecione o arquivo acima
        """.strip()
        
        ttk.Label(instructions_frame, text=instructions_text, justify=tk.LEFT).pack(anchor=tk.W)
        
        # Auto sync settings
        sync_frame = ttk.LabelFrame(frame, text="Sincronização Automática", padding=10)
        sync_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        self.auto_sync_var = tk.BooleanVar(value=calendar_settings.get('auto_sync', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar automaticamente", 
                       variable=self.auto_sync_var).pack(anchor=tk.W, pady=2)
        
        self.sync_cards_var = tk.BooleanVar(value=calendar_settings.get('sync_cards', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar cartões com prazo", 
                       variable=self.sync_cards_var).pack(anchor=tk.W, pady=2)
        
        self.sync_events_var = tk.BooleanVar(value=calendar_settings.get('sync_events', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar eventos do calendário", 
                       variable=self.sync_events_var).pack(anchor=tk.W, pady=2)
        
        # Email management settings
        email_frame = ttk.LabelFrame(frame, text="Gerenciamento de Emails", padding=10)
        email_frame.grid(row=4, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        # Add default emails
        ttk.Label(email_frame, text="Emails Padrão (um por linha):").pack(anchor=tk.W, pady=(0, 5))
        
        email_text_frame = ttk.Frame(email_frame)
        email_text_frame.pack(fill=tk.X, pady=(0, 5))
        
        self.default_emails_text = tk.Text(email_text_frame, height=4, width=50)
        email_scrollbar = ttk.Scrollbar(email_text_frame, orient="vertical", command=self.default_emails_text.yview)
        self.default_emails_text.configure(yscrollcommand=email_scrollbar.set)
        
        self.default_emails_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        email_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Load existing emails
        default_emails = calendar_settings.get('default_emails', [])
        self.default_emails_text.insert("1.0", "\n".join(default_emails))
        
        # Email options
        email_options_frame = ttk.Frame(email_frame)
        email_options_frame.pack(fill=tk.X, pady=(5, 0))
        
        self.include_default_emails_var = tk.BooleanVar(value=calendar_settings.get('include_default_emails', True))
        ttk.Checkbutton(email_options_frame, text="Incluir emails padrão em todos os eventos", 
                       variable=self.include_default_emails_var).pack(side=tk.LEFT, padx=(0, 10))
        
        self.include_card_members_var = tk.BooleanVar(value=calendar_settings.get('include_card_members', True))
        ttk.Checkbutton(email_options_frame, text="Incluir membros do card automaticamente", 
                       variable=self.include_card_members_var).pack(side=tk.LEFT)
        
        # Instructions for emails
        email_instructions = ttk.LabelFrame(email_frame, text="Instruções para Emails", padding=5)
        email_instructions.pack(fill=tk.X, pady=(10, 0))
        
        instructions_text = """
* Emails padrão: Serão incluídos em todos os eventos criados
* Membros do card: Serão adicionados automaticamente se tiverem email configurado
* Formato: um email por linha (exemplo@email.com)
* Os emails receberão convites automáticos do Google Calendar
        """.strip()
        
        ttk.Label(email_instructions, text=instructions_text, justify=tk.LEFT, font=("TkDefaultFont", 8)).pack(anchor=tk.W)

    def create_email_templates_tab(self):
        """Cria a aba de gerenciamento de templates de email"""
        frame = self.email_templates_tab
        frame.grid_columnconfigure(1, weight=1)
        frame.grid_rowconfigure(2, weight=1)
        
        # Template selection
        ttk.Label(frame, text="Template:").grid(row=0, column=0, sticky="w", padx=10, pady=5)
        self.template_var = tk.StringVar()
        self.template_combo = ttk.Combobox(frame, textvariable=self.template_var, state="readonly", width=30)
        self.template_combo.grid(row=0, column=1, sticky="w", padx=10, pady=5)
        self.template_combo['values'] = self.app.email_template_manager.get_available_templates()
        self.template_combo.bind("<<ComboboxSelected>>", self.on_template_selected)
        
        # Template actions
        template_actions = ttk.Frame(frame)
        template_actions.grid(row=1, column=0, columnspan=2, sticky="w", padx=10, pady=5)
        
        ttk.Button(template_actions, text="Novo Template", command=self.create_new_template).pack(side=tk.LEFT, padx=2)
        ttk.Button(template_actions, text="Duplicar", command=self.duplicate_template).pack(side=tk.LEFT, padx=2)
        ttk.Button(template_actions, text="Excluir", command=self.delete_template).pack(side=tk.LEFT, padx=2)
        
        # Template editor
        editor_frame = ttk.LabelFrame(frame, text="Editor de Template", padding=10)
        editor_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", padx=10, pady=10)
        editor_frame.grid_columnconfigure(0, weight=1)
        editor_frame.grid_rowconfigure(1, weight=1)
        
        # Subject
        ttk.Label(editor_frame, text="Assunto:").grid(row=0, column=0, sticky="w", pady=(0, 5))
        self.subject_var = tk.StringVar()
        self.subject_entry = ttk.Entry(editor_frame, textvariable=self.subject_var, width=60)
        self.subject_entry.grid(row=0, column=1, sticky="ew", pady=(0, 5), padx=(10, 0))
        
        # Body
        ttk.Label(editor_frame, text="Corpo do Email:").grid(row=1, column=0, sticky="nw", pady=(0, 5))
        body_frame = ttk.Frame(editor_frame)
        body_frame.grid(row=1, column=1, sticky="nsew", padx=(10, 0))
        body_frame.grid_columnconfigure(0, weight=1)
        body_frame.grid_rowconfigure(0, weight=1)
        
        # Advanced text editor for email body
        try:
            from advanced_text_editor import AdvancedTextEditor
            self.body_editor = AdvancedTextEditor(body_frame, height=15, width=60)
            self.body_editor.grid(row=0, column=0, sticky="nsew")
            self.body_text = self.body_editor.text_widget
        except ImportError:
            # Fallback to simple text widget if advanced editor is not available
            self.body_text = tk.Text(body_frame, height=15, width=60)
            body_scrollbar = ttk.Scrollbar(body_frame, orient="vertical", command=self.body_text.yview)
            self.body_text.configure(yscrollcommand=body_scrollbar.set)
            
            self.body_text.grid(row=0, column=0, sticky="nsew")
            body_scrollbar.grid(row=0, column=1, sticky="ns")
        
        # Variables help
        variables_frame = ttk.LabelFrame(frame, text="Variáveis Disponíveis", padding=10)
        variables_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        variables_text = """
Variáveis que podem ser usadas nos templates:
{card_title} - Título do cartão
{board_name} - Nome do quadro
{list_name} - Nome da lista
{card_description} - Descrição do cartão
{due_date} - Data de vencimento
{importance} - Nível de importância
{member_name} - Nome do membro
{changes} - Lista de alterações
{week_period} - Período do relatório
{completed_tasks} - Tarefas concluídas
{pending_tasks} - Tarefas pendentes
{total_pomodoro_time} - Tempo total de pomodoro
{productivity_score} - Score de produtividade
{important_completed_tasks} - Tarefas importantes concluídas
{upcoming_deadlines} - Próximos prazos
        """.strip()
        
        ttk.Label(variables_frame, text=variables_text, justify=tk.LEFT, font=("TkDefaultFont", 9)).pack(anchor=tk.W)
        
        # Save button
        save_frame = ttk.Frame(frame)
        save_frame.grid(row=4, column=0, columnspan=2, pady=10)
        
        ttk.Button(save_frame, text="Salvar Template", command=self.save_template).pack(side=tk.LEFT, padx=5)
        ttk.Button(save_frame, text="Testar Template", command=self.test_template).pack(side=tk.LEFT, padx=5)
        ttk.Button(save_frame, text="Restaurar Padrão", command=self.restore_default_template).pack(side=tk.LEFT, padx=5)

    def browse_credentials_file(self):
        """Abre diálogo para selecionar arquivo de credenciais"""
        from tkinter import filedialog
        filename = filedialog.askopenfilename(
            title="Selecionar arquivo de credenciais",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if filename:
            self.credentials_file_var.set(filename)

    def on_template_selected(self, event=None):
        """Chamado quando um template é selecionado"""
        template_name = self.template_var.get()
        if template_name:
            template = self.app.email_template_manager.get_template(template_name)
            if template:
                self.subject_var.set(template.get('subject', ''))
                self.body_text.delete("1.0", tk.END)
                self.body_text.insert("1.0", template.get('body', ''))

    def create_new_template(self):
        """Cria um novo template"""
        template_name = simpledialog.askstring("Novo Template", "Nome do template:")
        if template_name:
            if template_name in self.app.email_template_manager.get_available_templates():
                messagebox.showwarning("Aviso", "Template com este nome já existe!")
                return
            
            # Adicionar ao combo
            current_values = list(self.template_combo['values'])
            current_values.append(template_name)
            self.template_combo['values'] = current_values
            self.template_combo.set(template_name)
            
            # Limpar campos
            self.subject_var.set("")
            self.body_text.delete("1.0", tk.END)
            
            # Focar no campo de assunto
            self.subject_entry.focus()

    def duplicate_template(self):
        """Duplica o template selecionado"""
        current_template = self.template_var.get()
        if not current_template:
            messagebox.showwarning("Aviso", "Selecione um template para duplicar!")
            return
        
        new_name = simpledialog.askstring("Duplicar Template", f"Nome do novo template (baseado em {current_template}):")
        if new_name:
            if new_name in self.app.email_template_manager.get_available_templates():
                messagebox.showwarning("Aviso", "Template com este nome já existe!")
                return
            
            # Copiar template
            original_template = self.app.email_template_manager.get_template(current_template)
            self.app.email_template_manager.update_template(
                new_name, 
                original_template.get('subject', ''),
                original_template.get('body', '')
            )
            
            # Atualizar combo
            current_values = list(self.template_combo['values'])
            current_values.append(new_name)
            self.template_combo['values'] = current_values
            self.template_combo.set(new_name)

    def delete_template(self):
        """Exclui o template selecionado"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para excluir!")
            return
        
        if messagebox.askyesno("Confirmar", f"Tem certeza que deseja excluir o template '{template_name}'?"):
            # Remover template
            templates = self.app.email_template_manager.templates
            if template_name in templates:
                del templates[template_name]
                self.app.email_template_manager.save_templates()
            
            # Atualizar combo
            current_values = list(self.template_combo['values'])
            current_values.remove(template_name)
            self.template_combo['values'] = current_values
            self.template_combo.set("")
            
            # Limpar campos
            self.subject_var.set("")
            self.body_text.delete("1.0", tk.END)

    def save_template(self):
        """Salva o template atual"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para salvar!")
            return
        
        subject = self.subject_var.get().strip()
        body = self.body_text.get("1.0", tk.END).strip()
        
        if not subject:
            messagebox.showwarning("Aviso", "O assunto é obrigatório!")
            return
        
        # Salvar template
        self.app.email_template_manager.update_template(template_name, subject, body)
        messagebox.showinfo("Sucesso", "Template salvo com sucesso!")

    def test_template(self):
        """Testa o template atual com dados de exemplo"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para testar!")
            return
        
        # Dados de exemplo
        test_variables = {
            'card_title': 'Tarefa de Exemplo',
            'board_name': 'Quadro de Teste',
            'list_name': 'Em Progresso',
            'card_description': 'Esta é uma descrição de exemplo',
            'due_date': '2024-01-15',
            'importance': 'Alta',
            'member_name': 'João Silva',
            'changes': '- Título alterado\n- Prazo atualizado',
            'week_period': '01/01/2024 - 07/01/2024',
            'completed_tasks': '5',
            'pending_tasks': '3',
            'total_pomodoro_time': '12h 30m',
            'productivity_score': '85',
            'important_completed_tasks': '- Tarefa importante 1\n- Tarefa importante 2',
            'upcoming_deadlines': '- Reunião de equipe (15/01)\n- Relatório mensal (20/01)'
        }
        
        # Formatar template
        subject, body = self.app.email_template_manager.format_template(template_name, test_variables)
        
        # Mostrar preview
        preview_window = tk.Toplevel(self)
        preview_window.title("Preview do Template")
        preview_window.geometry("600x500")
        preview_window.transient(self)
        preview_window.grab_set()
        
        # Assunto
        ttk.Label(preview_window, text="Assunto:", font=("TkDefaultFont", 10, "bold")).pack(anchor="w", padx=10, pady=(10, 5))
        subject_text = tk.Text(preview_window, height=2, width=70)
        subject_text.pack(fill=tk.X, padx=10, pady=(0, 10))
        subject_text.insert("1.0", subject)
        subject_text.config(state="disabled")
        
        # Corpo
        ttk.Label(preview_window, text="Corpo:", font=("TkDefaultFont", 10, "bold")).pack(anchor="w", padx=10, pady=(10, 5))
        body_text = tk.Text(preview_window, height=20, width=70)
        body_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
        body_text.insert("1.0", body)
        body_text.config(state="disabled")
        
        # Botão fechar
        ttk.Button(preview_window, text="Fechar", command=preview_window.destroy).pack(pady=10)

    def restore_default_template(self):
        """Restaura o template padrão"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para restaurar!")
            return
        
        if messagebox.askyesno("Confirmar", f"Tem certeza que deseja restaurar o template '{template_name}' para o padrão?"):
            # Recarregar templates padrão
            self.app.email_template_manager.load_templates()
            
            # Atualizar campos
            self.on_template_selected()
            
            messagebox.showinfo("Sucesso", "Template restaurado para o padrão!")

    def toggle_config_frames(self):
        self.report_day_var = tk.StringVar(value=email_settings.get('weekly_report_day', 'monday'))
        report_day_combo = ttk.Combobox(report_frame, textvariable=self.report_day_var, 
                                       values=['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
                                       state="readonly")
        report_day_combo.pack(anchor=tk.W, pady=2)
        
        ttk.Label(report_frame, text="Horário (HH:MM):").pack(anchor=tk.W, pady=2)
        self.report_time_var = tk.StringVar(value=email_settings.get('weekly_report_time', '09:00'))
        report_time_entry = ttk.Entry(report_frame, textvariable=self.report_time_var, width=10)
        report_time_entry.pack(anchor=tk.W, pady=2)
        
        # Test connection button
        ttk.Button(frame, text="Testar Conexão", 
                  command=self.test_email_connection).grid(row=11, column=0, columnspan=2, pady=10)

    def toggle_config_frames(self):
        """Alterna a visibilidade dos frames de configuração"""
        if self.config_type_var.get() == "individual":
            self.individual_frame.grid()
            self.centralized_frame.grid_remove()
        else:
            self.individual_frame.grid_remove()
            self.centralized_frame.grid()

    def preview_dashboard_settings(self):
        """Mostra preview das configurações do dashboard"""
        enabled_widgets = [name for key, var in self.dashboard_widget_vars.items() if var.get()]
        messagebox.showinfo("Preview Dashboard", 
                          f"Widgets habilitados:\n" + "\n".join([f"• {name}" for name in enabled_widgets]))

    # Funções de teste e reautenticação do Google Calendar removidas - integração desabilitada

    def test_email_connection(self):
        """Testa a conexão de email"""
        try:
            # Create temporary email integration for testing
            temp_email = EmailIntegration(self.app)
            temp_email.settings = {
                'enabled': True,
                'provider': self.email_provider_var.get(),
                'email_address': self.email_address_entry.get(),
                'email_password': self.email_password_entry.get(),
                'app_password': self.app_password_entry.get(),
                'smtp_server': self.smtp_server_entry.get(),
                'smtp_port': int(self.smtp_port_entry.get()),
                'demo_mode': True  # Use demo mode for testing
            }
            
            # Test with demo mode
            if temp_email.send_email("test@example.com", "Teste de Conexão", "Este é um teste de conexão."):
                messagebox.showinfo("Teste de Conexão", "Conexão de email testada com sucesso (modo demo)!")
            else:
                messagebox.showerror("Erro de Conexão", "Falha ao testar conexão de email.")
                
        except Exception as e:
            messagebox.showerror("Erro de Conexão", f"Erro ao testar conexão: {e}")

    def create_pomodoro_tab(self):
        frame = self.pomodoro_tab
        frame.grid_columnconfigure(1, weight=1)

        ttk.Label(frame, text="Tempo do Pomodoro (minutos):").grid(row=0, column=0, sticky="w", padx=10, pady=(10, 2))
        self.pomodoro_entry = ttk.Spinbox(frame, from_=1, to=120, increment=1)
        self.pomodoro_entry.grid(row=0, column=1, sticky="ew", padx=10, pady=(10, 2))
        self.pomodoro_entry.set(self.app.settings['pomodoro'])

        ttk.Label(frame, text="Pausa Curta (minutos):").grid(row=1, column=0, sticky="w", padx=10, pady=2)
        self.short_break_entry = ttk.Spinbox(frame, from_=1, to=60, increment=1)
        self.short_break_entry.grid(row=1, column=1, sticky="ew", padx=10, pady=2)
        self.short_break_entry.set(self.app.settings['short_break'])

        ttk.Label(frame, text="Pausa Longa (minutos):").grid(row=2, column=0, sticky="w", padx=10, pady=2)
        self.long_break_entry = ttk.Spinbox(frame, from_=1, to=120, increment=1)
        self.long_break_entry.grid(row=2, column=1, sticky="ew", padx=10, pady=2)
        self.long_break_entry.set(self.app.settings['long_break'])

        ttk.Label(frame, text="Ciclos até a Pausa Longa:").grid(row=3, column=0, sticky="w", padx=10, pady=2)
        self.cycles_entry = ttk.Spinbox(frame, from_=1, to=10, increment=1)
        self.cycles_entry.grid(row=3, column=1, sticky="ew", padx=10, pady=2)
        self.cycles_entry.set(self.app.settings['cycles'])

    def _check_admin_permissions(self):
        """Verifica se o usuário atual tem permissões de administrador"""
        try:
            if not hasattr(self.app, 'current_user') or not self.app.current_user:
                return False
            
            # Verificar role do usuário
            user_role = getattr(self.app.current_user, 'role', '').lower()
            user_cargo = getattr(self.app.current_user, 'cargo', '').lower()
            
            # Administradores podem ser identificados por role ou cargo
            admin_roles = ['admin', 'administrador', 'administrator']
            admin_cargos = ['admin', 'administrador', 'administrator', 'gerente', 'manager']
            
            return (user_role in admin_roles or user_cargo in admin_cargos)
            
        except Exception as e:
            print(f"Erro ao verificar permissões de administrador: {e}")
            return False

    def _populate_importance_treeview(self):
        for i in self.importance_tree.get_children():
            self.importance_tree.delete(i)
        for name, color in self.app.settings["importance_colors"].items():
            self.importance_tree.insert("", "end", values=(name, color), tags=(name,))
            self.importance_tree.tag_configure(name, background=color)

    def _add_importance_level(self):
        # Verificar permissões de administrador
        if not self._check_admin_permissions():
            messagebox.showerror("Acesso Negado", "Apenas administradores podem adicionar níveis de importância.", parent=self)
            return
            
        new_name = simpledialog.askstring("Novo Nível de Importância", "Digite o nome para o novo nível de importância:", parent=self)
        if new_name:
            new_name = new_name.strip()
            if new_name in self.app.settings["importance_colors"]:
                messagebox.showwarning("Nome Duplicado", f"O nível de importância '{new_name}' já existe.", parent=self)
                return
            color_code = colorchooser.askcolor(title=f"Escolha a cor para {new_name}")
            if color_code[1]:
                self.app.settings["importance_colors"][new_name] = color_code[1]
                self._populate_importance_treeview()
            else:
                messagebox.showwarning("Cor Não Selecionada", "Nenhuma cor foi selecionada para o novo nível.", parent=self)

    def _remove_importance_level(self):
        # Verificar permissões de administrador
        if not self._check_admin_permissions():
            messagebox.showerror("Acesso Negado", "Apenas administradores podem remover níveis de importância.", parent=self)
            return
            
        selected_item = self.importance_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um nível de importância para remover.", parent=self)
            return
        
        importance_name = self.importance_tree.item(selected_item, "values")[0]
        
        # Prevent removal of default importance levels
        default_importance_levels = self.app.get_default_settings()["importance_colors"].keys()
        if importance_name in default_importance_levels:
            messagebox.showwarning("Nível Padrão", f"O nível de importância '{importance_name}' é padrão e não pode ser removido.", parent=self)
            return

        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover o nível de importância '{importance_name}'? Isso pode afetar cartões existentes.", parent=self):
            del self.app.settings["importance_colors"][importance_name]
            self._populate_importance_treeview()

    def _edit_importance_color(self, event):
        # Verificar permissões de administrador
        if not self._check_admin_permissions():
            messagebox.showerror("Acesso Negado", "Apenas administradores podem editar cores de importância.", parent=self)
            return
            
        selected_item = self.importance_tree.selection()
        if not selected_item:
            return
        
        importance_name = self.importance_tree.item(selected_item, "values")[0]
        current_color = self.app.settings["importance_colors"][importance_name]

        color_code = colorchooser.askcolor(title=f"Escolha a nova cor para {importance_name}", initialcolor=current_color)
        if color_code[1]:
            self.app.settings["importance_colors"][importance_name] = color_code[1]
            self._populate_importance_treeview()

    def choose_color(self, importance, color_label):
        # This method is now deprecated but kept for compatibility if needed elsewhere
        color_code = colorchooser.askcolor(title=f"Escolha a cor para {importance}")
        if color_code[1]:
            color_label.config(bg=color_code[1], text=color_code[1])

    def create_roles_tab(self):
        frame = self.roles_tab
        frame.grid_columnconfigure(0, weight=1)
        frame.grid_rowconfigure(0, weight=1)

        roles_frame = ttk.LabelFrame(frame, text="Gerenciar Cargos", padding=10)
        roles_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        roles_frame.grid_columnconfigure(0, weight=1)

        self.roles_tree = ttk.Treeview(roles_frame, columns=("Nome", "Descrição"), show="headings")
        self.roles_tree.heading("Nome", text="Nome")
        self.roles_tree.heading("Descrição", text="Descrição")
        self.roles_tree.column("Nome", width=150, anchor="w")
        self.roles_tree.column("Descrição", width=300, anchor="w")
        self.roles_tree.pack(fill="both", expand=True, pady=5)
        self.roles_tree.bind("<Double-1>", self._edit_role_level) # Double click to edit

        roles_buttons_frame = ttk.Frame(roles_frame)
        roles_buttons_frame.pack(fill="x", pady=5)

        ttk.Button(roles_buttons_frame, text="Adicionar Cargo", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_role_level).pack(side="left", padx=5)
        ttk.Button(roles_buttons_frame, text="Remover Cargo", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_role_level).pack(side="left", padx=5)

        self.app.load_settings() # Ensure settings are up-to-date
        self._populate_roles_treeview()

    def _populate_roles_treeview(self):
        for i in self.roles_tree.get_children():
            self.roles_tree.delete(i)
        for name, desc in self.app.settings["roles"].items():
            self.roles_tree.insert("", "end", values=(name, desc), tags=(name,))

    def _add_role_level(self):
        new_name = simpledialog.askstring("Novo Cargo", "Digite o nome para o novo cargo:", parent=self)
        if new_name:
            new_name = new_name.strip()
            if new_name in self.app.settings["roles"]:
                messagebox.showwarning("Nome Duplicado", f"O cargo '{new_name}' já existe.", parent=self)
                return
            new_desc = simpledialog.askstring("Descrição do Cargo", f"Digite a descrição para o cargo '{new_name}':", parent=self)
            if new_desc is not None:
                self.app.settings["roles"][new_name] = new_desc.strip()
                self.app.save_settings_file()
                self._populate_roles_treeview()
            else:
                messagebox.showwarning("Descrição Necessária", "A descrição do cargo é necessária.", parent=self)

    def _edit_role_level(self, event):
        selected_item = self.roles_tree.selection()
        if not selected_item:
            return
        
        role_name = self.roles_tree.item(selected_item, "values")[0]
        current_desc = self.app.settings["roles"][role_name]

        new_desc = simpledialog.askstring("Editar Cargo", f"Editar descrição para '{role_name}':", initialvalue=current_desc, parent=self)
        if new_desc is not None:
            self.app.settings["roles"][role_name] = new_desc.strip()
            self.app.save_settings_file()
            self._populate_roles_treeview()

    def _remove_role_level(self):
        selected_item = self.roles_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Seleção", "Selecione um cargo para remover.", parent=self)
            return
        
        role_name = self.roles_tree.item(selected_item, "values")[0]
        
        # Prevent removal of default roles
        default_roles = self.app.get_default_settings()["roles"].keys()
        if role_name in default_roles:
            messagebox.showwarning("Cargo Padrão", f"O cargo '{role_name}' é padrão e não pode ser removido.", parent=self)
            return

        if messagebox.askyesno("Confirmar Remoção", f"Tem certeza que deseja remover o cargo '{role_name}'?", parent=self):
            del self.app.settings["roles"][role_name]
            self.app.save_settings_file()
            self._populate_roles_treeview()

    def restore_defaults(self):
        if messagebox.askyesno("Restaurar Padrões", "Tem certeza que deseja restaurar todas as configurações para os valores de fábrica?"):
            self.app.settings = self.app.get_default_settings()
            self.app.save_settings_file()
            self.destroy()
            self.app.open_settings()

    def save_settings(self):
        try:
            # Verificar se as variáveis existem antes de acessá-las
            if hasattr(self, 'pomodoro_entry'):
                pomodoro = int(self.pomodoro_entry.get())
                short_break = int(self.short_break_entry.get())
                long_break = int(self.long_break_entry.get())
                cycles = int(self.cycles_entry.get())

                if not all(x > 0 for x in [pomodoro, short_break, long_break, cycles]):
                    raise ValueError("Todos os valores devem ser maiores que zero.")

                self.app.settings['pomodoro'] = pomodoro
                self.app.settings['short_break'] = short_break
                self.app.settings['long_break'] = long_break
                self.app.settings['cycles'] = cycles

            # Configurações gerais
            if hasattr(self, 'theme_combo'):
                self.app.settings['theme'] = self.theme_combo.get()
            if hasattr(self, 'unify_subjects_var'):
                self.app.settings['unify_subjects'] = self.unify_subjects_var.get()
            if hasattr(self, 'show_card_details_on_board_var'):
                self.app.settings['show_card_details_on_board'] = self.show_card_details_on_board_var.get()
            if hasattr(self, 'dev_mode_var'):
                self.app.settings['dev_mode'] = self.dev_mode_var.get()
            if hasattr(self, 'git_integration_enabled_var'):
                self.app.settings['git_integration_enabled'] = self.git_integration_enabled_var.get()

            # Save dashboard widget settings
            if hasattr(self, 'dashboard_widget_vars'):
                dashboard_widgets = {}
                for key, var in self.dashboard_widget_vars.items():
                    if key == 'meeting_widget':
                        # Salvar configuração do widget de reuniões
                        self.app.notification_manager.notification_settings['show_widget'] = var.get()
                        self.app.notification_manager.save_notification_settings()
                    else:
                        dashboard_widgets[key] = var.get()
                
                self.app.settings['dashboard_widgets'] = dashboard_widgets

            # Save Google Calendar settings
            if hasattr(self, 'calendar_enabled_var'):
                calendar_settings = {
                    'enabled': self.calendar_enabled_var.get(),
                    'auth_type': self.auth_type_var.get() if hasattr(self, 'auth_type_var') else 'json',
                    'credentials_file': self.credentials_file_var.get() if hasattr(self, 'credentials_file_var') else '',
                    'client_id': self.client_id_var.get() if hasattr(self, 'client_id_var') else '',
                    'client_secret': self.client_secret_var.get() if hasattr(self, 'client_secret_var') else '',
                    'sync_auto': self.sync_auto_var.get() if hasattr(self, 'sync_auto_var') else True,
                    'sync_cards_deadline': self.sync_cards_deadline_var.get() if hasattr(self, 'sync_cards_deadline_var') else True,
                    'sync_calendar_events': self.sync_calendar_events_var.get() if hasattr(self, 'sync_calendar_events_var') else True
                }
                
                # Validar configurações do Google Calendar antes de salvar
                if calendar_settings['enabled']:
                    if calendar_settings['auth_type'] == 'json':
                        if not calendar_settings['credentials_file'] or not os.path.exists(calendar_settings['credentials_file']):
                            messagebox.showerror("Erro", "❌ Arquivo de credenciais JSON não encontrado!\n\nConfigure um arquivo válido primeiro.")
                            return
                    elif calendar_settings['auth_type'] == 'key':
                        if not calendar_settings['client_id'].strip() or not calendar_settings['client_secret'].strip():
                            messagebox.showerror("Erro", "❌ Client ID e Client Secret são obrigatórios!\n\nConfigure as credenciais primeiro.")
                            return
                    else:
                        messagebox.showerror("Erro", "❌ Tipo de autenticação inválido!")
                        return
                
                self.app.settings['calendar_integration'] = calendar_settings

            # Save Google Calendar email settings
            if hasattr(self, 'default_emails_text'):
                # Get emails from text widget
                emails_text = self.default_emails_text.get("1.0", tk.END).strip()
                default_emails = [email.strip() for email in emails_text.split('\n') if email.strip()]
                
                # Validate email format
                import re
                email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
                valid_emails = []
                invalid_emails = []
                
                for email in default_emails:
                    if email_pattern.match(email):
                        valid_emails.append(email)
                    else:
                        invalid_emails.append(email)
                
                if invalid_emails:
                    messagebox.showwarning("Emails Inválidos", 
                                         f"Os seguintes emails não são válidos e serão ignorados:\n{', '.join(invalid_emails)}")
                
                # Update calendar settings with email configuration
                calendar_settings.update({
                    'default_emails': valid_emails,
                    'include_default_emails': self.include_default_emails_var.get() if hasattr(self, 'include_default_emails_var') else True,
                    'include_card_members': self.include_card_members_var.get() if hasattr(self, 'include_card_members_var') else True
                })
                
                self.app.settings['calendar_integration'] = calendar_settings

            # Save email integration settings
            if hasattr(self, 'email_enabled_var'):
                recipients = [email.strip() for email in self.recipients_entry.get().split(',') if email.strip()]
                self.app.settings['email_integration'] = {
                                    'enabled': self.email_enabled_var.get() if hasattr(self, 'email_enabled_var') else False,
                'provider': self.email_provider_var.get() if hasattr(self, 'email_provider_var') else 'gmail',
                    'email_address': self.email_address_entry.get() if hasattr(self, 'email_address_entry') else '',
                    'email_password': self.email_password_entry.get() if hasattr(self, 'email_password_entry') else '',
                    'app_password': self.app_password_entry.get() if hasattr(self, 'app_password_entry') else '',
                    'smtp_server': self.smtp_server_entry.get() if hasattr(self, 'smtp_server_entry') else 'smtp.gmail.com',
                    'smtp_port': int(self.smtp_port_entry.get()) if hasattr(self, 'smtp_port_entry') else 587,
                                    'auto_notifications': {
                    'card_created': self.notify_card_created_var.get() if hasattr(self, 'notify_card_created_var') else True,
                    'card_modified': self.notify_card_modified_var.get() if hasattr(self, 'notify_card_modified_var') else True,
                    'card_moved': self.notify_card_moved_var.get() if hasattr(self, 'notify_card_moved_var') else True,
                    'deadline_reminder': self.notify_deadline_reminder_var.get() if hasattr(self, 'notify_deadline_reminder_var') else True,
                    'weekly_report': self.notify_weekly_report_var.get() if hasattr(self, 'notify_weekly_report_var') else True
                },
                    'notification_recipients': recipients,
                    'deadline_reminder_hours': int(self.reminder_hours_var.get()) if hasattr(self, 'reminder_hours_var') else 24,
                    'weekly_report_day': self.report_day_var.get() if hasattr(self, 'report_day_var') else 'monday',
                    'weekly_report_time': self.report_time_var.get() if hasattr(self, 'report_time_var') else '09:00'
                }

            # Roles are already updated directly by _add_role_level, _edit_role_level, _remove_role_level
            # No need to iterate self.color_labels anymore

            self.app.save_settings_file()
            
            # Apply dashboard widget settings
            self.app.apply_dashboard_widget_settings()
            self.app.change_theme(self.app.settings['theme'])
            self.app.load_aux_data()
            self.app.update_timer_display()
            
            # Preservar o estado do calendário ANTES de atualizar os quadros
            calendar_state = None
            if hasattr(self.app, 'calendar_widget') and self.app.calendar_widget:
                try:
                    # Capturar estado atual do calendário
                    calendar_state = {
                        'selected_date': self.app.calendar_widget.get_date(),
                        'current_month': datetime.now().strftime("%Y-%m-%d"),  # Usar data atual em vez de calevent_date
                        'events': [],
                        'calendar_width': self.app.calendar_widget.winfo_width(),
                        'calendar_height': self.app.calendar_widget.winfo_height(),
                        'calendar_geometry': self.app.calendar_widget.winfo_geometry()
                    }
                    
                    # Capturar eventos se existirem
                    if hasattr(self.app, 'events_tree') and self.app.events_tree:
                        events = []
                        for item in self.app.events_tree.get_children():
                            values = self.app.events_tree.item(item)['values']
                            events.append(values)
                        calendar_state['events'] = events
                        
                    # Capturar estado do painel de eventos
                    if hasattr(self.app, 'events_tree') and self.app.events_tree:
                        calendar_state['events_tree_width'] = self.app.events_tree.winfo_width()
                        calendar_state['events_tree_height'] = self.app.events_tree.winfo_height()
                        
                except Exception as e:
                    print(f"Erro ao capturar estado do calendário: {e}")
                    calendar_state = None
            
            # Atualizar apenas os quadros sem recriar o calendário
            self.app.populate_boards()
            self.app.update_legend()
            self.app.update_pomodoro_task_list()
            
            # Restaurar o estado do calendário APÓS atualizar os quadros
            if calendar_state and hasattr(self.app, 'calendar_widget') and self.app.calendar_widget:
                try:
                    # Restaurar data selecionada
                    if calendar_state['selected_date']:
                        self.app.calendar_widget.selection_set(calendar_state['selected_date'])
                    
                    # Restaurar tamanho do calendário se necessário
                    if calendar_state.get('calendar_width') and calendar_state.get('calendar_height'):
                        try:
                            # Forçar redimensionamento do calendário
                            self.app.calendar_widget.configure(width=calendar_state['calendar_width'])
                            self.app.calendar_widget.update_idletasks()
                        except:
                            pass
                    
                    # Recarregar eventos do calendário se necessário
                    if hasattr(self.app, 'load_calendar_events'):
                        self.app.load_calendar_events()
                        
                    # Forçar atualização do layout
                    self.app.calendar_widget.update_idletasks()
                    if hasattr(self.app, 'events_tree') and self.app.events_tree:
                        self.app.events_tree.update_idletasks()
                        
                except Exception as e:
                    print(f"Erro ao restaurar estado do calendário: {e}")
            
            self.destroy()
            messagebox.showinfo("Configurações Salvas", "As configurações foram salvas com sucesso!")

        except ValueError as e:
            messagebox.showerror("Erro", f"Por favor, insira valores numéricos válidos e maiores que zero: {e}")

    def toggle_always_on_top(self):
        self.app.root.attributes("-topmost", self.always_on_top_var.get())

# Define CardDetailsWindow as an alias for CardWindow
CardDetailsWindow = CardWindow

class CategoriesManagerWindow:
    def __init__(self, parent, app):
        self.parent = parent
        self.app = app
        self.window = tk.Toplevel(parent)
        self.window.title("Gerenciar Categorias")
        self.window.geometry("600x500")
        self.window.transient(parent)
        self.window.grab_set()
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"⚠️ Erro ao criar widgets: {e}")
    
    def create_widgets(self):
        """Cria widgets da janela de gerenciamento de categorias"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title_label = ttk.Label(main_frame, text="Gerenciar Categorias", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Frame para lista de categorias
        list_frame = ttk.LabelFrame(main_frame, text="Categorias Cadastradas", padding="10")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Treeview para categorias
        columns = ("ID", "Nome", "Cor")
        self.categories_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=10)
        
        self.categories_tree.heading("ID", text="ID")
        self.categories_tree.heading("Nome", text="Nome")
        self.categories_tree.heading("Cor", text="Cor")
        
        self.categories_tree.column("ID", width=50, anchor="center")
        self.categories_tree.column("Nome", width=200, anchor="w")
        self.categories_tree.column("Cor", width=100, anchor="center")
        
        self.categories_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.categories_tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.categories_tree.configure(yscrollcommand=scrollbar.set)
        
        # Frame para adicionar/editar categoria
        edit_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Categoria", padding="10")
        edit_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Grid para campos
        edit_frame.columnconfigure(1, weight=1)
        
        # Nome da categoria
        ttk.Label(edit_frame, text="Nome:").grid(row=0, column=0, sticky="w", padx=(0, 10), pady=5)
        self.name_var = tk.StringVar()
        self.name_entry = ttk.Entry(edit_frame, textvariable=self.name_var, width=30)
        self.name_entry.grid(row=0, column=1, sticky="ew", padx=(0, 10), pady=5)
        
        # Cor da categoria
        ttk.Label(edit_frame, text="Cor:").grid(row=0, column=2, sticky="w", padx=(0, 10), pady=5)
        self.color_var = tk.StringVar(value="#3498db")
        self.color_entry = ttk.Entry(edit_frame, textvariable=self.color_var, width=10)
        self.color_entry.grid(row=0, column=3, sticky="w", padx=(0, 10), pady=5)
        
        # Botão para escolher cor
        self.color_button = tk.Button(edit_frame, text="Escolher", 
                                     command=self.choose_color, bg=self.color_var.get())
        self.color_button.grid(row=0, column=4, padx=(0, 10), pady=5)
        
        # Botões de ação
        button_frame = ttk.Frame(edit_frame)
        button_frame.grid(row=1, column=0, columnspan=5, pady=10)
        
        ttk.Button(button_frame, text="Adicionar", 
                  command=self.add_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Editar", 
                  command=self.edit_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Remover", 
                  command=self.remove_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Limpar", 
                  command=self.clear_form).pack(side=tk.LEFT, padx=5)
        
        # Botões principais
        main_button_frame = ttk.Frame(main_frame)
        main_button_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(main_button_frame, text="Fechar", 
                  command=self.window.destroy).pack(side=tk.RIGHT, padx=5)
        
        # Carregar categorias
        self.load_categories()
        
        # Bind para seleção
        self.categories_tree.bind("<<TreeviewSelect>>", self.on_category_select)
    
    def load_categories(self):
        """Carrega as categorias na treeview"""
        # Limpar treeview
        for item in self.categories_tree.get_children():
            self.categories_tree.delete(item)
        
        # Adicionar categorias
        for category in self.app.categories:
            self.categories_tree.insert("", "end", values=(
                category['id'],
                category['name'],
                category['color']
            ))
    
    def choose_color(self):
        """Abre o seletor de cores"""
        try:
            from tkinter import colorchooser
            color = colorchooser.askcolor(title="Escolher Cor da Categoria")[1]
            if color:
                self.color_var.set(color)
                self.color_button.config(bg=color)
        except ImportError:
            messagebox.showwarning("Aviso", "Seletor de cores não disponível")
    
    def add_category(self):
        """Adiciona uma nova categoria"""
        name = self.name_var.get().strip()
        color = self.color_var.get().strip()
        
        if not name:
            messagebox.showwarning("Aviso", "Nome da categoria é obrigatório!")
            return
        
        if not color:
            messagebox.showwarning("Aviso", "Cor da categoria é obrigatória!")
            return
        
        # Verificar se já existe
        for category in self.app.categories:
            if category['name'].lower() == name.lower():
                messagebox.showwarning("Aviso", f"Categoria '{name}' já existe!")
                return
        
        # Gerar novo ID
        new_id = max([cat['id'] for cat in self.app.categories], default=0) + 1
        
        # Adicionar categoria
        new_category = {
            'id': new_id,
            'name': name,
            'color': color
        }
        
        self.app.categories.append(new_category)
        self.app.save_categories()
        self.load_categories()
        self.clear_form()
        
        messagebox.showinfo("Sucesso", f"Categoria '{name}' adicionada com sucesso!")
    
    def edit_category(self):
        """Edita a categoria selecionada"""
        selected = self.categories_tree.selection()
        if not selected:
            messagebox.showwarning("Aviso", "Selecione uma categoria para editar!")
            return
        
        name = self.name_var.get().strip()
        color = self.color_var.get().strip()
        
        if not name:
            messagebox.showwarning("Aviso", "Nome da categoria é obrigatório!")
            return
        
        if not color:
            messagebox.showwarning("Aviso", "Cor da categoria é obrigatória!")
            return
        
        # Obter categoria selecionada
        item = self.categories_tree.item(selected[0])
        category_id = item['values'][0]
        
        # Verificar se nome já existe (exceto para a categoria atual)
        for category in self.app.categories:
            if category['id'] != category_id and category['name'].lower() == name.lower():
                messagebox.showwarning("Aviso", f"Categoria '{name}' já existe!")
                return
        
        # Atualizar categoria
        for category in self.app.categories:
            if category['id'] == category_id:
                category['name'] = name
                category['color'] = color
                break
        
        self.app.save_categories()
        self.load_categories()
        self.clear_form()
        
        messagebox.showinfo("Sucesso", f"Categoria '{name}' atualizada com sucesso!")
    
    def remove_category(self):
        """Remove a categoria selecionada"""
        selected = self.categories_tree.selection()
        if not selected:
            messagebox.showwarning("Aviso", "Selecione uma categoria para remover!")
            return
        
        item = self.categories_tree.item(selected[0])
        category_id = item['values'][0]
        category_name = item['values'][1]
        
        if messagebox.askyesno("Confirmar", f"Tem certeza que deseja remover a categoria '{category_name}'?"):
            # Remover categoria
            self.app.categories = [cat for cat in self.app.categories if cat['id'] != category_id]
            self.app.save_categories()
            self.load_categories()
            self.clear_form()
            
            messagebox.showinfo("Sucesso", f"Categoria '{category_name}' removida com sucesso!")
    
    def clear_form(self):
        """Limpa o formulário"""
        self.name_var.set("")
        self.color_var.set("#3498db")
        self.color_button.config(bg="#3498db")
        self.categories_tree.selection_remove(*self.categories_tree.selection())
    
    def on_category_select(self, event):
        """Chamado quando uma categoria é selecionada"""
        selected = self.categories_tree.selection()
        if selected:
            item = self.categories_tree.item(selected[0])
            values = item['values']
            
            self.name_var.set(values[1])
            self.color_var.set(values[2])
            self.color_button.config(bg=values[2])

    # ============================================================================
    # SISTEMA FINANCEIRO EMPRESARIAL
    # ============================================================================

    def create_finance_dashboard_enterprise(self, parent):
        """Cria o dashboard financeiro empresarial"""
        # Frame principal com scroll
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        canvas = tk.Canvas(main_frame)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Header
        header_frame = ttk.Frame(scrollable_frame)
        header_frame.pack(fill=tk.X, padx=20, pady=20)
        
        ttk.Label(header_frame, text="🏢 Dashboard Financeiro Empresarial", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        ttk.Button(header_frame, text="🔄 Atualizar", 
                  command=self.refresh_enterprise_dashboard).pack(side=tk.RIGHT)
        
        # Cards de métricas principais
        metrics_frame = ttk.Frame(scrollable_frame)
        metrics_frame.pack(fill=tk.X, padx=20, pady=10)
        
        # Saldo Total
        self.create_enterprise_metric_card(metrics_frame, "💰 Saldo Total", "R$ 0,00", "#2ecc71", 0, 0)
        
        # Receitas do Mês
        self.create_enterprise_metric_card(metrics_frame, "📈 Receitas/Mês", "R$ 0,00", "#3498db", 0, 1)
        
        # Despesas do Mês
        self.create_enterprise_metric_card(metrics_frame, "📉 Despesas/Mês", "R$ 0,00", "#e74c3c", 0, 2)
        
        # Lucro do Mês
        self.create_enterprise_metric_card(metrics_frame, "💵 Lucro/Mês", "R$ 0,00", "#f39c12", 0, 3)
        
        # Contas a Receber
        self.create_enterprise_metric_card(metrics_frame, "📥 Contas a Receber", "R$ 0,00", "#9b59b6", 1, 0)
        
        # Contas a Pagar
        self.create_enterprise_metric_card(metrics_frame, "📤 Contas a Pagar", "R$ 0,00", "#e67e22", 1, 1)
        
        # Clientes Ativos
        self.create_enterprise_metric_card(metrics_frame, "👥 Clientes Ativos", "0", "#1abc9c", 1, 2)
        
        # Fornecedores
        self.create_enterprise_metric_card(metrics_frame, "🏭 Fornecedores", "0", "#34495e", 1, 3)
        
        # Seção de gráficos
        charts_frame = ttk.Frame(scrollable_frame)
        charts_frame.pack(fill=tk.X, padx=20, pady=20)
        
        ttk.Label(charts_frame, text="📊 Análises Financeiras", 
                 font=("Arial", 14, "bold")).pack(anchor=tk.W)
        
        charts_buttons_frame = ttk.Frame(charts_frame)
        charts_buttons_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(charts_buttons_frame, text="📈 Evolução Mensal", 
                  command=lambda: self.show_enterprise_chart("evolucao")).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(charts_buttons_frame, text="🥧 Receitas por Categoria", 
                  command=lambda: self.show_enterprise_chart("receitas_categoria")).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(charts_buttons_frame, text="📊 Despesas por Departamento", 
                  command=lambda: self.show_enterprise_chart("despesas_departamento")).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(charts_buttons_frame, text="💼 Fluxo de Caixa", 
                  command=lambda: self.show_enterprise_chart("fluxo_caixa")).pack(side=tk.LEFT, padx=5)
        
        # Seção de alertas e pendências
        alerts_frame = ttk.Frame(scrollable_frame)
        alerts_frame.pack(fill=tk.X, padx=20, pady=20)
        
        ttk.Label(alerts_frame, text="⚠️ Alertas e Pendências", 
                 font=("Arial", 14, "bold")).pack(anchor=tk.W)
        
        # Treeview para alertas
        self.alerts_tree = ttk.Treeview(alerts_frame, columns=("tipo", "descricao", "valor", "prazo"), 
                                       show="headings", height=6)
        self.alerts_tree.heading("tipo", text="Tipo")
        self.alerts_tree.heading("descricao", text="Descrição")
        self.alerts_tree.heading("valor", text="Valor")
        self.alerts_tree.heading("prazo", text="Prazo")
        
        self.alerts_tree.column("tipo", width=100)
        self.alerts_tree.column("descricao", width=300)
        self.alerts_tree.column("valor", width=100)
        self.alerts_tree.column("prazo", width=100)
        
        self.alerts_tree.pack(fill=tk.X, pady=10)
        
        # Configurar scroll
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Atualizar dados
        self.refresh_enterprise_dashboard()
    
    def create_enterprise_metric_card(self, parent, title, value, color, row, col):
        """Cria um card de métrica empresarial"""
        card_frame = ttk.Frame(parent, relief=tk.RAISED, borderwidth=2)
        card_frame.grid(row=row, column=col, padx=10, pady=10, sticky="nsew")
        
        # Configurar grid
        parent.grid_columnconfigure(col, weight=1)
        parent.grid_rowconfigure(row, weight=1)
        
        # Título
        ttk.Label(card_frame, text=title, font=("Arial", 10, "bold")).pack(pady=(10, 5))
        
        # Valor
        value_label = ttk.Label(card_frame, text=value, font=("Arial", 16, "bold"), foreground=color)
        value_label.pack(pady=(0, 10))
        
        # Armazenar referência para atualização
        if not hasattr(self, 'enterprise_metrics'):
            self.enterprise_metrics = {}
        self.enterprise_metrics[f"{title}_{row}_{col}"] = value_label
    
    def refresh_enterprise_dashboard(self):
        """Atualiza o dashboard empresarial"""
        try:
            # Buscar dados do banco
            departments = self.db.get_departments()
            clients = self.db.get_clients()
            suppliers = self.db.get_suppliers()
            accounts_receivable = self.db.get_accounts_receivable()
            accounts_payable = self.db.get_accounts_payable()
            
            # Calcular métricas
            total_receivable = sum(float(ar['amount']) for ar in accounts_receivable if ar['status'] == 'Pendente')
            total_payable = sum(float(ap['amount']) for ap in accounts_payable if ap['status'] == 'Pendente')
            
            # Atualizar cards
            if hasattr(self, 'enterprise_metrics'):
                self.enterprise_metrics.get("💰 Saldo Total_0_0", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("📈 Receitas/Mês_0_1", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("📉 Despesas/Mês_0_2", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("💵 Lucro/Mês_0_3", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("📥 Contas a Receber_1_0", ttk.Label()).configure(text=f"R$ {total_receivable:,.2f}")
                self.enterprise_metrics.get("📤 Contas a Pagar_1_1", ttk.Label()).configure(text=f"R$ {total_payable:,.2f}")
                self.enterprise_metrics.get("👥 Clientes Ativos_1_2", ttk.Label()).configure(text=str(len(clients)))
                self.enterprise_metrics.get("🏭 Fornecedores_1_3", ttk.Label()).configure(text=str(len(suppliers)))
            
            # Atualizar alertas
            self.update_enterprise_alerts()
            
        except Exception as e:
            print(f"Erro ao atualizar dashboard empresarial: {e}")
    
    def update_enterprise_alerts(self):
        """Atualiza a lista de alertas empresariais"""
        if not hasattr(self, 'alerts_tree'):
            return
        
        # Limpar lista
        for item in self.alerts_tree.get_children():
            self.alerts_tree.delete(item)
        
        try:
            # Buscar contas a pagar vencidas
            accounts_payable = self.db.get_accounts_payable()
            today = datetime.now().date()
            
            for ap in accounts_payable:
                if ap['status'] == 'Pendente':
                    due_date = datetime.strptime(ap['due_date'], '%Y-%m-%d').date()
                    if due_date < today:
                        self.alerts_tree.insert("", "end", values=(
                            "Conta Vencida",
                            f"Pagar: {ap['description']}",
                            f"R$ {float(ap['amount']):,.2f}",
                            ap['due_date']
                        ))
            
            # Buscar contas a receber vencidas
            accounts_receivable = self.db.get_accounts_receivable()
            
            for ar in accounts_receivable:
                if ar['status'] == 'Pendente':
                    due_date = datetime.strptime(ar['due_date'], '%Y-%m-%d').date()
                    if due_date < today:
                        self.alerts_tree.insert("", "end", values=(
                            "Recebimento Vencido",
                            f"Receber: {ar['description']}",
                            f"R$ {float(ar['amount']):,.2f}",
                            ar['due_date']
                        ))
        
        except Exception as e:
            print(f"Erro ao atualizar alertas: {e}")
    
    def show_enterprise_chart(self, chart_type):
        """Mostra gráficos empresariais"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
            
            # Criar janela para o gráfico
            chart_window = tk.Toplevel(self.root)
            chart_window.title(f"Gráfico - {chart_type}")
            chart_window.geometry("800x600")
            
            fig, ax = plt.subplots(figsize=(10, 6))
            
            if chart_type == "evolucao":
                # Gráfico de evolução mensal
                months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun']
                receitas = [50000, 55000, 48000, 62000, 58000, 65000]
                despesas = [45000, 47000, 43000, 52000, 49000, 54000]
                
                ax.plot(months, receitas, 'o-', label='Receitas', color='#3498db')
                ax.plot(months, despesas, 's-', label='Despesas', color='#e74c3c')
                ax.set_title('Evolução Mensal - Receitas vs Despesas')
                ax.set_ylabel('Valor (R$)')
                ax.legend()
                ax.grid(True, alpha=0.3)
            
            elif chart_type == "receitas_categoria":
                # Gráfico de pizza - receitas por categoria
                categories = ['Vendas', 'Serviços', 'Consultoria', 'Outros']
                values = [45, 30, 20, 5]
                colors = ['#3498db', '#2ecc71', '#f39c12', '#e74c3c']
                
                ax.pie(values, labels=categories, colors=colors, autopct='%1.1f%%')
                ax.set_title('Receitas por Categoria')
            
            elif chart_type == "despesas_departamento":
                # Gráfico de barras - despesas por departamento
                departments = ['TI', 'Marketing', 'RH', 'Financeiro', 'Operações']
                expenses = [25000, 18000, 15000, 12000, 22000]
                colors = ['#3498db', '#2ecc71', '#f39c12', '#e74c3c', '#9b59b6']
                
                bars = ax.bar(departments, expenses, color=colors)
                ax.set_title('Despesas por Departamento')
                ax.set_ylabel('Valor (R$)')
                
                # Adicionar valores nas barras
                for bar, value in zip(bars, expenses):
                    ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 1000,
                           f'R$ {value:,.0f}', ha='center', va='bottom')
            
            elif chart_type == "fluxo_caixa":
                # Gráfico de fluxo de caixa
                dates = ['01/01', '15/01', '01/02', '15/02', '01/03', '15/03']
                cash_flow = [50000, 45000, 52000, 48000, 55000, 58000]
                
                ax.plot(dates, cash_flow, 'o-', color='#2ecc71', linewidth=2)
                ax.fill_between(dates, cash_flow, alpha=0.3, color='#2ecc71')
                ax.set_title('Fluxo de Caixa - Últimos 3 Meses')
                ax.set_ylabel('Saldo (R$)')
                ax.grid(True, alpha=0.3)
            
            # Configurar layout
            plt.tight_layout()
            
            # Criar canvas
            canvas = FigureCanvasTkAgg(fig, chart_window)
            canvas.draw()
            canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except ImportError:
            messagebox.showwarning("Aviso", "Matplotlib não está instalado. Instale com: pip install matplotlib")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar gráfico: {e}")
    
    def create_clients_management_tab(self, parent):
        """Cria a aba de gestão de clientes"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Header
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(header_frame, text="👥 Gestão de Clientes", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        ttk.Button(header_frame, text="➕ Novo Cliente", 
                  command=self.open_new_client_window).pack(side=tk.RIGHT)
        
        # Frame para formulário e lista
        content_frame = ttk.Frame(main_frame)
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        # Formulário de cliente
        form_frame = ttk.LabelFrame(content_frame, text="Dados do Cliente", padding=10)
        form_frame.pack(fill=tk.X, pady=(0, 20))
        
        # Primeira linha
        row1 = ttk.Frame(form_frame)
        row1.pack(fill=tk.X, pady=5)
        
        ttk.Label(row1, text="Nome/Razão Social:").pack(side=tk.LEFT)
        self.client_name_var = tk.StringVar()
        ttk.Entry(row1, textvariable=self.client_name_var, width=30).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row1, text="CNPJ/CPF:").pack(side=tk.LEFT)
        self.client_cnpj_var = tk.StringVar()
        ttk.Entry(row1, textvariable=self.client_cnpj_var, width=20).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row1, text="Segmento:").pack(side=tk.LEFT)
        self.client_segment_var = tk.StringVar()
        ttk.Combobox(row1, textvariable=self.client_segment_var, 
                    values=["Tecnologia", "Saúde", "Educação", "Varejo", "Indústria", "Serviços", "Outros"],
                    width=15).pack(side=tk.LEFT, padx=(10, 0))
        
        # Segunda linha
        row2 = ttk.Frame(form_frame)
        row2.pack(fill=tk.X, pady=5)
        
        ttk.Label(row2, text="Email:").pack(side=tk.LEFT)
        self.client_email_var = tk.StringVar()
        ttk.Entry(row2, textvariable=self.client_email_var, width=30).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row2, text="Telefone:").pack(side=tk.LEFT)
        self.client_phone_var = tk.StringVar()
        ttk.Entry(row2, textvariable=self.client_phone_var, width=15).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row2, text="Limite de Crédito:").pack(side=tk.LEFT)
        self.client_credit_var = tk.StringVar()
        ttk.Entry(row2, textvariable=self.client_credit_var, width=15).pack(side=tk.LEFT, padx=(10, 0))
        
        # Terceira linha
        row3 = ttk.Frame(form_frame)
        row3.pack(fill=tk.X, pady=5)
        
        ttk.Label(row3, text="Contato:").pack(side=tk.LEFT)
        self.client_contact_var = tk.StringVar()
        ttk.Entry(row3, textvariable=self.client_contact_var, width=30).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row3, text="Endereço:").pack(side=tk.LEFT)
        self.client_address_var = tk.StringVar()
        ttk.Entry(row3, textvariable=self.client_address_var, width=40).pack(side=tk.LEFT, padx=(10, 0))
        
        # Botões
        buttons_frame = ttk.Frame(form_frame)
        buttons_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(buttons_frame, text="💾 Salvar Cliente", 
                  command=self.save_client).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(buttons_frame, text="🔄 Limpar", 
                  command=self.clear_client_form).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(buttons_frame, text="🗑️ Excluir", 
                  command=self.delete_client).pack(side=tk.LEFT)
        
        # Lista de clientes
        list_frame = ttk.LabelFrame(content_frame, text="Clientes Cadastrados", padding=10)
        list_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview
        columns = ("id", "nome", "cnpj_cpf", "email", "telefone", "segmento", "limite_credito", "status")
        self.clients_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=10)
        
        self.clients_tree.heading("id", text="ID")
        self.clients_tree.heading("nome", text="Nome/Razão Social")
        self.clients_tree.heading("cnpj_cpf", text="CNPJ/CPF")
        self.clients_tree.heading("email", text="Email")
        self.clients_tree.heading("telefone", text="Telefone")
        self.clients_tree.heading("segmento", text="Segmento")
        self.clients_tree.heading("limite_credito", text="Limite de Crédito")
        self.clients_tree.heading("status", text="Status")
        
        self.clients_tree.column("id", width=50)
        self.clients_tree.column("nome", width=200)
        self.clients_tree.column("cnpj_cpf", width=120)
        self.clients_tree.column("email", width=150)
        self.clients_tree.column("telefone", width=100)
        self.clients_tree.column("segmento", width=100)
        self.clients_tree.column("limite_credito", width=120)
        self.clients_tree.column("status", width=80)
        
        # Scrollbars
        tree_scroll_y = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.clients_tree.yview)
        tree_scroll_x = ttk.Scrollbar(list_frame, orient=tk.HORIZONTAL, command=self.clients_tree.xview)
        self.clients_tree.configure(yscrollcommand=tree_scroll_y.set, xscrollcommand=tree_scroll_x.set)
        
        # Pack
        self.clients_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        tree_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Bind para seleção
        self.clients_tree.bind('<<TreeviewSelect>>', self.on_client_select)
        
        # Carregar dados
        self.load_clients()
    
    def save_client(self):
        """Salva um novo cliente"""
        try:
            # Validar campos obrigatórios
            if not self.client_name_var.get().strip():
                messagebox.showerror("Erro", "Nome/Razão Social é obrigatório!")
                return
            
            if not self.client_cnpj_var.get().strip():
                messagebox.showerror("Erro", "CNPJ/CPF é obrigatório!")
                return
            
            # Preparar dados
            client_data = {
                'name': self.client_name_var.get().strip(),
                'cnpj_cpf': self.client_cnpj_var.get().strip(),
                'email': self.client_email_var.get().strip(),
                'phone': self.client_phone_var.get().strip(),
                'address': self.client_address_var.get().strip(),
                'contact_person': self.client_contact_var.get().strip(),
                'segment': self.client_segment_var.get().strip(),
                'credit_limit': float(self.client_credit_var.get() or 0)
            }
            
            # Salvar no banco
            client_id = self.db.create_client(**client_data)
            
            if client_id:
                messagebox.showinfo("Sucesso", "Cliente salvo com sucesso!")
                self.clear_client_form()
                self.load_clients()
            else:
                messagebox.showerror("Erro", "Erro ao salvar cliente!")
        
        except ValueError:
            messagebox.showerror("Erro", "Limite de crédito deve ser um número válido!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar cliente: {e}")
    
    def clear_client_form(self):
        """Limpa o formulário de cliente"""
        self.client_name_var.set("")
        self.client_cnpj_var.set("")
        self.client_email_var.set("")
        self.client_phone_var.set("")
        self.client_address_var.set("")
        self.client_contact_var.set("")
        self.client_segment_var.set("")
        self.client_credit_var.set("")
    
    def load_clients(self):
        """Carrega a lista de clientes"""
        try:
            # Limpar lista
            for item in self.clients_tree.get_children():
                self.clients_tree.delete(item)
            
            # Buscar clientes
            clients = self.db.get_clients()
            
            # Adicionar à lista
            for client in clients:
                self.clients_tree.insert("", "end", values=(
                    client['id'],
                    client['name'],
                    client['cnpj_cpf'],
                    client['email'],
                    client['phone'],
                    client['segment'],
                    f"R$ {float(client['credit_limit']):,.2f}",
                    "Ativo" if client['is_active'] else "Inativo"
                ))
        
        except Exception as e:
            print(f"Erro ao carregar clientes: {e}")
    
    def on_client_select(self, event):
        """Evento de seleção de cliente"""
        selection = self.clients_tree.selection()
        if selection:
            item = self.clients_tree.item(selection[0])
            values = item['values']
            
            # Preencher formulário
            self.client_name_var.set(values[1])
            self.client_cnpj_var.set(values[2])
            self.client_email_var.set(values[3])
            self.client_phone_var.set(values[4])
            self.client_segment_var.set(values[5])
            self.client_credit_var.set(values[6].replace("R$ ", "").replace(",", ""))
    
    def delete_client(self):
        """Exclui um cliente"""
        selection = self.clients_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione um cliente para excluir!")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir este cliente?"):
            try:
                item = self.clients_tree.item(selection[0])
                client_id = item['values'][0]
                
                # Excluir do banco (soft delete)
                # self.db.delete_client(client_id)  # Implementar método
                
                messagebox.showinfo("Sucesso", "Cliente excluído com sucesso!")
                self.load_clients()
                self.clear_client_form()
            
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao excluir cliente: {e}")
    
    def open_new_client_window(self):
        """Abre janela para novo cliente"""
        self.clear_client_form()
        # Focar no primeiro campo
        # Implementar foco automático
    
    # Métodos placeholder para outras abas
    def create_suppliers_management_tab(self, parent):
        """Cria a aba de gestão de fornecedores"""
        ttk.Label(parent, text="🏭 Gestão de Fornecedores - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_receivables_management_tab(self, parent):
        """Cria a aba de contas a receber"""
        ttk.Label(parent, text="📥 Contas a Receber - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_payables_management_tab(self, parent):
        """Cria a aba de contas a pagar"""
        ttk.Label(parent, text="📤 Contas a Pagar - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_invoices_management_tab(self, parent):
        """Cria a aba de faturas"""
        ttk.Label(parent, text="🧾 Gestão de Faturas - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_cashflow_management_tab(self, parent):
        """Cria a aba de fluxo de caixa"""
        ttk.Label(parent, text="💼 Fluxo de Caixa - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_budgets_management_tab(self, parent):
        """Cria a aba de orçamentos"""
        ttk.Label(parent, text="📊 Gestão de Orçamentos - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_enterprise_reports_tab(self, parent):
        """Cria a aba de relatórios empresariais"""
        ttk.Label(parent, text="📈 Relatórios Empresariais - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_finance_config_tab(self, parent):
        """Cria a aba de configurações financeiras"""
        ttk.Label(parent, text="⚙️ Configurações Financeiras - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)

    # ============================================================================
    # MÉTODOS AUXILIARES PARA CONTAS A PAGAR E CONTAS A RECEBER
    # ============================================================================
    
    def load_receivables(self):
        """Carrega as contas a receber"""
        try:
            # Limpar treeview
            for item in self.receivables_tree.get_children():
                self.receivables_tree.delete(item)
            
            # Carregar dados (simulado por enquanto)
            receivables = self.get_receivables_data()
            
            for receivable in receivables:
                # Determinar cor baseada no status
                tags = ()
                if receivable['status'] == 'Vencido':
                    tags = ('overdue',)
                elif receivable['status'] == 'Pago':
                    tags = ('paid',)
                
                self.receivables_tree.insert("", "end", values=(
                    receivable['id'],
                    receivable['client'],
                    receivable['description'],
                    f"R$ {receivable['amount']:,.2f}",
                    receivable['due_date'],
                    receivable['status'],
                    receivable['created_date']
                ), tags=tags)
            
            # Atualizar estatísticas
            self.update_receivables_stats()
            
        except Exception as e:
            print(f"Erro ao carregar contas a receber: {e}")
    
    def get_receivables_data(self):
        """Retorna dados simulados de contas a receber"""
        return [
            {
                'id': 1,
                'client': 'Cliente A',
                'description': 'Prestação de serviços',
                'amount': 1500.00,
                'due_date': '2024-01-15',
                'status': 'Pendente',
                'created_date': '2024-01-01'
            },
            {
                'id': 2,
                'client': 'Cliente B',
                'description': 'Venda de produtos',
                'amount': 2500.00,
                'due_date': '2024-01-10',
                'status': 'Vencido',
                'created_date': '2024-01-01'
            },
            {
                'id': 3,
                'client': 'Cliente C',
                'description': 'Consultoria',
                'amount': 800.00,
                'due_date': '2024-01-20',
                'status': 'Pago',
                'created_date': '2024-01-01'
            }
        ]
    
    def update_receivables_stats(self):
        """Atualiza as estatísticas de contas a receber"""
        try:
            receivables = self.get_receivables_data()
            
            total = sum(r['amount'] for r in receivables)
            pending = sum(r['amount'] for r in receivables if r['status'] == 'Pendente')
            overdue = sum(r['amount'] for r in receivables if r['status'] == 'Vencido')
            paid = sum(r['amount'] for r in receivables if r['status'] == 'Pago')
            
            self.receivable_total_label.config(text=f"Total: R$ {total:,.2f}")
            self.receivable_pending_label.config(text=f"Pendente: R$ {pending:,.2f}")
            self.receivable_overdue_label.config(text=f"Vencido: R$ {overdue:,.2f}")
            self.receivable_paid_label.config(text=f"Pago: R$ {paid:,.2f}")
            
        except Exception as e:
            print(f"Erro ao atualizar estatísticas: {e}")
    
    def filter_receivables(self):
        """Filtra as contas a receber"""
        try:
            status_filter = self.receivable_status_filter.get()
            client_filter = self.receivable_client_filter.get()
            due_filter = self.receivable_due_filter.get()
            
            # Implementar lógica de filtro
            self.load_receivables()  # Recarregar com filtros
            
        except Exception as e:
            print(f"Erro ao filtrar contas a receber: {e}")
    
    def on_receivable_select(self, event):
        """Evento de seleção de conta a receber"""
        selection = self.receivables_tree.selection()
        if selection:
            item = self.receivables_tree.item(selection[0])
            values = item['values']
            
            # Abrir janela de edição
            self.open_edit_receivable_window(values[0])
    
    def open_new_receivable_window(self):
        """Abre janela para nova conta a receber"""
        self.open_receivable_form_window()
    
    def open_edit_receivable_window(self, receivable_id):
        """Abre janela para editar conta a receber"""
        self.open_receivable_form_window(receivable_id)
    
    def open_receivable_form_window(self, receivable_id=None):
        """Abre janela de formulário para conta a receber"""
        # Criar janela
        form_window = tk.Toplevel(self.root)
        form_window.title("Nova Conta a Receber" if receivable_id is None else "Editar Conta a Receber")
        form_window.geometry("500x600")
        form_window.resizable(False, False)
        form_window.transient(self.root)
        form_window.grab_set()
        
        # Centralizar janela
        form_window.update_idletasks()
        x = (form_window.winfo_screenwidth() // 2) - (500 // 2)
        y = (form_window.winfo_screenheight() // 2) - (600 // 2)
        form_window.geometry(f"500x600+{x}+{y}")
        
        # Frame principal
        main_frame = ttk.Frame(form_window, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title = "Nova Conta a Receber" if receivable_id is None else "Editar Conta a Receber"
        ttk.Label(main_frame, text=title, font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Formulário
        form_frame = ttk.Frame(main_frame)
        form_frame.pack(fill=tk.BOTH, expand=True)
        
        # Cliente
        ttk.Label(form_frame, text="Cliente:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        client_var = tk.StringVar()
        client_combo = ttk.Combobox(form_frame, textvariable=client_var, state="readonly", width=30)
        client_combo['values'] = ["Cliente A", "Cliente B", "Cliente C"]
        client_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        
        # Descrição
        ttk.Label(form_frame, text="Descrição:").grid(row=1, column=0, sticky="w", padx=5, pady=5)
        description_var = tk.StringVar()
        description_entry = ttk.Entry(form_frame, textvariable=description_var, width=30)
        description_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        
        # Valor
        ttk.Label(form_frame, text="Valor:").grid(row=2, column=0, sticky="w", padx=5, pady=5)
        amount_var = tk.StringVar()
        amount_entry = ttk.Entry(form_frame, textvariable=amount_var, width=30)
        amount_entry.grid(row=2, column=1, sticky="ew", padx=5, pady=5)
        
        # Data de vencimento
        ttk.Label(form_frame, text="Vencimento:").grid(row=3, column=0, sticky="w", padx=5, pady=5)
        due_date_var = tk.StringVar()
        due_date_entry = ttk.Entry(form_frame, textvariable=due_date_var, width=30)
        due_date_entry.grid(row=3, column=1, sticky="ew", padx=5, pady=5)
        
        # Status
        ttk.Label(form_frame, text="Status:").grid(row=4, column=0, sticky="w", padx=5, pady=5)
        status_var = tk.StringVar()
        status_combo = ttk.Combobox(form_frame, textvariable=status_var, 
                                  values=["Pendente", "Pago", "Vencido", "Cancelado"],
                                  state="readonly", width=30)
        status_combo.set("Pendente")
        status_combo.grid(row=4, column=1, sticky="ew", padx=5, pady=5)
        
        # Observações
        ttk.Label(form_frame, text="Observações:").grid(row=5, column=0, sticky="w", padx=5, pady=5)
        notes_text = tk.Text(form_frame, height=4, width=30)
        notes_text.grid(row=5, column=1, sticky="ew", padx=5, pady=5)
        
        # Configurar grid
        form_frame.columnconfigure(1, weight=1)
        
        # Botões
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X, pady=(20, 0))
        
        ttk.Button(buttons_frame, text="Salvar", 
                  command=lambda: self.save_receivable(form_window, receivable_id)).pack(side=tk.RIGHT, padx=5)
        ttk.Button(buttons_frame, text="Cancelar", 
                  command=form_window.destroy).pack(side=tk.RIGHT, padx=5)
        
        # Focar no primeiro campo
        client_combo.focus()
    
    def save_receivable(self, window, receivable_id=None):
        """Salva a conta a receber"""
        try:
            # Implementar lógica de salvamento
            messagebox.showinfo("Sucesso", "Conta a receber salva com sucesso!")
            window.destroy()
            self.load_receivables()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar conta a receber: {e}")
    
    def delete_receivable(self):
        """Exclui uma conta a receber"""
        selection = self.receivables_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma conta a receber para excluir!")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir esta conta a receber?"):
            try:
                # Implementar lógica de exclusão
                messagebox.showinfo("Sucesso", "Conta a receber excluída com sucesso!")
                self.load_receivables()
                
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao excluir conta a receber: {e}")
    
    def load_payables(self):
        """Carrega as contas a pagar"""
        try:
            # Limpar treeview
            for item in self.payables_tree.get_children():
                self.payables_tree.delete(item)
            
            # Carregar dados (simulado por enquanto)
            payables = self.get_payables_data()
            
            for payable in payables:
                # Determinar cor baseada no status
                tags = ()
                if payable['status'] == 'Vencido':
                    tags = ('overdue',)
                elif payable['status'] == 'Pago':
                    tags = ('paid',)
                
                self.payables_tree.insert("", "end", values=(
                    payable['id'],
                    payable['supplier'],
                    payable['description'],
                    f"R$ {payable['amount']:,.2f}",
                    payable['due_date'],
                    payable['status'],
                    payable['created_date']
                ), tags=tags)
            
            # Atualizar estatísticas
            self.update_payables_stats()
            
        except Exception as e:
            print(f"Erro ao carregar contas a pagar: {e}")
    
    def get_payables_data(self):
        """Retorna dados simulados de contas a pagar"""
        return [
            {
                'id': 1,
                'supplier': 'Fornecedor A',
                'description': 'Compra de materiais',
                'amount': 800.00,
                'due_date': '2024-01-20',
                'status': 'Pendente',
                'created_date': '2024-01-01'
            },
            {
                'id': 2,
                'supplier': 'Fornecedor B',
                'description': 'Serviços de manutenção',
                'amount': 1200.00,
                'due_date': '2024-01-12',
                'status': 'Vencido',
                'created_date': '2024-01-01'
            },
            {
                'id': 3,
                'supplier': 'Fornecedor C',
                'description': 'Aluguel',
                'amount': 1500.00,
                'due_date': '2024-01-05',
                'status': 'Pago',
                'created_date': '2024-01-01'
            }
        ]
    
    def update_payables_stats(self):
        """Atualiza as estatísticas de contas a pagar"""
        try:
            payables = self.get_payables_data()
            
            total = sum(p['amount'] for p in payables)
            pending = sum(p['amount'] for p in payables if p['status'] == 'Pendente')
            overdue = sum(p['amount'] for p in payables if p['status'] == 'Vencido')
            paid = sum(p['amount'] for p in payables if p['status'] == 'Pago')
            
            self.payable_total_label.config(text=f"Total: R$ {total:,.2f}")
            self.payable_pending_label.config(text=f"Pendente: R$ {pending:,.2f}")
            self.payable_overdue_label.config(text=f"Vencido: R$ {overdue:,.2f}")
            self.payable_paid_label.config(text=f"Pago: R$ {paid:,.2f}")
            
        except Exception as e:
            print(f"Erro ao atualizar estatísticas: {e}")
    
    def filter_payables(self):
        """Filtra as contas a pagar"""
        try:
            status_filter = self.payable_status_filter.get()
            supplier_filter = self.payable_supplier_filter.get()
            due_filter = self.payable_due_filter.get()
            
            # Implementar lógica de filtro
            self.load_payables()  # Recarregar com filtros
            
        except Exception as e:
            print(f"Erro ao filtrar contas a pagar: {e}")
    
    def on_payable_select(self, event):
        """Evento de seleção de conta a pagar"""
        selection = self.payables_tree.selection()
        if selection:
            item = self.payables_tree.item(selection[0])
            values = item['values']
            
            # Abrir janela de edição
            self.open_edit_payable_window(values[0])
    
    def open_new_payable_window(self):
        """Abre janela para nova conta a pagar"""
        self.open_payable_form_window()
    
    def open_edit_payable_window(self, payable_id):
        """Abre janela para editar conta a pagar"""
        self.open_payable_form_window(payable_id)
    
    def open_payable_form_window(self, payable_id=None):
        """Abre janela de formulário para conta a pagar"""
        # Criar janela
        form_window = tk.Toplevel(self.root)
        form_window.title("Nova Conta a Pagar" if payable_id is None else "Editar Conta a Pagar")
        form_window.geometry("500x600")
        form_window.resizable(False, False)
        form_window.transient(self.root)
        form_window.grab_set()
        
        # Centralizar janela
        form_window.update_idletasks()
        x = (form_window.winfo_screenwidth() // 2) - (500 // 2)
        y = (form_window.winfo_screenheight() // 2) - (600 // 2)
        form_window.geometry(f"500x600+{x}+{y}")
        
        # Frame principal
        main_frame = ttk.Frame(form_window, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        title = "Nova Conta a Pagar" if payable_id is None else "Editar Conta a Pagar"
        ttk.Label(main_frame, text=title, font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Formulário
        form_frame = ttk.Frame(main_frame)
        form_frame.pack(fill=tk.BOTH, expand=True)
        
        # Fornecedor
        ttk.Label(form_frame, text="Fornecedor:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        supplier_var = tk.StringVar()
        supplier_combo = ttk.Combobox(form_frame, textvariable=supplier_var, state="readonly", width=30)
        supplier_combo['values'] = ["Fornecedor A", "Fornecedor B", "Fornecedor C"]
        supplier_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        
        # Descrição
        ttk.Label(form_frame, text="Descrição:").grid(row=1, column=0, sticky="w", padx=5, pady=5)
        description_var = tk.StringVar()
        description_entry = ttk.Entry(form_frame, textvariable=description_var, width=30)
        description_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        
        # Valor
        ttk.Label(form_frame, text="Valor:").grid(row=2, column=0, sticky="w", padx=5, pady=5)
        amount_var = tk.StringVar()
        amount_entry = ttk.Entry(form_frame, textvariable=amount_var, width=30)
        amount_entry.grid(row=2, column=1, sticky="ew", padx=5, pady=5)
        
        # Data de vencimento
        ttk.Label(form_frame, text="Vencimento:").grid(row=3, column=0, sticky="w", padx=5, pady=5)
        due_date_var = tk.StringVar()
        due_date_entry = ttk.Entry(form_frame, textvariable=due_date_var, width=30)
        due_date_entry.grid(row=3, column=1, sticky="ew", padx=5, pady=5)
        
        # Status
        ttk.Label(form_frame, text="Status:").grid(row=4, column=0, sticky="w", padx=5, pady=5)
        status_var = tk.StringVar()
        status_combo = ttk.Combobox(form_frame, textvariable=status_var, 
                                  values=["Pendente", "Pago", "Vencido", "Cancelado"],
                                  state="readonly", width=30)
        status_combo.set("Pendente")
        status_combo.grid(row=4, column=1, sticky="ew", padx=5, pady=5)
        
        # Observações
        ttk.Label(form_frame, text="Observações:").grid(row=5, column=0, sticky="w", padx=5, pady=5)
        notes_text = tk.Text(form_frame, height=4, width=30)
        notes_text.grid(row=5, column=1, sticky="ew", padx=5, pady=5)
        
        # Configurar grid
        form_frame.columnconfigure(1, weight=1)
        
        # Botões
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X, pady=(20, 0))
        
        ttk.Button(buttons_frame, text="Salvar", 
                  command=lambda: self.save_payable(form_window, payable_id)).pack(side=tk.RIGHT, padx=5)
        ttk.Button(buttons_frame, text="Cancelar", 
                  command=form_window.destroy).pack(side=tk.RIGHT, padx=5)
        
        # Focar no primeiro campo
        supplier_combo.focus()
    
    def save_payable(self, window, payable_id=None):
        """Salva a conta a pagar"""
        try:
            # Implementar lógica de salvamento
            messagebox.showinfo("Sucesso", "Conta a pagar salva com sucesso!")
            window.destroy()
            self.load_payables()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar conta a pagar: {e}")
    
    def delete_payable(self):
        """Exclui uma conta a pagar"""
        selection = self.payables_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma conta a pagar para excluir!")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir esta conta a pagar?"):
            try:
                # Implementar lógica de exclusão
                messagebox.showinfo("Sucesso", "Conta a pagar excluída com sucesso!")
                self.load_payables()
                
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao excluir conta a pagar: {e}")

if __name__ == "__main__":
    try:
        # Sistema de controle de concorrência para o banco de dados
        print("🔒 Iniciando controle de concorrência do banco de dados...")
        db_control = DatabaseConcurrencyControl('boodesk_new.db')
        
        # Tentar adquirir lock do banco
        if not db_control.acquire_lock(timeout=30):
            print("❌ Não foi possível adquirir lock do banco de dados")
            print("💡 Verifique se há outras instâncias do app rodando")
            messagebox.showerror("Erro", "Não foi possível acessar o banco de dados.\nVerifique se há outras instâncias do app rodando.")
            sys.exit(1)
        
        print("✅ Lock do banco adquirido com sucesso")
        
        # Determine base_dir for icons
        if getattr(sys, 'frozen', False):
            base_dir = sys._MEIPASS
        else:
            base_dir = os.path.dirname(os.path.abspath(__file__))

        root = ThemedTk(theme="aquativo")
        
        # Configure main window to start maximized
        try:
            root.state('zoomed')  # Maximize the window on Windows
        except:
            try:
                root.attributes('-zoomed', True)  # Alternative for some Linux systems
            except:
                # Fallback: maximize using geometry
                root.update_idletasks()
                screen_width = root.winfo_screenwidth()
                screen_height = root.winfo_screenheight()
                root.geometry(f"{screen_width}x{screen_height}+0+0")
        
        root.resizable(True, True)  # Permitir redimensionamento
        
        # Load icons AFTER the root window is created
        app_icons = load_app_icons(base_dir)

        # Criar aplicação sem usuário inicial
        print("DEBUG: Criando aplicação...")
        app = BoodeskApp(root, None, app_icons)
        root.app = app
        
        # Configurar protocolo de fechamento
        def on_closing_with_lock():
            """Handler de fechamento que libera o lock do banco"""
            try:
                print("🔓 Liberando lock do banco de dados (fechamento)...")
                db_control.release_lock()
            except:
                pass
            app.on_closing()
        
        root.protocol("WM_DELETE_WINDOW", on_closing_with_lock)
        
        print("DEBUG: Aplicação criada com sucesso")
        
        # Configurar sistema de login
        root.login_successful = False
        root.current_user = None
        print("DEBUG: Sistema de login configurado")
        
        # Criar janela de login de forma mais direta
        print("DEBUG: Criando janela de login...")
        
        # Criar uma janela de login simples e robusta
        login_window = tk.Toplevel()
        login_window.title("Login - Sistema Boodesk")
        login_window.geometry("450x400")
        login_window.resizable(False, False)
        
        # Centralizar na tela
        login_window.update_idletasks()
        x = (login_window.winfo_screenwidth() - 450) // 2
        y = (login_window.winfo_screenheight() - 400) // 2
        login_window.geometry(f"450x400+{x}+{y}")
        
        # Forçar exibição
        login_window.lift()
        login_window.focus_force()
        login_window.deiconify()
        login_window.update()
        
        # Ocultar janela principal após criar a janela de login
        root.withdraw()
        print("DEBUG: Janela principal ocultada")
        
        # Criar widgets básicos
        frame = ttk.Frame(login_window, padding="20")
        frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        ttk.Label(frame, text="Login - Sistema Boodesk", font=("Arial", 16, "bold")).pack(pady=20)
        
        # Campo de usuário com ícone
        user_frame = ttk.Frame(frame)
        user_frame.pack(fill=tk.X, pady=5)
        ttk.Label(user_frame, text="👤 Usuário:", font=("Arial", 10, "bold")).pack(anchor=tk.W)
        user_entry = ttk.Entry(user_frame, width=30, font=("Arial", 11))
        user_entry.pack(fill=tk.X, pady=5)
        user_entry.insert(0, "admin")  # Preencher com admin por padrão
        
        # Campo de senha com ícone
        pass_frame = ttk.Frame(frame)
        pass_frame.pack(fill=tk.X, pady=5)
        ttk.Label(pass_frame, text="🔒 Senha:", font=("Arial", 10, "bold")).pack(anchor=tk.W)
        pass_entry = ttk.Entry(pass_frame, show="*", width=30, font=("Arial", 11))
        pass_entry.pack(fill=tk.X, pady=5)
        
        # Frame dos botões
        button_frame = ttk.Frame(frame)
        button_frame.pack(fill=tk.X, pady=20)
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        
        def do_login():
            username = user_entry.get().strip()
            password = pass_entry.get()
            print(f"DEBUG: Tentativa de login - Usuário: '{username}', Senha: '{password}'")
            
            if username and password:
                # Verificar se o usuário existe no banco de dados
                try:
                    # Usar o banco de dados em vez do arquivo XLSX
                    user_data = app.db.get_user_by_username(username)
                    print(f"DEBUG: Usuário encontrado no banco: {user_data is not None}")
                    
                    if user_data and user_data['password_hash'] == password:
                        # Verificar se o usuário tem membro associado
                        if 'member_id' in user_data and user_data['member_id']:
                            # Criar usuário manualmente
                            user = User(
                                username=user_data['username'],
                                role=user_data['role'],
                                cargo=user_data.get('cargo', 'Usuário') if hasattr(user_data, 'get') else user_data['cargo'],
                                user_id=user_data.get('id', 1) if hasattr(user_data, 'get') else user_data['id']
                            )
                            user.is_authenticated = True
                            user.login_time = pd.Timestamp.now()
                            
                            root.login_successful = True
                            root.current_user = user
                            print(f"DEBUG: Login bem-sucedido para {username}")
                            login_window.destroy()
                        else:
                            print(f"DEBUG: Usuário {username} não tem membro associado")
                            messagebox.showerror("Erro", "Usuário não tem membro associado. Contate o administrador.")
                    else:
                        print(f"DEBUG: Usuário não encontrado ou senha incorreta")
                        messagebox.showerror("Erro", "Usuário ou senha incorretos!")
                except Exception as e:
                    print(f"DEBUG: Erro no login: {e}")
                    messagebox.showerror("Erro", f"Erro no sistema de login: {e}")
            else:
                messagebox.showerror("Erro", "Preencha todos os campos!")
        
        def cancel():
            root.login_successful = False
            login_window.destroy()
        
        # Botões com ícones
        ttk.Button(button_frame, text="🔐 Entrar", command=do_login).grid(row=0, column=0, padx=5, sticky="ew")
        ttk.Button(button_frame, text="📝 Cadastrar", command=lambda: messagebox.showinfo("Info", "Funcionalidade de cadastro será implementada")).grid(row=0, column=1, padx=5, sticky="ew")
        ttk.Button(button_frame, text="🚪 Sair", command=cancel).grid(row=0, column=2, padx=5, sticky="ew")
        
        # Funcionalidade de Enter e Tab
        def on_user_enter(event):
            pass_entry.focus()
            return "break"
        
        def on_pass_enter(event):
            do_login()
            return "break"
        
        def on_user_tab(event):
            pass_entry.focus()
            return "break"
        
        def on_pass_tab(event):
            user_entry.focus()
            return "break"
        
        user_entry.bind("<Return>", on_user_enter)
        user_entry.bind("<Tab>", on_user_tab)
        pass_entry.bind("<Return>", on_pass_enter)
        pass_entry.bind("<Tab>", on_pass_tab)
        
        # Focar no campo de usuário
        user_entry.focus()
        
        # Forçar exibição novamente após criar widgets
        login_window.after(100, lambda: login_window.lift())
        login_window.after(200, lambda: login_window.focus_force())
        login_window.after(300, lambda: login_window.deiconify())
        
        print("DEBUG: Aguardando fechamento da janela de login...")
        try:
            root.wait_window(login_window)
            print("DEBUG: Janela de login fechada")
        except Exception as e:
            print(f"DEBUG: Erro ao aguardar janela de login: {e}")
            root.destroy()
        
        # Verificar se o login foi bem-sucedido
        print(f"DEBUG: login_successful = {root.login_successful}")
        print(f"DEBUG: current_user = {root.current_user}")
        
        if root.login_successful and root.current_user:
            print("DEBUG: Login bem-sucedido, configurando usuário...")
            # Configurar usuário na aplicação
            app.current_user = root.current_user
            app.apply_role_permissions()
            
            # Adicionar método _get_current_user_member à instância
            def _get_current_user_member(self):
                """Retorna o nome do membro associado ao usuario logado"""
                try:
                    if not self.current_user:
                        return None
                    
                    username = self.current_user.username
                    
                    # Buscar o usuário no PostgreSQL
                    user_data = self.db.get_user_by_username(username)
                    
                    if user_data and user_data.get('member_id'):
                        member_id = user_data['member_id']
                        # Buscar o nome do membro usando o member_id
                        members = self.db.get_all_members()
                        for member in members:
                            if member['id'] == member_id:
                                member_name = member['name']
                                print(f"DEBUG: Usuario {username} associado ao membro {member_name}")
                                return member_name
                    
                    print(f"DEBUG: Usuário {username} não tem membro associado")
                    return None
                    
                except Exception as e:
                    print(f"DEBUG: Erro ao buscar membro do usuário: {e}")
                    return None
            
            # Adicionar o método à instância
            import types
            app._get_current_user_member = types.MethodType(_get_current_user_member, app)
            
            # Inicializar displays após todos os métodos serem definidos
            print("DEBUG: Chamando update_all_displays")
            app.update_all_displays()
            print("DEBUG: update_all_displays concluído")
            
            # Aplicar tema salvo nas configurações
            # Aplicar tema salvo nas configurações com isolamento por usuário
            try:
                # Carregar tema específico do usuário do banco de dados
                user_id = app.get_current_user_id()
                saved_theme = "aquativo"  # Tema padrão
                
                if user_id and hasattr(app, 'db') and app.db:
                    try:
                        # Buscar tema do usuário no banco
                        db_theme = app.db.get_setting('theme', user_id=user_id)
                        if db_theme:
                            saved_theme = db_theme
                            print(f"DEBUG: Tema carregado do banco para usuário {user_id}: {saved_theme}")
                        else:
                            print(f"DEBUG: Nenhum tema encontrado no banco para usuário {user_id}, usando padrão")
                    except Exception as db_error:
                        print(f"DEBUG: Erro ao carregar tema do banco: {db_error}")
                else:
                    print("DEBUG: Usando tema padrão (usuário não identificado ou banco indisponível)")
                
                # Verificar se o tema existe na lista de temas disponíveis
                available_themes = app.root.get_themes()
                if saved_theme not in available_themes:
                    print(f"⚠️ Tema '{saved_theme}' não disponível, usando 'aquativo'")
                    saved_theme = 'aquativo'
                
                # Atualizar configurações com o tema carregado
                app.settings['theme'] = saved_theme
                
                print(f"DEBUG: Aplicando tema: {saved_theme}")
                app.root.set_theme(saved_theme)
                
                # Forçar atualização da interface após aplicar o tema
                app.root.update_idletasks()
                app.root.update()
                
                print("DEBUG: Tema aplicado com sucesso")
            except Exception as e:
                print(f"DEBUG: Erro ao aplicar tema: {e}")
                # Fallback para tema padrão
                try:
                    app.root.set_theme('aquativo')
                    print("DEBUG: Tema padrão aplicado como fallback")
                except:
                    print("DEBUG: Erro ao aplicar tema padrão")
            app.show_dashboard_for_admin()
            
            # Mostrar aplicação principal
            print("DEBUG: Mostrando aplicação principal...")
            root.deiconify()
            
            # Maximizar a janela principal
            try:
                root.state('zoomed')  # Windows
                print("DEBUG: Janela maximizada (Windows)")
            except:
                try:
                    root.attributes('-zoomed', True)  # Linux
                    print("DEBUG: Janela maximizada (Linux)")
                except:
                    # Fallback: maximizar usando geometry
                    root.update_idletasks()
                    screen_width = root.winfo_screenwidth()
                    screen_height = root.winfo_screenheight()
                    root.geometry(f"{screen_width}x{screen_height}+0+0")
                    print("DEBUG: Janela maximizada (Fallback)")
            
            # Mostrar notificações APÓS o login
            root.after(1000, app.show_deadline_notifications)
            
            root.mainloop()
        else:
            print("DEBUG: Login cancelado ou falhou, fechando aplicação...")
            # Login cancelado ou falhou
            root.destroy()
        
        # Liberar lock do banco ao sair
        print("🔓 Liberando lock do banco de dados...")
        db_control.release_lock()
            
    except Exception as e:
        import traceback
        error_msg = f"Ocorreu um erro inesperado: {e}\n\nDetalhes técnicos:\n{traceback.format_exc()}"
        print(f"DEBUG: Erro completo: {error_msg}")
        messagebox.showerror("Erro Inesperado", f"Ocorreu um erro inesperado: {e}")
        
        # Liberar lock do banco em caso de erro
        try:
            print("🔓 Liberando lock do banco de dados (erro)...")
            db_control.release_lock()
        except:
            pass
        
        # Tentar fechar a aplicação de forma limpa
        try:
            root.destroy()
        except:
            pass

# ============================================================================
# MELHORIAS IMPLEMENTADAS - SISTEMA DE FILTRO INTELIGENTE E NOTIFICAÇÕES
# ============================================================================

def get_boards_for_member(self, member_name):
    """Retorna apenas os quadros onde o membro participa de cards"""
    boards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards in board_data.items():
            if list_name == 'workflow':  # Ignorar metadados
                continue
            for card in cards:
                if member_name in card.get('members', []):
                    boards.append(board_name)
                    break  # Uma vez encontrado, não precisa verificar mais cards
    return list(set(boards))  # Remove duplicatas

def _should_show_board_for_user_improved(self, board_name, current_user_member):
    """Versão melhorada do filtro de quadros"""
    # Administradores veem todos os quadros
    if hasattr(self, 'current_user') and getattr(self.current_user, 'role', None) == 'admin':
        return True
    
    # Se não há membro associado, mostrar apenas quadros principais
    if not current_user_member:
        return board_name in ["Quadro Principal", "Quadro Geral"]
    
    # Verificar se o membro participa de algum card no quadro
    board_data = self.boodesk_data.get("boards", {}).get(board_name, {})
    if isinstance(board_data, dict):
        for list_name, cards in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards:
                if current_user_member in card.get('members', []):
                    return True
    
    # Quadros especiais sempre visíveis
    if board_name in ["Quadro Principal", "Quadro Geral"]:
        return True
    
    return False

def notify_member_added_to_card(self, card_id, member_name, added_by):
    """Notifica membro quando adicionado a um card"""
    card = self.get_card_by_id(card_id)
    if not card:
        return
    
    notification = {
        'type': 'member_added',
        'card_title': card['title'],
        'card_id': card_id,
        'member': member_name,
        'added_by': added_by,
        'board': card.get('board_name', ''),
        'list': card.get('list_name', ''),
        'timestamp': datetime.now().isoformat(),
        'read': False
    }
    
    # Salvar notificação no banco
    self.save_notification(notification)
    
    # Mostrar notificação na interface
    self.show_notification_popup(notification)

def show_notification_popup(self, notification):
    """Mostra popup de notificação"""
    popup = tk.Toplevel(self.root)
    popup.title("Nova Notificação")
    popup.geometry("400x200")
    
    message = f"Você foi adicionado ao card:\n'{notification['card_title']}'\n\nQuadro: {notification['board']}\nLista: {notification['list']}"
    
    ttk.Label(popup, text=message, wraplength=350).pack(pady=20)
    ttk.Button(popup, text="Ver Card", command=lambda: self.open_card(notification['card_id'])).pack(pady=10)
    ttk.Button(popup, text="Fechar", command=popup.destroy).pack(pady=5)

def save_notification(self, notification):
    """Salva notificação no banco de dados"""
    try:
        conn = supabase_config.get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO notifications (type, card_title, card_id, member, added_by, board, list_name, timestamp, read_status)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            notification['type'],
            notification['card_title'],
            notification['card_id'],
            notification['member'],
            notification['added_by'],
            notification['board'],
            notification['list'],
            notification['timestamp'],
            notification['read']
        ))
        
        conn.commit()
        conn.close()
        print(f"✅ Notificação salva para {notification['member']}")
    except Exception as e:
        print(f"❌ Erro ao salvar notificação: {e}")

def create_member_dashboard(self, member_name):
    """Cria dashboard personalizado para o membro"""
    dashboard = {
        'my_cards': self.get_cards_by_member(member_name),
        'my_boards': self.get_boards_for_member(member_name),
        'pending_tasks': self.get_pending_tasks(member_name),
        'completed_tasks': self.get_completed_tasks(member_name),
        'recent_activities': self.get_recent_activities(member_name),
        'upcoming_deadlines': self.get_upcoming_deadlines(member_name)
    }
    return dashboard

def get_cards_by_member(self, member_name):
    """Retorna todos os cards onde o membro participa"""
    cards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards_list in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards_list:
                if member_name in card.get('members', []):
                    card['board_name'] = board_name
                    card['list_name'] = list_name
                    cards.append(card)
    return cards

def get_pending_tasks(self, member_name):
    """Retorna tarefas pendentes do membro"""
    return [card for card in self.get_cards_by_member(member_name) 
            if card.get('status') != 'done']

def get_completed_tasks(self, member_name, days=30):
    """Retorna tarefas completadas nos últimos X dias"""
    cutoff_date = datetime.now() - timedelta(days=days)
    completed = []
    for card in self.get_cards_by_member(member_name):
        if card.get('status') == 'done':
            completed_date = card.get('completed_at')
            if completed_date and completed_date > cutoff_date:
                completed.append(card)
    return completed

def get_upcoming_deadlines(self, member_name, days=7):
    """Retorna prazos próximos do membro"""
    cutoff_date = datetime.now() + timedelta(days=days)
    upcoming = []
    for card in self.get_cards_by_member(member_name):
        deadline = card.get('deadline')
        if deadline and deadline <= cutoff_date and card.get('status') != 'done':
            upcoming.append(card)
    return upcoming

def log_activity(self, action, user, card_id=None, details=None):
    """Registra atividade no sistema"""
    activity = {
        'id': str(uuid.uuid4()),
        'action': action,
        'user': user,
        'card_id': card_id,
        'details': details,
        'timestamp': datetime.now().isoformat()
    }
    
    # Salvar no banco
    self.save_activity(activity)
    
    # Atualizar interface se necessário
    self.update_activity_display()

def save_activity(self, activity):
    """Salva atividade no banco de dados"""
    try:
        conn = supabase_config.get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO activities (id, action, user, card_id, details, timestamp)
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (
            activity['id'],
            activity['action'],
            activity['user'],
            activity['card_id'],
            activity['details'],
            activity['timestamp']
        ))
        
        conn.commit()
        conn.close()
        print(f"✅ Atividade registrada: {activity['action']}")
    except Exception as e:
        print(f"❌ Erro ao salvar atividade: {e}")

def get_recent_activities(self, member_name, limit=10):
    """Retorna atividades recentes relacionadas ao membro"""
    try:
        conn = supabase_config.get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT action, details, timestamp FROM activities 
            WHERE user = %s OR details LIKE %s
            ORDER BY timestamp DESC LIMIT %s
        """, (member_name, f"%{member_name}%", limit))
        
        activities = cursor.fetchall()
        conn.close()
        
        return [{'action': a[0], 'details': a[1], 'timestamp': a[2]} for a in activities]
    except Exception as e:
        print(f"❌ Erro ao buscar atividades: {e}")
        return []

def update_activity_display(self):
    """Atualiza display de atividades na interface"""
    if hasattr(self, 'activity_frame'):
        # Limpar frame atual
        for widget in self.activity_frame.winfo_children():
            widget.destroy()
        
        # Obter atividades do usuário atual
        current_user_member = self._get_current_user_member()
        activities = self.get_recent_activities(current_user_member, 5)
        
        # Criar lista de atividades
        for activity in activities:
            activity_text = f"{activity['action']} - {activity['timestamp']}"
            ttk.Label(self.activity_frame, text=activity_text).pack(anchor='w')

def get_member_metrics(self, member_name, period='month'):
    """Calcula métricas de produtividade do membro"""
    start_date = self.get_period_start_date(period)
    
    metrics = {
        'cards_created': len(self.get_cards_created_by(member_name, start_date)),
        'cards_completed': len(self.get_cards_completed_by(member_name, start_date)),
        'average_completion_time': self.get_avg_completion_time(member_name, start_date),
        'productivity_score': self.calculate_productivity_score(member_name, start_date),
        'on_time_completion_rate': self.get_on_time_completion_rate(member_name, start_date),
        'active_boards': len(self.get_boards_for_member(member_name))
    }
    return metrics

def get_period_start_date(self, period):
    """Retorna data de início do período"""
    now = datetime.now()
    if period == 'week':
        return now - timedelta(days=7)
    elif period == 'month':
        return now - timedelta(days=30)
    elif period == 'quarter':
        return now - timedelta(days=90)
    else:
        return now - timedelta(days=365)

def get_cards_created_by(self, member_name, start_date):
    """Retorna cards criados pelo membro desde uma data"""
    cards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards_list in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards_list:
                if card.get('created_by') == member_name:
                    created_date = card.get('created_at')
                    if created_date and created_date >= start_date:
                        cards.append(card)
    return cards

def get_cards_completed_by(self, member_name, start_date):
    """Retorna cards completados pelo membro desde uma data"""
    cards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards_list in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards_list:
                if member_name in card.get('members', []) and card.get('status') == 'done':
                    completed_date = card.get('completed_at')
                    if completed_date and completed_date >= start_date:
                        cards.append(card)
    return cards

def get_avg_completion_time(self, member_name, start_date):
    """Calcula tempo médio de conclusão"""
    completed_cards = self.get_cards_completed_by(member_name, start_date)
    if not completed_cards:
        return 0
    
    total_time = 0
    for card in completed_cards:
        created = card.get('created_at')
        completed = card.get('completed_at')
        if created and completed:
            try:
                created_dt = datetime.fromisoformat(created)
                completed_dt = datetime.fromisoformat(completed)
                total_time += (completed_dt - created_dt).total_seconds() / 3600  # em horas
            except:
                pass
    
    return total_time / len(completed_cards) if completed_cards else 0

def get_on_time_completion_rate(self, member_name, start_date):
    """Calcula taxa de conclusão no prazo"""
    completed_cards = self.get_cards_completed_by(member_name, start_date)
    if not completed_cards:
        return 0
    
    on_time_count = 0
    for card in completed_cards:
        deadline = card.get('deadline')
        completed = card.get('completed_at')
        if deadline and completed:
            try:
                deadline_dt = datetime.fromisoformat(deadline)
                completed_dt = datetime.fromisoformat(completed)
                if completed_dt <= deadline_dt:
                    on_time_count += 1
            except:
                pass
    
    return on_time_count / len(completed_cards) if completed_cards else 0

def calculate_productivity_score(self, member_name, start_date):
    """Calcula score de produtividade (0-100)"""
    completed = len(self.get_cards_completed_by(member_name, start_date))
    total_assigned = len(self.get_cards_by_member(member_name))
    
    if total_assigned == 0:
        return 0
    
    on_time_rate = self.get_on_time_completion_rate(member_name, start_date)
    completion_rate = completed / total_assigned
    
    # Score baseado em conclusão e pontualidade
    score = (completion_rate * 0.7 + on_time_rate * 0.3) * 100
    return min(100, max(0, score))

def generate_member_report(self, member_name, period='month'):
    """Gera relatório completo do membro"""
    metrics = self.get_member_metrics(member_name, period)
    cards = self.get_cards_by_member(member_name)
    
    report = {
        'member': member_name,
        'period': period,
        'metrics': metrics,
        'cards_summary': {
            'total': len(cards),
            'pending': len([c for c in cards if c.get('status') != 'done']),
            'completed': len([c for c in cards if c.get('status') == 'done']),
            'overdue': len([c for c in cards if self.is_card_overdue(c)])
        },
        'boards_participation': self.get_boards_for_member(member_name),
        'recent_activities': self.get_recent_activities(member_name, 10)
    }
    
    return report

def is_card_overdue(self, card):
    """Verifica se um card está atrasado"""
    deadline = card.get('deadline')
    if not deadline or card.get('status') == 'done':
        return False
    
    try:
        deadline_dt = datetime.fromisoformat(deadline)
        return datetime.now() > deadline_dt
    except:
        return False

def create_progress_indicators(self, board_frame, member_name):
    """Cria indicadores visuais de progresso"""
    progress_frame = ttk.LabelFrame(board_frame, text="Meu Progresso")
    progress_frame.pack(fill=tk.X, pady=5)
    
    # Cards pendentes
    pending = len(self.get_pending_tasks(member_name))
    ttk.Label(progress_frame, text=f"📋 Pendentes: {pending}").pack(side=tk.LEFT, padx=10)
    
    # Cards completados hoje
    completed_today = len(self.get_completed_tasks(member_name, 1))
    ttk.Label(progress_frame, text=f"✅ Completados Hoje: {completed_today}").pack(side=tk.LEFT, padx=10)
    
    # Cards atrasados
    overdue = len([c for c in self.get_cards_by_member(member_name) if self.is_card_overdue(c)])
    ttk.Label(progress_frame, text=f"⚠️ Atrasados: {overdue}").pack(side=tk.LEFT, padx=10)

def create_advanced_filters(self, board_frame):
    """Cria filtros avançados para cards"""
    filter_frame = ttk.LabelFrame(board_frame, text="Filtros")
    filter_frame.pack(fill=tk.X, pady=5)
    
    # Filtro por status
    status_var = tk.StringVar(value="Todos")
    ttk.Label(filter_frame, text="Status:").pack(side=tk.LEFT, padx=5)
    status_combo = ttk.Combobox(filter_frame, textvariable=status_var, 
                               values=["Todos", "Pendentes", "Em Progresso", "Concluídos"])
    status_combo.pack(side=tk.LEFT, padx=5)
    
    # Filtro por prazo
    deadline_var = tk.StringVar(value="Todos")
    ttk.Label(filter_frame, text="Prazo:").pack(side=tk.LEFT, padx=5)
    deadline_combo = ttk.Combobox(filter_frame, textvariable=deadline_var,
                                 values=["Todos", "Hoje", "Esta Semana", "Atrasados"])
    deadline_combo.pack(side=tk.LEFT, padx=5)
    
    # Botão aplicar filtros
    ttk.Button(filter_frame, text="Aplicar", 
               command=lambda: self.apply_filters(status_var.get(), deadline_var.get())).pack(side=tk.LEFT, padx=10)

def apply_filters(self, status_filter, deadline_filter):
    """Aplica filtros aos cards"""
    # Implementar lógica de filtros aqui
    print(f"Aplicando filtros: Status={status_filter}, Prazo={deadline_filter}")
    # Atualizar display dos cards com base nos filtros

def open_personal_dashboard(self):
    """Abre dashboard personalizado do usuário"""
    current_user_member = self._get_current_user_member()
    if not current_user_member:
        messagebox.showwarning("Aviso", "Você precisa estar logado para acessar o dashboard pessoal.")
        return
    
    dashboard_data = self.create_member_dashboard(current_user_member)
    self.show_personal_dashboard_window(dashboard_data)

def create_tooltip(self, widget, text):
    """Cria um tooltip para um widget"""
    def show_tooltip(event):
        tooltip = tk.Toplevel()
        tooltip.wm_overrideredirect(True)
        tooltip.wm_geometry(f"+{event.x_root+10}+{event.y_root+10}")
        
        label = ttk.Label(tooltip, text=text, justify=tk.LEFT,
                         background="#ffffe0", relief=tk.SOLID, borderwidth=1,
                         font=("Arial", "8", "normal"))
        label.pack()
        
        def hide_tooltip(event):
            tooltip.destroy()
        
        widget.bind('<Leave>', hide_tooltip)
        tooltip.bind('<Leave>', hide_tooltip)
    
    widget.bind('<Enter>', show_tooltip)

def show_kanban_performance(self):
        """Mostra janela de performance do Kanban"""
        if not hasattr(self, 'kanban_optimizer') or not self.kanban_optimizer:
            messagebox.showwarning("Aviso", "Otimizador de performance não está disponível")
            return
        
        # Criar janela de performance
        performance_window = tk.Toplevel(self.root)
        performance_window.title("Performance do Kanban")
        performance_window.geometry("400x300")
        performance_window.transient(self.root)
        performance_window.grab_set()
        
        # Frame principal
        main_frame = ttk.Frame(performance_window, padding=20)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Título
        ttk.Label(main_frame, text="Estatísticas de Performance", 
                 font=("Arial", 14, "bold")).pack(pady=(0, 20))
        
        # Obter estatísticas
        stats = self.kanban_optimizer.get_performance_stats()
        
        # Frame para estatísticas
        stats_frame = ttk.LabelFrame(main_frame, text="Cache e Performance", padding=10)
        stats_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Exibir estatísticas
        ttk.Label(stats_frame, text=f"Widgets em cache: {stats.get('cached_widgets', 0)}").pack(anchor='w')
        ttk.Label(stats_frame, text=f"Cards em cache: {stats.get('cached_cards', 0)}").pack(anchor='w')
        ttk.Label(stats_frame, text=f"Fila de atualizações: {stats.get('update_queue_size', 0)}").pack(anchor='w')
        
        # Frame para ações
        actions_frame = ttk.Frame(main_frame)
        actions_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(actions_frame, text="Limpar Cache", 
                  command=self.clear_kanban_cache).pack(side=tk.LEFT, padx=(0, 10))
        
        ttk.Button(actions_frame, text="Recarregar Otimizador", 
                  command=self.reload_kanban_optimizer).pack(side=tk.LEFT)
    
    def clear_kanban_cache(self):
        """Limpa cache do Kanban"""
        if hasattr(self, 'kanban_optimizer') and self.kanban_optimizer:
            self.kanban_optimizer.clear_cache()
            messagebox.showinfo("Sucesso", "Cache do Kanban limpo com sucesso!")
    
    def reload_kanban_optimizer(self):
        """Recarrega o otimizador do Kanban"""
        if KANBAN_OPTIMIZER_AVAILABLE:
            self.kanban_optimizer = KanbanPerformanceOptimizer(self)
            messagebox.showinfo("Sucesso", "Otimizador do Kanban recarregado!")
        else:
            messagebox.showerror("Erro", "Otimizador não está disponível")

    def show_personal_dashboard_window(self, dashboard_data):
        """Mostra janela do dashboard pessoal"""
    dashboard_window = tk.Toplevel(self.root)
    dashboard_window.title(f"Dashboard Pessoal - {dashboard_data['my_cards'][0]['members'][0] if dashboard_data['my_cards'] else 'Usuário'}")
    dashboard_window.geometry("800x600")
    
    # Criar notebook para organizar as seções
    notebook = ttk.Notebook(dashboard_window)
    notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    # Aba de Cards
    cards_frame = ttk.Frame(notebook)
    notebook.add(cards_frame, text="Meus Cards")
    
    # Lista de cards
    cards_text = tk.Text(cards_frame, wrap=tk.WORD, height=20)
    cards_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    for card in dashboard_data['my_cards']:
        status_icon = "✅" if card.get('status') == 'done' else "📋"
        card_text = f"{status_icon} {card['title']} - {card['board_name']} > {card['list_name']}\n"
        cards_text.insert(tk.END, card_text)
    
    # Aba de Métricas
    metrics_frame = ttk.Frame(notebook)
    notebook.add(metrics_frame, text="Métricas")
    
    metrics = self.get_member_metrics(dashboard_data['my_cards'][0]['members'][0] if dashboard_data['my_cards'] else 'Usuário')
    
    metrics_text = tk.Text(metrics_frame, wrap=tk.WORD, height=20)
    metrics_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    metrics_text.insert(tk.END, f"📊 MÉTRICAS DE PRODUTIVIDADE\n\n")
    metrics_text.insert(tk.END, f"Cards Criados: {metrics['cards_created']}\n")
    metrics_text.insert(tk.END, f"Cards Completados: {metrics['cards_completed']}\n")
    metrics_text.insert(tk.END, f"Tempo Médio de Conclusão: {metrics['average_completion_time']:.1f} horas\n")
    metrics_text.insert(tk.END, f"Score de Produtividade: {metrics['productivity_score']:.1f}%\n")
    metrics_text.insert(tk.END, f"Taxa de Conclusão no Prazo: {metrics['on_time_completion_rate']*100:.1f}%\n")
    metrics_text.insert(tk.END, f"Quadros Ativos: {metrics['active_boards']}\n")
    
    # Aba de Atividades
    activities_frame = ttk.Frame(notebook)
    notebook.add(activities_frame, text="Atividades Recentes")
    
    activities_text = tk.Text(activities_frame, wrap=tk.WORD, height=20)
    activities_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    for activity in dashboard_data['recent_activities']:
        activity_text = f"🕒 {activity['action']} - {activity['timestamp']}\n"
        activities_text.insert(tk.END, activity_text)


        """Cria o dashboard financeiro empresarial"""
        # Frame principal com scroll
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        canvas = tk.Canvas(main_frame)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Header
        header_frame = ttk.Frame(scrollable_frame)
        header_frame.pack(fill=tk.X, padx=20, pady=20)
        
        ttk.Label(header_frame, text="🏢 Dashboard Financeiro Empresarial", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        ttk.Button(header_frame, text="🔄 Atualizar", 
                  command=self.refresh_enterprise_dashboard).pack(side=tk.RIGHT)
        
        # Cards de métricas principais
        metrics_frame = ttk.Frame(scrollable_frame)
        metrics_frame.pack(fill=tk.X, padx=20, pady=10)
        
        # Saldo Total
        self.create_enterprise_metric_card(metrics_frame, "💰 Saldo Total", "R$ 0,00", "#2ecc71", 0, 0)
        
        # Receitas do Mês
        self.create_enterprise_metric_card(metrics_frame, "📈 Receitas/Mês", "R$ 0,00", "#3498db", 0, 1)
        
        # Despesas do Mês
        self.create_enterprise_metric_card(metrics_frame, "📉 Despesas/Mês", "R$ 0,00", "#e74c3c", 0, 2)
        
        # Lucro do Mês
        self.create_enterprise_metric_card(metrics_frame, "💵 Lucro/Mês", "R$ 0,00", "#f39c12", 0, 3)
        
        # Contas a Receber
        self.create_enterprise_metric_card(metrics_frame, "📥 Contas a Receber", "R$ 0,00", "#9b59b6", 1, 0)
        
        # Contas a Pagar
        self.create_enterprise_metric_card(metrics_frame, "📤 Contas a Pagar", "R$ 0,00", "#e67e22", 1, 1)
        
        # Clientes Ativos
        self.create_enterprise_metric_card(metrics_frame, "👥 Clientes Ativos", "0", "#1abc9c", 1, 2)
        
        # Fornecedores
        self.create_enterprise_metric_card(metrics_frame, "🏭 Fornecedores", "0", "#34495e", 1, 3)
        
        # Seção de gráficos
        charts_frame = ttk.Frame(scrollable_frame)
        charts_frame.pack(fill=tk.X, padx=20, pady=20)
        
        ttk.Label(charts_frame, text="📊 Análises Financeiras", 
                 font=("Arial", 14, "bold")).pack(anchor=tk.W)
        
        charts_buttons_frame = ttk.Frame(charts_frame)
        charts_buttons_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(charts_buttons_frame, text="📈 Evolução Mensal", 
                  command=lambda: self.show_enterprise_chart("evolucao")).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(charts_buttons_frame, text="🥧 Receitas por Categoria", 
                  command=lambda: self.show_enterprise_chart("receitas_categoria")).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(charts_buttons_frame, text="📊 Despesas por Departamento", 
                  command=lambda: self.show_enterprise_chart("despesas_departamento")).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(charts_buttons_frame, text="💼 Fluxo de Caixa", 
                  command=lambda: self.show_enterprise_chart("fluxo_caixa")).pack(side=tk.LEFT, padx=5)
        
        # Seção de alertas e pendências
        alerts_frame = ttk.Frame(scrollable_frame)
        alerts_frame.pack(fill=tk.X, padx=20, pady=20)
        
        ttk.Label(alerts_frame, text="⚠️ Alertas e Pendências", 
                 font=("Arial", 14, "bold")).pack(anchor=tk.W)
        
        # Treeview para alertas
        self.alerts_tree = ttk.Treeview(alerts_frame, columns=("tipo", "descricao", "valor", "prazo"), 
                                       show="headings", height=6)
        self.alerts_tree.heading("tipo", text="Tipo")
        self.alerts_tree.heading("descricao", text="Descrição")
        self.alerts_tree.heading("valor", text="Valor")
        self.alerts_tree.heading("prazo", text="Prazo")
        
        self.alerts_tree.column("tipo", width=100)
        self.alerts_tree.column("descricao", width=300)
        self.alerts_tree.column("valor", width=100)
        self.alerts_tree.column("prazo", width=100)
        
        self.alerts_tree.pack(fill=tk.X, pady=10)
        
        # Configurar scroll
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Atualizar dados
        self.refresh_enterprise_dashboard()
    
    def create_enterprise_metric_card(self, parent, title, value, color, row, col):
        """Cria um card de métrica empresarial"""
        card_frame = ttk.Frame(parent, relief=tk.RAISED, borderwidth=2)
        card_frame.grid(row=row, column=col, padx=10, pady=10, sticky="nsew")
        
        # Configurar grid
        parent.grid_columnconfigure(col, weight=1)
        parent.grid_rowconfigure(row, weight=1)
        
        # Título
        ttk.Label(card_frame, text=title, font=("Arial", 10, "bold")).pack(pady=(10, 5))
        
        # Valor
        value_label = ttk.Label(card_frame, text=value, font=("Arial", 16, "bold"), foreground=color)
        value_label.pack(pady=(0, 10))
        
        # Armazenar referência para atualização
        if not hasattr(self, 'enterprise_metrics'):
            self.enterprise_metrics = {}
        self.enterprise_metrics[f"{title}_{row}_{col}"] = value_label
    
    def refresh_enterprise_dashboard(self):
        """Atualiza o dashboard empresarial"""
        try:
            # Buscar dados do banco
            departments = self.db.get_departments()
            clients = self.db.get_clients()
            suppliers = self.db.get_suppliers()
            accounts_receivable = self.db.get_accounts_receivable()
            accounts_payable = self.db.get_accounts_payable()
            
            # Calcular métricas
            total_receivable = sum(float(ar['amount']) for ar in accounts_receivable if ar['status'] == 'Pendente')
            total_payable = sum(float(ap['amount']) for ap in accounts_payable if ap['status'] == 'Pendente')
            
            # Atualizar cards
            if hasattr(self, 'enterprise_metrics'):
                self.enterprise_metrics.get("💰 Saldo Total_0_0", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("📈 Receitas/Mês_0_1", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("📉 Despesas/Mês_0_2", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("💵 Lucro/Mês_0_3", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("📥 Contas a Receber_1_0", ttk.Label()).configure(text=f"R$ {total_receivable:,.2f}")
                self.enterprise_metrics.get("📤 Contas a Pagar_1_1", ttk.Label()).configure(text=f"R$ {total_payable:,.2f}")
                self.enterprise_metrics.get("👥 Clientes Ativos_1_2", ttk.Label()).configure(text=str(len(clients)))
                self.enterprise_metrics.get("🏭 Fornecedores_1_3", ttk.Label()).configure(text=str(len(suppliers)))
            
            # Atualizar alertas
            self.update_enterprise_alerts()
            
        except Exception as e:
            print(f"Erro ao atualizar dashboard empresarial: {e}")
    
    def update_enterprise_alerts(self):
        """Atualiza a lista de alertas empresariais"""
        if not hasattr(self, 'alerts_tree'):
            return
        
        # Limpar lista
        for item in self.alerts_tree.get_children():
            self.alerts_tree.delete(item)
        
        try:
            # Buscar contas a pagar vencidas
            accounts_payable = self.db.get_accounts_payable()
            today = datetime.now().date()
            
            for ap in accounts_payable:
                if ap['status'] == 'Pendente':
                    due_date = datetime.strptime(ap['due_date'], '%Y-%m-%d').date()
                    if due_date < today:
                        self.alerts_tree.insert("", "end", values=(
                            "Conta Vencida",
                            f"Pagar: {ap['description']}",
                            f"R$ {float(ap['amount']):,.2f}",
                            ap['due_date']
                        ))
            
            # Buscar contas a receber vencidas
            accounts_receivable = self.db.get_accounts_receivable()
            
            for ar in accounts_receivable:
                if ar['status'] == 'Pendente':
                    due_date = datetime.strptime(ar['due_date'], '%Y-%m-%d').date()
                    if due_date < today:
                        self.alerts_tree.insert("", "end", values=(
                            "Recebimento Vencido",
                            f"Receber: {ar['description']}",
                            f"R$ {float(ar['amount']):,.2f}",
                            ar['due_date']
                        ))
        
        except Exception as e:
            print(f"Erro ao atualizar alertas: {e}")
    
    def show_enterprise_chart(self, chart_type):
        """Mostra gráficos empresariais"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
            
            # Criar janela para o gráfico
            chart_window = tk.Toplevel(self.root)
            chart_window.title(f"Gráfico - {chart_type}")
            chart_window.geometry("800x600")
            
            fig, ax = plt.subplots(figsize=(10, 6))
            
            if chart_type == "evolucao":
                # Gráfico de evolução mensal
                months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun']
                receitas = [50000, 55000, 48000, 62000, 58000, 65000]
                despesas = [45000, 47000, 43000, 52000, 49000, 54000]
                
                ax.plot(months, receitas, 'o-', label='Receitas', color='#3498db')
                ax.plot(months, despesas, 's-', label='Despesas', color='#e74c3c')
                ax.set_title('Evolução Mensal - Receitas vs Despesas')
                ax.set_ylabel('Valor (R$)')
                ax.legend()
                ax.grid(True, alpha=0.3)
            
            elif chart_type == "receitas_categoria":
                # Gráfico de pizza - receitas por categoria
                categories = ['Vendas', 'Serviços', 'Consultoria', 'Outros']
                values = [45, 30, 20, 5]
                colors = ['#3498db', '#2ecc71', '#f39c12', '#e74c3c']
                
                ax.pie(values, labels=categories, colors=colors, autopct='%1.1f%%')
                ax.set_title('Receitas por Categoria')
            
            elif chart_type == "despesas_departamento":
                # Gráfico de barras - despesas por departamento
                departments = ['TI', 'Marketing', 'RH', 'Financeiro', 'Operações']
                expenses = [25000, 18000, 15000, 12000, 22000]
                colors = ['#3498db', '#2ecc71', '#f39c12', '#e74c3c', '#9b59b6']
                
                bars = ax.bar(departments, expenses, color=colors)
                ax.set_title('Despesas por Departamento')
                ax.set_ylabel('Valor (R$)')
                
                # Adicionar valores nas barras
                for bar, value in zip(bars, expenses):
                    ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 1000,
                           f'R$ {value:,.0f}', ha='center', va='bottom')
            
            elif chart_type == "fluxo_caixa":
                # Gráfico de fluxo de caixa
                dates = ['01/01', '15/01', '01/02', '15/02', '01/03', '15/03']
                cash_flow = [50000, 45000, 52000, 48000, 55000, 58000]
                
                ax.plot(dates, cash_flow, 'o-', color='#2ecc71', linewidth=2)
                ax.fill_between(dates, cash_flow, alpha=0.3, color='#2ecc71')
                ax.set_title('Fluxo de Caixa - Últimos 3 Meses')
                ax.set_ylabel('Saldo (R$)')
                ax.grid(True, alpha=0.3)
            
            # Configurar layout
            plt.tight_layout()
            
            # Criar canvas
            canvas = FigureCanvasTkAgg(fig, chart_window)
            canvas.draw()
            canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except ImportError:
            messagebox.showwarning("Aviso", "Matplotlib não está instalado. Instale com: pip install matplotlib")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar gráfico: {e}")
    
    def create_clients_management_tab(self, parent):
        """Cria a aba de gestão de clientes"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Header
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(header_frame, text="👥 Gestão de Clientes", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        ttk.Button(header_frame, text="➕ Novo Cliente", 
                  command=self.open_new_client_window).pack(side=tk.RIGHT)
        
        # Frame para formulário e lista
        content_frame = ttk.Frame(main_frame)
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        # Formulário de cliente
        form_frame = ttk.LabelFrame(content_frame, text="Dados do Cliente", padding=10)
        form_frame.pack(fill=tk.X, pady=(0, 20))
        
        # Primeira linha
        row1 = ttk.Frame(form_frame)
        row1.pack(fill=tk.X, pady=5)
        
        ttk.Label(row1, text="Nome/Razão Social:").pack(side=tk.LEFT)
        self.client_name_var = tk.StringVar()
        ttk.Entry(row1, textvariable=self.client_name_var, width=30).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row1, text="CNPJ/CPF:").pack(side=tk.LEFT)
        self.client_cnpj_var = tk.StringVar()
        ttk.Entry(row1, textvariable=self.client_cnpj_var, width=20).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row1, text="Segmento:").pack(side=tk.LEFT)
        self.client_segment_var = tk.StringVar()
        ttk.Combobox(row1, textvariable=self.client_segment_var, 
                    values=["Tecnologia", "Saúde", "Educação", "Varejo", "Indústria", "Serviços", "Outros"],
                    width=15).pack(side=tk.LEFT, padx=(10, 0))
        
        # Segunda linha
        row2 = ttk.Frame(form_frame)
        row2.pack(fill=tk.X, pady=5)
        
        ttk.Label(row2, text="Email:").pack(side=tk.LEFT)
        self.client_email_var = tk.StringVar()
        ttk.Entry(row2, textvariable=self.client_email_var, width=30).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row2, text="Telefone:").pack(side=tk.LEFT)
        self.client_phone_var = tk.StringVar()
        ttk.Entry(row2, textvariable=self.client_phone_var, width=15).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row2, text="Limite de Crédito:").pack(side=tk.LEFT)
        self.client_credit_var = tk.StringVar()
        ttk.Entry(row2, textvariable=self.client_credit_var, width=15).pack(side=tk.LEFT, padx=(10, 0))
        
        # Terceira linha
        row3 = ttk.Frame(form_frame)
        row3.pack(fill=tk.X, pady=5)
        
        ttk.Label(row3, text="Contato:").pack(side=tk.LEFT)
        self.client_contact_var = tk.StringVar()
        ttk.Entry(row3, textvariable=self.client_contact_var, width=30).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row3, text="Endereço:").pack(side=tk.LEFT)
        self.client_address_var = tk.StringVar()
        ttk.Entry(row3, textvariable=self.client_address_var, width=40).pack(side=tk.LEFT, padx=(10, 0))
        
        # Botões
        buttons_frame = ttk.Frame(form_frame)
        buttons_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(buttons_frame, text="💾 Salvar Cliente", 
                  command=self.save_client).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(buttons_frame, text="🔄 Limpar", 
                  command=self.clear_client_form).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(buttons_frame, text="🗑️ Excluir", 
                  command=self.delete_client).pack(side=tk.LEFT)
        
        # Lista de clientes
        list_frame = ttk.LabelFrame(content_frame, text="Clientes Cadastrados", padding=10)
        list_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview
        columns = ("id", "nome", "cnpj_cpf", "email", "telefone", "segmento", "limite_credito", "status")
        self.clients_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=10)
        
        self.clients_tree.heading("id", text="ID")
        self.clients_tree.heading("nome", text="Nome/Razão Social")
        self.clients_tree.heading("cnpj_cpf", text="CNPJ/CPF")
        self.clients_tree.heading("email", text="Email")
        self.clients_tree.heading("telefone", text="Telefone")
        self.clients_tree.heading("segmento", text="Segmento")
        self.clients_tree.heading("limite_credito", text="Limite de Crédito")
        self.clients_tree.heading("status", text="Status")
        
        self.clients_tree.column("id", width=50)
        self.clients_tree.column("nome", width=200)
        self.clients_tree.column("cnpj_cpf", width=120)
        self.clients_tree.column("email", width=150)
        self.clients_tree.column("telefone", width=100)
        self.clients_tree.column("segmento", width=100)
        self.clients_tree.column("limite_credito", width=120)
        self.clients_tree.column("status", width=80)
        
        # Scrollbars
        tree_scroll_y = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.clients_tree.yview)
        tree_scroll_x = ttk.Scrollbar(list_frame, orient=tk.HORIZONTAL, command=self.clients_tree.xview)
        self.clients_tree.configure(yscrollcommand=tree_scroll_y.set, xscrollcommand=tree_scroll_x.set)
        
        # Pack
        self.clients_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        tree_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Bind para seleção
        self.clients_tree.bind('<<TreeviewSelect>>', self.on_client_select)
        
        # Carregar dados
        self.load_clients()
    
    def save_client(self):
        """Salva um novo cliente"""
        try:
            # Validar campos obrigatórios
            if not self.client_name_var.get().strip():
                messagebox.showerror("Erro", "Nome/Razão Social é obrigatório!")
                return
            
            if not self.client_cnpj_var.get().strip():
                messagebox.showerror("Erro", "CNPJ/CPF é obrigatório!")
                return
            
            # Preparar dados
            client_data = {
                'name': self.client_name_var.get().strip(),
                'cnpj_cpf': self.client_cnpj_var.get().strip(),
                'email': self.client_email_var.get().strip(),
                'phone': self.client_phone_var.get().strip(),
                'address': self.client_address_var.get().strip(),
                'contact_person': self.client_contact_var.get().strip(),
                'segment': self.client_segment_var.get().strip(),
                'credit_limit': float(self.client_credit_var.get() or 0)
            }
            
            # Salvar no banco
            client_id = self.db.create_client(**client_data)
            
            if client_id:
                messagebox.showinfo("Sucesso", "Cliente salvo com sucesso!")
                self.clear_client_form()
                self.load_clients()
            else:
                messagebox.showerror("Erro", "Erro ao salvar cliente!")
        
        except ValueError:
            messagebox.showerror("Erro", "Limite de crédito deve ser um número válido!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar cliente: {e}")
    
    def clear_client_form(self):
        """Limpa o formulário de cliente"""
        self.client_name_var.set("")
        self.client_cnpj_var.set("")
        self.client_email_var.set("")
        self.client_phone_var.set("")
        self.client_address_var.set("")
        self.client_contact_var.set("")
        self.client_segment_var.set("")
        self.client_credit_var.set("")
    
    def load_clients(self):
        """Carrega a lista de clientes"""
        try:
            # Limpar lista
            for item in self.clients_tree.get_children():
                self.clients_tree.delete(item)
            
            # Buscar clientes
            clients = self.db.get_clients()
            
            # Adicionar à lista
            for client in clients:
                self.clients_tree.insert("", "end", values=(
                    client['id'],
                    client['name'],
                    client['cnpj_cpf'],
                    client['email'],
                    client['phone'],
                    client['segment'],
                    f"R$ {float(client['credit_limit']):,.2f}",
                    "Ativo" if client['is_active'] else "Inativo"
                ))
        
        except Exception as e:
            print(f"Erro ao carregar clientes: {e}")
    
    def on_client_select(self, event):
        """Evento de seleção de cliente"""
        selection = self.clients_tree.selection()
        if selection:
            item = self.clients_tree.item(selection[0])
            values = item['values']
            
            # Preencher formulário
            self.client_name_var.set(values[1])
            self.client_cnpj_var.set(values[2])
            self.client_email_var.set(values[3])
            self.client_phone_var.set(values[4])
            self.client_segment_var.set(values[5])
            self.client_credit_var.set(values[6].replace("R$ ", "").replace(",", ""))
    
    def delete_client(self):
        """Exclui um cliente"""
        selection = self.clients_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione um cliente para excluir!")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir este cliente?"):
            try:
                item = self.clients_tree.item(selection[0])
                client_id = item['values'][0]
                
                # Excluir do banco (soft delete)
                # self.db.delete_client(client_id)  # Implementar método
                
                messagebox.showinfo("Sucesso", "Cliente excluído com sucesso!")
                self.load_clients()
                self.clear_client_form()
            
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao excluir cliente: {e}")
    
    def open_new_client_window(self):
        """Abre janela para novo cliente"""
        self.clear_client_form()
        # Focar no primeiro campo
        # Implementar foco automático
    
    # Métodos placeholder para outras abas
    def create_suppliers_management_tab(self, parent):
        """Cria a aba de gestão de fornecedores"""
        ttk.Label(parent, text="🏭 Gestão de Fornecedores - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_receivables_management_tab(self, parent):
        """Cria a aba de contas a receber"""
        ttk.Label(parent, text="📥 Contas a Receber - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_payables_management_tab(self, parent):
        """Cria a aba de contas a pagar"""
        ttk.Label(parent, text="📤 Contas a Pagar - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_invoices_management_tab(self, parent):
        """Cria a aba de faturas"""
        ttk.Label(parent, text="🧾 Gestão de Faturas - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_cashflow_management_tab(self, parent):
        """Cria a aba de fluxo de caixa"""
        ttk.Label(parent, text="💼 Fluxo de Caixa - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_budgets_management_tab(self, parent):
        """Cria a aba de orçamentos"""
        ttk.Label(parent, text="📊 Gestão de Orçamentos - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_enterprise_reports_tab(self, parent):
        """Cria a aba de relatórios empresariais"""
        ttk.Label(parent, text="📈 Relatórios Empresariais - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_finance_config_tab(self, parent):
        """Cria a aba de configurações financeiras"""
        ttk.Label(parent, text="⚙️ Configurações Financeiras - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)


# ============================================================================
# FIM DAS MELHORIAS IMPLEMENTADAS
# ============================================================================
