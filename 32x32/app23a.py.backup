import tkinter as tk
from supabase_setup import supabase_config
# Kanban Performance Optimizer
try:
    from kanban_performance_optimizer import KanbanPerformanceOptimizer
    KANBAN_OPTIMIZER_AVAILABLE = True
    print("‚úÖ Kanban Performance Optimizer dispon√≠vel")
except ImportError as e:
    KANBAN_OPTIMIZER_AVAILABLE = False
    print(f"‚ö†Ô∏è Kanban Performance Optimizer n√£o dispon√≠vel: {e}")
from tkinter import ttk, messagebox, simpledialog, colorchooser, filedialog
from ttkthemes import ThemedTk
import pandas as pd
import json
import os
import requests
import json
from datetime import datetime
from os.path import sep
import random
import winsound # Apenas para Windows
from datetime import datetime, timedelta, timezone
from functools import partial
from PIL import Image, ImageTk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import sys
import uuid
from tkcalendar import Calendar, DateEntry
import calendar
import threading
import time
import psutil
import signal
import subprocess
import shutil
import base64
import platform

# Sistema de upload completo (Supabase + Cloudflare R2)
try:
    from sistema_upload_completo import SistemaUploadCompleto
    SISTEMA_UPLOAD_DISPONIVEL = True
except ImportError:
    SISTEMA_UPLOAD_DISPONIVEL = False
    print("‚ö†Ô∏è Sistema de upload completo n√£o dispon√≠vel. Usando upload local.")

# Carregar vari√°veis de ambiente do arquivo .env
try:
    from dotenv import load_dotenv
    load_dotenv()
    print("‚úÖ Vari√°veis de ambiente carregadas do arquivo .env")
except ImportError:
    print("‚ö†Ô∏è python-dotenv n√£o instalado. Usando vari√°veis de ambiente do sistema.")
except Exception as e:
    print(f"‚ö†Ô∏è Erro ao carregar .env: {e}")

class ImageUploadManager:
    """Gerencia uploads e manipula√ß√£o de imagens de perfil"""
    
    def __init__(self, upload_dir="uploads"):
        self.upload_dir = upload_dir
        self.allowed_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp'}

        self.max_file_size = 5 * 1024 * 1024  # 5MB
        self.profile_size = (150, 150)  # Tamanho padr√£o para foto de perfil
        
        # Criar diret√≥rio de uploads se n√£o existir
        if not os.path.exists(upload_dir):
            os.makedirs(upload_dir)
    
    def select_image(self, parent_window):
        """Abre di√°logo para selecionar imagem"""
        file_path = filedialog.askopenfilename(
            parent=parent_window,
            title="Selecionar Foto de Perfil",
            filetypes=[
                ("Imagens", "*.jpg *.jpeg *.png *.gif *.bmp"),
                ("JPEG", "*.jpg *.jpeg"),
                ("PNG", "*.png"),
                ("GIF", "*.gif"),
                ("BMP", "*.bmp"),
                ("Todos os arquivos", "*.*")
            ]
        )
        
        if file_path:
            return self.process_image(file_path)
        return None
    
    def process_image(self, file_path):
        """Processa e redimensiona a imagem"""
        try:
            # Verificar extens√£o
            file_ext = os.path.splitext(file_path)[1].lower()
            if file_ext not in self.allowed_extensions:
                raise ValueError(f"Formato n√£o suportado: {file_ext}")
            
            # Verificar tamanho
            file_size = os.path.getsize(file_path)
            if file_size > self.max_file_size:
                raise ValueError(f"Arquivo muito grande: {file_size / 1024 / 1024:.1f}MB (m√°x: 5MB)")
            
            # Abrir e redimensionar imagem
            with Image.open(file_path) as img:
                # Converter para RGB se necess√°rio
                if img.mode != 'RGB':
                    img = img.convert('RGB')
                
                # Redimensionar mantendo propor√ß√£o
                img.thumbnail(self.profile_size, Image.Resampling.LANCZOS)
                
                # Salvar imagem processada
                filename = f"profile_{uuid.uuid4().hex[:8]}.jpg"
                save_path = os.path.join(self.upload_dir, filename)
                img.save(save_path, 'JPEG', quality=85, optimize=True)
                
                return {
                    'original_path': file_path,
                    'processed_path': save_path,
                    'filename': filename,
                    'size': img.size
                }
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao processar imagem:\n{str(e)}")
            return None
    
    def get_image_preview(self, image_path, size=(100, 100)):
        """Cria preview da imagem para exibi√ß√£o"""
        try:
            with Image.open(image_path) as img:
                img.thumbnail(size, Image.Resampling.LANCZOS)
                return ImageTk.PhotoImage(img)
        except Exception as e:
            print(f"Erro ao criar preview: {e}")
            return None
    
    def delete_image(self, filename):
        """Remove imagem do sistema"""
        try:
            file_path = os.path.join(self.upload_dir, filename)
            if os.path.exists(file_path):
                os.remove(file_path)
                return True
        except Exception as e:
            print(f"Erro ao deletar imagem: {e}")
        return False
    
    def image_to_base64(self, image_path):
        """Converte imagem para base64"""
        try:
            with open(image_path, 'rb') as img_file:
                return base64.b64encode(img_file.read()).decode('utf-8')
        except Exception as e:
            print(f"Erro ao converter para base64: {e}")
            return None
    
    def base64_to_image(self, base64_data, filename):
        """Converte base64 para imagem"""
        try:
            image_data = base64.b64decode(base64_data)
            file_path = os.path.join(self.upload_dir, filename)
            with open(file_path, 'wb') as img_file:
                img_file.write(image_data)
            return file_path
        except Exception as e:
            print(f"Erro ao converter base64 para imagem: {e}")
            return None

class DatabaseConcurrencyControl:
    """Sistema de controle de concorr√™ncia para o banco de dados"""
    
    def __init__(self, db_file='boodesk_new.db'):
        self.db_file = db_file
        self.lock_file = f"{db_file}.lock"
        self.pid_file = f"{db_file}.pid"
        self.current_pid = os.getpid()
        self.lock_acquired = False
        
    def acquire_lock(self, timeout=30):
        """Tenta adquirir o lock do banco de dados"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                # Verificar se j√° temos o lock
                if self.lock_acquired:
                    print(f"‚úÖ Lock j√° adquirido (PID: {self.current_pid})")
                    return True
                
                # Verificar se j√° existe um lock para este processo
                if os.path.exists(self.lock_file):
                    try:
                        with open(self.lock_file, 'r') as f:
                            pid_str = f.read().strip()
                            if pid_str == str(self.current_pid):
                                self.lock_acquired = True
                                print(f"‚úÖ Lock j√° adquirido por este processo (PID: {self.current_pid})")
                                return True
                    except:
                        pass
                
                # Verificar se h√° outro processo usando o banco
                if self._is_other_process_using_db():
                    print(f"‚ö†Ô∏è Outro processo est√° usando o banco. Tentando interromper...")
                    if self._terminate_other_processes():
                        time.sleep(2)  # Aguardar processo terminar
                        continue
                    else:
                        print(f"‚ùå N√£o foi poss√≠vel interromper outros processos")
                        return False
                
                # Verificar se h√° outro processo usando o lock
                if os.path.exists(self.lock_file):
                    try:
                        with open(self.lock_file, 'r') as f:
                            pid_str = f.read().strip()
                            if pid_str:
                                try:
                                    pid = int(pid_str)
                                    if psutil.pid_exists(pid) and pid != self.current_pid:
                                        print(f"‚ö†Ô∏è Lock j√° existe para PID {pid}")
                                        return False
                                except:
                                    pass
                    except:
                        pass
                
                # Tentar criar arquivo de lock
                with open(self.lock_file, 'w') as f:
                    f.write(str(self.current_pid))
                
                # Verificar se conseguiu criar o lock
                if os.path.exists(self.lock_file):
                    with open(self.lock_file, 'r') as f:
                        pid_in_file = f.read().strip()
                        if pid_in_file == str(self.current_pid):
                            self.lock_acquired = True
                            print(f"‚úÖ Lock adquirido com sucesso (PID: {self.current_pid})")
                            return True
                
                time.sleep(0.5)
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao tentar adquirir lock: {e}")
                time.sleep(0.5)
        
        print(f"‚ùå Timeout ao tentar adquirir lock do banco")
        return False
    
    def release_lock(self):
        """Libera o lock do banco de dados"""
        try:
            if self.lock_acquired and os.path.exists(self.lock_file):
                try:
                    with open(self.lock_file, 'r') as f:
                        pid_in_file = f.read().strip()
                        if pid_in_file == str(self.current_pid):
                            try:
                                os.remove(self.lock_file)
                                self.lock_acquired = False
                                print(f"‚úÖ Lock liberado (PID: {self.current_pid})")
                            except Exception as e:
                                print(f"‚ö†Ô∏è Erro ao remover arquivo de lock: {e}")
                                # Tentar novamente ap√≥s um pequeno delay
                                time.sleep(0.1)
                                try:
                                    os.remove(self.lock_file)
                                    self.lock_acquired = False
                                    print(f"‚úÖ Lock liberado na segunda tentativa (PID: {self.current_pid})")
                                except:
                                    pass
                except Exception as e:
                    print(f"‚ö†Ô∏è Erro ao ler arquivo de lock: {e}")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao liberar lock: {e}")
    
    def _is_other_process_using_db(self):
        """Verifica se h√° outro processo usando o banco"""
        try:
            # Verificar arquivo de lock
            if os.path.exists(self.lock_file):
                with open(self.lock_file, 'r') as f:
                    pid_str = f.read().strip()
                    if pid_str and pid_str != str(self.current_pid):
                        try:
                            pid = int(pid_str)
                            if psutil.pid_exists(pid):
                                return True
                        except:
                            pass
            
            # Verificar processos Python que podem estar usando o banco
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    if proc.info['name'] and 'python' in proc.info['name'].lower():
                        if proc.info['cmdline']:
                            cmdline = ' '.join(proc.info['cmdline'])
                            if 'app23a.py' in cmdline and proc.info['pid'] != self.current_pid:
                                return True
                except:
                    continue
            
            return False
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao verificar outros processos: {e}")
            return False
    
    def _terminate_other_processes(self):
        """Tenta terminar outros processos Python que estejam usando o banco"""
        try:
            terminated_count = 0
            
            # Terminar processos Python que executam app23a.py
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    if proc.info['name'] and 'python' in proc.info['name'].lower():
                        if proc.info['cmdline']:
                            cmdline = ' '.join(proc.info['cmdline'])
                            if 'app23a.py' in cmdline and proc.info['pid'] != self.current_pid:
                                print(f"üîÑ Terminando processo Python (PID: {proc.info['pid']})")
                                proc.terminate()
                                proc.wait(timeout=5)
                                terminated_count += 1
                except:
                    continue
            
            # Limpar arquivos de lock √≥rf√£os
            if os.path.exists(self.lock_file):
                try:
                    with open(self.lock_file, 'r') as f:
                        pid_str = f.read().strip()
                        if pid_str:
                            try:
                                pid = int(pid_str)
                                if not psutil.pid_exists(pid):
                                    os.remove(self.lock_file)
                                    print(f"üóëÔ∏è Removido lock √≥rf√£o (PID: {pid})")
                            except:
                                os.remove(self.lock_file)
                except:
                    pass
            
            # Limpar arquivos WAL/SHM se existirem
            wal_file = f"{self.db_file}-wal"
            shm_file = f"{self.db_file}-shm"
            
            for file_path in [wal_file, shm_file]:
                if os.path.exists(file_path):
                    try:
                        os.remove(file_path)
                        print(f"üóëÔ∏è Removido arquivo: {file_path}")
                    except:
                        pass
            
            print(f"‚úÖ {terminated_count} processos terminados")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao terminar outros processos: {e}")
            return False
    
    def __enter__(self):
        """Context manager para adquirir lock automaticamente"""
        if not self.acquire_lock():
            raise RuntimeError("N√£o foi poss√≠vel adquirir lock do banco de dados")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager para liberar lock automaticamente"""
        self.release_lock()

class UserManagement:
    def __init__(self):
        """Inicializa o gerenciamento de usu√°rios usando banco SQLite"""
        self.load_users()
    
    def load_users(self):
        """Carrega usu√°rios do banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, username, email, password_hash, role, cargo, created_at, updated_at, member_id
                FROM users ORDER BY username
            """)
            users_data = cursor.fetchall()
            conn.close()
            
            # Converter para DataFrame
            if users_data:
                self.users_df = pd.DataFrame(users_data, columns=[
                    'user_id', 'username', 'email', 'password', 'role', 'Cargo', 
                    'created_at', 'last_login', 'member_id'
                ])
            else:
                # Criar DataFrame vazio com estrutura correta
                self.users_df = pd.DataFrame(columns=[
                    'user_id', 'username', 'email', 'password', 'role', 'Cargo', 
                    'created_at', 'last_login', 'member_id'
                ])
            
            print(f"DEBUG: {len(self.users_df)} usu√°rios carregados do SQLite")
            
        except Exception as e:
            print(f"Erro ao carregar usu√°rios do SQLite: {e}")
            # Criar DataFrame vazio em caso de erro
            self.users_df = pd.DataFrame(columns=[
                'user_id', 'username', 'email', 'password', 'role', 'Cargo', 
                'created_at', 'last_login', 'member_id'
            ])
    
    def save_users(self):
        """Salva usu√°rios no banco SQLite"""
        try:
            print("DEBUG: Usu√°rios salvos no SQLite")
        except Exception as e:
            print(f"Erro ao salvar usu√°rios: {e}")
    
    def login(self, username, password):
        """Autentica um usu√°rio usando banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, username, email, password_hash, role, cargo, member_id
                FROM users WHERE username = %s AND password_hash = %s
            """, (username, password))
            
            user_data = cursor.fetchone()
            conn.close()
            
            if user_data:
                user_id, username, email, password_hash, role, cargo, member_id = user_data
                
                user = User(
                    username=username,
                    role=role,
                    cargo=cargo,
                    user_id=user_id
                )
                user.is_authenticated = True
                user.login_time = pd.Timestamp.now()
                user.member_id = member_id
                
                # Atualizar √∫ltimo login no banco
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                cursor.execute("""
                    UPDATE users SET updated_at = %s WHERE id = %s
                """, (datetime.now(), user_id))
                conn.commit()
                conn.close()
                
                return user
            return None
            
        except Exception as e:
            print(f"Erro no login: {e}")
            return None
    
    def register_user(self, username, password, role, cargo):
        """Registra um novo usu√°rio no banco SQLite"""
        try:
            import sqlite3
            from datetime import datetime
            
            # Verificar se o usu√°rio j√° existe
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("SELECT id FROM users WHERE username = %s", (username,))
            if cursor.fetchone():
                conn.close()
                return False, "Usu√°rio j√° existe"
            
            # Validar dados
            if not username or not password:
                return False, "Usu√°rio e senha s√£o obrigat√≥rios"
            
            if len(password) < 6:
                return False, "Senha deve ter pelo menos 6 caracteres"
            
            if role not in ['admin', 'user', 'manager']:
                return False, "Role inv√°lido"
            
            # Inserir novo usu√°rio
            cursor.execute("""
                INSERT INTO users (username, email, password_hash, role, cargo, created_at, updated_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """, (username, '', password, role, cargo, datetime.now(), datetime.now()))
            
            conn.commit()
            conn.close()
            
            # Recarregar usu√°rios
            self.load_users()
            
            return True, "Usu√°rio registrado com sucesso"
            
        except Exception as e:
            print(f"Erro ao registrar usu√°rio: {e}")
            return False, f"Erro ao registrar usu√°rio: {e}"
    
    def update_user(self, user_id, username, password, role, cargo):
        """Atualiza dados de um usu√°rio"""
        user_idx = self.users_df[self.users_df['user_id'] == user_id].index
        if len(user_idx) == 0:
            return False, "Usu√°rio n√£o encontrado"
        
        idx = user_idx[0]
        
        # Verificar se o novo username j√° existe (exceto para o pr√≥prio usu√°rio)
        existing_user = self.users_df[
            (self.users_df['username'] == username) & 
            (self.users_df['user_id'] != user_id)
        ]
        if not existing_user.empty:
            return False, "Username j√° existe"
        
        # Atualizar dados
        self.users_df.loc[idx, 'username'] = username
        if password:  # S√≥ atualizar senha se fornecida
            self.users_df.loc[idx, 'password'] = password
        self.users_df.loc[idx, 'role'] = role
        self.users_df.loc[idx, 'Cargo'] = cargo
        
        self.save_users()
        return True, "Usu√°rio atualizado com sucesso"
    
    def delete_user(self, user_id):
        """Remove um usu√°rio"""
        user_idx = self.users_df[self.users_df['user_id'] == user_id].index
        if len(user_idx) == 0:
            return False, "Usu√°rio n√£o encontrado"
        
        # N√£o permitir deletar o √∫ltimo admin
        user_role = self.users_df.loc[user_idx[0], 'role']
        if user_role == 'admin':
            admin_count = len(self.users_df[self.users_df['role'] == 'admin'])
            if admin_count <= 1:
                return False, "N√£o √© poss√≠vel deletar o √∫ltimo administrador"
        
        self.users_df = self.users_df[self.users_df['user_id'] != user_id]
        self.save_users()
        return True, "Usu√°rio removido com sucesso"
    
    def get_all_users(self):
        """Retorna todos os usu√°rios do banco SQLite"""
        try:
            import sqlite3
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, username, email, role, cargo, created_at, updated_at, member_id
                FROM users ORDER BY username
            """)
            users_data = cursor.fetchall()
            conn.close()
            
            users = []
            for user_data in users_data:
                user_id, username, email, role, cargo, created_at, updated_at, member_id = user_data
                users.append({
                    'user_id': user_id,
                    'username': username,
                    'email': email,
                    'role': role,
                    'cargo': cargo,
                    'created_at': created_at,
                    'last_login': updated_at,
                    'member_id': member_id
                })
            
            return users
            
        except Exception as e:
            print(f"Erro ao buscar usu√°rios: {e}")
            return []
    
    def get_user_by_id(self, user_id):
        """Retorna um usu√°rio espec√≠fico por ID"""
        user_data = self.users_df[self.users_df['user_id'] == user_id]
        if not user_data.empty:
            user_row = user_data.iloc[0]
            return User(
                username=user_row['username'],
                role=user_row['role'],
                cargo=user_row['Cargo'],
                user_id=user_row['user_id']
            )
        return None

class EmailIntegration:
    def __init__(self, app):
        self.app = app
        self.settings = app.settings.get('email_integration', {})
        self.email_thread = None
        self.running = False
        
    def start_email_service(self):
        if not self.settings.get('enabled', False):
            return
            
        self.running = True
        self.email_thread = threading.Thread(target=self._email_loop, daemon=True)
        self.email_thread.start()
    
    def stop_email_service(self):
        self.running = False
        if self.email_thread:
            self.email_thread.join(timeout=1)
    
    def _email_loop(self):
        while self.running:
            try:
                if self.settings.get('auto_notifications', {}).get('deadline_reminder', True):
                    self._check_deadline_reminders()
                
                if self.settings.get('auto_notifications', {}).get('weekly_report', True):
                    self._check_weekly_report()
                
                time.sleep(3600)  # Check every hour
            except Exception as e:
                print(f"Erro no loop de email: {e}")
                time.sleep(300)
    
    def send_email(self, to_email, subject, body, attachments=None):
        try:
            if self.settings.get('demo_mode', False):
                return self._demo_send_email(to_email, subject, body)
            
            provider = self.settings.get('provider', 'gmail')
            
            if provider == 'gmail':
                return self._send_gmail(to_email, subject, body, attachments)
            elif provider == 'outlook':
                return self._send_outlook(to_email, subject, body, attachments)
            else:
                return self._send_smtp(to_email, subject, body, attachments)
                
        except Exception as e:
            print(f"Erro ao enviar email: {e}")
            return False
    
    def _demo_send_email(self, to_email, subject, body):
        """Simula envio de email em modo demo"""
        print(f"DEMO EMAIL - Para: {to_email}")
        print(f"Assunto: {subject}")
        print(f"Corpo: {body}")
        print("--- Email simulado com sucesso ---")
        return True
    
    def _send_gmail(self, to_email, subject, body, attachments=None):
        try:
            email_address = self.settings.get('email_address', '')
            app_password = self.settings.get('app_password', '')
            
            if not email_address or not app_password:
                print("Credenciais de email n√£o configuradas")
                return False
            
            msg = MIMEMultipart()
            msg['From'] = email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            if attachments:
                for attachment in attachments:
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                        msg.attach(part)
            
            server = smtplib.SMTP('smtp.gmail.com', 587)
            server.starttls()
            server.login(email_address, app_password)
            text = msg.as_string()
            server.sendmail(email_address, to_email, text)
            server.quit()
            
            print(f"Email enviado com sucesso para {to_email}")
            return True
            
        except Exception as e:
            print(f"Erro ao enviar email via Gmail: {e}")
            return False
    
    def _send_outlook(self, to_email, subject, body, attachments=None):
        try:
            email_address = self.settings.get('email_address', '')
            email_password = self.settings.get('email_password', '')
            smtp_server = self.settings.get('smtp_server', 'smtp-mail.outlook.com')
            smtp_port = self.settings.get('smtp_port', 587)
            
            if not email_address or not email_password:
                print("Credenciais de email n√£o configuradas")
                return False
            
            msg = MIMEMultipart()
            msg['From'] = email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            if attachments:
                for attachment in attachments:
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                        msg.attach(part)
            
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(email_address, email_password)
            text = msg.as_string()
            server.sendmail(email_address, to_email, text)
            server.quit()
            
            print(f"Email enviado com sucesso para {to_email}")
            return True
            
        except Exception as e:
            print(f"Erro ao enviar email via Outlook: {e}")
            return False
    
    def _send_smtp(self, to_email, subject, body, attachments=None):
        try:
            email_address = self.settings.get('email_address', '')
            email_password = self.settings.get('email_password', '')
            smtp_server = self.settings.get('smtp_server', '')
            smtp_port = self.settings.get('smtp_port', 587)
            
            if not all([email_address, email_password, smtp_server]):
                print("Configura√ß√µes SMTP incompletas")
                return False
            
            msg = MIMEMultipart()
            msg['From'] = email_address
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            if attachments:
                for attachment in attachments:
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                        msg.attach(part)
            
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(email_address, email_password)
            text = msg.as_string()
            server.sendmail(email_address, to_email, text)
            server.quit()
            
            print(f"Email enviado com sucesso para {to_email}")
            return True
            
        except Exception as e:
            print(f"Erro ao enviar email via SMTP: {e}")
            return False
    
    def notify_card_created(self, card_data):
        """Notifica cria√ß√£o de novo cart√£o"""
        try:
            # Verificar se card_data √© um dicion√°rio
            if not isinstance(card_data, dict):
                print(f"DEBUG: card_data n√£o √© um dicion√°rio: {type(card_data)} - {card_data}")
                return
            
            # Verificar se as configura√ß√µes est√£o dispon√≠veis
            if not hasattr(self, 'settings') or not isinstance(self.settings, dict):
                print("DEBUG: settings n√£o dispon√≠vel ou n√£o √© um dicion√°rio")
                return
            
            # Verificar se auto_notifications existe e √© um dicion√°rio
            auto_notifications = self.settings.get('auto_notifications', {})
            if not isinstance(auto_notifications, dict):
                print("DEBUG: auto_notifications n√£o √© um dicion√°rio, usando padr√£o")
                auto_notifications = {}
            
            if not auto_notifications.get('card_created', True):
                return
            
            # Verificar se email_templates existe e √© um dicion√°rio
            email_templates = self.settings.get('email_templates', {})
            if not isinstance(email_templates, dict):
                print("DEBUG: email_templates n√£o √© um dicion√°rio, usando padr√£o")
                email_templates = {}
            
            template = email_templates.get('card_created', 'Novo cart√£o criado: {title}')
            
            # Garantir que todos os campos necess√°rios estejam presentes
            safe_card_data = {
                'title': card_data.get('title', ''),
                'board': card_data.get('board', ''),
                'column': card_data.get('column', ''),
                'created_by': card_data.get('created_by', ''),
                'created_date': card_data.get('created_date', ''),
                'importance': card_data.get('importance', ''),
                'due_date': card_data.get('due_date', '')
            }
            
            try:
                subject = template.format(**safe_card_data)
            except Exception as format_error:
                print(f"Erro ao formatar template: {format_error}")
                subject = f"Novo cart√£o criado: {safe_card_data.get('title', '')}"
            
            body = f"""
Novo cart√£o criado no Boodesk:

T√≠tulo: {safe_card_data.get('title', '')}
Quadro: {safe_card_data.get('board', '')}
Lista: {safe_card_data.get('column', '')}
Criado por: {safe_card_data.get('created_by', '')}
Data de cria√ß√£o: {safe_card_data.get('created_date', '')}
Import√¢ncia: {safe_card_data.get('importance', '')}
Prazo: {safe_card_data.get('due_date', '')}
"""
            
            # Verificar se notification_recipients existe e √© uma lista
            notification_recipients = self.settings.get('notification_recipients', [])
            if not isinstance(notification_recipients, list):
                print("DEBUG: notification_recipients n√£o √© uma lista, usando lista vazia")
                notification_recipients = []
            
            for recipient in notification_recipients:
                if hasattr(self, 'send_email'):
                    self.send_email(recipient, subject, body)
                
        except Exception as e:
            print(f"Erro ao notificar cria√ß√£o de cart√£o: {e}")

    def notify_card_modified(self, card_data, changes):
        """Notifica modifica√ß√£o de cart√£o"""
        try:
            # Verificar se card_data √© um dicion√°rio
            if not isinstance(card_data, dict):
                print(f"DEBUG: card_data n√£o √© um dicion√°rio: {type(card_data)} - {card_data}")
                return
            
            # Verificar se as configura√ß√µes est√£o dispon√≠veis
            if not hasattr(self, 'settings') or not isinstance(self.settings, dict):
                print("DEBUG: settings n√£o dispon√≠vel ou n√£o √© um dicion√°rio")
                return
            
            # Verificar se auto_notifications existe e √© um dicion√°rio
            auto_notifications = self.settings.get('auto_notifications', {})
            if not isinstance(auto_notifications, dict):
                print("DEBUG: auto_notifications n√£o √© um dicion√°rio, usando padr√£o")
                auto_notifications = {}
            
            if not auto_notifications.get('card_modified', True):
                return
            
            # Verificar se email_templates existe e √© um dicion√°rio
            email_templates = self.settings.get('email_templates', {})
            if not isinstance(email_templates, dict):
                print("DEBUG: email_templates n√£o √© um dicion√°rio, usando padr√£o")
                email_templates = {}
            
            template = email_templates.get('card_modified', 'Cart√£o modificado: {title}')
            
            # Garantir que todos os campos necess√°rios estejam presentes
            safe_card_data = {
                'title': card_data.get('title', ''),
                'board': card_data.get('board', ''),
                'column': card_data.get('column', ''),
                'modified_by': card_data.get('modified_by', ''),
                'modified_date': card_data.get('modified_date', '')
            }
            
            try:
                subject = template.format(**safe_card_data)
            except Exception as format_error:
                print(f"Erro ao formatar template: {format_error}")
                subject = f"Cart√£o modificado: {safe_card_data.get('title', '')}"
            
            # Criar lista de mudan√ßas
            changes_text = "\n".join([f"‚Ä¢ {change}" for change in changes]) if isinstance(changes, list) else str(changes)
            
            body = f"""
Cart√£o modificado no Boodesk:

T√≠tulo: {safe_card_data.get('title', '')}
Quadro: {safe_card_data.get('board', '')}
Lista: {safe_card_data.get('column', '')}
Modificado por: {safe_card_data.get('modified_by', '')}
Data de modifica√ß√£o: {safe_card_data.get('modified_date', '')}

Mudan√ßas realizadas:
{changes_text}
"""
            
            # Verificar se notification_recipients existe e √© uma lista
            notification_recipients = self.settings.get('notification_recipients', [])
            if not isinstance(notification_recipients, list):
                print("DEBUG: notification_recipients n√£o √© uma lista, usando lista vazia")
                notification_recipients = []
            
            for recipient in notification_recipients:
                if hasattr(self, 'send_email'):
                    self.send_email(recipient, subject, body)
                
        except Exception as e:
            print(f"Erro ao notificar modifica√ß√£o de cart√£o: {e}")


import requests
import base64
import urllib.parse
import threading
import time
# Importa√ß√µes para Google Calendar e templates de email
import threading
import time
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
import ssl
import pickle
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import webbrowser
from database_postgres import DatabasePostgres as Database
# Sistema de atualiza√ß√µes autom√°ticas
from auto_updater import AutoUpdater, UpdateDialog, check_for_updates_in_background
import threading
import time


# Configura√ß√µes da API Google Calendar
SCOPES = ['https://www.googleapis.com/auth/calendar']
CREDENTIALS_FILE = 'credentials.json'
TOKEN_FILE = 'token.pickle'

class User:
    def __init__(self, username, role, cargo=None, user_id=None):
        self.username = username
        self.role = role
        self.cargo = cargo or "Usu√°rio"
        self.user_id = user_id
        self.is_authenticated = False
        self.login_time = None
        
    def has_permission(self, permission):
        """Verifica se o usu√°rio tem uma determinada permiss√£o"""
        # Verificar se o role √© v√°lido
        if not hasattr(self, 'role') or not self.role:
            print("DEBUG: Usu√°rio sem role, usando role padr√£o 'user'")
            self.role = "user"
        
        # Mapear roles em portugu√™s para ingl√™s
        role_mapping = {
            "Administrador": "admin",
            "admin": "admin",
            "Manager": "manager", 
            "manager": "manager",
            "Usu√°rio": "user",
            "user": "user"
        }
        
        # Normalizar o role
        normalized_role = role_mapping.get(self.role, self.role)
        
        if normalized_role == "admin":
            return True  # Admin tem todas as permiss√µes
        
        # Permiss√µes espec√≠ficas por role
        permissions = {
            "user": [
                "view_boards", "view_cards", "edit_own_cards", 
                "move_cards", "add_comments", "view_reports"
            ],
            "manager": [
                "view_boards", "view_cards", "edit_cards", 
                "move_cards", "add_comments", "view_reports",
                "manage_members", "create_cards", "delete_cards",
                "manage_users"
            ]
        }
        
        return permission in permissions.get(normalized_role, [])
    
    def can_manage_users(self):
        """Verifica se o usu√°rio pode gerenciar outros usu√°rios"""
        if not hasattr(self, 'role') or not self.role:
            return False
        
        # Mapear roles em portugu√™s para ingl√™s
        role_mapping = {
            "Administrador": "admin",
            "admin": "admin",
            "Manager": "manager", 
            "manager": "manager",
            "Usu√°rio": "user",
            "user": "user"
        }
        
        # Normalizar o role
        normalized_role = role_mapping.get(self.role, self.role)
        return normalized_role in ["admin", "manager"]
    
    def can_manage_settings(self):
        """Verifica se o usu√°rio pode gerenciar configura√ß√µes"""
        if not hasattr(self, 'role') or not self.role:
            return False
        return self.role == "admin"
    
    def can_delete_cards(self):
        """Verifica se o usu√°rio pode deletar cart√µes"""
        if not hasattr(self, 'role') or not self.role:
            return False
        return self.role in ["admin", "manager"]
    
    def can_edit_all_cards(self):
        """Verifica se o usu√°rio pode editar todos os cart√µes"""
        if not hasattr(self, 'role') or not self.role:
            return False
        return self.role in ["admin", "manager"]
    
    def __str__(self):
        cargo = getattr(self, 'cargo', 'Usu√°rio')
        return f"{self.username} ({cargo})"

class NotificationManager:
    def __init__(self, app):
        self.app = app
        self.notification_settings = self.load_notification_settings()
        self.notification_thread = None
        self.running = False
        
    def load_notification_settings(self):
        """Carrega configura√ß√µes de notifica√ß√£o"""
        default_settings = {
            'enabled': True,
            'sound_enabled': True,
            'popup_enabled': True,
            'advance_notification_minutes': 15,
            'show_widget': True,
            'widget_position': 'top_right',
            'notification_duration': 10
        }
        
        try:
            if os.path.exists('notification_settings.json'):
                with open('notification_settings.json', 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                    # Mesclar com configura√ß√µes padr√£o
                    for key, value in default_settings.items():
                        if key not in settings:
                            settings[key] = value
                    return settings
            else:
                return default_settings
        except Exception as e:
            print(f"Erro ao carregar configura√ß√µes de notifica√ß√£o: {e}")
            return default_settings
    
    def save_notification_settings(self):
        """Salva configura√ß√µes de notifica√ß√£o"""
        try:
            with open('notification_settings.json', 'w', encoding='utf-8') as f:
                json.dump(self.notification_settings, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"Erro ao salvar configura√ß√µes de notifica√ß√£o: {e}")
    
    def start_notification_monitor(self):
        """Inicia o monitor de notifica√ß√µes"""
        if not self.notification_settings['enabled']:
            return
            
        self.running = True
        self.notification_thread = threading.Thread(target=self._monitor_meetings, daemon=True)
        self.notification_thread.start()
    
    def stop_notification_monitor(self):
        """Para o monitor de notifica√ß√µes"""
        self.running = False
        if self.notification_thread:
            self.notification_thread.join(timeout=1)
    
    def _monitor_meetings(self):
        """Monitora reuni√µes para notifica√ß√µes"""
        while self.running:
            try:
                current_time = datetime.now()
                
                # Verificar reuni√µes pr√≥ximas
                for meeting_id, meeting in self.app.meeting_integration.meeting_data.items():
                    if meeting.get('notified', False):
                        continue
                    
                    # Verificar se date e time n√£o est√£o vazios
                    if not meeting.get('date') or not meeting.get('time'):
                        print(f"Reuni√£o com data/hora vazia ignorada: {meeting}")
                        continue
                    
                    try:
                        meeting_datetime = datetime.strptime(f"{meeting['date']} {meeting['time']}", "%Y-%m-%d %H:%M")
                        time_diff = meeting_datetime - current_time
                    except ValueError as e:
                        print(f"Erro ao fazer parse da data/hora da reuni√£o: {e}")
                        continue
                    
                    # Notificar X minutos antes
                    if 0 <= time_diff.total_seconds() <= self.notification_settings['advance_notification_minutes'] * 60:
                        self._show_meeting_notification(meeting)
                        meeting['notified'] = True
                        self.app.meeting_integration.save_meeting_data()
                
                time.sleep(30)  # Verificar a cada 30 segundos
                
            except Exception as e:
                print(f"Erro no monitor de notifica√ß√µes: {e}")
                time.sleep(60)
    
    def _show_meeting_notification(self, meeting):
        """Mostra notifica√ß√£o de reuni√£o"""
        if self.notification_settings['sound_enabled']:
            self._play_notification_sound()
        
        if self.notification_settings['popup_enabled']:
            self._show_popup_notification(meeting)
    
    def _play_notification_sound(self):
        """Toca som de notifica√ß√£o"""
        try:
            winsound.MessageBeep(winsound.MB_ICONEXCLAMATION)
        except:
            pass  # Ignorar se n√£o conseguir tocar som
    
    def _show_popup_notification(self, meeting):
        """Mostra popup de notifica√ß√£o simples"""
        def show_popup():
            popup = tk.Toplevel()
            popup.title("Reuni√£o")
            popup.geometry("300x120")
            
            # Centralizar na tela
            popup.update_idletasks()
            x = (popup.winfo_screenwidth() // 2) - (300 // 2)
            y = (popup.winfo_screenheight() // 2) - (120 // 2)
            popup.geometry(f"300x120+{x}+{y}")
            
            # Sempre no topo
            popup.attributes('-topmost', True)
            
            # Conte√∫do simples
            title_label = tk.Label(popup, text="Reuni√£o Pr√≥xima", 
                                 font=("Arial", 12, "bold"))
            title_label.pack(pady=5)
            
            meeting_label = tk.Label(popup, text=meeting['title'], 
                                   font=("Arial", 10))
            meeting_label.pack(pady=2)
            
            time_label = tk.Label(popup, text=f"{meeting['time']} - {meeting['platform'].upper()}", 
                                font=("Arial", 9))
            time_label.pack(pady=2)
            
            # Bot√µes simples
            button_frame = tk.Frame(popup)
            button_frame.pack(pady=10)
            
            tk.Button(button_frame, text="Entrar", 
                     command=lambda: [webbrowser.open(meeting['link']), popup.destroy()]).pack(side=tk.LEFT, padx=5)
            
            tk.Button(button_frame, text="Fechar", 
                     command=popup.destroy).pack(side=tk.LEFT, padx=5)
            
            # Auto-fechar ap√≥s X segundos
            popup.after(self.notification_settings['notification_duration'] * 1000, popup.destroy)
        
        # Executar na thread principal
        self.app.root.after(0, show_popup)

class MeetingWidget:
    def __init__(self, app, parent_frame):
        self.app = app
        self.parent_frame = parent_frame
        self.widget_frame = None
        self.create_widget()
    
    def create_widget(self):
        """Cria o widget de reuni√µes discreto no menu principal"""
        if not self.app.notification_manager.notification_settings['show_widget']:
            return
            
        # Criar frame discreto para o widget
        self.widget_frame = ttk.Frame(self.parent_frame)
        self.widget_frame.pack(fill=tk.X, padx=10, pady=2)
        
        # T√≠tulo discreto com √≠cone
        title_frame = ttk.Frame(self.widget_frame)
        title_frame.pack(anchor=tk.W, pady=(0, 2))
        
        if hasattr(self.app, 'icons') and self.app.icons.get('reuniao_icon'):
            title_label = ttk.Label(title_frame, text="Pr√≥xima Reuni√£o:", image=self.app.icons['reuniao_icon'], compound=tk.LEFT, font=("Arial", 9))
        else:
            title_label = ttk.Label(title_frame, text="Pr√≥xima Reuni√£o:", font=("Arial", 9))
        title_label.pack(side=tk.LEFT)
        
        # Lista de reuni√µes
        self.meetings_frame = tk.Frame(self.widget_frame)
        self.meetings_frame.pack(fill=tk.X)
        
        # Atualizar reuni√µes
        self.refresh_meetings()
        
        # Atualizar periodicamente
        self._schedule_refresh()
    
    def refresh_meetings(self):
        """Atualiza a lista de reuni√µes"""
        # Limpar frame
        for widget in self.meetings_frame.winfo_children():
            widget.destroy()
        
        # Buscar reuni√µes pr√≥ximas e em andamento
        current_time = datetime.now()
        upcoming_meetings = []
        ongoing_meetings = []
        
        for meeting_id, meeting in self.app.meeting_integration.meeting_data.items():
            try:
                # Verificar se date e time n√£o est√£o vazios
                date_str = meeting.get('date', '').strip()
                time_str = meeting.get('time', '').strip()
                
                if not date_str or not time_str:
                    print(f"Reuni√£o com data/hora vazia ignorada: {meeting}")
                    continue
                
                meeting_datetime = datetime.strptime(f"{date_str} {time_str}", "%Y-%m-%d %H:%M")
                duration_minutes = int(meeting.get('duration', 60))  # Dura√ß√£o padr√£o 60 min
                end_datetime = meeting_datetime + timedelta(minutes=duration_minutes)
            except (ValueError, KeyError) as e:
                print(f"Erro ao processar reuni√£o: {meeting} - {e}")
                continue
            
            # Verificar se a reuni√£o est√° em andamento
            if meeting_datetime <= current_time <= end_datetime:
                ongoing_meetings.append((meeting_datetime, meeting, end_datetime))
            # Verificar se a reuni√£o est√° pr√≥xima (pr√≥ximas 24 horas)
            elif 0 <= (meeting_datetime - current_time).total_seconds() <= 24 * 60 * 60:
                upcoming_meetings.append((meeting_datetime, meeting))
        
        # Ordenar por data/hora (primeiro elemento da tupla √© o datetime)
        ongoing_meetings.sort(key=lambda x: x[0])
        upcoming_meetings.sort(key=lambda x: x[0])
        
        # Mostrar reuni√£o em andamento primeiro, depois a pr√≥xima
        if ongoing_meetings:
            meeting_datetime, meeting, end_datetime = ongoing_meetings[0]
            self._display_meeting(meeting, meeting_datetime, is_ongoing=True, end_datetime=end_datetime)
        elif upcoming_meetings:
            meeting_datetime, meeting = upcoming_meetings[0]
            self._display_meeting(meeting, meeting_datetime, is_ongoing=False)
        else:
            # Se n√£o h√° reuni√µes, mostrar mensagem discreta
            no_meetings_label = ttk.Label(self.meetings_frame, text="Nenhuma reuni√£o nas pr√≥ximas 24h", 
                                        font=("Arial", 8), 
                                        foreground='#7f8c8d')
            no_meetings_label.pack(pady=2)
    
    def _display_meeting(self, meeting, meeting_datetime, is_ongoing=False, end_datetime=None):
        """Exibe uma reuni√£o no widget"""
        current_time = datetime.now()
        
        # Frame principal da reuni√£o
        meeting_frame = tk.Frame(self.meetings_frame, relief=tk.SUNKEN, bd=1)
        meeting_frame.pack(fill=tk.X, pady=1)
        
        if is_ongoing:
            # Reuni√£o em andamento
            time_remaining = end_datetime - current_time
            minutes_remaining = int(time_remaining.total_seconds() // 60)
            time_text = f"EM ANDAMENTO ({minutes_remaining}m restantes)"
            time_color = '#e74c3c'  # Vermelho para reuni√£o em andamento
        else:
            # Reuni√£o pr√≥xima
            time_diff = meeting_datetime - current_time
            hours = int(time_diff.total_seconds() // 3600)
            minutes = int((time_diff.total_seconds() % 3600) // 60)
            
            if hours > 0:
                time_text = f"em {hours}h {minutes}m"
            else:
                time_text = f"em {minutes}m"
            time_color = '#e67e22'  # Laranja para reuni√£o pr√≥xima
        
        # Frame para informa√ß√µes da reuni√£o
        info_frame = tk.Frame(meeting_frame)
        info_frame.pack(fill=tk.X, padx=5, pady=3)
        
        # T√≠tulo da reuni√£o (clic√°vel)
        title_label = tk.Label(info_frame, text=meeting['title'][:30] + "..." if len(meeting['title']) > 30 else meeting['title'], 
                             font=("Arial", 9), 
                             fg='#2c3e50', cursor="hand2")
        title_label.pack(side=tk.LEFT, anchor=tk.W)
        
        # Bind duplo clique para abrir link
        title_label.bind("<Double-1>", lambda e, m=meeting: webbrowser.open(m['link']))
        
        # Tempo restante
        time_label = tk.Label(info_frame, text=time_text, 
                            font=("Arial", 8), 
                            fg=time_color)
        time_label.pack(side=tk.LEFT, padx=(10, 0))
        
        # Hora e plataforma
        time_info = tk.Label(info_frame, text=f"{meeting['time']} - {meeting['platform'].upper()}", 
                           font=("Arial", 8), 
                           fg='#7f8c8d')
        time_info.pack(side=tk.LEFT, padx=(10, 0))
        
        # Bot√£o discreto para copiar link
        copy_button = tk.Button(info_frame, 
                              image=self.app.icons.get('copy_icon'),
                              relief=tk.FLAT, 
                              bd=0,
                              command=lambda m=meeting: self.copy_meeting_link(m))
        copy_button.pack(side=tk.RIGHT, padx=(5, 0))
        
        # Tooltip para o bot√£o
        copy_button.bind("<Enter>", lambda e, btn=copy_button: btn.config(bg='#e0e0e0'))
        copy_button.bind("<Leave>", lambda e, btn=copy_button: btn.config(bg='SystemButtonFace'))
    
    def copy_meeting_link(self, meeting):
        """Copia o link da reuni√£o para a √°rea de transfer√™ncia"""
        try:
            self.app.root.clipboard_clear()
            self.app.root.clipboard_append(meeting['link'])
            # Mostrar feedback discreto
            messagebox.showinfo("Link Copiado", f"Link da reuni√£o '{meeting['title']}' copiado para a √°rea de transfer√™ncia!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao copiar link: {e}")
    
    def _schedule_refresh(self):
        """Agenda atualiza√ß√£o autom√°tica"""
        self.refresh_meetings()
        self.widget_frame.after(60000, self._schedule_refresh)  # Atualizar a cada minuto
    
    def open_notification_settings(self):
        """Abre configura√ß√µes de notifica√ß√£o"""
        NotificationSettingsWindow(self.app)

class NotificationSettingsWindow:
    def __init__(self, app):
        self.app = app
        self.window = tk.Toplevel(app.root)
        self.window.title("Configura√ß√µes de Notifica√ß√£o")
        self.window.geometry("500x400")
        self.window.transient(app.root)
        self.window.grab_set()
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
    
    def create_widgets(self):
        """Cria widgets da janela de configura√ß√µes"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_label = ttk.Label(main_frame, text="Configura√ß√µes de Notifica√ß√£o", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Configura√ß√µes
        settings_frame = ttk.LabelFrame(main_frame, text="Notifica√ß√µes", padding="10")
        settings_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Habilitar notifica√ß√µes
        self.enabled_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['enabled'])
        ttk.Checkbutton(settings_frame, text="Habilitar notifica√ß√µes", 
                       variable=self.enabled_var).pack(anchor=tk.W, pady=2)
        
        # Som
        self.sound_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['sound_enabled'])
        ttk.Checkbutton(settings_frame, text="Tocar som", 
                       variable=self.sound_var).pack(anchor=tk.W, pady=2)
        
        # Popup
        self.popup_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['popup_enabled'])
        ttk.Checkbutton(settings_frame, text="Mostrar popup", 
                       variable=self.popup_var).pack(anchor=tk.W, pady=2)
        
        # Widget
        self.widget_var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['show_widget'])
        ttk.Checkbutton(settings_frame, text="Mostrar widget na tela", 
                       variable=self.widget_var).pack(anchor=tk.W, pady=2)
        
        # Configura√ß√µes avan√ßadas
        advanced_frame = ttk.LabelFrame(main_frame, text="Configura√ß√µes Avan√ßadas", padding="10")
        advanced_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Anteced√™ncia da notifica√ß√£o
        ttk.Label(advanced_frame, text="Notificar (minutos antes):").pack(anchor=tk.W, pady=2)
        self.advance_var = tk.StringVar(value=str(self.app.notification_manager.notification_settings['advance_notification_minutes']))
        advance_entry = ttk.Entry(advanced_frame, textvariable=self.advance_var, width=10)
        advance_entry.pack(anchor=tk.W, pady=2)
        
        # Dura√ß√£o da notifica√ß√£o
        ttk.Label(advanced_frame, text="Dura√ß√£o do popup (segundos):").pack(anchor=tk.W, pady=2)
        self.duration_var = tk.StringVar(value=str(self.app.notification_manager.notification_settings['notification_duration']))
        duration_entry = ttk.Entry(advanced_frame, textvariable=self.duration_var, width=10)
        duration_entry.pack(anchor=tk.W, pady=2)
        
        # Posi√ß√£o do widget
        ttk.Label(advanced_frame, text="Posi√ß√£o do widget:").pack(anchor=tk.W, pady=2)
        self.position_var = tk.StringVar(value=self.app.notification_manager.notification_settings['widget_position'])
        position_combo = ttk.Combobox(advanced_frame, textvariable=self.position_var, 
                                     values=['top_right', 'top_left', 'bottom_right', 'bottom_left'], 
                                     state="readonly", width=15)
        position_combo.pack(anchor=tk.W, pady=2)
        
        # Bot√µes
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=20)
        
        ttk.Button(button_frame, text="Salvar", 
                  command=self.save_settings).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Testar Notifica√ß√£o", 
                  command=self.test_notification).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancelar", 
                  command=self.window.destroy).pack(side=tk.RIGHT, padx=5)
    
    def save_settings(self):
        """Salva as configura√ß√µes"""
        try:
            self.app.notification_manager.notification_settings.update({
                'enabled': self.enabled_var.get(),
                'sound_enabled': self.sound_var.get(),
                'popup_enabled': self.popup_var.get(),
                'show_widget': self.widget_var.get(),
                'advance_notification_minutes': int(self.advance_var.get()),
                'notification_duration': int(self.duration_var.get()),
                'widget_position': self.position_var.get()
            })
            
            self.app.notification_manager.save_notification_settings()
            
            # Reiniciar monitor se necess√°rio
            if self.app.notification_manager.notification_settings['enabled']:
                self.app.notification_manager.stop_notification_monitor()
                self.app.notification_manager.start_notification_monitor()
            
            messagebox.showinfo("Sucesso", "Configura√ß√µes salvas com sucesso!")
            self.window.destroy()
            
        except ValueError:
            messagebox.showerror("Erro", "Por favor, insira valores num√©ricos v√°lidos.")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar configura√ß√µes: {e}")
    
    def test_notification(self):
        """Testa a notifica√ß√£o"""
        test_meeting = {
            'title': 'Reuni√£o de Teste',
            'date': datetime.now().strftime('%Y-%m-%d'),
            'time': datetime.now().strftime('%H:%M'),
            'platform': 'test',
            'link': '#'
        }
        
        self.app.notification_manager._show_meeting_notification(test_meeting)

class GoogleCalendarManager:
    def __init__(self):
        self.service = None
        self.credentials = None
        
    def authenticate(self):
        """Autentica com a API do Google Calendar"""
        try:
            # Verificar se j√° temos credenciais salvas
            if os.path.exists(TOKEN_FILE):
                with open(TOKEN_FILE, 'rb') as token:
                    self.credentials = pickle.load(token)
            
            # Se n√£o h√° credenciais v√°lidas, fazer login
            if not self.credentials or not self.credentials.valid:
                if self.credentials and self.credentials.expired and self.credentials.refresh_token:
                    self.credentials.refresh(Request())
                else:
                    if not os.path.exists(CREDENTIALS_FILE):
                        messagebox.showerror("Erro", 
                                           "Arquivo credentials.json n√£o encontrado!\n\n"
                                           "Para usar o Google Meet:\n"
                                           "1. Acesse https://console.cloud.google.com\n"
                                           "2. Crie um projeto e ative a Google Calendar API\n"
                                           "3. Crie credenciais OAuth 2.0\n"
                                           "4. Baixe o arquivo como 'credentials.json'\n"
                                           "5. Coloque na pasta do aplicativo")
                        return False
                    
                    flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_FILE, SCOPES)
                    self.credentials = flow.run_local_server(port=0)
                
                # Salvar credenciais para uso futuro
                with open(TOKEN_FILE, 'wb') as token:
                    pickle.dump(self.credentials, token)
            
            # Construir o servi√ßo
            self.service = build('calendar', 'v3', credentials=self.credentials)
            return True
            
        except Exception as e:
            messagebox.showerror("Erro de Autentica√ß√£o", f"Erro ao autenticar com Google Calendar:\n{str(e)}")
            return False
    
    def create_meeting(self, title, date, time_str, duration=60, description="", timezone="America/Sao_Paulo"):
        """Cria uma reuni√£o real no Google Calendar com Google Meet"""
        try:
            if not self.service:
                if not self.authenticate():
                    return None
            
            # Converter data e hora para datetime
            datetime_str = f"{date} {time_str}"
            start_time = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M")
            end_time = start_time + timedelta(minutes=duration)
            
            # Formatar para RFC3339 com fuso hor√°rio (sem 'Z' no final)
            start_rfc = start_time.isoformat()
            end_rfc = end_time.isoformat()
            
            # Criar evento no Google Calendar
            event = {
                'summary': title,
                'description': description,
                'start': {
                    'dateTime': start_rfc,
                    'timeZone': timezone,
                },
                'end': {
                    'dateTime': end_rfc,
                    'timeZone': timezone,
                },
                'conferenceData': {
                    'createRequest': {
                        'requestId': f"meet_{int(time.time())}",
                        'conferenceSolutionKey': {
                            'type': 'hangoutsMeet'
                        }
                    }
                }
            }
            
            # Inserir evento
            event = self.service.events().insert(
                calendarId='primary',
                body=event,
                conferenceDataVersion=1
            ).execute()
            
            # Extrair link do Google Meet
            meet_link = event.get('conferenceData', {}).get('entryPoints', [{}])[0].get('uri', '')
            
            return {
                'id': event['id'],
                'title': title,
                'date': date,
                'time': time_str,
                'duration': duration,
                'link': meet_link,
                'platform': 'google_meet',
                'created_by': 'Sistema',
                'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'status': 'scheduled',
                'google_event_id': event['id']
            }
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao criar reuni√£o no Google Meet:\n{str(e)}")
            return None
    
    def cancel_meeting(self, event_id):
        """Cancela uma reuni√£o no Google Calendar"""
        try:
            if not self.service:
                if not self.authenticate():
                    return False
            
            # Deletar evento do Google Calendar
            self.service.events().delete(
                calendarId='primary',
                eventId=event_id
            ).execute()
            
            print(f"‚úÖ Reuni√£o cancelada no Google Calendar: {event_id}")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao cancelar reuni√£o no Google Calendar: {e}")
            return False

# New function to load all icons
def load_app_icons(base_dir):
    print("DEBUG: Iniciando load_app_icons")
    icons = {}
    # Helper function to load images safely within this scope
    def _load_image(filename, size):
        try:
            path = os.path.join(base_dir, filename)
            img = Image.open(path)
            return ImageTk.PhotoImage(img.resize(size))
        except FileNotFoundError:
            print(f"Erro: Arquivo de imagem n√£o encontrado: {filename}")
            return None # Return None or a placeholder image
        except Exception as e:
            print(f"Erro ao carregar imagem {filename}: {e}")
            return None

    small_icon_size = (16, 16)
    large_icon_size = (32, 32)

    # Load small icons (16x16) for menus and compact areas
    icons['logo_icon'] = _load_image("LOGO.png", (32, 32)) # Keep logo larger
    icons['add_icon'] = _load_image("Add.png", small_icon_size)
    icons['delete_icon'] = _load_image("Delete.png", small_icon_size)
    icons['save_icon'] = _load_image("Save.png", small_icon_size)
    icons['search_icon'] = _load_image("Search.png", small_icon_size)
    icons['key_icon'] = _load_image("Key.png", small_icon_size)
    icons['cancel_icon'] = _load_image("Cancel.png", small_icon_size)
    icons['up_icon'] = _load_image("Up.png", small_icon_size)
    icons['down_icon'] = _load_image("Down.png", small_icon_size)
    icons['back_icon'] = _load_image("Back.png", small_icon_size)
    icons['left_icon'] = _load_image("Left.png", small_icon_size)
    icons['right_icon'] = _load_image("Right.png", small_icon_size)
    icons['forward_icon'] = _load_image("Forward.png", small_icon_size)
    icons['ok_icon'] = _load_image("Ok.png", small_icon_size)
    icons['settings_icon'] = _load_image("Settings.png", small_icon_size)
    icons['exit_icon'] = _load_image("Exit.png", small_icon_size)
    icons['folder_icon'] = _load_image("Folder.png", small_icon_size)
    icons['pencil_icon'] = _load_image("Pencil.png", small_icon_size)
    icons['clear_icon'] = _load_image("Clear.png", small_icon_size)
    icons['apply_icon'] = _load_image("Apply.png", small_icon_size)
    icons['add_folder_icon'] = _load_image("Add folder.png", small_icon_size)
    icons['info_icon'] = _load_image("Info.png", small_icon_size)
    icons['play_icon'] = _load_image("Play.png", small_icon_size)
    icons['stop_icon'] = _load_image("Stop.png", small_icon_size)
    icons['refresh_icon'] = _load_image("Refresh.png", small_icon_size)
    icons['time_icon'] = _load_image("Time.png", small_icon_size)
    icons['import_icon'] = _load_image("Import.png", small_icon_size)
    icons['export_icon'] = _load_image("Export.png", small_icon_size)
    icons['registration_icon'] = _load_image("Registration.png", small_icon_size)
    icons['chart_xy_icon'] = _load_image("Chart xy.png", small_icon_size)
    icons['pie_chart_icon'] = _load_image("Pie chart.png", small_icon_size)
    icons['bar_chart_icon'] = _load_image("3d bar chart.png", small_icon_size)
    icons['objects_icon'] = _load_image("Objects.png", small_icon_size)
    icons['coffee_icon'] = _load_image("Coffee.png", small_icon_size)
    icons['card_icon'] = _load_image("card.png", small_icon_size)  # √çcone para cart√µes
    icons['chat_icon'] = _load_image("chat.png", small_icon_size)  # √çcone para chat
    icons['calendar_icon'] = _load_image("Calendar.png", small_icon_size)  # √çcone espec√≠fico para calend√°rio
    icons['copy_icon'] = _load_image("Apply.png", small_icon_size)  # Usar Apply como copy
    icons['meet_icon'] = _load_image("Play.png", small_icon_size)  # Usar Play como meet
    icons['home_icon'] = _load_image("Home.png", small_icon_size)  # √çcone para Menu Principal
    icons['money_icon'] = _load_image("Money.png", small_icon_size)  # √çcone para Finan√ßas
    icons['gantt_icon'] = _load_image("Chart xy.png", small_icon_size)  # √çcone para Gr√°fico de Gantt
    icons['dashboard_icon'] = _load_image("Bar chart.png", small_icon_size)  # √çcone para Dashboard
    icons['reuniao_icon'] = _load_image("reuniao.png", small_icon_size)  # √çcone para reuni√µes
    icons['pomodoro_icon'] = _load_image("pomodoro.png", small_icon_size)  # √çcone para Pomodoro
    icons['minhas_atividades_icon'] = _load_image("minhasatividadess.png", small_icon_size)  # √çcone para Minhas Atividades

    # Load large icons (32x32) for main action buttons
    icons['forward_icon_32'] = _load_image("Forward.png", large_icon_size)
    icons['open_file_icon_32'] = _load_image("Open file.png", large_icon_size)
    icons['refresh_icon_32'] = _load_image("Refresh.png", large_icon_size)
    icons['save_icon_32'] = _load_image("Save.png", large_icon_size)
    icons['cancel_icon_32'] = _load_image("Cancel.png", large_icon_size)
    
    # Dashboard icons (32x32)
    icons['chart_icon_32'] = _load_image("Chart xy.png", large_icon_size)
    icons['team_icon_32'] = _load_image("Objects.png", large_icon_size)
    icons['clock_icon_32'] = _load_image("Time.png", large_icon_size)
    icons['burndown_icon_32'] = _load_image("Bar chart.png", large_icon_size)
    icons['ai_icon_32'] = _load_image("Info.png", large_icon_size)
    icons['meeting_icon_32'] = _load_image("reuniao.png", large_icon_size)
    icons['export_icon_32'] = _load_image("Export.png", large_icon_size)
    icons['chart_xy_icon_32'] = _load_image("Chart xy.png", large_icon_size)
    
    # Load check status icons (32x32)
    icons['check_white_icon_32'] = _load_image("checkembranco.png", large_icon_size)
    icons['check_completed_icon_32'] = _load_image("concluido.png", large_icon_size)

    return icons

# --- Helper Classes ---

class LoginWindow(tk.Toplevel):
    def __init__(self, parent, db, icons):
        super().__init__(parent)
        self.parent = parent
        self.db = db
        self.icons = icons
        
        print("DEBUG: LoginWindow.__init__ iniciado")
        
        self.title("Login - Sistema Boodesk")
        self.geometry("400x300")
        self.resizable(False, False)
        self.transient(parent)
        self.grab_set()
        self.protocol("WM_DELETE_WINDOW", self.cancel_login)

        # Centralizar a janela
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 400
        window_height = 300
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

        print("DEBUG: LoginWindow criando widgets...")
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        
        # Focar no campo de usu√°rio
        self.user_entry.focus()
        
        # Garantir que a janela seja vis√≠vel
        self.after(100, self.ensure_visibility)
        print("DEBUG: LoginWindow criada com sucesso")

    def create_widgets(self):
        # Aumentar o tamanho da janela para acomodar todos os elementos
        self.geometry("500x500")
        
        main_frame = ttk.Frame(self, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configurar grid
        main_frame.columnconfigure(1, weight=1)
        
        # Logo e t√≠tulo
        logo_frame = ttk.Frame(main_frame)
        logo_frame.grid(row=0, column=0, columnspan=2, pady=(0, 20))
        
        if self.icons.get('logo_icon'):
            logo_label = ttk.Label(logo_frame, image=self.icons['logo_icon'])
            logo_label.pack(side=tk.LEFT, padx=(0, 10))
        
        title_label = ttk.Label(logo_frame, text="Sistema Boodesk", font=("Arial", 16, "bold"))
        title_label.pack(side=tk.LEFT)
        
        # Subt√≠tulo
        subtitle_label = ttk.Label(main_frame, text="Fa√ßa login para continuar", font=("Arial", 10))
        subtitle_label.grid(row=1, column=0, columnspan=2, pady=(0, 20))
        
        # Campo de usu√°rio com √≠cone
        user_frame = ttk.Frame(main_frame)
        user_frame.grid(row=2, column=0, columnspan=2, sticky="ew", pady=5)
        user_frame.columnconfigure(1, weight=1)
        
        ttk.Label(user_frame, text="üë§ Usu√°rio:", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="w")
        self.user_entry = ttk.Entry(user_frame, font=("Arial", 11), width=25)
        self.user_entry.grid(row=0, column=1, sticky="ew", padx=(10, 0))
        self.user_entry.insert(0, "admin")  # Preencher com admin por padr√£o
        self.user_entry.bind("<Return>", lambda e: self.password_entry.focus())
        self.user_entry.bind("<Tab>", lambda e: self.password_entry.focus())
        
        # Campo de senha com √≠cone
        password_frame = ttk.Frame(main_frame)
        password_frame.grid(row=3, column=0, columnspan=2, sticky="ew", pady=5)
        password_frame.columnconfigure(1, weight=1)
        
        ttk.Label(password_frame, text="üîí Senha:", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="w")
        self.password_entry = ttk.Entry(password_frame, show="*", font=("Arial", 11), width=25)
        self.password_entry.grid(row=0, column=1, sticky="ew", padx=(10, 0))
        self.password_entry.bind("<Return>", lambda e: self.check_login())
        self.password_entry.bind("<Tab>", lambda e: self.user_entry.focus())
        
        # Frame dos bot√µes - Melhorado para garantir visibilidade
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=4, column=0, columnspan=2, pady=20, sticky="ew")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        
        # Bot√£o de login com √≠cone
        login_btn = ttk.Button(button_frame, text="üîê Entrar", 
                              command=self.check_login, style="Accent.TButton")
        login_btn.grid(row=0, column=0, padx=5, sticky="ew")
        
        # Bot√£o de cadastro com √≠cone
        register_btn = ttk.Button(button_frame, text="üìù Cadastrar", 
                                 command=self.open_user_registration)
        register_btn.grid(row=0, column=1, padx=5, sticky="ew")
        
        # Bot√£o sair com √≠cone (vis√≠vel)
        exit_btn = ttk.Button(button_frame, text="üö™ Sair", 
                             command=self.cancel_login)
        exit_btn.grid(row=0, column=2, padx=5, sticky="ew")
        
        # Informa√ß√µes de usu√°rios padr√£o
        info_frame = ttk.LabelFrame(main_frame, text="üë• Usu√°rios Padr√£o", padding="10")
        info_frame.grid(row=5, column=0, columnspan=2, pady=(10, 0), sticky="ew")
        
        info_text = """Usu√°rios padr√£o do sistema:
‚Ä¢ admin / admin123 (Administrador)
‚Ä¢ user / user123 (Usu√°rio)
‚Ä¢ manager / manager123 (Gerente)"""
        
        info_label = ttk.Label(info_frame, text=info_text, font=("Arial", 9), justify=tk.LEFT)
        info_label.pack()
        
        # Centralizar a janela novamente ap√≥s ajustar o tamanho
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 500
        window_height = 500
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

    def check_login(self):
        username = self.user_entry.get().strip()
        password = self.password_entry.get()
        
        if not username or not password:
            messagebox.showerror("Erro", "Por favor, preencha todos os campos!")
            return
        
        user_data = self.db.get_user_by_username(username)
        
        if user_data and user_data['password_hash'] == password:
            user = User(
                username=user_data['username'],
                role=user_data['role'],
                cargo=user_data['cargo'],
                user_id=user_data['id']
            )
            user.is_authenticated = True
            user.login_time = datetime.now()
            
            self.parent.login_successful = True
            self.parent.current_user = user
            messagebox.showinfo("Login Bem-sucedido", f"Bem-vindo, {user.username}!\nN√≠vel de acesso: {user.cargo}")
            self.destroy()
        else:
            messagebox.showerror("Erro de Login", "Usu√°rio ou senha incorretos!")
            self.password_entry.delete(0, tk.END)
            self.password_entry.focus()

    def open_user_registration(self):
        """Abre a janela de cadastro de usu√°rios"""
        UserRegistrationWindow(self, self.db, self.icons)

    def ensure_visibility(self):
        """Garante que a janela seja vis√≠vel"""
        print("DEBUG: ensure_visibility chamado")
        self.lift()
        self.focus_force()
        self.deiconify()
        self.update()
        print("DEBUG: Janela de login deve estar vis√≠vel agora")
        
    def on_user_keypress(self, event):
        """Trata teclas no campo usu√°rio"""
        if event.keysym == 'Return':
            print("DEBUG: Enter pressionado no campo usu√°rio")
            self.password_entry.focus()
            return "break"
        elif event.keysym == 'Tab':
            # Permitir navega√ß√£o com Tab
            return None
    
    def on_password_keypress(self, event):
        """Trata teclas no campo senha"""
        if event.keysym == 'Return':
            print("DEBUG: Enter pressionado no campo senha")
            self.check_login()
            return "break"
        elif event.keysym == 'Tab':
            # Permitir navega√ß√£o com Tab
            return None
            return "break"
        elif event.keysym == 'Tab':
            # Permitir navega√ß√£o com Tab
            return None
    
    def cancel_login(self):
        self.parent.login_successful = False
        self.destroy()

class UserRegistrationWindow(tk.Toplevel):
    def __init__(self, parent, db, icons, app=None, preselected_member_id=None):
        try:
            super().__init__(parent)
            self.parent = parent
            self.db = db
            self.icons = icons
            self.app = app
            self.preselected_member_id = preselected_member_id
            
            print("DEBUG: Inicializando UserRegistrationWindow...")
            
            self.title("Cadastro de Usu√°rios")
            self.geometry("700x500")
            self.resizable(True, True)
            self.transient(parent)
            self.grab_set()
            
            # Centralizar a janela
            self.update_idletasks()
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()
            window_width = 700
            window_height = 500
            x = (screen_width - window_width) // 2
            y = (screen_height - window_height) // 2
            self.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            # Vari√°veis para edi√ß√£o
            self.edit_mode = False
            self.selected_user_id = None
            
            print("DEBUG: Criando widgets...")
            try:
                if hasattr(self, 'create_widgets'):
                    self.create_widgets()
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
            
            print("DEBUG: Populando lista de usu√°rios...")
            self.populate_users_list()
            
            print("DEBUG: UserRegistrationWindow inicializada com sucesso!")
            
        except Exception as e:
            print(f"DEBUG: Erro ao inicializar UserRegistrationWindow: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir a tela de gerenciar usu√°rios: {e}")
            self.destroy()
    
    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configurar grid
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # T√≠tulo
        title_label = ttk.Label(main_frame, text="Gerenciamento de Usu√°rios", font=("Arial", 14, "bold"))
        title_label.grid(row=0, column=0, pady=(0, 10))
        
        # Frame da lista de usu√°rios
        list_frame = ttk.LabelFrame(main_frame, text="Lista de Usu√°rios", padding="5")
        list_frame.grid(row=1, column=0, sticky="nsew", pady=(0, 10))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        # Treeview para lista de usu√°rios
        columns = ("ID", "Usu√°rio", "Cargo", "Role", "Criado em", "√öltimo Login")
        self.users_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=8)
        
        # Configurar colunas
        self.users_tree.heading("ID", text="ID")
        self.users_tree.heading("Usu√°rio", text="Usu√°rio")
        self.users_tree.heading("Cargo", text="Cargo")
        self.users_tree.heading("Role", text="N√≠vel de Acesso")
        self.users_tree.heading("Criado em", text="Criado em")
        self.users_tree.heading("√öltimo Login", text="√öltimo Login")
        
        self.users_tree.column("ID", width=50, anchor="center")
        self.users_tree.column("Usu√°rio", width=120, anchor="w")
        self.users_tree.column("Cargo", width=100, anchor="w")
        self.users_tree.column("Role", width=100, anchor="w")
        self.users_tree.column("Criado em", width=120, anchor="w")
        self.users_tree.column("√öltimo Login", width=120, anchor="w")
        
        self.users_tree.grid(row=0, column=0, sticky="nsew", pady=5)
        self.users_tree.bind("<<TreeviewSelect>>", self.on_user_select)
        
        # Scrollbar para a lista
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.users_tree.yview)
        scrollbar.grid(row=0, column=1, sticky="ns")
        self.users_tree.config(yscrollcommand=scrollbar.set)
        
        # Frame do formul√°rio
        form_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Usu√°rio", padding="10")
        form_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        form_frame.columnconfigure(1, weight=1)
        
        # Campos do formul√°rio
        ttk.Label(form_frame, text="Usu√°rio:").grid(row=0, column=0, sticky="w", pady=2)
        self.username_entry = ttk.Entry(form_frame)
        self.username_entry.grid(row=0, column=1, sticky="ew", padx=(5, 0), pady=2)
        
        ttk.Label(form_frame, text="Senha:").grid(row=1, column=0, sticky="w", pady=2)
        self.password_entry = ttk.Entry(form_frame, show="*")
        self.password_entry.grid(row=1, column=1, sticky="ew", padx=(5, 0), pady=2)
        
        ttk.Label(form_frame, text="Cargo:").grid(row=2, column=0, sticky="w", pady=2)
        self.cargo_combo = ttk.Combobox(form_frame, state="readonly")
        try:
            if self.app and hasattr(self.app, 'settings') and 'roles' in self.app.settings:
                self.cargo_combo['values'] = list(self.app.settings['roles'].keys())
        except Exception:
            pass
        if not self.cargo_combo['values']:
            self.cargo_combo['values'] = ["Usu√°rio", "Administrador", "Manager"]
        self.cargo_combo.set(self.cargo_combo['values'][0])
        self.cargo_combo.grid(row=2, column=1, sticky="ew", padx=(5, 0), pady=2)
        cargo_btn = ttk.Button(form_frame, text="Cadastrar Cargo", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self._open_roles_settings_from_users)
        cargo_btn.grid(row=2, column=2, padx=5, pady=2, sticky="w")
        
        ttk.Label(form_frame, text="N√≠vel de Acesso:").grid(row=3, column=0, sticky="w", pady=2)
        self.role_combo = ttk.Combobox(form_frame, values=["user", "manager", "admin"], state="readonly")
        self.role_combo.set("user")
        self.role_combo.grid(row=3, column=1, sticky="ew", padx=(5, 0), pady=2)
        
        ttk.Label(form_frame, text="Membro:").grid(row=4, column=0, sticky="w", pady=2)
        self.member_combo = ttk.Combobox(form_frame, state="readonly")
        self.member_combo.grid(row=4, column=1, sticky="ew", padx=(5, 0), pady=2)
        member_btn = ttk.Button(form_frame, text="Cadastrar Membro", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self._open_members_window_from_users)
        member_btn.grid(row=4, column=2, padx=5, pady=2, sticky="w")
        self.populate_members_combo()
        
        # Frame dos bot√µes do formul√°rio
        form_buttons_frame = ttk.Frame(form_frame)
        form_buttons_frame.grid(row=5, column=0, columnspan=2, pady=10)
        form_buttons_frame.columnconfigure(0, weight=1)
        form_buttons_frame.columnconfigure(1, weight=1)
        
        ttk.Button(form_buttons_frame, text="Adicionar Usu√°rio", 
                  image=self.icons.get('add_icon'), compound=tk.LEFT, 
                  command=self.add_user).grid(row=0, column=0, padx=2)
        
        ttk.Button(form_buttons_frame, text="Limpar", 
                  image=self.icons.get('clear_icon'), compound=tk.LEFT, 
                  command=self.clear_form).grid(row=0, column=1, padx=2)
        
        # Frame dos bot√µes de a√ß√£o
        action_frame = ttk.Frame(main_frame)
        action_frame.grid(row=3, column=0, pady=5)
        
        ttk.Button(action_frame, text="Editar Usu√°rio", 
                  image=self.icons.get('edit_icon'), compound=tk.LEFT, 
                  command=self.edit_user).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(action_frame, text="Remover Usu√°rio", 
                  image=self.icons.get('delete_icon'), compound=tk.LEFT, 
                  command=self.remove_user).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(action_frame, text="Atualizar Lista", 
                  image=self.icons.get('refresh_icon'), compound=tk.LEFT, 
                  command=self.populate_users_list).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(action_frame, text="Fechar", 
                  image=self.icons.get('cancel_icon'), compound=tk.LEFT, 
                  command=self.destroy).pack(side=tk.LEFT, padx=5)
    
    def populate_members_combo(self):
        """Popula o combo de membros"""
        try:
            import sqlite3
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("SELECT id, membro, email FROM members ORDER BY membro")
            members = cursor.fetchall()
            conn.close()
            
            # Criar lista de membros para o combo
            member_list = []
            self.member_dict = {}  # Dicion√°rio para mapear nome -> id
            
            for member_id, name, email in members:
                # Tratar email nulo ou vazio
                if email is None or email == '' or email == 'nan':
                    display_name = f"{name} (sem email)"
                else:
                    display_name = f"{name} ({email})"
                
                member_list.append(display_name)
                self.member_dict[display_name] = member_id
            
            self.member_combo['values'] = member_list
            if member_list:
                if self.preselected_member_id and self.preselected_member_id in self.member_dict.values():
                    for display_name, mid in self.member_dict.items():
                        if mid == self.preselected_member_id:
                            self.member_combo.set(display_name)
                            break
                else:
                    self.member_combo.set(member_list[0])
            
        except Exception as e:
            print(f"DEBUG: Erro ao popular combo de membros: {e}")

    def _open_roles_settings_from_users(self):
        """Abre a aba de cargos das configura√ß√µes a partir da tela de usu√°rios"""
        try:
            if not self.app:
                messagebox.showerror("Erro", "Aplica√ß√£o n√£o dispon√≠vel para abrir Cargos.")
                return
            # Abrir configura√ß√µes normalmente
            settings_window = SettingsWindow(self.master, self.app)
            self.master.wait_window(settings_window)
            # Atualizar lista de cargos ap√≥s fechar as configura√ß√µes
            if self.app and hasattr(self.app, 'settings') and 'roles' in self.app.settings:
                if hasattr(self, 'cargo_combo') and self.cargo_combo:
                    self.cargo_combo['values'] = list(self.app.settings['roles'].keys())
                    if self.cargo_combo.get() not in self.cargo_combo['values'] and self.cargo_combo['values']:
                        self.cargo_combo.set(self.cargo_combo['values'][0])
        except Exception as e:
            print(f"DEBUG: Erro ao abrir configura√ß√µes de cargos pela tela de usu√°rios: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir as configura√ß√µes de cargos: {e}")

    def _open_members_window_from_users(self):
        """Abre a janela de gerenciamento de membros a partir da tela de usu√°rios"""
        try:
            if not self.app:
                messagebox.showerror("Erro", "Aplica√ß√£o n√£o dispon√≠vel para abrir Membros.")
                return
            
            # Abrir janela de membros
            members_window = MembersWindow(self.master, self.app)
            self.master.wait_window(members_window)
            
            # Atualizar lista de membros ap√≥s fechar a janela
            self.populate_members_combo()
            
        except Exception as e:
            print(f"DEBUG: Erro ao abrir janela de membros pela tela de usu√°rios: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir a janela de membros: {e}")
    
    def populate_users_list(self):
        """Popula a lista de usu√°rios"""
        try:
            print("DEBUG: Populando lista de usu√°rios...")
            
            # Limpar lista atual
            for item in self.users_tree.get_children():
                self.users_tree.delete(item)
            
            # Usar o banco de dados PostgreSQL
            users = self.app.db.get_all_users()
            
            print(f"DEBUG: {len(users)} usu√°rios encontrados")
            
            for user in users:
                try:
                    user_id = user.get('id')
                    username = user.get('username', '')
                    cargo = user.get('cargo', '')
                    role = user.get('role', '')
                    created_at = user.get('created_at')
                    updated_at = user.get('updated_at')
                    
                    # Formatar data de cria√ß√£o
                    if created_at:
                        try:
                            if isinstance(created_at, str):
                                created_at = datetime.strptime(created_at, '%Y-%m-%d %H:%M:%S.%f').strftime('%d/%m/%Y %H:%M')
                            else:
                                created_at = created_at.strftime('%d/%m/%Y %H:%M')
                        except:
                            created_at = str(created_at)[:19] if len(str(created_at)) > 19 else str(created_at)
                    else:
                        created_at = "N/A"

                    # Formatar data de √∫ltimo login (usar updated_at como aproxima√ß√£o)
                    if updated_at:
                        try:
                            if isinstance(updated_at, str):
                                last_login = datetime.strptime(updated_at, '%Y-%m-%d %H:%M:%S.%f').strftime('%d/%m/%Y %H:%M')
                            else:
                                last_login = updated_at.strftime('%d/%m/%Y %H:%M')
                        except:
                            last_login = str(updated_at)[:19] if len(str(updated_at)) > 19 else str(updated_at)
                    else:
                        last_login = "Nunca"

                    self.users_tree.insert("", "end", values=(
                        user_id,
                        username,
                        cargo,
                        role,
                        created_at,
                        last_login
                    ))
                except Exception as e:
                    print(f"DEBUG: Erro ao processar usu√°rio {user}: {e}")
                    continue
            
            print("DEBUG: Lista de usu√°rios populada com sucesso!")
            
        except Exception as e:
            print(f"DEBUG: Erro ao popular lista de usu√°rios: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel carregar a lista de usu√°rios: {e}")
    
    def on_user_select(self, event):
        """Manipula sele√ß√£o de usu√°rio na lista"""
        selected_item = self.users_tree.selection()
        if selected_item:
            values = self.users_tree.item(selected_item, "values")
            self.selected_user_id = int(values[0])
            
            # Preencher formul√°rio para edi√ß√£o
            self.username_entry.delete(0, tk.END)
            self.username_entry.insert(0, values[1])
            
            if hasattr(self, 'cargo_combo') and self.cargo_combo['values']:
                if values[2] in self.cargo_combo['values']:
                    self.cargo_combo.set(values[2])
                else:
                    try:
                        self.cargo_combo['values'] = list(dict.fromkeys([values[2], *self.cargo_combo['values']]))
                        self.cargo_combo.set(values[2])
                    except Exception:
                        pass
            
            self.role_combo.set(values[3])
            
            # Buscar e preencher o membro associado
            try:
                user_data = self.app.db.get_user_by_id(self.selected_user_id)
                if user_data and user_data.get('member_id'):
                    member_id = user_data['member_id']
                    # Encontrar o membro no combo
                    for display_name, mid in self.member_dict.items():
                        if mid == member_id:
                            self.member_combo.set(display_name)
                            break
            except Exception as e:
                print(f"DEBUG: Erro ao buscar membro associado: {e}")
            
            # Limpar senha (n√£o mostrar senha atual)
            self.password_entry.delete(0, tk.END)
            
            self.edit_mode = True
        else:
            self.edit_mode = False
            self.selected_user_id = None
    
    def add_user(self):
        """Adiciona um novo usu√°rio"""
        username = self.username_entry.get().strip()
        password = self.password_entry.get()
        cargo = self.cargo_combo.get().strip()
        role = self.role_combo.get()
        member_selection = self.member_combo.get()
        
        if not username or not password or not cargo or not member_selection:
            messagebox.showerror("Erro", "Todos os campos s√£o obrigat√≥rios!")
            return
        
        # Obter o ID do membro selecionado
        member_id = self.member_dict.get(member_selection)
        if not member_id:
            messagebox.showerror("Erro", "Selecione um membro v√°lido!")
            return
        
        # Usar o banco de dados SQLite diretamente
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Verificar se usu√°rio j√° existe
            cursor.execute("SELECT id FROM users WHERE username = %s", (username,))
            if cursor.fetchone():
                messagebox.showerror("Erro", "Usu√°rio j√° existe")
                conn.close()
                return
            
            # Inserir novo usu√°rio
            cursor.execute("""
                INSERT INTO users (username, password_hash, email, role, cargo, member_id, created_at, updated_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """, (username, password, "", role, cargo, member_id, datetime.now(), datetime.now()))
            
            conn.commit()
            conn.close()
            
            messagebox.showinfo("Sucesso", "Usu√°rio registrado com sucesso")
            self.clear_form()
            self.populate_users_list()
            
        except Exception as e:
            print(f"DEBUG: Erro ao adicionar usu√°rio: {e}")
            messagebox.showerror("Erro", f"Erro ao registrar usu√°rio: {e}")
    
    def edit_user(self):
        """Edita um usu√°rio selecionado"""
        if not self.edit_mode or not self.selected_user_id:
            messagebox.showwarning("Aviso", "Selecione um usu√°rio para editar!")
            return
        
        username = self.username_entry.get().strip()
        password = self.password_entry.get()
        cargo = self.cargo_combo.get().strip()
        role = self.role_combo.get()
        member_selection = self.member_combo.get()
        
        if not username or not cargo or not member_selection:
            messagebox.showerror("Erro", "Usu√°rio, cargo e membro s√£o obrigat√≥rios!")
            return
        
        # Obter o ID do membro selecionado
        member_id = self.member_dict.get(member_selection)
        if not member_id:
            messagebox.showerror("Erro", "Selecione um membro v√°lido!")
            return
        
        # Usar o banco de dados SQLite diretamente
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Atualizar usu√°rio
            if password:  # Se senha foi fornecida, atualizar
                cursor.execute("""
                    UPDATE users SET username = %s, password_hash = %s, role = %s, cargo = %s, member_id = %s, updated_at = %s
                    WHERE id = %s
                """, (username, password, role, cargo, member_id, datetime.now(), self.selected_user_id))
            else:  # Se n√£o, manter senha atual
                cursor.execute("""
                    UPDATE users SET username = %s, role = %s, cargo = %s, member_id = %s, updated_at = %s
                    WHERE id = %s
                """, (username, role, cargo, member_id, datetime.now(), self.selected_user_id))
            
            conn.commit()
            conn.close()
            
            messagebox.showinfo("Sucesso", "Usu√°rio atualizado com sucesso")
            self.clear_form()
            self.populate_users_list()
            
        except Exception as e:
            print(f"DEBUG: Erro ao editar usu√°rio: {e}")
            messagebox.showerror("Erro", f"Erro ao atualizar usu√°rio: {e}")
    
    def remove_user(self):
        """Remove um usu√°rio selecionado"""
        if not self.edit_mode or not self.selected_user_id:
            messagebox.showwarning("Aviso", "Selecione um usu√°rio para remover!")
            return
        
        username = self.username_entry.get()
        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover o usu√°rio '{username}'?"):
            # Usar o banco de dados SQLite diretamente
            try:
                import sqlite3
                
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                
                # Remover usu√°rio
                cursor.execute("DELETE FROM users WHERE id = %s", (self.selected_user_id,))
                
                conn.commit()
                conn.close()
                
                messagebox.showinfo("Sucesso", "Usu√°rio removido com sucesso")
                self.clear_form()
                self.populate_users_list()
                
            except Exception as e:
                print(f"DEBUG: Erro ao remover usu√°rio: {e}")
                messagebox.showerror("Erro", f"Erro ao remover usu√°rio: {e}")

    def clear_form(self):
        """Limpa o formul√°rio"""
        self.username_entry.delete(0, tk.END)
        self.password_entry.delete(0, tk.END)
        if hasattr(self, 'cargo_combo') and self.cargo_combo['values']:
            self.cargo_combo.set(self.cargo_combo['values'][0])
        self.role_combo.set("user")
        if hasattr(self, 'member_combo') and self.member_combo['values']:
            self.member_combo.set(self.member_combo['values'][0])
        self.edit_mode = False
        self.selected_user_id = None
        self.users_tree.selection_remove(*self.users_tree.selection())


class NumericEntryWithButtons(tk.Frame):
    def __init__(self, parent, icons, initial_value=0.00, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self._value = initial_value # Store as float internally

        self.entry = ttk.Entry(self, width=15, justify='right')
        self.entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.entry.bind("<FocusOut>", self._on_focus_out)
        self.entry.bind("<FocusIn>", self._on_focus_in)
        self.entry.bind("<KeyRelease>", self._on_key_release)

        self.up_button = ttk.Button(self, image=icons.get('up_icon'), width=2, command=self._increment)
        self.up_button.pack(side=tk.LEFT, padx=1)
        self.down_button = ttk.Button(self, image=icons.get('down_icon'), width=2, command=self._decrement)
        self.down_button.pack(side=tk.LEFT, padx=1)

        self._format_display() # Initial display

    def _format_display(self):
        # Formats the internal float value (dot) to display string (comma)
        display_text = f"{self._value:.2f}".replace('.', ',')
        self.entry.delete(0, tk.END)
        self.entry.insert(0, display_text)

    def _on_focus_in(self, event):
        # When focused, convert display string (comma) to internal float string (dot) for editing
        current_text = self.entry.get().replace(',', '.')
        try:
            val = float(current_text)
            self.entry.delete(0, tk.END)
            self.entry.insert(0, str(val)) # Show with dot for editing
        except ValueError:
            self.entry.delete(0, tk.END)
            self.entry.insert(0, "0.00") # Reset if invalid

    def _on_focus_out(self, event):
        # When focus leaves, update internal value from entry and re-apply display format
        self._update_value_from_entry()
        self._format_display()

    def _on_key_release(self, event):
        # Live update of internal value as user types, but don't reformat display yet
        self._update_value_from_entry(live_update=True) # Pass a flag for live update

    def _update_value_from_entry(self, live_update=False):
        current_text = self.entry.get().replace(',', '.')
        try:
            val = float(current_text)
            self._value = val
        except ValueError:
            # If invalid input during live typing, don't change the internal value
            # unless it's on focus out, then reset to 0.00
            if not live_update:
                self._value = 0.00
                self.entry.delete(0, tk.END)
                self.entry.insert(0, "0.00")

    def _increment(self):
        self._update_value_from_entry() # Ensure value is up-to-date
        self._value += 1.00 # Increment by 1.00
        self._format_display()

    def _decrement(self):
        self._update_value_from_entry() # Ensure value is up-to-date
        self._value -= 1.00 # Decrement by 1.00
        self._format_display()

    def get(self):
        self._update_value_from_entry() # Ensure value is up-to-date before returning
        return self._value

    def set(self, new_value):
        self._value = new_value
        self._format_display()

class DatePickerDialog(tk.Toplevel):
    def __init__(self, parent, current_date=None, icons=None):
        super().__init__(parent)
        self.parent = parent
        self.result_date = None
        self.title("Selecionar Data")
        self.transient(parent)
        self.grab_set()

        self.icons = icons or {}  # Store the icons dictionary or empty dict

        if current_date:
            try:
                if isinstance(current_date, str):
                    self.current_date = datetime.strptime(current_date, "%Y-%m-%d")
                else:
                    self.current_date = current_date
            except ValueError:
                self.current_date = datetime.now()
        else:
            self.current_date = datetime.now()

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        self.update_calendar()

        # Center the dialog
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')

    def create_widgets(self):
        # Navigation Frame
        nav_frame = ttk.Frame(self)
        nav_frame.pack(pady=5)

        # Usar texto em vez de √≠cones se n√£o dispon√≠veis
        ttk.Button(nav_frame, text="<<", command=self.prev_year).pack(side=tk.LEFT)
        ttk.Button(nav_frame, text="<", command=self.prev_month).pack(side=tk.LEFT)
        
        self.month_year_label = ttk.Label(nav_frame, text="", width=20, anchor="center")
        self.month_year_label.pack(side=tk.LEFT, padx=10)

        ttk.Button(nav_frame, text=">", command=self.next_month).pack(side=tk.LEFT)
        ttk.Button(nav_frame, text=">>", command=self.next_year).pack(side=tk.LEFT)

        # Day Labels (Sun, Mon, etc.)
        days_frame = ttk.Frame(self)
        days_frame.pack()
        for i, day in enumerate(["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S√°b"]):
            ttk.Label(days_frame, text=day, width=4, anchor="center").grid(row=0, column=i, padx=1, pady=1)

        # Calendar Grid
        self.calendar_frame = ttk.Frame(self)
        self.calendar_frame.pack()

        # OK/Cancel Buttons
        button_frame = ttk.Frame(self)
        button_frame.pack(pady=5)
        ttk.Button(button_frame, text="OK", command=self.ok).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.cancel).pack(side=tk.LEFT, padx=5)

    def update_calendar(self):
        for widget in self.calendar_frame.winfo_children():
            widget.destroy()

        self.month_year_label.config(text=self.current_date.strftime("%B %Y"))

        first_day_of_month = self.current_date.replace(day=1)
        # weekday() returns 0 for Monday, 6 for Sunday. We want 0 for Sunday.
        start_day_offset = (first_day_of_month.weekday() + 1) % 7 

        days_in_month = (self.current_date.replace(month=self.current_date.month % 12 + 1, day=1) - timedelta(days=1)).day

        for day_num in range(1, days_in_month + 1):
            row = (start_day_offset + day_num - 1) // 7
            col = (start_day_offset + day_num - 1) % 7
            
            date_to_check = self.current_date.replace(day=day_num)
            btn = ttk.Button(self.calendar_frame, text=str(day_num), width=4,
                             command=partial(self.select_date, date_to_check))
            btn.grid(row=row, column=col, padx=1, pady=1)

            if date_to_check.date() == datetime.now().date():
                btn.config(style="TButton") # Default style
            elif date_to_check.date() == self.current_date.date(): # Selected month, but not necessarily selected day
                btn.config(style="Accent.TButton") # Highlight current month days

    def prev_month(self):
        self.current_date = self.current_date.replace(day=1) - timedelta(days=1)
        self.update_calendar()

    def next_month(self):
        if self.current_date.month == 12:
            self.current_date = self.current_date.replace(year=self.current_date.year + 1, month=1, day=1)
        else:
            self.current_date = self.current_date.replace(month=self.current_date.month + 1, day=1)
        self.update_calendar()

    def prev_year(self):
        self.current_date = self.current_date.replace(year=self.current_date.year - 1)
        self.update_calendar()

    def next_year(self):
        self.current_date = self.current_date.replace(year=self.current_date.year + 1)
        self.update_calendar()

    def select_date(self, date):
        self.result_date = date
        self.ok()

    def ok(self):
        self.parent.focus_set()
        self.destroy()

    def cancel(self):
        self.result_date = None
        self.parent.focus_set()
        self.destroy()

    @property
    def selected_date(self):
        return self.result_date


class TimePickerDialog(tk.Toplevel):
    """Dialog para sele√ß√£o de hora no formato brasileiro"""
    
    def __init__(self, parent, current_time="09:00"):
        super().__init__(parent)
        self.parent = parent
        self.selected_time = None
        self.title("Selecionar Hora")
        self.transient(parent)
        self.grab_set()
        
        # Parse current time
        try:
            self.current_hour, self.current_minute = map(int, current_time.split(':'))
        except:
            self.current_hour, self.current_minute = 9, 0
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        
        # Centralizar janela
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
    
    def create_widgets(self):
        """Cria os widgets da interface"""
        main_frame = ttk.Frame(self, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        ttk.Label(main_frame, text="Selecione a hora:", 
                 font=("Arial", 12, "bold")).pack(pady=(0, 20))
        
        # Frame para hora e minuto
        time_frame = ttk.Frame(main_frame)
        time_frame.pack(pady=10)
        
        # Hora
        hour_frame = ttk.Frame(time_frame)
        hour_frame.pack(side=tk.LEFT, padx=10)
        
        ttk.Label(hour_frame, text="Hora:").pack()
        
        # Spinbox para hora (0-23)
        self.hour_var = tk.StringVar(value=str(self.current_hour))
        hour_spinbox = ttk.Spinbox(hour_frame, from_=0, to=23, width=5,
                                  textvariable=self.hour_var, wrap=True)
        hour_spinbox.pack(pady=5)
        
        # Minuto
        minute_frame = ttk.Frame(time_frame)
        minute_frame.pack(side=tk.LEFT, padx=10)
        
        ttk.Label(minute_frame, text="Minuto:").pack()
        
        # Spinbox para minuto (0-59)
        self.minute_var = tk.StringVar(value=str(self.current_minute))
        minute_spinbox = ttk.Spinbox(minute_frame, from_=0, to=59, width=5,
                                    textvariable=self.minute_var, wrap=True)
        minute_spinbox.pack(pady=5)
        
        # Separador
        ttk.Label(time_frame, text=":", font=("Arial", 16, "bold")).pack(side=tk.LEFT, padx=5)
        
        # Bot√µes de hora r√°pida
        quick_frame = ttk.LabelFrame(main_frame, text="Horas Comuns", padding="10")
        quick_frame.pack(fill=tk.X, pady=10)
        
        quick_hours = [
            ("08:00", "8:00"),
            ("09:00", "9:00"),
            ("10:00", "10:00"),
            ("11:00", "11:00"),
            ("12:00", "12:00"),
            ("13:00", "13:00"),
            ("14:00", "14:00"),
            ("15:00", "15:00"),
            ("16:00", "16:00"),
            ("17:00", "17:00"),
            ("18:00", "18:00")
        ]
        
        for i, (time_value, time_label) in enumerate(quick_hours):
            btn = ttk.Button(quick_frame, text=time_label, width=6,
                           command=lambda t=time_value: self.set_quick_time(t))
            btn.grid(row=i//5, column=i%5, padx=2, pady=2)
        
        # Bot√µes de a√ß√£o
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=20)
        
        ttk.Button(button_frame, text="OK", command=self.ok).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.cancel).pack(side=tk.RIGHT, padx=5)
    
    def set_quick_time(self, time_str):
        """Define uma hora r√°pida"""
        hour, minute = map(int, time_str.split(':'))
        self.hour_var.set(str(hour))
        self.minute_var.set(str(minute))
    
    def ok(self):
        """Confirma a sele√ß√£o"""
        try:
            hour = int(self.hour_var.get())
            minute = int(self.minute_var.get())
            
            if 0 <= hour <= 23 and 0 <= minute <= 59:
                self.selected_time = f"{hour:02d}:{minute:02d}"
                self.parent.focus_set()
                self.destroy()
            else:
                messagebox.showerror("Erro", "Hora inv√°lida!", parent=self)
        except ValueError:
            messagebox.showerror("Erro", "Hora inv√°lida!", parent=self)
    
    def cancel(self):
        """Cancela a sele√ß√£o"""
        self.selected_time = None
        self.parent.focus_set()
        self.destroy()


class SubtaskEditorWindow(tk.Toplevel):
    def __init__(self, parent, app, card, subtask):
        super().__init__(parent)
        self.app = app
        self.card = card
        self.subtask = subtask

        self.title(f"Editar Subtarefa")
        self.transient(parent)
        self.grab_set()
        self.geometry("450x350")

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text=f"Tarefa Principal: {self.card.get('title', '')}").pack(anchor="w")
        ttk.Label(main_frame, text=f"Subtarefa: {self.subtask.get('text', '')}").pack(anchor="w", pady=(0, 10))

        ttk.Label(main_frame, text="Descri√ß√£o da Subtarefa:").pack(anchor="w", pady=(0, 5))
        self.desc_text = tk.Text(main_frame, wrap=tk.WORD, height=10)
        self.desc_text.pack(fill=tk.BOTH, expand=True)
        self.desc_text.insert("1.0", self.subtask.get("desc", ""))

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))

        ttk.Button(button_frame, text="Salvar", image=self.app.icons.get('save_icon_32'), compound=tk.LEFT, command=self.save_and_close).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", image=self.app.icons.get('cancel_icon_32'), compound=tk.LEFT, command=self.destroy).pack(side=tk.RIGHT)

    def save_and_close(self):
        new_desc = self.desc_text.get("1.0", tk.END).strip()
        self.subtask["desc"] = new_desc
        self.app.save_trello_data()
        if hasattr(self.app, 'activities_tree'):
            self.app.update_my_activities_tab()
        self.app.populate_boards()
        self.destroy()




class ThemeSettingsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Configurar Tema")
        self.geometry("350x150")
        self.transient(parent)
        self.grab_set()

        # Centralizar
        self.update_idletasks()
        x = parent.winfo_x() + (parent.winfo_width() // 2) - (self.winfo_width() // 2)
        y = parent.winfo_y() + (parent.winfo_height() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Escolha um tema para a aplica√ß√£o:").pack(anchor="w", pady=5)

        # Combobox com temas
        self.theme_var = tk.StringVar()
        self.theme_combo = ttk.Combobox(main_frame, textvariable=self.theme_var, state="readonly")
        
        # Carregar temas dispon√≠veis
        available_themes = sorted(self.app.root.get_themes())
        self.theme_combo['values'] = available_themes
        
        # Definir tema atual
        current_theme = self.app.db.get_setting('theme', default='arc', user_id=self.app.current_user.user_id)
        if current_theme in available_themes:
            self.theme_combo.set(current_theme)
        else:
            self.theme_combo.set('arc')

        self.theme_combo.pack(fill=tk.X, pady=5)

        # Bot√µes
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Salvar", command=self.save_theme).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.destroy).pack(side=tk.RIGHT)

    def save_theme(self):
        selected_theme = self.theme_var.get()
        if not selected_theme:
            messagebox.showwarning("Nenhum Tema", "Por favor, selecione um tema.", parent=self)
            return

        try:
            # Salvar no banco de dados
            self.app.db.save_setting('theme', selected_theme, user_id=self.app.current_user.user_id)
            
            # Aplicar o tema imediatamente
            self.app.root.set_theme(selected_theme)
            
            messagebox.showinfo("Sucesso", f"Tema '{selected_theme}' aplicado com sucesso!", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel salvar ou aplicar o tema: {e}", parent=self)


class ThemeSettingsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Configurar Tema")
        self.geometry("350x150")
        self.transient(parent)
        self.grab_set()

        # Centralizar
        self.update_idletasks()
        x = parent.winfo_x() + (parent.winfo_width() // 2) - (self.winfo_width() // 2)
        y = parent.winfo_y() + (parent.winfo_height() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Escolha um tema para a aplica√ß√£o:").pack(anchor="w", pady=5)

        # Combobox com temas
        self.theme_var = tk.StringVar()
        self.theme_combo = ttk.Combobox(main_frame, textvariable=self.theme_var, state="readonly")
        
        # Carregar temas dispon√≠veis
        available_themes = sorted(self.app.root.get_themes())
        self.theme_combo['values'] = available_themes
        
        # Definir tema atual
        current_theme = self.app.db.get_setting('theme', default='arc', user_id=self.app.current_user.user_id)
        if current_theme in available_themes:
            self.theme_combo.set(current_theme)
        else:
            self.theme_combo.set('arc')

        self.theme_combo.pack(fill=tk.X, pady=5)

        # Bot√µes
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Salvar", command=self.save_theme).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.destroy).pack(side=tk.RIGHT)

    def save_theme(self):
        selected_theme = self.theme_var.get()
        if not selected_theme:
            messagebox.showwarning("Nenhum Tema", "Por favor, selecione um tema.", parent=self)
            return

        try:
            # Salvar no banco de dados
            self.app.db.save_setting('theme', selected_theme, user_id=self.app.current_user.user_id)
            
            # Aplicar o tema imediatamente
            self.app.root.set_theme(selected_theme)
            
            messagebox.showinfo("Sucesso", f"Tema '{selected_theme}' aplicado com sucesso!", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel salvar ou aplicar o tema: {e}", parent=self)


class DraggableTreeview:
    """Treeview otimizado para drag and drop com cache de performance"""
    
    def __init__(self, treeview, app, board_name, list_name):
        self.treeview = treeview
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self._drag_data = {"item": None, "x": 0, "y": 0, "card_id": None, "source_treeview": None}
        self._drag_widget = None
        self._is_dragging = False
        
        # Cache para performance
        self._cached_items = {}
        self._last_update = 0
        
        # Configurar eventos otimizados
        self._setup_optimized_events()
    
    def _setup_optimized_events(self):
        """Configura eventos otimizados para drag and drop"""
        self.treeview.bind("<Button-1>", self._on_drag_start_optimized)
        self.treeview.bind("<B1-Motion>", self._on_drag_motion_optimized)
        self.treeview.bind("<ButtonRelease-1>", self._on_drag_release_optimized)
        
        # Eventos para melhor feedback visual
        self.treeview.bind("<Enter>", self._on_enter_list)
        self.treeview.bind("<Leave>", self._on_leave_list)
    
    def _on_drag_start_optimized(self, event):
        """In√≠cio do drag otimizado"""
        item = self.treeview.identify_row(event.y)
        if not item:
            return
        
        # Verificar se o item √© v√°lido
        values = self.treeview.item(item, "values")
        if not values or len(values) < 5:
            return
        
        card_id = values[4]  # card_id est√° na posi√ß√£o 4
        if not card_id:
            return
        
        # Configurar dados do drag
        self._drag_data = {
            "item": item,
            "x": event.x,
            "y": event.y,
            "card_id": card_id,
            "source_treeview": self.treeview
        }
        
        # Selecionar item
        self.treeview.selection_set(item)
        
        # Criar widget visual de drag
        self._create_drag_widget(event)
        
        print(f"üöÄ Drag iniciado: {card_id} de {self.board_name}/{self.list_name}")
    
    def _create_drag_widget(self, event):
        """Cria widget visual para o drag"""
        if self._drag_widget:
            self._drag_widget.destroy()
        
        # Obter dados do item
        item = self._drag_data["item"]
        values = self.treeview.item(item, "values")
        title = values[0] if values else "Card"
        
        # Criar widget de drag
        self._drag_widget = tk.Toplevel(self.treeview)
        self._drag_widget.overrideredirect(True)
        self._drag_widget.attributes('-topmost', True)
        
        # Frame do widget
        frame = ttk.Frame(self._drag_widget, relief="solid", borderwidth=2)
        frame.pack(padx=5, pady=5)
        
        # Label com t√≠tulo
        label = ttk.Label(frame, text=title, background="lightblue", padding=5)
        label.pack()
        
        # Posicionar widget
        x = event.x_root - 50
        y = event.y_root - 25
        self._drag_widget.geometry(f"+{x}+{y}")
    
    def _on_drag_motion_optimized(self, event):
        """Movimento do drag otimizado"""
        if not self._drag_data["item"]:
            return
        
        # Atualizar posi√ß√£o do widget visual
        if self._drag_widget:
            x = event.x_root - 50
            y = event.y_root - 25
            self._drag_widget.geometry(f"+{x}+{y}")
        
        # Atualizar dados do drag
        self._drag_data["x"] = event.x
        self._drag_data["y"] = event.y
        
        # Feedback visual para listas de destino
        self._highlight_target_lists(event)
    
    def _highlight_target_lists(self, event):
        """Destaca listas de destino durante o drag"""
        target_widget = event.widget.winfo_containing(event.x_root, event.y_root)
        
        # Resetar todas as listas
        for (b_name, l_name), tv_widget in self.app.listbox_refs.items():
            if hasattr(tv_widget, 'configure'):
                try:
                    tv_widget.configure(style='Treeview')
                except:
                    pass
        
        # Destacar lista de destino
        if target_widget and target_widget != self.treeview:
            for (b_name, l_name), tv_widget in self.app.listbox_refs.items():
                if tv_widget == target_widget:
                    try:
                        tv_widget.configure(style='Treeview.Highlight')
                    except:
                        pass
                    break
    
    def _on_drag_release_optimized(self, event):
        """Release do drag otimizado"""
        if not self._drag_data["item"] or not self._drag_data["card_id"]:
            return
        
        # Limpar widget visual
        if self._drag_widget:
            self._drag_widget.destroy()
            self._drag_widget = None
        
        # Identificar destino
        target_widget = event.widget.winfo_containing(event.x_root, event.y_root)
        target_board, target_list = self._get_target_location_optimized(target_widget)
        
        # Executar movimento se v√°lido
        if target_board and target_list and (target_board != self.board_name or target_list != self.list_name):
            self._execute_optimized_move(target_board, target_list)
        
        # Limpar dados do drag
        self._drag_data = {"item": None, "x": 0, "y": 0, "card_id": None, "source_treeview": None}
        
        # Resetar destaque das listas
        self._reset_list_highlights()
    
    def _get_target_location_optimized(self, widget):
        """Identifica localiza√ß√£o do destino de forma otimizada"""
        if not widget:
            return None, None
        
        # Usar cache se dispon√≠vel
        if hasattr(self.app, 'kanban_optimizer') and self.app.kanban_optimizer:
            return self.app.kanban_optimizer._get_target_location(widget)
        
        # Fallback para busca tradicional
        for (b_name, l_name), tv_widget in self.app.listbox_refs.items():
            if tv_widget == widget:
                return b_name, l_name
        
        return None, None
    
    def _execute_optimized_move(self, target_board, target_list):
        """Executa movimento otimizado"""
        card_id = self._drag_data["card_id"]
        
        print(f"‚ö° Movimento otimizado: {card_id} -> {target_board}/{target_list}")
        
        # Usar otimizador se dispon√≠vel
        if hasattr(self.app, 'kanban_optimizer') and self.app.kanban_optimizer:
            self.app.kanban_optimizer._optimized_move_card(
                card_id, self.board_name, self.list_name, target_board, target_list
            )
        else:
            # Fallback para m√©todo original
            self.app.move_card_data(self.board_name, self.list_name, card_id, target_board, target_list)
    
    def _reset_list_highlights(self):
        """Reseta destaque das listas"""
        for (b_name, l_name), tv_widget in self.app.listbox_refs.items():
            if hasattr(tv_widget, 'configure'):
                try:
                    tv_widget.configure(style='Treeview')
                except:
                    pass
    
    def _on_enter_list(self, event):
        """Evento ao entrar na lista"""
        if self._is_dragging:
            # Destacar lista
            try:
                self.treeview.configure(style='Treeview.Highlight')
            except:
                pass
    
    def _on_leave_list(self, event):
        """Evento ao sair da lista"""
        if self._is_dragging:
            # Remover destaque
            try:
                self.treeview.configure(style='Treeview')
            except:
                pass
    def __init__(self, treeview, app, board_name, list_name):
        self.treeview = treeview
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self.treeview.bind("<ButtonPress-1>", self.on_drag_start)
        self.treeview.bind("<B1-Motion>", self.on_drag_motion)
        self.treeview.bind("<ButtonRelease-1>", self.on_drag_release)
        self._drag_data = {"item": None, "x": 0, "y": 0, "card_id": None, "source_treeview": None}
        self._drag_widget = None

    def on_drag_start(self, event):
        item_id = self.treeview.identify_row(event.y)
        if not item_id or self.treeview.parent(item_id):  # Don't drag child items
            return

        self.treeview.selection_set(item_id)
        self._drag_data["item"] = item_id
        self._drag_data["x"] = event.x
        self._drag_data["y"] = event.y
        self._drag_data["source_treeview"] = self.treeview

        # Get card_id from the tags
        self._drag_data["card_id"] = self.treeview.item(item_id, "tags")[0]

        # Create a temporary drag widget
        x, y, width, height = self.treeview.bbox(item_id)
        display_text = self.treeview.item(item_id, "values")[0] # Get the title
        self._drag_widget = tk.Label(self.treeview, text=display_text, background="lightblue", relief="raised", borderwidth=1)
        self._drag_widget.place(x=x, y=y, width=width, height=height)

    def on_drag_motion(self, event):
        if self._drag_widget:
            x = self.treeview.winfo_x() + event.x - self._drag_data["x"]
            y = self.treeview.winfo_y() + event.y - self._drag_data["y"]
            self._drag_widget.place(x=x, y=y)

    def on_drag_release(self, event):
        if self._drag_widget:
            self._drag_widget.destroy()
            self._drag_widget = None

        if not self._drag_data["item"] or not self._drag_data["card_id"]:
            return

        # Find the widget under the cursor
        x_root, y_root = event.x_root, event.y_root
        target_widget = event.widget.winfo_containing(x_root, y_root)

        target_treeview = None
        target_list_name = None
        target_board_name = None

        # Traverse up the widget hierarchy to find the Treeview
        current_widget = target_widget
        while current_widget:
            if isinstance(current_widget, ttk.Treeview):
                # Now find which board/list this treeview belongs to
                for (b_name, l_name), tv_widget in self.app.listbox_refs.items():
                    if tv_widget == current_widget:
                        target_treeview = tv_widget
                        target_list_name = l_name
                        target_board_name = b_name
                        break
                if target_treeview:
                    break
            current_widget = current_widget.master

        if target_treeview and target_list_name and target_board_name:
            # We have a valid drop target
            print(f"CARD MOVIDO: Card '{self._drag_data['card_id']}' solto na lista '{target_list_name}' do quadro '{target_board_name}'")

            # Check if it's a different list
            if target_board_name != self.board_name or target_list_name != self.list_name:
                print(f"MOVENDO CARD: De '{self.list_name}' para '{target_list_name}'")
                # Call the existing move_card_data method which handles DB update and logging
                self.app.move_card_data(
                    self.board_name, 
                    self.list_name, 
                    self._drag_data["card_id"],
                    target_board_name, 
                    target_list_name
                )
            else:
                print(f"INFO: Card solto na mesma lista. Nenhuma a√ß√£o necess√°ria.")
        else:
            print("AVISO: Card solto em um local inv√°lido.")

        # Reset drag data
        self._drag_data = {"item": None, "x": 0, "y": 0, "card_id": None, "source_treeview": None}

class TrelloApp:
    def load_and_apply_user_theme(self):
        """Carrega e aplica o tema do usu√°rio a partir do banco de dados."""
        if self.current_user and self.current_user.user_id:
            # Usar 'arc' como tema padr√£o se nenhum for encontrado
            theme = self.db.get_setting('theme', default='arc', user_id=self.current_user.user_id)
            try:
                self.root.set_theme(theme)
            except Exception as e:
                print(f"Erro ao aplicar o tema '{theme}': {e}")
                # Se o tema salvo for inv√°lido, aplicar o padr√£o
                try:
                    self.root.set_theme("arc")
                except Exception as e_arc:
                    print(f"Erro ao aplicar o tema padr√£o 'arc': {e_arc}")
        
        # Configurar estilo personalizado para bot√µes uniformes
        try:
            style = ttk.Style()
            # Configurar estilo para bot√µes com altura uniforme
            style.configure('Uniform.TButton', 
                          padding=(10, 8),  # padding horizontal e vertical
                          relief='flat',
                          borderwidth=1)
        except Exception as e:
            print(f"Erro ao configurar estilo Uniform.TButton: {e}")
        
        # Inicializar sistema de atualiza√ß√µes
        self.current_version = "2.4.0"  # ATUALIZAR VERS√ÉO AQUI
        self.updater = AutoUpdater(self.current_version)
        self.update_dialog = None
        
        # Verificar atualiza√ß√µes em background ap√≥s inicializa√ß√£o
        self.root.after(5000, self.check_for_updates_delayed)

    def open_theme_settings(self):
        ThemeSettingsWindow(self.root, self)
    
    def check_for_updates_delayed(self):
        """Verifica atualiza√ß√µes ap√≥s um delay para n√£o bloquear a inicializa√ß√£o"""
        try:
            # Executar verifica√ß√£o em thread separada
            update_thread = threading.Thread(target=self.check_for_updates)
            update_thread.daemon = True
            update_thread.start()
        except Exception as e:
            print(f"Erro ao verificar atualiza√ß√µes: {e}")
    
    def check_for_updates(self):
        """Verifica se h√° atualiza√ß√µes dispon√≠veis"""
        try:
            # Verificar atualiza√ß√µes
            update_result = check_for_updates_in_background(self.current_version)
            
            if update_result:
                # Mostrar di√°logo de atualiza√ß√£o na thread principal
                self.root.after(0, self.show_update_dialog, update_result)
                
        except Exception as e:
            print(f"Erro na verifica√ß√£o de atualiza√ß√µes: {e}")
    
    def show_update_dialog(self, update_result):
        """Mostra di√°logo de atualiza√ß√£o"""
        try:
            if update_result['type'] == 'forced_update':
                # Atualiza√ß√£o for√ßada - mostrar di√°logo modal
                self.update_dialog = UpdateDialog(self.root, self.updater)
                self.update_dialog.show_update_dialog(update_result['version_info'])
            elif update_result['type'] == 'optional_update':
                # Atualiza√ß√£o opcional - perguntar ao usu√°rio
                response = messagebox.askyesno(
                    "üÜï Nova Vers√£o Dispon√≠vel",
                    f"Uma nova vers√£o do Boodesk est√° dispon√≠vel!\n\n"
                    f"Vers√£o atual: {self.current_version}\n"
                    f"Nova vers√£o: {update_result['version_info']['versao']}\n\n"
                    f"Deseja atualizar agora?"
                )
                
                if response:
                    self.update_dialog = UpdateDialog(self.root, self.updater)
                    self.update_dialog.show_update_dialog(update_result['version_info'])
                    
        except Exception as e:
            print(f"Erro ao mostrar di√°logo de atualiza√ß√£o: {e}")
    
    def check_for_updates_manual(self):
        """Abre uma janela para verificar atualiza√ß√µes manualmente"""
        try:
            # Criar janela de atualiza√ß√µes
            update_window = tk.Toplevel(self.root)
            update_window.title("Verificar Atualiza√ß√µes - Boodesk")
            update_window.geometry("1000x900")
            update_window.resizable(True, True)
            update_window.transient(self.root)
            update_window.grab_set()
            
            # Centralizar a janela
            update_window.update_idletasks()
            x = (update_window.winfo_screenwidth() // 2) - (1000 // 2)
            y = (update_window.winfo_screenheight() // 2) - (900 // 2)
            update_window.geometry(f"1000x900+{x}+{y}")
            
            # Frame principal com scrollbar
            main_container = ttk.Frame(update_window)
            main_container.pack(fill='both', expand=True, padx=10, pady=10)
            
            # Canvas para scroll
            canvas = tk.Canvas(main_container)
            scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # Frame principal
            main_frame = ttk.Frame(scrollable_frame, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # T√≠tulo principal
            title_label = ttk.Label(main_frame, text="üîÑ SISTEMA DE ATUALIZA√á√ïES", 
                                   font=('Segoe UI', 18, 'bold'))
            title_label.pack(pady=(0, 10))
            
            # Subt√≠tulo
            subtitle_label = ttk.Label(main_frame, text="Gerencie as atualiza√ß√µes do Boodesk", 
                                     font=('Segoe UI', 12))
            subtitle_label.pack(pady=(0, 20))
            
            # Frame de status
            status_frame = ttk.LabelFrame(main_frame, text="Status da Verifica√ß√£o", padding=15)
            status_frame.pack(fill='x', pady=(0, 20))
            
            # Status inicial
            status_label = ttk.Label(status_frame, text="‚è≥ Verificando atualiza√ß√µes...", 
                                    font=('Segoe UI', 10))
            status_label.pack()
            
            # Frame de informa√ß√µes
            info_frame = ttk.LabelFrame(main_frame, text="Informa√ß√µes do Sistema", padding=15)
            info_frame.pack(fill='x', pady=(0, 20))
            
            # Informa√ß√µes do sistema
            system_info = f"""
Vers√£o Atual: 2.4.10
Data de Compila√ß√£o: {datetime.now().strftime('%d/%m/%Y')}
Sistema Operacional: {platform.system()} {platform.release()}
Python: {platform.python_version()}
Banco de Dados: PostgreSQL/Supabase
Status: Conectado ‚úÖ
            """
            
            info_text = tk.Text(info_frame, height=8, width=80, wrap=tk.WORD, 
                               font=('Consolas', 9), state='disabled')
            info_text.pack(fill='x')
            info_text.config(state='normal')
            info_text.insert('1.0', system_info.strip())
            info_text.config(state='disabled')
            
            # Frame para progresso de download
            progress_frame = ttk.LabelFrame(main_frame, text="Progresso de Download", padding=15)
            progress_frame.pack(fill='x', pady=(0, 20))
            
            # Barra de progresso
            progress_bar = ttk.Progressbar(progress_frame, mode='determinate', length=600)
            progress_bar.pack(pady=(0, 10))
            
            # Label de progresso
            progress_label = ttk.Label(progress_frame, text="Aguardando download...", 
                                     font=('Segoe UI', 9))
            progress_label.pack()
            
            # Separador visual
            separator = ttk.Separator(main_frame, orient='horizontal')
            separator.pack(fill='x', pady=(20, 20))
            
            # T√≠tulo dos bot√µes
            buttons_title = ttk.Label(main_frame, text="üéØ A√á√ïES DISPON√çVEIS", 
                                     font=('Segoe UI', 14, 'bold'))
            buttons_title.pack(pady=(0, 20))
            
            # Frame de bot√µes principais - Primeira linha
            button_frame1 = ttk.Frame(main_frame)
            button_frame1.pack(fill='x', pady=(0, 15))
            
            # Bot√£o de verificar novamente
            check_button = ttk.Button(button_frame1, text="üîÑ Verificar Novamente", 
                                     command=lambda: self.check_updates_again(status_label, progress_bar, progress_label),
                                     style='Accent.TButton', width=25)
            check_button.pack(side='left', padx=(0, 15))
            
            # Bot√£o de download
            download_button = ttk.Button(button_frame1, text="‚¨áÔ∏è Download Atualiza√ß√£o", 
                                       command=lambda: self.download_update(progress_bar, progress_label, update_window),
                                       style='Accent.TButton', width=25)
            download_button.pack(side='left', padx=(0, 15))
            
            # Bot√£o de instala√ß√£o
            install_button = ttk.Button(button_frame1, text="‚öôÔ∏è Instalar Atualiza√ß√£o", 
                                      command=lambda: self.install_update(progress_bar, progress_label),
                                      style='Accent.TButton', width=25)
            install_button.pack(side='left', padx=(0, 15))
            
            # Bot√£o para configurar diret√≥rio de download
            configure_dir_button = ttk.Button(button_frame1, text="‚öôÔ∏è Configurar Diret√≥rio", 
                                            command=lambda: self.configure_download_directory(),
                                            width=25)
            configure_dir_button.pack(side='left', padx=(0, 15))
            
            # Label para mostrar diret√≥rio atual
            download_dir_label = ttk.Label(button_frame1, text="üìÅ Diret√≥rio atual: Carregando...", 
                                         font=("Arial", 9))
            download_dir_label.pack(side='left', padx=(10, 0))
            
            # Bot√£o de abrir local do execut√°vel (inicialmente desabilitado)
            open_location_button = ttk.Button(button_frame1, text="üìÅ Abrir Local do Execut√°vel", 
                                            command=lambda: self.open_executable_location(),
                                            state='disabled', width=25)
            open_location_button.pack(side='left', padx=(0, 15))
            
            # Armazenar refer√™ncia do bot√£o para habilitar ap√≥s download
            update_window.open_location_button = open_location_button
            update_window.download_dir_label = download_dir_label
            
            # Frame de bot√µes secund√°rios - Segunda linha
            button_frame2 = ttk.Frame(main_frame)
            button_frame2.pack(fill='x', pady=(15, 15))
            
            # Bot√£o de configura√ß√µes avan√ßadas
            advanced_button = ttk.Button(button_frame2, text="üîß Configura√ß√µes Avan√ßadas", 
                                       command=lambda: self.show_advanced_update_settings(update_window),
                                       width=30)
            advanced_button.pack(side='left', padx=(0, 15))
            
            # Bot√£o de hist√≥rico de atualiza√ß√µes
            history_button = ttk.Button(button_frame2, text="üìã Hist√≥rico de Atualiza√ß√µes", 
                                      command=lambda: self.show_update_history(update_window),
                                      width=30)
            history_button.pack(side='left', padx=(0, 15))
            
            # Frame de bot√£o fechar - Terceira linha
            button_frame3 = ttk.Frame(main_frame)
            button_frame3.pack(fill='x', pady=(20, 0))
            
            # Bot√£o de fechar
            close_button = ttk.Button(button_frame3, text="‚ùå Fechar", 
                                     command=update_window.destroy,
                                     width=20)
            close_button.pack(side='right')
            
            # Configurar scrollbar
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # Simular verifica√ß√£o
            self.root.after(2000, lambda: self.simulate_update_check(status_label, progress_bar, progress_label))
            self.root.after(100, lambda: self.update_download_dir_label())
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir verifica√ß√£o de atualiza√ß√µes: {e}")
    
    def check_updates_again(self, status_label, progress_bar=None, progress_label=None):
        """Verifica atualiza√ß√µes novamente"""
        status_label.config(text="‚è≥ Verificando atualiza√ß√µes...")
        if progress_bar and progress_label:
            progress_bar['value'] = 0
            progress_label.config(text="Verificando...")
        self.root.after(2000, lambda: self.simulate_update_check(status_label, progress_bar, progress_label))
        self.root.after(100, lambda: self.update_download_dir_label())
    
    def simulate_update_check(self, status_label, progress_bar=None, progress_label=None):
        """Verifica atualiza√ß√µes reais no Cloudflare R2"""
        try:
            # Configura√ß√µes do Cloudflare R2
            r2_endpoint = "https://pub-93ac59355fc342489651074099b6e8a7.r2.dev"
            bucket_name = "boodesk-cdn"
            executable_name = "boodesk_latest.exe"
            
            # URL do execut√°vel no Cloudflare R2
            download_url = f"{r2_endpoint}/{executable_name}"
            
            print(f"üîç Verificando atualiza√ß√µes em: {download_url}")
            
            # Verificar se o arquivo existe no R2
            try:
                response = requests.head(download_url, timeout=10)
                if response.status_code == 200:
                    file_size = int(response.headers.get('content-length', 0))
                    print(f"‚úÖ Arquivo encontrado no Cloudflare R2! Tamanho: {file_size} bytes")
                    
                    # Verificar se o tamanho √© v√°lido (m√≠nimo 50MB)
                    if file_size > 50 * 1024 * 1024:  # 50MB
                        status_label.config(text="‚úÖ Atualiza√ß√£o dispon√≠vel! Vers√£o mais recente")
                        if progress_bar and progress_label:
                            progress_bar['value'] = 0
                            progress_label.config(text="Atualiza√ß√£o dispon√≠vel para download")
                        
                        # Mostrar informa√ß√µes da atualiza√ß√£o
                        update_info = f"""Nova vers√£o dispon√≠vel!

üì¶ Tamanho: {file_size//1024//1024}MB
üåê Fonte: Cloudflare R2
üìÖ Verificado: {datetime.now().strftime('%d/%m/%Y %H:%M')}

Clique em 'Download Atualiza√ß√£o' para baixar a nova vers√£o."""
                        
                        messagebox.showinfo("Atualiza√ß√£o Dispon√≠vel", update_info)
                    else:
                        status_label.config(text="‚ö†Ô∏è Arquivo no servidor parece estar corrompido")
                        if progress_bar and progress_label:
                            progress_bar['value'] = 0
                            progress_label.config(text="Arquivo inv√°lido no servidor")
                else:
                    status_label.config(text="‚úÖ Sistema atualizado! Voc√™ est√° usando a vers√£o mais recente.")
                    if progress_bar and progress_label:
                        progress_bar['value'] = 100
                        progress_label.config(text="Sistema atualizado")
                    print("‚ÑπÔ∏è Nenhuma atualiza√ß√£o dispon√≠vel no Cloudflare R2")
                    
            except requests.exceptions.RequestException as req_error:
                status_label.config(text="‚ùå Erro de conex√£o com servidor")
                if progress_bar and progress_label:
                    progress_bar['value'] = 0
                    progress_label.config(text="Erro de conex√£o")
                print(f"‚ùå Erro de conex√£o: {req_error}")
                
        except Exception as e:
            status_label.config(text=f"‚ùå Erro na verifica√ß√£o: {e}")
            if progress_bar and progress_label:
                progress_bar['value'] = 0
                progress_label.config(text="Erro na verifica√ß√£o")
            print(f"‚ùå Erro na verifica√ß√£o: {e}")
    
    
    def download_update(self, progress_bar, progress_label, update_window=None):
        """Download de atualiza√ß√£o do Cloudflare R2 com backup e instala√ß√£o"""
        try:
            progress_label.config(text="üîÑ Preparando atualiza√ß√£o...")
            progress_bar['value'] = 0
            
            # Configura√ß√µes do Cloudflare R2
            r2_endpoint = "https://pub-93ac59355fc342489651074099b6e8a7.r2.dev"
            bucket_name = "boodesk-cdn"
            executable_name = "boodesk_latest.exe"
            
            # URL do execut√°vel no Cloudflare R2
            download_url = f"{r2_endpoint}/{executable_name}"
            
            print(f"üîó Tentando baixar de: {download_url}")
            
            # Obter diret√≥rio de download configurado
            download_dir = self.get_download_directory()
            print(f"üîç Diret√≥rio de download configurado: {download_dir}")
            
            # Verificar se o diret√≥rio existe e √© grav√°vel
            if not os.path.exists(download_dir):
                os.makedirs(download_dir, exist_ok=True)
                print(f"üìÅ Diret√≥rio criado: {download_dir}")
            
            if not os.access(download_dir, os.W_OK):
                raise Exception(f"Sem permiss√£o de escrita no diret√≥rio: {download_dir}")
            
            current_exe = os.path.abspath(sys.argv[0])
            current_name = os.path.basename(current_exe)
            
            print(f"üìÅ Diret√≥rio de download: {download_dir}")
            
            # Nomes dos arquivos
            backup_name = f"{current_name}.backup"
            new_exe_name = "boodesk_latest.exe"
            installer_script = "install_update.bat"
            
            backup_path = os.path.join(download_dir, backup_name)
            new_exe_path = os.path.join(download_dir, new_exe_name)
            
            # 1. Fazer backup inteligente do execut√°vel atual
            progress_label.config(text="üîÑ Criando backup inteligente...")
            progress_bar['value'] = 10
            self.root.update_idletasks()
            
            # Backup inteligente: sempre sobrescrever boodesk_old.exe
            backup_old_name = "boodesk_old.exe"
            backup_old_path = os.path.join(download_dir, backup_old_name)
            
            try:
                import shutil
                # Sempre copiar o app atual como boodesk_old.exe (sobrescrever)
                shutil.copy2(current_exe, backup_old_path)
                print(f"‚úÖ Backup inteligente criado: {backup_old_path}")
                print(f"‚ÑπÔ∏è Este backup ser√° sobrescrito na pr√≥xima atualiza√ß√£o")
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao criar backup inteligente: {e}")
                # Continuar mesmo sem backup
            
            # 2. Verificar se o arquivo existe no R2
            progress_label.config(text="üîç Verificando arquivo no Cloudflare R2...")
            progress_bar['value'] = 15
            self.root.update_idletasks()
            
            try:
                response = requests.head(download_url, timeout=10)
                if response.status_code == 200:
                    file_size = int(response.headers.get('content-length', 0))
                    print(f"‚úÖ Arquivo encontrado! Tamanho: {file_size} bytes")
                    
                    # 3. Download do novo execut√°vel
                    progress_label.config(text="üì• Baixando nova vers√£o...")
                    progress_bar['value'] = 20
                    self.root.update_idletasks()
                    
                    download_response = requests.get(download_url, stream=True, timeout=60)
                    download_response.raise_for_status()
                    
                    downloaded_size = 0
                    
                    with open(new_exe_path, 'wb') as f:
                        for chunk in download_response.iter_content(chunk_size=8192):
                            if chunk:
                                f.write(chunk)
                                downloaded_size += len(chunk)
                                
                                # Atualizar progresso
                                if file_size > 0:
                                    progress = int((downloaded_size / file_size) * 60) + 20  # 20% a 80%
                                    progress_bar['value'] = progress
                                    
                                    # Atualizar label com tamanho
                                    downloaded_mb = downloaded_size / (1024 * 1024)
                                    total_mb = file_size / (1024 * 1024)
                                    progress_label.config(text=f"üì• Baixando... {downloaded_mb:.1f}MB / {total_mb:.1f}MB")
                                    self.root.update_idletasks()
                    
                    # 4. Verificar integridade do arquivo
                    progress_label.config(text="üîç Verificando integridade...")
                    progress_bar['value'] = 85
                    self.root.update_idletasks()
                    
                    if os.path.exists(new_exe_path):
                        downloaded_file_size = os.path.getsize(new_exe_path)
                        if downloaded_file_size > 0:
                            print(f"‚úÖ Arquivo baixado: {new_exe_path} ({downloaded_file_size} bytes)")
                        else:
                            raise Exception("Arquivo baixado est√° vazio")
                    else:
                        raise Exception("Arquivo n√£o foi baixado")
                    
                    # 5. Criar script de instala√ß√£o
                    progress_label.config(text="üìù Preparando instala√ß√£o...")
                    progress_bar['value'] = 90
                    self.root.update_idletasks()
                    
                    install_script_content = f"""@echo off
echo ========================================
echo    INSTALADOR DE ATUALIZACAO BOODESK
echo ========================================
echo.
echo Instalando nova versao do Boodesk...
echo.

REM Aguardar um pouco para garantir que o app foi fechado
echo Aguardando fechamento do aplicativo...
timeout /t 3 /nobreak > nul

REM Backup inteligente j√° foi criado como boodesk_old.exe
echo Backup inteligente ja foi criado como boodesk_old.exe
echo Este backup sera sobrescrito na proxima atualizacao

REM Substituir o executavel atual
if exist "{new_exe_name}" (
    echo Substituindo executavel...
    del "{current_name}"
    ren "{new_exe_name}" "{current_name}"
    echo Executavel atualizado com sucesso!
    
    REM Limpar arquivos temporarios
    if exist "install_update.bat" del "install_update.bat"
    
    echo.
    echo ========================================
    echo    ATUALIZACAO CONCLUIDA COM SUCESSO!
    echo ========================================
    echo.
    echo Iniciando nova versao...
    start "" "{current_name}"
    
    REM Fechar esta janela ap√≥s alguns segundos
    timeout /t 5 /nobreak > nul
    exit
) else (
    echo.
    echo ========================================
    echo    ERRO NA ATUALIZACAO!
    echo ========================================
    echo.
    echo ERRO: Arquivo {new_exe_name} nao encontrado!
    echo.
    echo Restaurando backup...
    if exist "{backup_name}" (
        copy "{backup_name}" "{current_name}"
        echo Backup restaurado com sucesso.
    ) else (
        echo ERRO: Backup nao encontrado!
    )
    echo.
    echo Pressione qualquer tecla para continuar...
    pause > nul
)
"""
                    
                    # Script de instala√ß√£o ser√° executado diretamente no c√≥digo
                    print("üìù Instala√ß√£o ser√° executada diretamente no c√≥digo")
                    
                    # 6. Finalizar
                    progress_bar['value'] = 100
                    progress_label.config(text="‚úÖ Download conclu√≠do com sucesso!")
                    self.root.update_idletasks()
                    
                    # Mostrar informa√ß√µes do backup
                    print(f"üì¶ Nova vers√£o: {new_exe_name}")
                    print(f"üíæ Backup criado: {backup_old_name}")
                    print(f"üìÅ Local: {download_dir}")
                    print(f"‚ÑπÔ∏è O backup ser√° sobrescrito na pr√≥xima atualiza√ß√£o")
                    
                    # 7. Salvar informa√ß√µes no banco
                    download_info = {
                        "download_date": datetime.now().isoformat(),
                        "file_path": new_exe_path,
                        "file_size": downloaded_file_size,
                        "backup_path": backup_path,
                        "installer_script": installer_script,
                        "source": "cloudflare_r2"
                    }
                    
                    try:
                        if hasattr(self, 'db') and self.db:
                            user_id = self.get_current_user_id() or 1
                            self.db.save_setting('last_update_download', json.dumps(download_info), user_id)
                            print("‚úÖ Informa√ß√µes do download salvas no banco")
                    except Exception as save_error:
                        print(f"‚ö†Ô∏è Erro ao salvar informa√ß√µes: {save_error}")
                    
                    # 8. Habilitar bot√µes
                    if update_window:
                        if hasattr(update_window, 'download_button'):
                            update_window.download_button.config(state='disabled', text="‚úÖ Download Conclu√≠do")
                        if hasattr(update_window, 'install_button'):
                            update_window.install_button.config(state='normal', text="üöÄ Instalar Atualiza√ß√£o")
                        if hasattr(update_window, 'open_location_button'):
                            update_window.open_location_button.config(state='normal', text="üìÅ Abrir Local do Execut√°vel")
                    
                    messagebox.showinfo("Download Conclu√≠do", 
                        f"Atualiza√ß√£o baixada com sucesso!\n\n"
                        f"Arquivo: {new_exe_path}\n"
                        f"Tamanho: {downloaded_file_size//1024//1024}MB\n"
                        f"Backup: {backup_path}\n\n"
                        "Clique em 'Instalar Atualiza√ß√£o' para aplicar a atualiza√ß√£o.\n"
                        "O aplicativo ser√° fechado automaticamente durante a instala√ß√£o.")
                else:
                    raise Exception(f"Arquivo n√£o encontrado no Cloudflare R2 (Status: {response.status_code})")
            except requests.exceptions.RequestException as req_error:
                raise Exception(f"Erro de conex√£o com Cloudflare R2: {req_error}")
            
        except Exception as e:
            error_msg = f"Erro no download: {e}"
            print(f"‚ùå {error_msg}")
            messagebox.showerror("Erro no Download", error_msg)
            progress_label.config(text="‚ùå Erro no download")
            progress_bar['value'] = 0
            def update_progress():
                current = progress_bar['value']
                if current < 100:
                    progress_bar['value'] += 10
                    if current < 30:
                        progress_label.config(text="Baixando arquivos...")
                    elif current < 60:
                        progress_label.config(text="Verificando integridade...")
                    elif current < 90:
                        progress_label.config(text="Finalizando download...")
                    else:
                        progress_label.config(text="Download conclu√≠do!")
                    
                    if current < 100:
                        self.root.after(500, update_progress)
                    else:
                        messagebox.showinfo("Download Conclu√≠do", "Atualiza√ß√£o baixada com sucesso!\nClique em 'Instalar Atualiza√ß√£o' para aplicar.")
            
            update_progress()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro no download: {e}")
            progress_label.config(text="Erro no download")
    
    
    def get_current_version(self):
        """Retorna a vers√£o atual do aplicativo"""
        try:
            # Tentar obter do banco de dados
            if hasattr(self, 'db') and self.db:
                conn = self.db.get_connection()
                if conn:
                    cursor = conn.cursor()
                    cursor.execute("""
                        SELECT versao FROM versoes_sistema 
                        WHERE ativo = true 
                        ORDER BY data_lancamento DESC 
                        LIMIT 1
                    """)
                    result = cursor.fetchone()
                    if result:
                        return result[0]
        except:
            pass
        
        # Fallback para vers√£o hardcoded
        return "2.4.9"
    def install_update(self, progress_bar, progress_label):
        """Instala a atualiza√ß√£o baixada com sistema robusto"""
        try:
            # Verificar se o download foi conclu√≠do com sucesso
            download_dir = self.get_download_directory()
            new_exe_path = os.path.join(download_dir, "boodesk_latest.exe")
            
            print(f"üîç Verificando arquivo de atualiza√ß√£o: {new_exe_path}")
            
            # Verificar se o arquivo novo existe e √© v√°lido
            if not os.path.exists(new_exe_path):
                print("‚ùå Arquivo de atualiza√ß√£o n√£o encontrado")
                messagebox.showwarning("Aviso", "Arquivo de atualiza√ß√£o n√£o encontrado.\n\nClique em '‚¨áÔ∏è Download Atualiza√ß√£o' primeiro!")
                return
            
            # Verificar se o arquivo √© v√°lido (m√≠nimo 50MB)
            file_size = os.path.getsize(new_exe_path)
            print(f"üì¶ Tamanho do arquivo: {file_size} bytes ({file_size//1024//1024}MB)")
            
            if file_size < self.UPDATE_CONFIG['MIN_FILE_SIZE']:
                print("‚ùå Arquivo de atualiza√ß√£o muito pequeno (possivelmente corrompido)")
                messagebox.showerror("Erro", f"Arquivo de atualiza√ß√£o inv√°lido ou corrompido!\n\nTamanho: {file_size//1024//1024}MB (m√≠nimo: {self.UPDATE_CONFIG['MIN_FILE_SIZE']//1024//1024}MB)\n\nTente fazer o download novamente.")
                return
            
            print("‚úÖ Todos os arquivos necess√°rios encontrados")
            
            progress_label.config(text="üöÄ Preparando instala√ß√£o...")
            progress_bar['value'] = 0
            self.root.update_idletasks()
            
            # Confirmar instala√ß√£o
            result = messagebox.askyesno("Confirmar Instala√ß√£o", 
                "A instala√ß√£o ir√°:\n\n"
                "1. Fazer backup do execut√°vel atual\n"
                "2. Substituir pelo novo execut√°vel\n"
                "3. Fechar o aplicativo atual\n"
                "4. Abrir a nova vers√£o\n\n"
                "Deseja continuar?")
            
            if not result:
                return
            
            progress_label.config(text="üìù Salvando configura√ß√µes...")
            progress_bar['value'] = 20
            self.root.update_idletasks()
            
            # Salvar informa√ß√µes da instala√ß√£o
            try:
                if hasattr(self, 'db') and self.db:
                    user_id = self.get_current_user_id() or 1
                    install_info = {
                        "install_date": datetime.now().isoformat(),
                        "version": self.get_current_version(),
                        "source": "cloudflare_r2",
                        "new_exe_path": new_exe_path
                    }
                    self.db.save_setting('last_update_install', json.dumps(install_info), user_id)
                    print("‚úÖ Informa√ß√µes da instala√ß√£o salvas no banco")
            except Exception as save_error:
                print(f"‚ö†Ô∏è Erro ao salvar informa√ß√µes: {save_error}")
            
            progress_label.config(text="üîÑ Iniciando processo de instala√ß√£o...")
            progress_bar['value'] = 50
            self.root.update_idletasks()
            
            # Executar instala√ß√£o robusta
            try:
                print("üîÑ Iniciando instala√ß√£o robusta...")
                
                # 1. Fazer backup do execut√°vel atual
                current_exe_path = self.get_current_executable_path()
                backup_path = None
                
                if current_exe_path and os.path.exists(current_exe_path):
                    backup_path = current_exe_path + ".backup"
                    import shutil
                    shutil.copy2(current_exe_path, backup_path)
                    print(f"‚úÖ Backup criado: {backup_path}")
                
                # 2. Obter diret√≥rio da aplica√ß√£o
                app_dir = self.get_app_directory()
                target_exe_path = os.path.join(app_dir, "BoodeskApp.exe")
                
                # 3. Copiar nova vers√£o
                if os.path.exists(new_exe_path):
                    import shutil
                    shutil.copy2(new_exe_path, target_exe_path)
                    print(f"‚úÖ Nova vers√£o copiada: {target_exe_path}")
                    
                    # 4. Verificar integridade da nova vers√£o
                    if os.path.exists(target_exe_path):
                        new_size = os.path.getsize(target_exe_path)
                        if new_size >= self.UPDATE_CONFIG['MIN_FILE_SIZE']:
                            print("‚úÖ Integridade da nova vers√£o verificada")
                            
                            # 5. Limpar arquivos tempor√°rios
                            try:
                                os.remove(new_exe_path)
                                print("‚úÖ Arquivo tempor√°rio removido")
                            except:
                                pass
                            
                            # 6. Iniciar nova vers√£o
                            print("üöÄ Iniciando nova vers√£o...")
                            import subprocess
                            subprocess.Popen([target_exe_path], cwd=app_dir)
                            
                            # 7. Fechar aplica√ß√£o atual
                            print("üëã Fechando aplica√ß√£o atual...")
                            self.root.after(2000, self.root.quit)
                            
                        else:
                            raise Exception(f"Arquivo copiado inv√°lido: {new_size} bytes")
                    else:
                        raise Exception("Falha ao copiar arquivo")
                else:
                    raise Exception("Arquivo de nova vers√£o n√£o encontrado")
                    
            except Exception as e:
                print(f"‚ùå Erro na instala√ß√£o: {e}")
                messagebox.showerror("Erro", f"Erro na instala√ß√£o: {e}")
                
                # Rollback autom√°tico
                if backup_path and os.path.exists(backup_path):
                    try:
                        import shutil
                        shutil.copy2(backup_path, current_exe_path)
                        print("‚úÖ Rollback autom√°tico executado")
                        messagebox.showinfo("Rollback", "Rollback autom√°tico executado. Aplicativo restaurado.")
                    except Exception as rollback_error:
                        print(f"‚ùå Falha no rollback: {rollback_error}")
                        messagebox.showerror("Erro Cr√≠tico", "Falha no rollback. Restaure manualmente o backup.")
                
                progress_label.config(text="‚ùå Erro na instala√ß√£o")
                progress_bar['value'] = 0
                self.root.update_idletasks()
                return
            
            progress_label.config(text="‚úÖ Instala√ß√£o conclu√≠da!")
            progress_bar['value'] = 100
            self.root.update_idletasks()
            
            # Mostrar mensagem final
            messagebox.showinfo("Instala√ß√£o Conclu√≠da", 
                "A instala√ß√£o foi conclu√≠da com sucesso!\n\n"
                "O aplicativo ser√° fechado e a nova vers√£o ser√° aberta automaticamente.\n\n"
                "Se algo der errado, o rollback ser√° executado automaticamente.")
                
        except Exception as e:
            print(f"‚ùå Erro geral na instala√ß√£o: {e}")
            messagebox.showerror("Erro", f"Erro geral na instala√ß√£o: {e}")
            progress_label.config(text="‚ùå Erro na instala√ß√£o")
            progress_bar['value'] = 0
            self.root.update_idletasks()


    def open_executable_location(self):
        """Abre o local do execut√°vel baixado"""
        try:
            import subprocess
            import platform
            
            # Caminho do execut√°vel baixado (correto)
            download_dir = self.get_download_directory()
            new_exe_path = os.path.join(download_dir, "boodesk_latest.exe")
            
            print(f"üîç Verificando arquivo: {new_exe_path}")
            
            if not os.path.exists(new_exe_path):
                print("‚ùå Arquivo de atualiza√ß√£o n√£o encontrado")
                messagebox.showwarning("Aviso", "Arquivo de atualiza√ß√£o n√£o encontrado.\n\nClique em '‚¨áÔ∏è Download Atualiza√ß√£o' primeiro!")
                return
            
            # Verificar se o arquivo √© v√°lido
            file_size = os.path.getsize(new_exe_path)
            print(f"üì¶ Tamanho do arquivo: {file_size} bytes ({file_size//1024//1024}MB)")
            
            if file_size < 50*1024*1024:  # Menos de 50MB
                print("‚ùå Arquivo de atualiza√ß√£o muito pequeno")
                messagebox.showwarning("Aviso", "Arquivo de atualiza√ß√£o inv√°lido.\n\nTente fazer o download novamente.")
                return
            
            # Abrir o explorador de arquivos no local do execut√°vel
            if platform.system() == "Windows":
                subprocess.run(["explorer", "/select,", new_exe_path])
            elif platform.system() == "Darwin":  # macOS
                subprocess.run(["open", "-R", new_exe_path])
            else:  # Linux
                subprocess.run(["xdg-open", os.path.dirname(new_exe_path)])
                
            print(f"‚úÖ Local do execut√°vel aberto: {new_exe_path}")
            
        except Exception as e:
            print(f"‚ùå Erro ao abrir local do execut√°vel: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir local do execut√°vel: {e}")
        except Exception as e:
            print(f"‚ùå Erro ao abrir local do execut√°vel: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir local do execut√°vel: {e}")

    def configure_download_directory(self):
        """Permite ao usu√°rio configurar o diret√≥rio de download"""
        try:
            import tkinter.filedialog as filedialog
            
            current_dir = self.get_download_directory()
            
            # Abrir di√°logo para selecionar diret√≥rio
            new_dir = filedialog.askdirectory(
                title="Selecionar Diret√≥rio de Download",
                initialdir=current_dir
            )
            
            if new_dir:
                if self.set_download_directory(new_dir):
                    messagebox.showinfo("Sucesso", f"Diret√≥rio de download configurado:\n{new_dir}")
                    self.update_download_dir_label()
                else:
                    messagebox.showerror("Erro", "N√£o foi poss√≠vel configurar o diret√≥rio de download")
            
        except Exception as e:
            print(f"‚ùå Erro ao configurar diret√≥rio: {e}")
            messagebox.showerror("Erro", f"Erro ao configurar diret√≥rio: {e}")

    def update_download_dir_label(self):
        """Atualiza o label mostrando o diret√≥rio de download atual"""
        try:
            if hasattr(self, 'download_dir_label'):
                current_dir = self.get_download_directory()
                # Mostrar apenas o nome do diret√≥rio ou caminho abreviado
                if len(current_dir) > 40:
                    display_dir = "..." + current_dir[-37:]
                else:
                    display_dir = current_dir
                self.download_dir_label.config(text=f"üìÅ {display_dir}")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao atualizar label: {e}")


    def show_advanced_update_settings(self, parent_window):
        """Mostra configura√ß√µes avan√ßadas de atualiza√ß√£o"""
        try:
            settings_window = tk.Toplevel(parent_window)
            settings_window.title("Configura√ß√µes Avan√ßadas - Atualiza√ß√µes")
            settings_window.geometry("500x400")
            settings_window.transient(parent_window)
            settings_window.grab_set()
            
            # Frame principal
            main_frame = ttk.Frame(settings_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # T√≠tulo
            ttk.Label(main_frame, text="üîß Configura√ß√µes Avan√ßadas", 
                     font=('Segoe UI', 14, 'bold')).pack(pady=(0, 20))
            
            # Op√ß√µes de atualiza√ß√£o
            options_frame = ttk.LabelFrame(main_frame, text="Op√ß√µes de Atualiza√ß√£o", padding=15)
            options_frame.pack(fill='x', pady=(0, 20))
            
            # Checkboxes
            auto_check_var = tk.BooleanVar(value=True)
            ttk.Checkbutton(options_frame, text="Verificar atualiza√ß√µes automaticamente", 
                           variable=auto_check_var).pack(anchor='w', pady=2)
            
            auto_download_var = tk.BooleanVar(value=False)
            ttk.Checkbutton(options_frame, text="Baixar atualiza√ß√µes automaticamente", 
                           variable=auto_download_var).pack(anchor='w', pady=2)
            
            beta_updates_var = tk.BooleanVar(value=False)
            ttk.Checkbutton(options_frame, text="Receber atualiza√ß√µes beta", 
                           variable=beta_updates_var).pack(anchor='w', pady=2)
            
            # Frequ√™ncia de verifica√ß√£o
            freq_frame = ttk.Frame(options_frame)
            freq_frame.pack(fill='x', pady=(10, 0))
            
            ttk.Label(freq_frame, text="Frequ√™ncia de verifica√ß√£o:").pack(side='left')
            freq_var = tk.StringVar(value="di√°ria")
            freq_combo = ttk.Combobox(freq_frame, textvariable=freq_var, 
                                     values=["di√°ria", "semanal", "mensal"], 
                                     state="readonly", width=10)
            freq_combo.pack(side='left', padx=(10, 0))
            
            # Bot√µes
            button_frame = ttk.Frame(main_frame)
            button_frame.pack(fill='x', pady=(20, 0))
            
            ttk.Button(button_frame, text="Salvar", 
                      command=lambda: self.save_update_settings(auto_check_var, auto_download_var, 
                                                              beta_updates_var, freq_var, settings_window)).pack(side='left', padx=(0, 10))
            ttk.Button(button_frame, text="Cancelar", 
                      command=settings_window.destroy).pack(side='right')
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir configura√ß√µes: {e}")
    
    def save_update_settings(self, auto_check_var, auto_download_var, beta_updates_var, freq_var, window):
        """Salva as configura√ß√µes de atualiza√ß√£o"""
        try:
            # Aqui voc√™ pode salvar as configura√ß√µes no banco de dados ou arquivo
            settings = {
                'auto_check': auto_check_var.get(),
                'auto_download': auto_download_var.get(),
                'beta_updates': beta_updates_var.get(),
                'frequency': freq_var.get()
            }
            
            # Simular salvamento
            print(f"Configura√ß√µes salvas: {settings}")
            
            messagebox.showinfo("Sucesso", "Configura√ß√µes salvas com sucesso!")
            window.destroy()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar configura√ß√µes: {e}")
    
    def show_update_history(self, parent_window):
        """Mostra hist√≥rico de atualiza√ß√µes"""
        try:
            history_window = tk.Toplevel(parent_window)
            history_window.title("Hist√≥rico de Atualiza√ß√µes")
            history_window.geometry("600x400")
            history_window.transient(parent_window)
            history_window.grab_set()
            
            # Frame principal
            main_frame = ttk.Frame(history_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # T√≠tulo
            ttk.Label(main_frame, text="üìã Hist√≥rico de Atualiza√ß√µes", 
                     font=('Segoe UI', 14, 'bold')).pack(pady=(0, 20))
            
            # Treeview para hist√≥rico
            columns = ("Data", "Vers√£o", "Tipo", "Status")
            history_tree = ttk.Treeview(main_frame, columns=columns, show="headings", height=15)
            
            for col in columns:
                history_tree.heading(col, text=col)
                history_tree.column(col, width=120, anchor="center")
            
            # Scrollbar
            scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=history_tree.yview)
            history_tree.configure(yscrollcommand=scrollbar.set)
            
            # Posicionar
            history_tree.pack(side='left', fill='both', expand=True)
            scrollbar.pack(side='right', fill='y')
            
            # Dados de exemplo
            sample_data = [
                ("25/08/2025", "2.3.1", "Atualiza√ß√£o", "‚úÖ Instalada"),
                ("20/08/2025", "2.3.0", "Atualiza√ß√£o", "‚úÖ Instalada"),
                ("15/08/2025", "2.2.9", "Corre√ß√£o", "‚úÖ Instalada"),
                ("10/08/2025", "2.2.8", "Atualiza√ß√£o", "‚úÖ Instalada"),
                ("05/08/2025", "2.2.7", "Corre√ß√£o", "‚úÖ Instalada"),
            ]
            
            for item in sample_data:
                history_tree.insert("", "end", values=item)
            
            # Bot√£o de fechar
            ttk.Button(main_frame, text="Fechar", 
                      command=history_window.destroy).pack(pady=(20, 0))
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir hist√≥rico: {e}")
    
    def show_about_dialog(self):
        """Mostra a janela Sobre o Boodesk"""
        try:
            about_window = tk.Toplevel(self.root)
            about_window.title("Sobre o Boodesk")
            about_window.geometry("400x300")
            about_window.resizable(False, False)
            about_window.transient(self.root)
            about_window.grab_set()
            
            # Centralizar a janela
            about_window.update_idletasks()
            x = (about_window.winfo_screenwidth() // 2) - (400 // 2)
            y = (about_window.winfo_screenheight() // 2) - (300 // 2)
            about_window.geometry(f"400x300+{x}+{y}")
            
            # Frame principal
            main_frame = ttk.Frame(about_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # Logo/T√≠tulo
            title_label = ttk.Label(main_frame, text="üéØ BOODESK", 
                                   font=('Segoe UI', 20, 'bold'))
            title_label.pack(pady=(0, 10))
            
            subtitle_label = ttk.Label(main_frame, text="Sistema de Gerenciamento de Tarefas", 
                                      font=('Segoe UI', 12))
            subtitle_label.pack(pady=(0, 20))
            
            # Informa√ß√µes
            info_text = """
Vers√£o: 2.3.1
Desenvolvido por: Thalles Daniel
Data: Agosto 2025

Sistema completo de gerenciamento de tarefas
com integra√ß√£o PostgreSQL/Supabase e
interface moderna em Tkinter.

Funcionalidades:
‚Ä¢ Quadros Kanban
‚Ä¢ Sistema Pomodoro
‚Ä¢ Chat em tempo real
‚Ä¢ Dashboard executivo
‚Ä¢ Integra√ß√£o com calend√°rio
‚Ä¢ Upload de arquivos
‚Ä¢ Relat√≥rios avan√ßados
            """
            
            info_label = ttk.Label(main_frame, text=info_text, 
                                  font=('Segoe UI', 9), justify='left')
            info_label.pack(pady=(0, 20))
            
            # Bot√£o fechar
            close_button = ttk.Button(main_frame, text="Fechar", 
                                     command=about_window.destroy)
            close_button.pack()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir janela Sobre: {e}")

    def __init__(self, root):
        self.root = root
        self.db = Database()
        self.db.create_tables()
        self.current_user = None
        self.login_successful = False
        self.boodesk_data = {'boards': {}}
        self.icons = load_app_icons(os.path.dirname(os.path.abspath(__file__)))
        self.listbox_refs = {}
        self.theme_color = "#0079BF"
        self.pomodoro_timer = None
        self.pomodoro_running = False
        self.pomodoro_start_time = None
        self.pomodoro_session_type = "work" # "work" or "break"
        self.pomodoro_work_duration = 25 * 60
        self.pomodoro_break_duration = 5 * 60
        self.pomodoro_task = None
        self.notification_manager = NotificationManager(self)
        self.meeting_integration = GoogleCalendarManager()
        self.email_integration = EmailIntegration(self)
        self.settings = self.load_settings()
        
        self.root.title("Boodesk - Sistema de Gerenciamento de Tarefas")
        self.root.geometry("1200x800")
        
        self.show_login_window()
        
        if self.login_successful:
            self.load_and_apply_user_theme()
            self.load_and_apply_user_theme()
            self.create_main_widgets()
            self.load_trello_data()
            self.populate_boards()
            self.notification_manager.start_notification_monitor()
            self.email_integration.start_email_service()
        else:
            self.root.destroy()
        
        # Criar menu ap√≥s todos os m√©todos terem sido definidos
        # self.create_menu() ser√° chamado ap√≥s create_widgets


    # Removed load_data_from_db method - now using load_trello_data which loads from SQL

    def add_card(self, board_name, list_name, card_title, card_desc, card_due_date, card_importance, subject="-", goal="-", members=None, git_branch="", git_commit="", recurrence="Nenhuma", dependencies=None):
        """Add card directly to SQL database"""
        try:
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Get or create board
            board_id = self.get_board_id_by_name(board_name)
            if not board_id:
                board_id = self.db.create_board(board_name, owner_id=user_id)
            
            # Create card in database
            card_id = self.db.create_card(
                board_id=board_id,
                list_name=list_name,
                title=card_title,
                description=card_desc,
                status='to_do',
                importance=card_importance,
                due_date=card_due_date,
                subject=subject,
                goal=goal,
                members=members or [],
                git_branch=git_branch,
                git_commit=git_commit,
                recurrence=recurrence,
                dependencies=dependencies or [],
                user_id=user_id
            )
            
            # Reload data from database
            self.load_trello_data()
            self.populate_boards()
            return card_id
        except Exception as e:
            print(f"Erro ao adicionar cart√£o: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel adicionar o cart√£o: {e}")
            return None

    def update_card_data(self, card_id, title, desc, due_date, importance, subject=None, goal=None, members=None, git_branch=None, git_commit=None, recurrence=None, dependencies=None):
        """Update card directly in SQL database"""
        try:
            self.db.update_card(
                card_id=card_id,
                title=title,
                description=desc,
                status='to_do',
                importance=importance,
                due_date=due_date,
                subject=subject,
                goal=goal,
                members=members,
                git_branch=git_branch,
                git_commit=git_commit,
                recurrence=recurrence,
                dependencies=dependencies
            )
            # Reload data from database
            self.load_trello_data()
            self.populate_boards()
        except Exception as e:
            print(f"Erro ao atualizar cart√£o: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel atualizar o cart√£o: {e}")

    def move_card_data(self, source_board_name, source_list_name, card_id, target_board_name, target_list_name):
        """Move card directly in SQL database with proper list_name update and logging"""
        # Usar otimizador se dispon√≠vel
        if hasattr(self, 'kanban_optimizer') and self.kanban_optimizer:
            return self.kanban_optimizer._optimized_move_card(
                card_id, source_board_name, source_list_name, target_board_name, target_list_name
            )
        
        # Fallback para m√©todo original
        try:
            print(f"üîÑ SISTEMA: Iniciando movimenta√ß√£o de card")
            print(f"üìã Card ID: {card_id}")
            print(f"üìç Origem: '{source_board_name}' / '{source_list_name}'")
            print(f"üéØ Destino: '{target_board_name}' / '{target_list_name}'")
            
            # Obter board_id do quadro de destino
            target_board_id = self.get_board_id_by_name(target_board_name)
            if not target_board_id:
                print(f"‚ùå ERRO: Board '{target_board_name}' n√£o encontrado no banco")
                print(f"‚ùå ERRO: Quadro '{target_board_name}' n√£o encontrado!")
                return False
            
            print(f"‚úÖ Board ID encontrado: {target_board_id}")
            
            # Verificar se o card existe antes de mover
            card_exists = self.db.get_card_by_id(card_id)
            if not card_exists:
                print(f"‚ùå ERRO: Card {card_id} n√£o encontrado no banco")
                print(f"‚ùå ERRO: Cart√£o n√£o encontrado no banco de dados!")
                return False
            
            print(f"‚úÖ Card encontrado no banco: {card_exists.get('title', 'Sem t√≠tulo')}")
            
            # ATUALIZAR O CARD NO BANCO DE DADOS POSTGRESQL
            print(f"üîÑ Atualizando card no PostgreSQL...")
            success = self.db.move_card(card_id, target_board_id, target_list_name)
            
            if success:
                print(f"‚úÖ SUCESSO: Card {card_id} movido para '{target_board_name}/{target_list_name}'")
                
                # REGISTRAR NO LOG DO SISTEMA
                try:
                    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    user_name = self.current_user.username if self.current_user else "Sistema"
                    
                    # Log detalhado da movimenta√ß√£o
                    log_entry = {
                        "timestamp": current_time,
                        "action": "MOVIMENTA√á√ÉO DE CARD",
                        "user": user_name,
                        "card_id": card_id,
                        "card_title": card_exists.get('title', 'Sem t√≠tulo'),
                        "source_board": source_board_name,
                        "source_list": source_list_name,
                        "target_board": target_board_name,
                        "target_list": target_list_name,
                        "target_board_id": target_board_id,
                        "status": "SUCESSO"
                    }
                    
                    print(f"üìù LOG SISTEMA: {log_entry}")
                    
                    # Adicionar ao hist√≥rico do card
                    card_data = self.db.get_card_by_id(card_id)
                    if card_data:
                        history = card_data.get('history', [])
                        if isinstance(history, str):
                            try:
                                import json
                                history = json.loads(history)
                            except:
                                history = []
                        if not isinstance(history, list):
                            history = []
                        
                        # Adicionar entrada detalhada no hist√≥rico
                        history_entry = {
                            "timestamp": current_time,
                            "action": f"Card movido de '{source_list_name}' para '{target_list_name}'",
                            "user": user_name,
                            "source_board": source_board_name,
                            "source_list": source_list_name,
                            "target_board": target_board_name,
                            "target_list": target_list_name,
                            "list_name_updated": target_list_name,
                            "board_id_updated": target_board_id
                        }
                        
                        history.append(history_entry)
                        
                        # Atualizar hist√≥rico no banco
                        self.update_card_history(card_id, history)
                        print(f"‚úÖ Hist√≥rico atualizado no banco")
                
                except Exception as history_error:
                    print(f"‚ö†Ô∏è Erro ao registrar hist√≥rico: {history_error}")
                
                # Notifica√ß√£o por email se habilitada
                try:
                    if hasattr(self, 'email_integration') and self.email_integration:
                        card_data = {
                            "title": card_exists.get("title", "Sem t√≠tulo"),
                            "board": target_board_name,
                            "column": target_list_name,
                            "modified_by": user_name,
                            "modified_date": current_time
                        }
                        changes = [f"Cart√£o movido de '{source_list_name}' para '{target_list_name}'"]
                        self.email_integration.notify_card_modified(card_data, changes)
                except Exception as email_error:
                    print(f"‚ö†Ô∏è Erro ao enviar notifica√ß√£o por email: {email_error}")
                
                # RECARREGAR DADOS DO BANCO E ATUALIZAR INTERFACE
                print(f"üîÑ Recarregando dados do banco...")
                self.load_trello_data()
                self.populate_boards()
                
                print(f"‚úÖ INTERFACE: Dados recarregados e interface atualizada")
                
                # Log de sucesso no terminal (sem popup)
                print(f"‚úÖ SUCESSO: Cart√£o movido com sucesso para '{target_list_name}'!")
                return True
            else:
                print(f"‚ùå FALHA: N√£o foi poss√≠vel mover card {card_id} no banco")
                print(f"‚ùå ERRO: Falha ao mover o cart√£o no banco de dados!")
                return False
                
        except Exception as e:
            print(f"‚ùå ERRO CR√çTICO ao mover cart√£o: {e}")
            print(f"‚ùå ERRO: N√£o foi poss√≠vel mover o cart√£o: {e}")
            return False

    def delete_card(self, board_name, list_name, card_id):
        """Delete card directly from SQL database"""
        try:
            self.db.delete_card(card_id)
            # Reload data from database
            self.load_trello_data()
            self.populate_boards()
        except Exception as e:
            print(f"Erro ao deletar cart√£o: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel deletar o cart√£o: {e}")
    
    def update_card_history(self, card_id, history):
        """Atualiza o hist√≥rico de um card no banco de dados"""
        try:
            if hasattr(self.db, 'update_card_history'):
                self.db.update_card_history(card_id, history)
            else:
                # Fallback: atualizar o card com o hist√≥rico
                card_data = self.db.get_card_by_id(card_id)
                if card_data:
                    card_data['history'] = history
                    self.db.update_card(card_id, card_data)
            print(f"‚úÖ Hist√≥rico do card {card_id} atualizado no banco")
        except Exception as e:
            print(f"‚ùå Erro ao atualizar hist√≥rico do card {card_id}: {e}")
    
    def verify_card_consistency(self):
        """Verifica e corrige inconsist√™ncias nos dados dos cards"""
        try:
            print(f"üîç SISTEMA: Iniciando verifica√ß√£o de consist√™ncia dos cards")
            
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print(f"‚ùå Banco n√£o dispon√≠vel para verifica√ß√£o")
                return False
            
            # Obter todos os cards do banco
            all_cards = self.db.get_all_cards()
            if not all_cards:
                print(f"‚ÑπÔ∏è Nenhum card encontrado no banco")
                return True
            
            print(f"üìã Verificando {len(all_cards)} cards no banco...")
            
            inconsistencies_found = 0
            fixed_cards = 0
            
            for card in all_cards:
                card_id = card.get('card_id')
                list_name = card.get('list_name')
                board_id = card.get('board_id')
                title = card.get('title', 'Sem t√≠tulo')
                
                # Verificar se o card tem list_name v√°lido
                if not list_name or list_name.strip() == '':
                    print(f"‚ö†Ô∏è Card '{title}' (ID: {card_id}) sem list_name - corrigindo...")
                    try:
                        self.db.update_card_list_name(card_id, 'A Fazer')
                        inconsistencies_found += 1
                        fixed_cards += 1
                        print(f"‚úÖ Card '{title}' corrigido - list_name definido como 'A Fazer'")
                    except Exception as e:
                        print(f"‚ùå Erro ao corrigir card '{title}': {e}")
                
                # Verificar se o board_id √© v√°lido
                if not board_id:
                    print(f"‚ö†Ô∏è Card '{title}' (ID: {card_id}) sem board_id - corrigindo...")
                    try:
                        # Obter o primeiro board dispon√≠vel
                        boards = self.db.get_boards()
                        if boards:
                            default_board_id = boards[0]['id']
                            self.db.update_card_board_id(card_id, default_board_id)
                            inconsistencies_found += 1
                            fixed_cards += 1
                            print(f"‚úÖ Card '{title}' corrigido - board_id definido como {default_board_id}")
                    except Exception as e:
                        print(f"‚ùå Erro ao corrigir board_id do card '{title}': {e}")
            
            print(f"üìä RESULTADO DA VERIFICA√á√ÉO:")
            print(f"   - Cards verificados: {len(all_cards)}")
            print(f"   - Inconsist√™ncias encontradas: {inconsistencies_found}")
            print(f"   - Cards corrigidos: {fixed_cards}")
            
            if fixed_cards > 0:
                print(f"üîÑ Recarregando dados ap√≥s corre√ß√µes...")
                self.load_trello_data()
                self.populate_boards()
                print(f"‚úÖ Dados recarregados ap√≥s corre√ß√µes")
            
            return True
            
        except Exception as e:
            print(f"‚ùå ERRO na verifica√ß√£o de consist√™ncia: {e}")
            return False
    
    def force_update_card_list_name(self, card_id, new_list_name):
        """For√ßa a atualiza√ß√£o do list_name de um card no banco de dados"""
        try:
            print(f"üîÑ FOR√áANDO atualiza√ß√£o do list_name do card {card_id} para '{new_list_name}'")
            
            # Verificar se o card existe
            card_data = self.db.get_card_by_id(card_id)
            if not card_data:
                print(f"‚ùå Card {card_id} n√£o encontrado no banco")
                return False
            
            # Verificar se o m√©todo existe no banco
            if not hasattr(self.db, 'update_card_list_name'):
                print(f"‚ö†Ô∏è M√©todo update_card_list_name n√£o encontrado no banco, usando SQL direto")
                # Usar SQL direto como fallback
                success = self.db.execute_sql_update_card_list_name(card_id, new_list_name)
            else:
                # Atualizar diretamente no banco
                success = self.db.update_card_list_name(card_id, new_list_name)
            
            if success:
                print(f"‚úÖ Card {card_id} atualizado com sucesso - list_name: '{new_list_name}'")
                
                # Registrar no log
                current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                user_name = self.current_user.username if self.current_user else "Sistema"
                
                log_entry = {
                    "timestamp": current_time,
                    "action": "FOR√áA ATUALIZA√á√ÉO LIST_NAME",
                    "user": user_name,
                    "card_id": card_id,
                    "card_title": card_data.get('title', 'Sem t√≠tulo'),
                    "old_list_name": card_data.get('list_name', 'Desconhecido'),
                    "new_list_name": new_list_name,
                    "status": "SUCESSO"
                }
                
                print(f"üìù LOG SISTEMA: {log_entry}")
                
                # Recarregar dados
                self.load_trello_data()
                self.populate_boards()
                
                return True
            else:
                print(f"‚ùå Falha ao atualizar card {card_id}")
                return False
                
        except Exception as e:
            print(f"‚ùå ERRO ao for√ßar atualiza√ß√£o do card {card_id}: {e}")
            return False
    
    def check_database_methods(self):
        """Verifica se os m√©todos necess√°rios existem no banco de dados"""
        try:
            print(f"üîç Verificando m√©todos do banco de dados...")
            
            required_methods = [
                'get_all_cards',
                'update_card_list_name', 
                'update_card_board_id',
                'get_card_by_id',
                'move_card'
            ]
            
            missing_methods = []
            
            for method in required_methods:
                if not hasattr(self.db, method):
                    missing_methods.append(method)
                    print(f"‚ö†Ô∏è M√©todo '{method}' n√£o encontrado no banco")
                else:
                    print(f"‚úÖ M√©todo '{method}' encontrado no banco")
            
            if missing_methods:
                print(f"‚ùå M√©todos faltando: {missing_methods}")
                return False
            else:
                print(f"‚úÖ Todos os m√©todos necess√°rios est√£o dispon√≠veis")
                return True
                
        except Exception as e:
            print(f"‚ùå Erro ao verificar m√©todos do banco: {e}")
            return False



    def send_weekly_report(self):
        """Envia relat√≥rio semanal por email"""
        try:
            report_data = self._generate_weekly_report()
            
            subject = f"Relat√≥rio Semanal - {report_data['week_period']}"
            body = f"""
Resumo Geral:
- Total de cart√µes: {report_data['total_cards']}
- Cart√µes criados: {report_data['cards_created']}
- Cart√µes conclu√≠dos: {report_data['cards_completed']}
- Cart√µes em atraso: {report_data['overdue_cards']}

Produtividade:
- Taxa de conclus√£o: {report_data['completion_rate']}%
- Tempo m√©dio de conclus√£o: {report_data['avg_completion_time']} dias

Cart√µes Mais Importantes:
{report_data['top_important_cards']}

Pr√≥ximos Prazos:
{report_data['upcoming_deadlines']}

---
Boodesk - Sistema de Gerenciamento de Tarefas
"""
            body = body.strip()
            
            recipients = self.settings.get('notification_recipients', [])
            for recipient in recipients:
                self.send_email(recipient, subject, body)
                
        except Exception as e:
            print(f"Erro ao enviar relat√≥rio semanal: {e}")
    
    def _generate_weekly_report(self):
        """Gera dados para o relat√≥rio semanal"""
        try:
            now = datetime.now()
            week_start = now - timedelta(days=7)
            
            total_cards = 0
            cards_created = 0
            cards_completed = 0
            overdue_cards = 0
            important_cards = []
            upcoming_deadlines = []
            
            for board_name, board_data in self.app.boodesk_data.get('boards', {}).items():
                for list_name, cards in board_data.items():
                    if list_name != 'workflow':
                        total_cards += len(cards)
                        
                        for card in cards:
                            # Cart√µes criados na semana
                            creation_date = card.get('creation_date', '')
                            if creation_date:
                                try:
                                    card_creation = datetime.strptime(creation_date, '%Y-%m-%d %H:%M:%S')
                                    if card_creation >= week_start:
                                        cards_created += 1
                                except ValueError:
                                    pass
                            
                            # Cart√µes conclu√≠dos
                            if list_name == 'Conclu√≠do':
                                cards_completed += 1
                            
                            # Cart√µes em atraso
                            due_date_str = card.get('due_date', '')
                            if due_date_str:
                                try:
                                    due_date = datetime.strptime(due_date_str, '%Y-%m-%d %H:%M')
                                    if due_date < now and list_name != 'Conclu√≠do':
                                        overdue_cards += 1
                                except ValueError:
                                    pass
                            
                            # Cart√µes importantes
                            if card.get('importance') in ['Alta', 'Cr√≠tica']:
                                important_cards.append(card.get('title', ''))
                            
                            # Pr√≥ximos prazos
                            if due_date_str:
                                try:
                                    due_date = datetime.strptime(due_date_str, '%Y-%m-%d %H:%M')
                                    if due_date > now and due_date <= now + timedelta(days=7):
                                        upcoming_deadlines.append(f"{card.get('title', '')} - {due_date_str}")
                                except ValueError:
                                    pass
            
            completion_rate = (cards_completed / total_cards * 100) if total_cards > 0 else 0
            
            return {
                'week_period': f"{week_start.strftime('%d/%m')} - {now.strftime('%d/%m/%Y')}",
                'total_cards': total_cards,
                'cards_created': cards_created,
                'cards_completed': cards_completed,
                'overdue_cards': overdue_cards,
                'completion_rate': round(completion_rate, 1),
                'avg_completion_time': '3.5',  # Placeholder
                'top_important_cards': '\n'.join(important_cards[:5]),
                'upcoming_deadlines': '\n'.join(upcoming_deadlines[:5])
            }
            
        except Exception as e:
            print(f"Erro ao gerar relat√≥rio semanal: {e}")
            return {}


class GoogleCalendarIntegration:
    """Integra√ß√£o com Google Calendar para sincroniza√ß√£o de eventos"""
    
    SCOPES = ['https://www.googleapis.com/auth/calendar']
    
    def __init__(self, app):
        self.app = app
        self.service = None
        self.credentials = None
        self.calendar_id = 'primary'
        self.token_file = os.path.join(self.app.base_dir, 'google_calendar_token.pickle')
        self.credentials_file = os.path.join(self.app.base_dir, 'google_calendar_credentials.json')
        self.is_authenticated = False
        
    def authenticate(self):
        """Autentica com Google Calendar API"""
        try:
            # Verificar se as bibliotecas est√£o dispon√≠veis
            try:
                from google.auth.transport.requests import Request
                from google_auth_oauthlib.flow import InstalledAppFlow
                from googleapiclient.discovery import build
                from googleapiclient.errors import HttpError
                import pickle
            except ImportError as e:
                print(f"‚ùå Bibliotecas do Google Calendar n√£o dispon√≠veis: {e}")
                messagebox.showerror("Erro", 
                                   f"Bibliotecas do Google Calendar n√£o est√£o instaladas.\n\n"
                                   f"Execute: pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
                return False
            
            # Verificar se h√° credenciais configuradas
            calendar_settings = self.app.settings.get('calendar_integration', {})
            
            if calendar_settings.get('auth_type') == 'json':
                # Usar arquivo JSON
                credentials_file = calendar_settings.get('credentials_file', '')
                if not credentials_file or not os.path.exists(credentials_file):
                    messagebox.showwarning(
                        "Configura√ß√£o Necess√°ria",
                        "Arquivo de credenciais do Google Calendar n√£o encontrado.\n"
                        "Por favor, configure as credenciais nas configura√ß√µes."
                    )
                    return False
                
                self.credentials_file = credentials_file
                
            elif calendar_settings.get('auth_type') == 'key':
                # Usar ID e chave privada
                client_id = calendar_settings.get('client_id', '').strip()
                client_secret = calendar_settings.get('client_secret', '').strip()
                
                if not client_id or not client_secret:
                    messagebox.showwarning(
                        "Configura√ß√£o Necess√°ria",
                        "Client ID e Client Secret do Google Calendar n√£o configurados.\n"
                        "Por favor, configure as credenciais nas configura√ß√µes."
                    )
                    return False
                
                # Criar arquivo tempor√°rio de credenciais
                temp_creds = {
                    "installed": {
                        "client_id": client_id,
                        "client_secret": client_secret,
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "token_uri": "https://oauth2.googleapis.com/token",
                        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                        "redirect_uris": ["http://localhost"]
                    }
                }
                
                import tempfile
                import json
                
                with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                    json.dump(temp_creds, f)
                    self.credentials_file = f.name
            else:
                messagebox.showwarning(
                    "Configura√ß√£o Necess√°ria",
                    "Tipo de autentica√ß√£o do Google Calendar n√£o configurado.\n"
                    "Por favor, configure as credenciais nas configura√ß√µes."
                )
                return False
            
            # Tentar carregar token existente
            if os.path.exists(self.token_file):
                try:
                    with open(self.token_file, 'rb') as token:
                        self.credentials = pickle.load(token)
                except Exception as e:
                    print(f"Erro ao carregar token: {e}")
                    self.credentials = None
            
            # Verificar se as credenciais s√£o v√°lidas
            if not self.credentials or not self.credentials.valid:
                if self.credentials and self.credentials.expired and self.credentials.refresh_token:
                    try:
                        self.credentials.refresh(Request())
                    except Exception as e:
                        print(f"Erro ao renovar token: {e}")
                        self.credentials = None
                
                # Se ainda n√£o h√° credenciais v√°lidas, fazer nova autentica√ß√£o
                if not self.credentials:
                    try:
                        flow = InstalledAppFlow.from_client_secrets_file(
                            self.credentials_file, self.SCOPES)
                        self.credentials = flow.run_local_server(port=0)
                        
                        # Salvar token
                        with open(self.token_file, 'wb') as token:
                            pickle.dump(self.credentials, token)
                            
                    except Exception as e:
                        print(f"Erro na autentica√ß√£o OAuth: {e}")
                        messagebox.showerror("Erro", f"Erro na autentica√ß√£o OAuth:\n{e}")
                        return False
            
            # Criar servi√ßo
            self.service = build('calendar', 'v3', credentials=self.credentials)
            self.is_authenticated = True
            
            print("‚úÖ Autentica√ß√£o com Google Calendar bem-sucedida!")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro na autentica√ß√£o do Google Calendar: {e}")
            messagebox.showerror("Erro", f"Erro na autentica√ß√£o do Google Calendar:\n{e}")
            return False
    
    def create_event(self, title, description, start_datetime, duration=None, card_id=None, attendees=None):
        """Cria um evento no Google Calendar e salva no PostgreSQL"""
        try:
            if not self.service:
                if not self.authenticate():
                    return False
            
            # Calcular hor√°rio de fim
            if duration:
                end_datetime = start_datetime + duration
            else:
                end_datetime = start_datetime + timedelta(hours=1)
            
            # Preparar evento
            event = {
                'summary': title,
                'description': description,
                'start': {
                    'dateTime': start_datetime.isoformat(),
                    'timeZone': 'America/Sao_Paulo',
                },
                'end': {
                    'dateTime': end_datetime.isoformat(),
                    'timeZone': 'America/Sao_Paulo',
                },
                'reminders': {
                    'useDefault': False,
                    'overrides': [
                        {'method': 'popup', 'minutes': 30},
                        {'method': 'email', 'minutes': 60},
                    ],
                },
            }
            
            # Adicionar card_id como metadados se fornecido
            if card_id:
                event['extendedProperties'] = {
                    'private': {
                        'card_id': card_id,
                        'source': 'boodesk_app'
                    }
                }
            
            if attendees:
                event['attendees'] = [{'email': email} for email in attendees]
            
            # Criar evento no Google Calendar
            created_event = self.service.events().insert(
                calendarId=self.calendar_id, body=event).execute()
            
            # Salvar no PostgreSQL
            if hasattr(self.app, 'calendar_manager'):
                event_data = {
                    'title': title,
                    'description': description,
                    'start_datetime': start_datetime,
                    'end_datetime': end_datetime,
                    'location': '',
                    'attendees': attendees or [],
                    'event_type': 'google',
                    'source': 'boodesk',
                    'status': 'scheduled',
                    'priority': 'normal',
                    'color': '#4285f4',
                    'is_all_day': False,
                    'created_by': getattr(self.app, 'current_user_id', 1),
                    'metadata': {
                        'card_id': card_id,
                        'google_event_id': created_event.get('id'),
                        'google_html_link': created_event.get('htmlLink'),
                        'source': 'boodesk_app'
                    }
                }
                
                local_event_id = self.app.calendar_manager.create_event(event_data)
                
                if local_event_id:
                    # Sincronizar com Google Calendar
                    self.app.calendar_manager.sync_with_google_calendar(
                        local_event_id, created_event.get('id')
                    )
                    print(f'‚úÖ Evento salvo no PostgreSQL com ID: {local_event_id}')
            
            print(f'‚úÖ Evento criado no Google Calendar: {created_event.get("htmlLink")}')
            return True
            
        except Exception as error:
            print(f'‚ùå Erro ao criar evento no Google Calendar: {error}')
            return False
    
    def sync_card_to_calendar(self, card_data, board_name, list_name):
        """Sincroniza um cart√£o para o Google Calendar"""
        try:
            if not card_data.get('due_date'):
                return False
            
            # Parse da data de vencimento
            due_date_str = card_data['due_date']
            if ' ' in due_date_str:
                due_date_str = due_date_str.split(' ')[0]
            
            due_date = datetime.strptime(due_date_str, "%Y-%m-%d")
            
            # Criar evento de 1 hora
            start_time = due_date.replace(hour=9, minute=0, second=0, microsecond=0)
            end_time = start_time + timedelta(hours=1)
            
            title = f"[{board_name}] {card_data['title']}"
            description = f"""
Tarefa: {card_data['title']}
Quadro: {board_name}
Lista: {list_name}
Descri√ß√£o: {card_data.get('description', 'N/A')}
Respons√°vel: {', '.join(card_data.get('members', []))}
Import√¢ncia: {card_data.get('importance', 'Normal')}
            """.strip()
            
            return self.create_event(title, description, start_time, end_time)
            
        except Exception as e:
            print(f"Erro ao sincronizar cart√£o com calend√°rio: {e}")
            return False
    
    def get_upcoming_events(self, days=7):
        """Obt√©m eventos pr√≥ximos do Google Calendar"""
        try:
            if not self.service:
                if not self.authenticate():
                    return []
            
            # Usar formato RFC3339 para datas
            now = datetime.now(timezone.utc)
            end_date = now + timedelta(days=days)
            
            # Formatar datas no formato correto para Google Calendar API
            time_min = now.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
            time_max = end_date.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
            
            events_result = self.service.events().list(
                calendarId=self.calendar_id,
                timeMin=time_min,
                timeMax=time_max,
                singleEvents=True,
                orderBy='startTime'
            ).execute()
            
            events = events_result.get('items', [])
            return events
            
        except Exception as e:
            print(f"Erro ao obter eventos do Google Calendar: {e}")
            return []


class EmailTemplateManager:
    """Gerenciador de templates de email personaliz√°veis"""
    
    def __init__(self, app):
        self.app = app
        self.templates_file = os.path.join(self.app.base_dir, 'email_templates.json')
        self.templates = self.load_templates()
        
    def load_templates(self):
        """Carrega templates de email do arquivo"""
        try:
            if os.path.exists(self.templates_file):
                with open(self.templates_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                # Templates padr√£o
                default_templates = {
                    "card_created": {
                        "subject": "Nova Tarefa Criada: {card_title}",
                        "body": """
Ol√° {member_name},

Uma nova tarefa foi criada e voc√™ foi designado como respons√°vel:

**Tarefa:** {card_title}
**Quadro:** {board_name}
**Lista:** {list_name}
**Descri√ß√£o:** {card_description}
**Prazo:** {due_date}
**Import√¢ncia:** {importance}

Acesse o sistema para mais detalhes.

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    },
                    "card_modified": {
                        "subject": "Tarefa Atualizada: {card_title}",
                        "body": """
Ol√° {member_name},

A tarefa "{card_title}" foi atualizada:

**Altera√ß√µes:**
{changes}

**Detalhes Atuais:**
- Quadro: {board_name}
- Lista: {list_name}
- Prazo: {due_date}
- Import√¢ncia: {importance}

Acesse o sistema para mais detalhes.

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    },
                    "deadline_reminder": {
                        "subject": "Lembrete de Prazo: {card_title}",
                        "body": """
Ol√° {member_name},

Este √© um lembrete sobre a tarefa que vence em breve:

**Tarefa:** {card_title}
**Quadro:** {board_name}
**Lista:** {list_name}
**Prazo:** {due_date}
**Import√¢ncia:** {importance}

Por favor, verifique o status desta tarefa.

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    },
                    "weekly_report": {
                        "subject": "Relat√≥rio Semanal - {week_period}",
                        "body": """
Ol√° {member_name},

Aqui est√° seu relat√≥rio semanal de produtividade:

**Resumo da Semana:**
- Tarefas Conclu√≠das: {completed_tasks}
- Tarefas Pendentes: {pending_tasks}
- Tempo Total Pomodoro: {total_pomodoro_time}
- Produtividade: {productivity_score}%

**Tarefas Importantes Conclu√≠das:**
{important_completed_tasks}

**Pr√≥ximos Prazos:**
{upcoming_deadlines}

Continue assim!

Atenciosamente,
Sistema Boodesk
                        """.strip()
                    }
                }
                self.save_templates(default_templates)
                return default_templates
        except Exception as e:
            print(f"Erro ao carregar templates de email: {e}")
            return {}
    
    def save_templates(self, templates=None):
        """Salva templates de email no arquivo"""
        try:
            if templates is None:
                templates = self.templates
            
            with open(self.templates_file, 'w', encoding='utf-8') as f:
                json.dump(templates, f, indent=2, ensure_ascii=False)
            
            self.templates = templates
            
        except Exception as e:
            print(f"Erro ao salvar templates de email: {e}")
    
    def get_template(self, template_name):
        """Obt√©m um template espec√≠fico"""
        return self.templates.get(template_name, {})
    
    def update_template(self, template_name, subject, body):
        """Atualiza um template"""
        self.templates[template_name] = {
            "subject": subject,
            "body": body
        }
        self.save_templates()
    
    def format_template(self, template_name, variables):
        """Formata um template com vari√°veis"""
        template = self.get_template(template_name)
        if not template:
            return "", ""
        
        subject = template.get("subject", "")
        body = template.get("body", "")
        
        # Substituir vari√°veis
        for key, value in variables.items():
            placeholder = "{" + key + "}"
            subject = subject.replace(placeholder, str(value))
            body = body.replace(placeholder, str(value))
        
        return subject, body
    
    def get_available_templates(self):
        """Retorna lista de templates dispon√≠veis"""
        return list(self.templates.keys())


class CalendarEventWindow(tk.Toplevel):
    """Janela para criar/editar eventos do calend√°rio"""
    
    def __init__(self, parent, date_str, event_data=None):
        super().__init__(parent)
        self.parent = parent
        self.date_str = date_str
        self.event_data = event_data
        
        self.title("Novo Evento" if not event_data else "Editar Evento")
        self.geometry("500x400")
        self.transient(parent)
        self.grab_set()
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        
    def create_widgets(self):
        """Cria os widgets da janela"""
        main_frame = ttk.Frame(self, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        ttk.Label(main_frame, text="T√≠tulo:").grid(row=0, column=0, sticky="w", pady=5)
        self.title_var = tk.StringVar(value=self.event_data.get('title', '') if self.event_data else '')
        self.title_entry = ttk.Entry(main_frame, textvariable=self.title_var, width=50)
        self.title_entry.grid(row=0, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        
        # Data
        ttk.Label(main_frame, text="Data:").grid(row=1, column=0, sticky="w", pady=5)
        self.date_var = tk.StringVar(value=self.date_str)
        self.date_entry = ttk.Entry(main_frame, textvariable=self.date_var, width=15)
        self.date_entry.grid(row=1, column=1, sticky="w", pady=5, padx=(10, 0))
        ttk.Button(main_frame, text="üìÖ", command=self.open_date_picker).grid(row=1, column=2, sticky="w", padx=5)
        
        # Hora de in√≠cio
        ttk.Label(main_frame, text="Hora de In√≠cio:").grid(row=2, column=0, sticky="w", pady=5)
        self.start_time_var = tk.StringVar(value=self.event_data.get('start_time', '09:00') if self.event_data else '09:00')
        self.start_time_entry = ttk.Entry(main_frame, textvariable=self.start_time_var, width=10)
        self.start_time_entry.grid(row=2, column=1, sticky="w", pady=5, padx=(10, 0))
        
        # Hora de fim
        ttk.Label(main_frame, text="Hora de Fim:").grid(row=3, column=0, sticky="w", pady=5)
        self.end_time_var = tk.StringVar(value=self.event_data.get('end_time', '10:00') if self.event_data else '10:00')
        self.end_time_entry = ttk.Entry(main_frame, textvariable=self.end_time_var, width=10)
        self.end_time_entry.grid(row=3, column=1, sticky="w", pady=5, padx=(10, 0))
        
        # Descri√ß√£o
        ttk.Label(main_frame, text="Descri√ß√£o:").grid(row=4, column=0, sticky="nw", pady=5)
        self.description_text = tk.Text(main_frame, height=8, width=50)
        self.description_text.grid(row=4, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        if self.event_data and self.event_data.get('description'):
            self.description_text.insert("1.0", self.event_data['description'])
        
        # Local
        ttk.Label(main_frame, text="Local:").grid(row=5, column=0, sticky="w", pady=5)
        self.location_var = tk.StringVar(value=self.event_data.get('location', '') if self.event_data else '')
        self.location_entry = ttk.Entry(main_frame, textvariable=self.location_var, width=50)
        self.location_entry.grid(row=5, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        
        # Participantes
        ttk.Label(main_frame, text="Participantes:").grid(row=6, column=0, sticky="w", pady=5)
        self.attendees_var = tk.StringVar(value=self.event_data.get('attendees', '') if self.event_data else '')
        self.attendees_entry = ttk.Entry(main_frame, textvariable=self.attendees_var, width=50)
        self.attendees_entry.grid(row=6, column=1, columnspan=2, sticky="ew", pady=5, padx=(10, 0))
        ttk.Label(main_frame, text="(emails separados por v√≠rgula)").grid(row=6, column=3, sticky="w", pady=5)
        
        # Sincronizar com Google Calendar
        self.sync_google_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(main_frame, text="Sincronizar com Google Calendar", 
                       variable=self.sync_google_var).grid(row=7, column=0, columnspan=3, sticky="w", pady=10)
        
        # Bot√µes
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=8, column=0, columnspan=3, pady=20)
        
        ttk.Button(button_frame, text="Salvar", command=self.save_event).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancelar", command=self.destroy).pack(side=tk.LEFT, padx=5)
        
        # Configurar grid
        main_frame.columnconfigure(1, weight=1)
        
    def open_date_picker(self):
        """Abre o seletor de data"""
        try:
            current_date = datetime.strptime(self.date_var.get(), "%Y-%m-%d")
            date_picker = DatePickerDialog(self, current_date)
            if date_picker.result:
                self.date_var.set(date_picker.result.strftime("%Y-%m-%d"))
        except ValueError:
            date_picker = DatePickerDialog(self)
            if date_picker.result:
                self.date_var.set(date_picker.result.strftime("%Y-%m-%d"))
    
    def save_event(self):
        """Salva o evento no PostgreSQL e Google Calendar"""
        try:
            # Validar campos obrigat√≥rios
            title = self.title_var.get().strip()
            if not title:
                messagebox.showwarning("Aviso", "O t√≠tulo √© obrigat√≥rio!")
                return
            
            # Validar formato de data
            try:
                event_date = datetime.strptime(self.date_var.get(), "%Y-%m-%d")
            except ValueError:
                messagebox.showwarning("Aviso", "Data inv√°lida!")
                return
            
            # Validar formato de hora
            try:
                start_time = datetime.strptime(self.start_time_var.get(), "%H:%M")
                end_time = datetime.strptime(self.end_time_var.get(), "%H:%M")
            except ValueError:
                messagebox.showwarning("Aviso", "Formato de hora inv√°lido! Use HH:MM")
                return
            
            # Criar dados do evento
            event_data = {
                'title': title,
                'date': self.date_var.get(),
                'start_time': self.start_time_var.get(),
                'end_time': self.end_time_var.get(),
                'description': self.description_text.get("1.0", tk.END).strip(),
                'location': self.location_var.get().strip(),
                'attendees': [email.strip() for email in self.attendees_var.get().split(',') if email.strip()],
                'sync_google': self.sync_google_var.get()
            }
            
            # Salvar no PostgreSQL
            if hasattr(self.parent, 'calendar_manager'):
                start_datetime = datetime.combine(event_date, start_time.time())
                end_datetime = datetime.combine(event_date, end_time.time())
                
                db_event_data = {
                    'title': event_data['title'],
                    'description': event_data['description'],
                    'start_datetime': start_datetime,
                    'end_datetime': end_datetime,
                    'location': event_data['location'],
                    'attendees': event_data['attendees'],
                    'event_type': 'local',
                    'source': 'boodesk',
                    'status': 'scheduled',
                    'priority': 'normal',
                    'color': '#2563eb',
                    'is_all_day': False,
                    'created_by': getattr(self.parent, 'current_user_id', 1),
                    'metadata': {
                        'source': 'manual_entry'
                    }
                }
                
                local_event_id = self.parent.calendar_manager.create_event(db_event_data)
                
                if local_event_id:
                    print(f"‚úÖ Evento salvo no PostgreSQL com ID: {local_event_id}")
                    
                    # Salvar no Google Calendar se solicitado
                    if event_data['sync_google'] and self.parent.calendar_status_var.get() == "Conectado":
                        success = self.parent.google_calendar.create_event(
                            title=event_data['title'],
                            description=event_data['description'],
                            start_datetime=start_datetime,
                            end_datetime=end_datetime,
                            attendees=event_data['attendees'] if event_data['attendees'] else None
                        )
                        
                        if success:
                            messagebox.showinfo("Sucesso", "Evento criado no Google Calendar e PostgreSQL!")
                        else:
                            messagebox.showwarning("Aviso", "Evento salvo no PostgreSQL, mas erro no Google Calendar!")
                    else:
                        messagebox.showinfo("Sucesso", "Evento salvo no PostgreSQL!")
                else:
                    messagebox.showerror("Erro", "Erro ao salvar evento no PostgreSQL!")
            else:
                messagebox.showerror("Erro", "Gerenciador de calend√°rio n√£o dispon√≠vel!")
            
            self.destroy()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar evento:\n{e}")


# Sistema de Integra√ß√£o com Reuni√µes (Zoom/Teams)
class MeetingIntegration:
    """Sistema de integra√ß√£o com plataformas de reuni√£o"""
    
    def __init__(self, app):
        self.app = app
        self.meeting_data = {}  # Dados de reuni√µes
        self.migration_in_progress = False  # Flag para evitar recurs√£o
        self.load_meeting_data()
    
    def load_meeting_data(self):
        """Carrega dados de reuni√µes do banco de dados"""
        try:
            # Carregar do banco de dados
            meetings_from_db = self.app.db.get_meetings()
            
            # Converter para o formato esperado pelo sistema
            self.meeting_data = {}
            for meeting in meetings_from_db:
                meeting_id = str(meeting.get('id', ''))
                self.meeting_data[meeting_id] = {
                    'id': meeting_id,
                    'title': meeting.get('title', ''),
                    'description': meeting.get('description', ''),
                    'date': meeting.get('date', ''),
                    'time': meeting.get('time', ''),
                    'duration': meeting.get('duration', 60),
                    'platform': meeting.get('platform', ''),
                    'link': meeting.get('link', ''),
                    'board_name': meeting.get('board_name', 'Quadro Principal'),
                    'created_by': meeting.get('created_by', 'Sistema'),
                    'created_at': meeting.get('created_at', ''),
                    'status': 'scheduled'
                }
            
            print(f"‚úÖ Carregadas {len(self.meeting_data)} reuni√µes do banco de dados")
            
            # Migrar dados do JSON se existir e banco estiver vazio
            if len(meetings_from_db) == 0 and os.path.exists('meeting_data.json') and not self.migration_in_progress:
                self.migration_in_progress = True
                self.migrate_json_to_database()
                self.migration_in_progress = False
            
        except Exception as e:
            print(f"Erro ao carregar dados de reuni√µes do banco: {e}")
            # Fallback para JSON se banco falhar
            try:
                if os.path.exists('meeting_data.json'):
                    with open('meeting_data.json', 'r', encoding='utf-8') as f:
                        self.meeting_data = json.load(f)
                    print(f"‚úÖ Carregadas {len(self.meeting_data)} reuni√µes do JSON (fallback)")
                else:
                    self.meeting_data = {}
            except Exception as e2:
                print(f"Erro ao carregar backup JSON: {e2}")
                self.meeting_data = {}
    
    def migrate_json_to_database(self):
        """Migra dados do JSON para o banco de dados"""
        if self.migration_in_progress:
            print("‚ö†Ô∏è Migra√ß√£o j√° em andamento, pulando...")
            return
            
        try:
            print("üîÑ Migrando dados de reuni√µes do JSON para o banco de dados...")
            
            with open('meeting_data.json', 'r', encoding='utf-8') as f:
                json_data = json.load(f)
            
            migrated_count = 0
            for meeting_id, meeting in json_data.items():
                try:
                    # Salvar no banco de dados
                    self.app.db.save_meeting(
                        title=meeting.get('title', ''),
                        description=meeting.get('description', ''),
                        date=meeting.get('date', ''),
                        time=meeting.get('time', ''),
                        duration=meeting.get('duration', 60),
                        platform=meeting.get('platform', ''),
                        link=meeting.get('link', ''),
                        board_name=meeting.get('board_name', 'Quadro Principal'),
                        created_by=meeting.get('created_by', 'Sistema')
                    )
                    migrated_count += 1
                except Exception as e:
                    print(f"Erro ao migrar reuni√£o {meeting_id}: {e}")
            
            print(f"‚úÖ Migra√ß√£o conclu√≠da: {migrated_count} reuni√µes migradas para o banco")
            
            # Recarregar dados do banco sem chamar load_meeting_data para evitar recurs√£o
            meetings_from_db = self.app.db.get_meetings()
            self.meeting_data = {}
            for meeting in meetings_from_db:
                meeting_id = str(meeting.get('id', ''))
                self.meeting_data[meeting_id] = {
                    'id': meeting_id,
                    'title': meeting.get('title', ''),
                    'description': meeting.get('description', ''),
                    'date': meeting.get('date', ''),
                    'time': meeting.get('time', ''),
                    'duration': meeting.get('duration', 60),
                    'platform': meeting.get('platform', ''),
                    'link': meeting.get('link', ''),
                    'board_name': meeting.get('board_name', 'Quadro Principal'),
                    'created_by': meeting.get('created_by', 'Sistema'),
                    'created_at': meeting.get('created_at', ''),
                    'status': 'scheduled'
                }
            
        except Exception as e:
            print(f"Erro na migra√ß√£o: {e}")
    
    def save_meeting_data(self):
        """Salva dados de reuni√µes no banco de dados PostgreSQL"""
        try:
            print("DEBUG: Salvando dados de reuni√µes no PostgreSQL...")
            
            # Obter reuni√µes existentes no banco
            existing_meetings = self.app.db.get_meetings()
            existing_ids = {str(m.get('id', '')) for m in existing_meetings}
            
            # Salvar cada reuni√£o no banco de dados PostgreSQL
            for meeting_id, meeting in self.meeting_data.items():
                try:
                    # Verificar se a reuni√£o j√° existe no banco
                    if str(meeting_id) not in existing_ids:
                        print(f"DEBUG: Salvando nova reuni√£o {meeting_id} no PostgreSQL")
                        
                        # Preparar dados para o banco PostgreSQL
                        meeting_data = {
                            'meeting_id': str(meeting_id),
                            'title': meeting.get('title', ''),
                            'description': meeting.get('description', ''),
                            'platform': meeting.get('platform', 'google_meet'),
                            'meeting_link': meeting.get('link', ''),
                            'password': meeting.get('password', ''),
                            'meeting_date': meeting.get('date', ''),
                            'meeting_time': meeting.get('time', ''),
                            'duration_minutes': meeting.get('duration', 60),
                            'status': meeting.get('status', 'scheduled'),
                            'participants': json.dumps(meeting.get('participants', [])),
                            'created_by': self.app.get_current_user_id() if hasattr(self.app, 'get_current_user_id') else 1
                        }
                        
                        # Salvar no banco PostgreSQL
                        success = self.app.db.create_meeting(meeting_data)
                        
                        if success:
                            print(f"‚úÖ Reuni√£o {meeting_id} salva com sucesso no PostgreSQL")
                        else:
                            print(f"‚ùå Falha ao salvar reuni√£o {meeting_id} no PostgreSQL")
                    else:
                        print(f"DEBUG: Reuni√£o {meeting_id} j√° existe no PostgreSQL")
                        
                except Exception as meeting_error:
                    print(f"‚ùå Erro ao salvar reuni√£o {meeting_id}: {meeting_error}")
                    continue
            
            # Manter backup em JSON por compatibilidade (opcional)
            try:
                with open('meeting_data.json', 'w', encoding='utf-8') as f:
                    json.dump(self.meeting_data, f, ensure_ascii=False, indent=2)
                print("‚úÖ Backup JSON mantido para compatibilidade")
            except Exception as json_error:
                print(f"‚ö†Ô∏è Erro ao salvar backup JSON: {json_error}")
                
        except Exception as e:
            print(f"‚ùå Erro ao salvar dados de reuni√µes: {e}")
            # Fallback para JSON se banco falhar
            try:
                with open('meeting_data.json', 'w', encoding='utf-8') as f:
                    json.dump(self.meeting_data, f, ensure_ascii=False, indent=2)
                print("‚úÖ Fallback para JSON executado")
            except Exception as e2:
                print(f"‚ùå Erro ao salvar backup JSON: {e2}")
    
    def create_zoom_meeting(self, title, date, time_str, duration=60, password=None):
        """Cria link de reuni√£o do Zoom"""
        # Gerar ID de reuni√£o √∫nico (formato Zoom: 10 d√≠gitos)
        meeting_id = ''.join(random.choices('0123456789', k=10))
        
        # Gerar senha se n√£o fornecida (formato Zoom: 6 d√≠gitos)
        if not password:
            password = ''.join(random.choices('0123456789', k=6))
        
        # Criar link do Zoom (formato padr√£o)
        zoom_link = f"https://zoom.us/j/{meeting_id}?pwd={password}"
        
        meeting_info = {
            'id': meeting_id,
            'title': title,
            'date': date,
            'time': time_str,
            'duration': duration,
            'password': password,
            'link': zoom_link,
            'platform': 'zoom',
            'created_by': getattr(self.app.current_user, 'username', 'Sistema') if hasattr(self.app, 'current_user') and self.app.current_user else 'Sistema',
            'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'status': 'scheduled'
        }
        
        self.meeting_data[meeting_id] = meeting_info
        self.save_meeting_data()
        
        return meeting_info
    
    def create_teams_meeting(self, title, date, time_str, duration=60):
        """Cria link de reuni√£o do Teams"""
        # Gerar ID de reuni√£o √∫nico (formato Teams: GUID)
        import uuid
        meeting_id = str(uuid.uuid4())
        
        # Criar link do Teams (formato padr√£o)
        teams_link = f"https://teams.microsoft.com/l/meetup-join/{meeting_id}"
        
        meeting_info = {
            'id': meeting_id,
            'title': title,
            'date': date,
            'time': time_str,
            'duration': duration,
            'link': teams_link,
            'platform': 'teams',
            'created_by': getattr(self.app.current_user, 'username', 'Sistema') if hasattr(self.app, 'current_user') and self.app.current_user else 'Sistema',
            'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'status': 'scheduled'
        }
        
        self.meeting_data[meeting_id] = meeting_info
        self.save_meeting_data()
        
        return meeting_info
    
    def create_google_meet_meeting(self, title, date, time_str, duration=60, timezone="America/Sao_Paulo"):
        """Cria link de reuni√£o do Google Meet usando API real e salva no PostgreSQL"""
        try:
            print(f"DEBUG: Criando reuni√£o Google Meet: {title}")
            
            # Usar o Google Calendar Manager para criar reuni√£o real
            if not hasattr(self.app, 'google_calendar_manager'):
                self.app.google_calendar_manager = GoogleCalendarManager()
            
            meeting_info = self.app.google_calendar_manager.create_meeting(
                title, date, time_str, duration, timezone=timezone
            )
            
            if meeting_info:
                print(f"‚úÖ Reuni√£o Google Meet criada com sucesso: {meeting_info.get('id', 'N/A')}")
                
                # Salvar no sistema local
                self.meeting_data[meeting_info['id']] = meeting_info
                
                # Salvar diretamente no PostgreSQL
                try:
                    meeting_data = {
                        'meeting_id': str(meeting_info['id']),
                        'title': meeting_info.get('title', title),
                        'description': meeting_info.get('description', ''),
                        'platform': 'google_meet',
                        'meeting_link': meeting_info.get('link', ''),
                        'password': meeting_info.get('password', ''),
                        'meeting_date': meeting_info.get('date', date),
                        'meeting_time': meeting_info.get('time', time_str),
                        'duration_minutes': meeting_info.get('duration', duration),
                        'status': meeting_info.get('status', 'scheduled'),
                        'participants': json.dumps(meeting_info.get('participants', [])),
                        'created_by': self.app.get_current_user_id() if hasattr(self.app, 'get_current_user_id') else 1
                    }
                    
                    success = self.app.db.create_meeting(meeting_data)
                    if success:
                        print(f"‚úÖ Reuni√£o salva no PostgreSQL: {meeting_info['id']}")
                    else:
                        print(f"‚ö†Ô∏è Falha ao salvar reuni√£o no PostgreSQL, usando backup JSON")
                        self.save_meeting_data()  # Fallback para JSON
                        
                except Exception as db_error:
                    print(f"‚ùå Erro ao salvar no PostgreSQL: {db_error}")
                    self.save_meeting_data()  # Fallback para JSON
                
                return meeting_info
            else:
                print("‚ö†Ô∏è API do Google Meet falhou, usando fallback simulado")
                return self._create_fallback_google_meet(title, date, time_str, duration)
                
        except Exception as e:
            print(f"‚ùå Erro ao criar reuni√£o Google Meet: {e}")
            return self._create_fallback_google_meet(title, date, time_str, duration)
    
    def _create_fallback_google_meet(self, title, date, time_str, duration):
        """Cria reuni√£o Google Meet simulada como fallback"""
        import string
        chars = string.ascii_lowercase + string.digits
        part1 = ''.join(random.choices(chars, k=3))
        part2 = ''.join(random.choices(chars, k=4))
        part3 = ''.join(random.choices(chars, k=3))
        meeting_id = f"{part1}-{part2}-{part3}"
        
        meet_link = f"https://meet.google.com/{meeting_id}"
        
        meeting_info = {
            'id': meeting_id,
            'title': title,
            'date': date,
            'time': time_str,
            'duration': duration,
            'link': meet_link,
            'platform': 'google_meet',
            'created_by': getattr(self.app.current_user, 'username', 'Sistema') if hasattr(self.app, 'current_user') and self.app.current_user else 'Sistema',
            'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'status': 'scheduled'
        }
        
        self.meeting_data[meeting_id] = meeting_info
        
        # Salvar no PostgreSQL
        try:
            meeting_data = {
                'meeting_id': str(meeting_id),
                'title': title,
                'description': '',
                'platform': 'google_meet',
                'meeting_link': meet_link,
                'password': '',
                'meeting_date': date,
                'meeting_time': time_str,
                'duration_minutes': duration,
                'status': 'scheduled',
                'participants': json.dumps([]),
                'created_by': self.app.get_current_user_id() if hasattr(self.app, 'get_current_user_id') else 1
            }
            
            success = self.app.db.create_meeting(meeting_data)
            if success:
                print(f"‚úÖ Reuni√£o fallback salva no PostgreSQL: {meeting_id}")
            else:
                print(f"‚ö†Ô∏è Falha ao salvar reuni√£o fallback no PostgreSQL")
                self.save_meeting_data()  # Fallback para JSON
                
        except Exception as db_error:
            print(f"‚ùå Erro ao salvar fallback no PostgreSQL: {db_error}")
            self.save_meeting_data()  # Fallback para JSON
        
        return meeting_info
    
    def get_meetings_by_project(self, project_name):
        """Retorna reuni√µes de um projeto espec√≠fico"""
        return [meeting for meeting in self.meeting_data.values() 
                if meeting.get('project') == project_name]
    
    def get_upcoming_meetings(self):
        """Retorna pr√≥ximas reuni√µes"""
        upcoming = []
        current_time = datetime.now()
        
        for meeting in self.meeting_data.values():
            try:
                meeting_datetime = datetime.strptime(f"{meeting['date']} {meeting['time']}", "%Y-%m-%d %H:%M")
                if meeting_datetime > current_time:
                    upcoming.append(meeting)
            except:
                continue
        
        return sorted(upcoming, key=lambda x: f"{x['date']} {x['time']}")


class MeetingWindow:
    """Janela para criar e gerenciar reuni√µes"""
    
    def __init__(self, parent, app, project_name=None):
        self.parent = parent
        self.app = app
        self.project_name = project_name
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title("Criar Reuni√£o")
        self.window.geometry("900x750")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        title_text = "Criar Reuni√£o"
        if self.project_name:
            title_text += f" - {self.project_name}"
        
        ttk.Label(title_frame, text=title_text, 
                 font=("Arial", 14, "bold")).pack(side=tk.LEFT)
        
        # Frame para formul√°rio
        form_frame = ttk.LabelFrame(main_frame, text="Detalhes da Reuni√£o", padding="10")
        form_frame.pack(fill=tk.X, pady=(0, 10))
        
        # T√≠tulo da reuni√£o
        ttk.Label(form_frame, text="T√≠tulo:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.title_var = tk.StringVar()
        self.title_entry = ttk.Entry(form_frame, textvariable=self.title_var, width=40)
        self.title_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        
        # Data (formato brasileiro)
        ttk.Label(form_frame, text="Data:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        date_frame = ttk.Frame(form_frame)
        date_frame.grid(row=1, column=1, sticky="w", padx=5, pady=2)
        
        self.date_var = tk.StringVar()
        self.date_entry = ttk.Entry(date_frame, textvariable=self.date_var, width=15)
        self.date_entry.pack(side=tk.LEFT, padx=(0, 5))
        self.date_entry.insert(0, datetime.now().strftime("%d/%m/%Y"))
        
        # Bot√£o para abrir seletor de data
        date_button = ttk.Button(date_frame, text="üìÖ", width=3, 
                                command=self.open_date_picker)
        date_button.pack(side=tk.LEFT)
        
        # Hora (formato brasileiro)
        ttk.Label(form_frame, text="Hora:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        time_frame = ttk.Frame(form_frame)
        time_frame.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        
        self.time_var = tk.StringVar()
        self.time_entry = ttk.Entry(time_frame, textvariable=self.time_var, width=8)
        self.time_entry.pack(side=tk.LEFT, padx=(0, 5))
        self.time_entry.insert(0, "09:00")
        
        # Bot√£o para abrir seletor de hora
        time_button = ttk.Button(time_frame, text="üïê", width=3,
                                command=self.open_time_picker)
        time_button.pack(side=tk.LEFT)
        
        # Dura√ß√£o
        ttk.Label(form_frame, text="Dura√ß√£o (min):").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.duration_var = tk.StringVar(value="60")
        self.duration_entry = ttk.Entry(form_frame, textvariable=self.duration_var, width=10)
        self.duration_entry.grid(row=3, column=1, sticky="w", padx=5, pady=2)
        
        # Tipo de Associa√ß√£o
        ttk.Label(form_frame, text="Associar a:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.association_type_var = tk.StringVar(value="Nenhuma")
        association_combo = ttk.Combobox(form_frame, textvariable=self.association_type_var,
                                        values=["Nenhuma", "Membro", "Card", "Quadro"], 
                                        state="readonly", width=15)
        association_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)
        association_combo.bind('<<ComboboxSelected>>', self.on_association_type_change)
        
        # Frame para sele√ß√£o de associa√ß√£o
        self.association_frame = ttk.Frame(form_frame)
        self.association_frame.grid(row=5, column=0, columnspan=2, sticky="ew", padx=5, pady=2)
        
        # Inicialmente vazio
        self.association_widget = None
        
        # Plataforma
        ttk.Label(form_frame, text="Plataforma:").grid(row=6, column=0, sticky="w", padx=5, pady=2)
        self.platform_var = tk.StringVar(value="google_meet")
        
        # Verificar se Google Meet est√° dispon√≠vel
        google_meet_available = os.path.exists(CREDENTIALS_FILE)
        platform_values = ["google_meet", "zoom", "teams"]
        if not google_meet_available:
            platform_values = ["zoom", "teams"]
        
        platform_combo = ttk.Combobox(form_frame, textvariable=self.platform_var, 
                                     values=platform_values, state="readonly", width=15)
        platform_combo.grid(row=6, column=1, sticky="w", padx=5, pady=2)
        
        # Mostrar status do Google Meet
        if not google_meet_available:
            status_label = ttk.Label(form_frame, text="‚ö†Ô∏è Google Meet: Configure credentials.json", 
                                   foreground="orange", font=("Arial", 8))
            status_label.grid(row=6, column=2, sticky="w", padx=5, pady=2)
        else:
            status_label = ttk.Label(form_frame, text="‚úÖ Google Meet: Dispon√≠vel", 
                                   foreground="green", font=("Arial", 8))
            status_label.grid(row=6, column=2, sticky="w", padx=5, pady=2)
        
        # Fuso Hor√°rio
        ttk.Label(form_frame, text="Fuso Hor√°rio:").grid(row=7, column=0, sticky="w", padx=5, pady=2)
        self.timezone_var = tk.StringVar(value="America/Sao_Paulo")
        
        timezone_values = [
            "America/Sao_Paulo",
            "America/New_York", 
            "America/Los_Angeles",
            "Europe/London",
            "Europe/Paris",
            "Asia/Tokyo",
            "Australia/Sydney",
            "UTC"
        ]
        
        timezone_combo = ttk.Combobox(form_frame, textvariable=self.timezone_var,
                                     values=timezone_values, state="readonly", width=20)
        timezone_combo.grid(row=7, column=1, sticky="w", padx=5, pady=2)
        timezone_combo.bind('<<ComboboxSelected>>', self.update_timezone_label)
        
        # Mostrar fuso hor√°rio atual
        self.current_tz_label = ttk.Label(form_frame, text="üåç Fuso atual: America/Sao_Paulo (UTC-3)", 
                                        foreground="blue", font=("Arial", 8))
        self.current_tz_label.grid(row=7, column=2, sticky="w", padx=5, pady=2)
        
        # Senha (apenas para Zoom)
        self.password_frame = ttk.Frame(form_frame)
        self.password_frame.grid(row=8, column=0, columnspan=2, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.password_frame, text="Senha (opcional):").pack(side=tk.LEFT)
        self.password_var = tk.StringVar()
        self.password_entry = ttk.Entry(self.password_frame, textvariable=self.password_var, width=15)
        self.password_entry.pack(side=tk.LEFT, padx=(5, 0))
        
        # Configurar grid
        form_frame.columnconfigure(1, weight=1)
        
        # Bot√µes principais
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Bot√£o Criar Reuni√£o (sempre vis√≠vel)
        create_btn = ttk.Button(buttons_frame, text="Criar Reuni√£o", 
                               image=self.icons.get('reuniao_icon'), compound=tk.LEFT,
                               command=self.create_meeting)
        create_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        # Bot√£o para configurar Google Meet se n√£o estiver dispon√≠vel
        if not google_meet_available:
            config_btn = ttk.Button(buttons_frame, text="Configurar Google Meet", 
                                   image=self.icons.get('settings_icon'), compound=tk.LEFT,
                                   command=self.show_google_setup)
            config_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        # Bot√£o Cancelar (sempre vis√≠vel)
        cancel_btn = ttk.Button(buttons_frame, text="Cancelar", 
                               image=self.icons.get('cancel_icon'), compound=tk.LEFT,
                               command=self.window.destroy)
        cancel_btn.pack(side=tk.RIGHT)
        
        # Garantir que os bot√µes sejam vis√≠veis
        buttons_frame.update_idletasks()
        
        # Frame para reuni√µes existentes
        meetings_frame = ttk.LabelFrame(main_frame, text="Reuni√µes Agendadas", padding="10")
        meetings_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para reuni√µes
        columns = ("Data", "Hora", "T√≠tulo", "Plataforma", "Criado por")
        self.meetings_tree = ttk.Treeview(meetings_frame, columns=columns, show="headings", height=10)
        
        for col in columns:
            self.meetings_tree.heading(col, text=col)
            self.meetings_tree.column(col, width=100, anchor="w")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(meetings_frame, orient="vertical", command=self.meetings_tree.yview)
        self.meetings_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.meetings_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Bot√µes de a√ß√£o para reuni√µes
        action_frame = ttk.Frame(main_frame)
        action_frame.pack(fill=tk.X)
        
        # Frame para filtros
        filter_frame = ttk.LabelFrame(action_frame, text="Filtros", padding="5")
        filter_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        ttk.Button(filter_frame, text="üë§ Por Membro", 
                  command=lambda: self.filter_meetings_by_type('member')).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(filter_frame, text="üìã Por Card", 
                  command=lambda: self.filter_meetings_by_type('card')).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(filter_frame, text="üìä Por Quadro", 
                  command=lambda: self.filter_meetings_by_type('board')).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(filter_frame, text="üîç Todas", 
                  command=self.load_meetings).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(filter_frame, text="üßπ Limpar Inv√°lidas", 
                  command=self.clean_invalid_meetings).pack(side=tk.LEFT, padx=(0, 5))
        
        # Frame para a√ß√µes
        actions_frame = ttk.Frame(action_frame)
        actions_frame.pack(side=tk.RIGHT)
        
        # Bot√£o Copiar Link
        copy_btn = ttk.Button(actions_frame, text="Copiar Link", 
                             image=self.icons.get('copy_icon'), compound=tk.LEFT,
                             command=self.copy_meeting_link)
        copy_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        # Bot√£o Excluir
        delete_btn = ttk.Button(actions_frame, text="Excluir", 
                               image=self.icons.get('delete_icon'), compound=tk.LEFT,
                               command=self.delete_meeting)
        delete_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        # Bot√£o Atualizar
        refresh_btn = ttk.Button(actions_frame, text="Atualizar", 
                                image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                                command=self.load_meetings)
        refresh_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        # Bot√£o Templates (usar √≠cone alternativo se template_icon n√£o existir)
        template_icon = self.icons.get('template_icon') or self.icons.get('settings_icon')
        template_btn = ttk.Button(actions_frame, text="Templates", 
                                 image=template_icon, compound=tk.LEFT,
                                 command=self.open_templates_window)
        template_btn.pack(side=tk.LEFT)
        
        # Garantir que os bot√µes sejam vis√≠veis
        actions_frame.update_idletasks()
        
        # Carregar reuni√µes existentes
        self.load_meetings()
        
        # Focar no t√≠tulo
        self.title_entry.focus()
    
    def open_templates_window(self):
        """Abre janela de templates de reuni√£o"""
        MeetingTemplatesWindow(self.window, self.app)
    
    def apply_template(self, template):
        """Aplica template selecionado"""
        # Aplicar dados do template
        self.title_var.set(template.get('title', ''))
        self.duration_var.set(str(template.get('duration', 60)))
        self.platform_var.set(template.get('platform', 'google_meet'))
        self.timezone_var.set(template.get('timezone', 'America/Sao_Paulo'))
        
        # Atualizar label do fuso hor√°rio
        if hasattr(self, 'update_timezone_label'):
            self.update_timezone_label()
        
        # Focar no t√≠tulo
        self.title_entry.focus()
        
        messagebox.showinfo("Template Aplicado", 
                          f"Template '{template.get('name')}' aplicado com sucesso!\n"
                          f"Preencha a data e hora para criar a reuni√£o.")
    
    def show_google_setup(self):
        """Mostra instru√ß√µes para configurar Google Meet"""
        setup_text = """
Para usar o Google Meet com links reais, voc√™ precisa configurar a API do Google:

1. Acesse: https://console.cloud.google.com
2. Crie um projeto e ative a Google Calendar API
3. Crie credenciais OAuth 2.0
4. Baixe o arquivo como 'credentials.json'
5. Coloque na pasta do aplicativo

Arquivo de instru√ß√µes completo: GOOGLE_MEET_SETUP.md

Depend√™ncias necess√°rias:
pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client
        """
        
        # Criar janela de instru√ß√µes
        setup_window = tk.Toplevel(self.window)
        setup_window.title("Configurar Google Meet")
        setup_window.geometry("600x400")
        setup_window.transient(self.window)
        setup_window.grab_set()
        
        # Texto das instru√ß√µes
        text_widget = tk.Text(setup_window, wrap=tk.WORD, padx=10, pady=10)
        text_widget.pack(fill=tk.BOTH, expand=True)
        text_widget.insert(tk.END, setup_text)
        text_widget.config(state=tk.DISABLED)
        
        # Bot√µes
        button_frame = ttk.Frame(setup_window)
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        ttk.Button(button_frame, text="Abrir Google Cloud Console", 
                  command=lambda: webbrowser.open("https://console.cloud.google.com")).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Instalar Depend√™ncias", 
                  command=self.install_google_deps).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", 
                  command=setup_window.destroy).pack(side=tk.RIGHT, padx=5)
    
    def install_google_deps(self):
        """Instala as depend√™ncias do Google"""
        try:
            import subprocess
            subprocess.check_call([os.path.abspath(sys.argv[0]), "-m", "pip", "install", 
                                 "google-auth", "google-auth-oauthlib", 
                                 "google-auth-httplib2", "google-api-python-client"])
            messagebox.showinfo("Sucesso", "Depend√™ncias instaladas com sucesso!\nReinicie o aplicativo.")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao instalar depend√™ncias:\n{str(e)}")
    
    def open_date_picker(self):
        """Abre o seletor de data"""
        try:
            # Converter data atual para datetime se existir
            current_date = None
            if self.date_var.get():
                try:
                    # Converter do formato brasileiro para datetime
                    current_date = datetime.strptime(self.date_var.get(), "%d/%m/%Y")
                except ValueError:
                    current_date = datetime.now()
            else:
                current_date = datetime.now()
            
            # Abrir seletor de data
            date_picker = DatePickerDialog(self.window, current_date)
            self.window.wait_window(date_picker)
            
            if date_picker.selected_date:
                # Formatar data no padr√£o brasileiro
                formatted_date = date_picker.selected_date.strftime("%d/%m/%Y")
                self.date_var.set(formatted_date)
                
        except Exception as e:
            print(f"Erro ao abrir seletor de data: {e}")
            messagebox.showerror("Erro", "Erro ao abrir seletor de data")
    
    def open_time_picker(self):
        """Abre o seletor de hora"""
        try:
            # Obter hora atual do campo
            current_time = self.time_var.get() if self.time_var.get() else "09:00"
            
            # Abrir seletor de hora
            time_picker = TimePickerDialog(self.window, current_time)
            self.window.wait_window(time_picker)
            
            if time_picker.selected_time:
                self.time_var.set(time_picker.selected_time)
                
        except Exception as e:
            print(f"Erro ao abrir seletor de hora: {e}")
            messagebox.showerror("Erro", "Erro ao abrir seletor de hora")
    
    def update_timezone_label(self, event=None):
        """Atualiza o label do fuso hor√°rio quando selecionado"""
        timezone = self.timezone_var.get()
        timezone_info = {
            "America/Sao_Paulo": "UTC-3",
            "America/New_York": "UTC-5",
            "America/Los_Angeles": "UTC-8", 
            "Europe/London": "UTC+0",
            "Europe/Paris": "UTC+1",
            "Asia/Tokyo": "UTC+9",
            "Australia/Sydney": "UTC+10",
            "UTC": "UTC+0"
        }
        
        offset = timezone_info.get(timezone, "UTC")
        self.current_tz_label.config(text=f"üåç Fuso atual: {timezone} ({offset})")
    
    def on_association_type_change(self, event=None):
        """Gerencia a mudan√ßa no tipo de associa√ß√£o"""
        association_type = self.association_type_var.get()
        
        # Limpar frame de associa√ß√£o
        for widget in self.association_frame.winfo_children():
            widget.destroy()
        
        if association_type == "Nenhuma":
            return
        
        elif association_type == "Membro":
            self.create_member_association_widget()
        
        elif association_type == "Card":
            self.create_card_association_widget()
        
        elif association_type == "Quadro":
            self.create_board_association_widget()
    
    def create_member_association_widget(self):
        """Cria widget para sele√ß√£o de membro"""
        ttk.Label(self.association_frame, text="Selecionar Membro:").pack(side=tk.LEFT, padx=(0, 5))
        
        # Buscar membros do banco
        members = self.app.db.get_all_members()
        member_names = [member.get('name', member.get('membro', '')) for member in members]
        
        self.member_var = tk.StringVar()
        member_combo = ttk.Combobox(self.association_frame, textvariable=self.member_var,
                                   values=member_names, state="readonly", width=20)
        member_combo.pack(side=tk.LEFT, padx=(0, 5))
        
        # Bot√£o para atualizar lista
        ttk.Button(self.association_frame, text="üîÑ", width=3,
                  command=self.refresh_members).pack(side=tk.LEFT)
    
    def create_card_association_widget(self):
        """Cria widget para sele√ß√£o de card"""
        ttk.Label(self.association_frame, text="Selecionar Card:").pack(side=tk.LEFT, padx=(0, 5))
        
        # Buscar cards do banco
        cards = []
        boards = self.app.db.get_boards()
        for board in boards:
            board_cards = self.app.db.get_cards_for_board(board.get('board_id'))
            for card in board_cards:
                cards.append({
                    'id': card.get('card_id'),
                    'title': card.get('title'),
                    'board': board.get('name')
                })
        
        card_titles = [f"{card['title']} ({card['board']})" for card in cards]
        
        self.card_var = tk.StringVar()
        card_combo = ttk.Combobox(self.association_frame, textvariable=self.card_var,
                                 values=card_titles, state="readonly", width=30)
        card_combo.pack(side=tk.LEFT, padx=(0, 5))
        
        # Bot√£o para atualizar lista
        ttk.Button(self.association_frame, text="üîÑ", width=3,
                  command=self.refresh_cards).pack(side=tk.LEFT)
    
    def create_board_association_widget(self):
        """Cria widget para sele√ß√£o de quadro"""
        ttk.Label(self.association_frame, text="Selecionar Quadro:").pack(side=tk.LEFT, padx=(0, 5))
        
        # Buscar quadros do banco
        boards = self.app.db.get_boards()
        board_names = [board.get('name') for board in boards]
        
        self.board_var = tk.StringVar()
        board_combo = ttk.Combobox(self.association_frame, textvariable=self.board_var,
                                  values=board_names, state="readonly", width=20)
        board_combo.pack(side=tk.LEFT, padx=(0, 5))
        
        # Bot√£o para atualizar lista
        ttk.Button(self.association_frame, text="üîÑ", width=3,
                  command=self.refresh_boards).pack(side=tk.LEFT)
    
    def refresh_members(self):
        """Atualiza lista de membros"""
        members = self.app.db.get_all_members()
        member_names = [member.get('name', member.get('membro', '')) for member in members]
        
        # Encontrar o combobox de membros
        for widget in self.association_frame.winfo_children():
            if isinstance(widget, ttk.Combobox):
                widget['values'] = member_names
                break
    
    def refresh_cards(self):
        """Atualiza lista de cards"""
        cards = []
        boards = self.app.db.get_boards()
        for board in boards:
            board_cards = self.app.db.get_cards_for_board(board.get('board_id'))
            for card in board_cards:
                cards.append({
                    'id': card.get('card_id'),
                    'title': card.get('title'),
                    'board': board.get('name')
                })
        
        card_titles = [f"{card['title']} ({card['board']})" for card in cards]
        
        # Encontrar o combobox de cards
        for widget in self.association_frame.winfo_children():
            if isinstance(widget, ttk.Combobox):
                widget['values'] = card_titles
                break
    
    def refresh_boards(self):
        """Atualiza lista de quadros"""
        boards = self.app.db.get_boards()
        board_names = [board.get('name') for board in boards]
        
        # Encontrar o combobox de quadros
        for widget in self.association_frame.winfo_children():
            if isinstance(widget, ttk.Combobox):
                widget['values'] = board_names
                break
    
    def get_association_data(self):
        """Retorna os dados da associa√ß√£o selecionada"""
        association_type = self.association_type_var.get()
        
        if association_type == "Nenhuma":
            return None
        
        elif association_type == "Membro":
            member_name = self.member_var.get() if hasattr(self, 'member_var') else ""
            return {
                'type': 'member',
                'name': member_name
            }
        
        elif association_type == "Card":
            card_title = self.card_var.get() if hasattr(self, 'card_var') else ""
            return {
                'type': 'card',
                'title': card_title
            }
        
        elif association_type == "Quadro":
            board_name = self.board_var.get() if hasattr(self, 'board_var') else ""
            return {
                'type': 'board',
                'name': board_name
            }
        
        return None
    
    def filter_meetings_by_type(self, association_type):
        """Filtra reuni√µes por tipo de associa√ß√£o"""
        # Limpar treeview
        for item in self.meetings_tree.get_children():
            self.meetings_tree.delete(item)
        
        # Carregar reuni√µes
        if self.project_name:
            meetings = self.app.meeting_integration.get_meetings_by_project(self.project_name)
        else:
            meetings = list(self.app.meeting_integration.meeting_data.values())
        
        # Filtrar reuni√µes por tipo de associa√ß√£o
        filtered_meetings = []
        for meeting in meetings:
            if 'association' in meeting and meeting['association'].get('type') == association_type:
                filtered_meetings.append(meeting)
        
        # Exibir reuni√µes filtradas
        for meeting in filtered_meetings:
            # Converter nome da plataforma para exibi√ß√£o
            platform = meeting.get('platform', '')
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(platform, platform.upper())
            
            # Obter informa√ß√£o de associa√ß√£o
            association_info = ""
            if 'association' in meeting:
                assoc = meeting['association']
                if assoc['type'] == 'member':
                    association_info = f"üë§ {assoc['name']}"
                elif assoc['type'] == 'card':
                    association_info = f"üìã {assoc['title']}"
                elif assoc['type'] == 'board':
                    association_info = f"üìä {assoc['name']}"
            
            # Adicionar associa√ß√£o ao t√≠tulo se existir
            title = meeting.get('title', '')
            if association_info:
                title = f"{title} {association_info}"
            
            self.meetings_tree.insert("", "end", values=(
                meeting.get('date', ''),
                meeting.get('time', ''),
                title,
                platform_display,
                meeting.get('created_by', '')
            ), tags=(meeting['id'],))
        
        # Mostrar mensagem se n√£o houver reuni√µes
        if not filtered_meetings:
            messagebox.showinfo("Filtro", f"Nenhuma reuni√£o encontrada associada a {association_type}.")
    
    def clean_invalid_meetings(self):
        """Remove reuni√µes sem data/hora v√°lidas"""
        try:
            # Buscar reuni√µes inv√°lidas
            invalid_meetings = []
            for meeting_id, meeting in self.app.meeting_integration.meeting_data.items():
                if not meeting.get('date') or not meeting.get('time'):
                    invalid_meetings.append(meeting_id)
            
            if invalid_meetings:
                if messagebox.askyesno("Limpar Reuni√µes", 
                                     f"Encontradas {len(invalid_meetings)} reuni√µes sem data/hora.\n"
                                     f"Deseja remov√™-las?"):
                    
                    # Remover reuni√µes inv√°lidas
                    for meeting_id in invalid_meetings:
                        del self.app.meeting_integration.meeting_data[meeting_id]
                    
                    # Salvar altera√ß√µes
                    self.app.meeting_integration.save_meeting_data()
                    
                    # Recarregar lista
                    self.load_meetings()
                    
                    messagebox.showinfo("Sucesso", f"{len(invalid_meetings)} reuni√µes inv√°lidas removidas!")
            else:
                messagebox.showinfo("Limpeza", "Nenhuma reuni√£o inv√°lida encontrada!")
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao limpar reuni√µes: {str(e)}")
    
    def create_meeting(self):
        """Cria uma nova reuni√£o"""
        title = self.title_var.get().strip()
        date = self.date_var.get().strip()
        time = self.time_var.get().strip()
        duration = self.duration_var.get().strip()
        platform = self.platform_var.get()
        password = self.password_var.get().strip()
        
        # Valida√ß√µes
        if not title:
            messagebox.showerror("Erro", "T√≠tulo √© obrigat√≥rio!")
            return
        
        if not date:
            messagebox.showerror("Erro", "Data √© obrigat√≥ria!")
            return
        
        if not time:
            messagebox.showerror("Erro", "Hora √© obrigat√≥ria!")
            return
        
        # Validar formato da data
        try:
            datetime.strptime(date, "%d/%m/%Y")
        except ValueError:
            messagebox.showerror("Erro", "Formato de data inv√°lido! Use dd/mm/aaaa")
            return
        
        # Validar formato da hora
        try:
            datetime.strptime(time, "%H:%M")
        except ValueError:
            messagebox.showerror("Erro", "Formato de hora inv√°lido! Use hh:mm")
            return
        
        try:
            duration = int(duration)
        except ValueError:
            messagebox.showerror("Erro", "Dura√ß√£o deve ser um n√∫mero!")
            return
        
        try:
            # Converter data do formato brasileiro (dd/mm/yyyy) para formato ISO (yyyy-mm-dd)
            try:
                date_obj = datetime.strptime(date, "%d/%m/%Y")
                date_iso = date_obj.strftime("%Y-%m-%d")
            except ValueError:
                messagebox.showerror("Erro", "Formato de data inv√°lido! Use dd/mm/aaaa")
                return
            
            # Obter fuso hor√°rio selecionado
            timezone = self.timezone_var.get()
            
            # Obter dados de associa√ß√£o
            association_data = self.get_association_data()
            
            # Criar reuni√£o
            if platform == "zoom":
                meeting_info = self.app.meeting_integration.create_zoom_meeting(
                    title, date_iso, time, duration, password if password else None
                )
            elif platform == "teams":
                meeting_info = self.app.meeting_integration.create_teams_meeting(
                    title, date_iso, time, duration
                )
            else:  # google_meet
                meeting_info = self.app.meeting_integration.create_google_meet_meeting(
                    title, date_iso, time, duration, timezone=timezone
                )
            
            # Adicionar dados de associa√ß√£o
            if association_data:
                meeting_info['association'] = association_data
            
            # Adicionar projeto se especificado
            if self.project_name:
                meeting_info['project'] = self.project_name
                self.app.meeting_integration.save_meeting_data()
            
            # Mostrar link gerado
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(meeting_info['platform'], meeting_info['platform'].upper())
            
            messagebox.showinfo("Reuni√£o Criada", 
                              f"Reuni√£o criada com sucesso!\n\n"
                              f"Link: {meeting_info['link']}\n"
                              f"Plataforma: {platform_display}")
            
            # Limpar formul√°rio
            self.title_var.set("")
            self.password_var.set("")
            
            # Recarregar lista
            self.load_meetings()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao criar reuni√£o: {e}")
    
    def load_meetings(self):
        """Carrega reuni√µes existentes"""
        # Limpar treeview
        for item in self.meetings_tree.get_children():
            self.meetings_tree.delete(item)
        
        # Carregar reuni√µes
        if self.project_name:
            meetings = self.app.meeting_integration.get_meetings_by_project(self.project_name)
        else:
            meetings = list(self.app.meeting_integration.meeting_data.values())
        
        # Exibir reuni√µes
        for meeting in meetings:
            # Converter nome da plataforma para exibi√ß√£o
            platform = meeting.get('platform', '')
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(platform, platform.upper())
            
            # Obter informa√ß√£o de associa√ß√£o
            association_info = ""
            if 'association' in meeting:
                assoc = meeting['association']
                if assoc['type'] == 'member':
                    association_info = f"üë§ {assoc['name']}"
                elif assoc['type'] == 'card':
                    association_info = f"üìã {assoc['title']}"
                elif assoc['type'] == 'board':
                    association_info = f"üìä {assoc['name']}"
            
            # Adicionar associa√ß√£o ao t√≠tulo se existir
            title = meeting.get('title', '')
            if association_info:
                title = f"{title} {association_info}"
            
            self.meetings_tree.insert("", "end", values=(
                meeting.get('date', ''),
                meeting.get('time', ''),
                title,
                platform_display,
                meeting.get('created_by', '')
            ), tags=(meeting['id'],))
    
    def copy_meeting_link(self):
        """Copia link da reuni√£o selecionada"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reuni√£o!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        
        if meeting_id in self.app.meeting_integration.meeting_data:
            meeting = self.app.meeting_integration.meeting_data[meeting_id]
            link = meeting['link']
            
            # Copiar para √°rea de transfer√™ncia
            self.window.clipboard_clear()
            self.window.clipboard_append(link)
            
            messagebox.showinfo("Link Copiado", f"Link copiado para a √°rea de transfer√™ncia:\n{link}")
    
    def delete_meeting(self):
        """Exclui reuni√£o selecionada"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reuni√£o!")
            return
        
        try:
            item = self.meetings_tree.item(selection[0])
            meeting_id = item['tags'][0] if item['tags'] else None
            meeting_title = item['values'][2] if len(item['values']) > 2 else "Reuni√£o"
            
            if not meeting_id:
                messagebox.showerror("Erro", "ID da reuni√£o n√£o encontrado!")
                return
            
            if messagebox.askyesno("Confirmar Exclus√£o", 
                                  f"Tem certeza que deseja excluir a reuni√£o '{meeting_title}'?\n\n"
                                  f"Isso tamb√©m cancelar√° a reuni√£o no Google Calendar."):
                
                # Verificar se a reuni√£o existe no sistema
                if not hasattr(self.app, 'meeting_integration') or not self.app.meeting_integration:
                    messagebox.showerror("Erro", "Sistema de reuni√µes n√£o dispon√≠vel!")
                    return
                
                if meeting_id not in self.app.meeting_integration.meeting_data:
                    # Tentar remover da lista mesmo se n√£o estiver no sistema
                    self.meetings_tree.delete(selection[0])
                    messagebox.showinfo("Sucesso", f"Reuni√£o '{meeting_title}' removida da lista!")
                    return
                
                meeting = self.app.meeting_integration.meeting_data[meeting_id]
                
                # Tentar cancelar no Google Calendar se for Google Meet
                google_canceled = False
                if meeting.get('platform') == 'google_meet' and meeting.get('google_event_id'):
                    try:
                        if not hasattr(self.app, 'google_calendar_manager'):
                            self.app.google_calendar_manager = GoogleCalendarManager()
                        
                        google_canceled = self.app.google_calendar_manager.cancel_meeting(
                            meeting.get('google_event_id')
                        )
                    except Exception as e:
                        print(f"Erro ao cancelar no Google Calendar: {e}")
                
                # Remover do sistema local e banco de dados
                try:
                    # Remover do banco de dados
                    self.app.db.delete_meeting(int(meeting_id))
                    
                    # Remover da mem√≥ria
                    del self.app.meeting_integration.meeting_data[meeting_id]
                    
                    # Salvar backup em JSON
                    self.app.meeting_integration.save_meeting_data()
                    
                except Exception as e:
                    print(f"Erro ao remover reuni√£o do sistema: {e}")
                    # Fallback: apenas remover da mem√≥ria
                    try:
                        del self.app.meeting_integration.meeting_data[meeting_id]
                    except:
                        pass
                
                # Recarregar lista
                self.load_meetings()
                
                # Atualizar widget de reuni√µes no menu principal e dashboard
                self._update_meeting_widgets()
                
                # Mostrar resultado
                if google_canceled:
                    messagebox.showinfo("Sucesso", 
                                      f"Reuni√£o '{meeting_title}' exclu√≠da com sucesso!\n"
                                      f"‚úÖ Tamb√©m cancelada no Google Calendar.")
                elif meeting.get('platform') == 'google_meet':
                    messagebox.showwarning("Parcialmente Bem-sucedido", 
                                         f"Reuni√£o '{meeting_title}' exclu√≠da do sistema.\n"
                                         f"‚ö†Ô∏è N√£o foi poss√≠vel cancelar no Google Calendar.\n"
                                         f"Cancele manualmente no Google Calendar.")
                else:
                    messagebox.showinfo("Sucesso", f"Reuni√£o '{meeting_title}' exclu√≠da com sucesso!")
                    
        except Exception as e:
            print(f"Erro ao excluir reuni√£o: {e}")
            messagebox.showerror("Erro", f"Erro ao excluir reuni√£o: {str(e)}")
    
    def _update_meeting_widgets(self):
        """Atualiza todos os widgets de reuni√µes no menu principal e dashboard"""
        try:
            # Atualizar widget no menu principal
            if hasattr(self, 'meeting_widget') and self.meeting_widget:
                self.meeting_widget.refresh_meetings()
            
            # Atualizar widget no dashboard (se existir)
            # O widget do dashboard √© o mesmo do menu principal, ent√£o n√£o precisa atualizar separadamente
            print("‚úÖ Widgets de reuni√µes atualizados com sucesso")
            
        except Exception as e:
            print(f"Erro ao atualizar widgets de reuni√µes: {e}")


# Sistema de Templates de Reuni√£o
class MeetingTemplatesWindow(tk.Toplevel):
    """Janela para gerenciar templates de reuni√£o"""
    
    def __init__(self, parent, app):
        super().__init__(parent)
        self.parent = parent
        self.app = app
        self.templates_file = 'meeting_templates.json'
        self.templates = self.load_templates()
        
        # Configurar janela
        self.title("Templates de Reuni√£o")
        self.geometry("700x500")
        self.transient(parent)
        self.grab_set()
        
        # Centralizar
        self.center_window()
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        
        # Focar na janela
        self.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (700 // 2)
        y = (self.winfo_screenheight() // 2) - (500 // 2)
        self.geometry(f"700x500+{x}+{y}")
    
    def load_templates(self):
        """Carrega templates salvos"""
        try:
            if os.path.exists(self.templates_file):
                with open(self.templates_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception as e:
            print(f"Erro ao carregar templates: {e}")
        
        # Se n√£o existir arquivo, criar templates padr√£o
        if not os.path.exists(self.templates_file):
            default_templates = self.create_default_templates()
            self.save_default_templates(default_templates)
            return default_templates
        
        return []
    
    def create_default_templates(self):
        """Cria templates padr√£o"""
        return [
            {
                'name': 'Daily Standup',
                'title': 'Daily Standup - Equipe',
                'duration': 15,
                'platform': 'google_meet',
                'timezone': 'America/Sao_Paulo',
                'description': 'Reuni√£o di√°ria para alinhamento da equipe'
            },
            {
                'name': 'Sprint Planning',
                'title': 'Sprint Planning',
                'duration': 60,
                'platform': 'google_meet',
                'timezone': 'America/Sao_Paulo',
                'description': 'Planejamento da sprint com toda a equipe'
            },
            {
                'name': 'Sprint Review',
                'title': 'Sprint Review',
                'duration': 45,
                'platform': 'google_meet',
                'timezone': 'America/Sao_Paulo',
                'description': 'Apresenta√ß√£o dos resultados da sprint'
            },
            {
                'name': 'Retrospectiva',
                'title': 'Sprint Retrospectiva',
                'duration': 30,
                'platform': 'google_meet',
                'timezone': 'America/Sao_Paulo',
                'description': 'Reflex√£o sobre a sprint e melhorias'
            },
            {
                'name': 'Reuni√£o Cliente',
                'title': 'Reuni√£o com Cliente',
                'duration': 60,
                'platform': 'zoom',
                'timezone': 'America/Sao_Paulo',
                'description': 'Reuni√£o para apresenta√ß√£o ou alinhamento com cliente'
            },
            {
                'name': 'Code Review',
                'title': 'Code Review',
                'duration': 30,
                'platform': 'google_meet',
                'timezone': 'America/Sao_Paulo',
                'description': 'Revis√£o de c√≥digo em equipe'
            }
        ]
    
    def save_default_templates(self, templates):
        """Salva templates padr√£o"""
        try:
            with open(self.templates_file, 'w', encoding='utf-8') as f:
                json.dump(templates, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erro ao salvar templates padr√£o: {e}")
    
    def save_templates(self):
        """Salva templates no arquivo"""
        try:
            with open(self.templates_file, 'w', encoding='utf-8') as f:
                json.dump(self.templates, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erro ao salvar templates: {e}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_label = ttk.Label(main_frame, text="üìã Templates de Reuni√£o", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Frame para lista e formul√°rio
        content_frame = ttk.Frame(main_frame)
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        # Lista de templates (esquerda)
        list_frame = ttk.LabelFrame(content_frame, text="Templates Dispon√≠veis", padding="10")
        list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))
        
        # Treeview para templates
        columns = ("Nome", "Plataforma", "Dura√ß√£o")
        self.templates_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.templates_tree.heading(col, text=col)
            self.templates_tree.column(col, width=100)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.templates_tree.yview)
        self.templates_tree.configure(yscrollcommand=scrollbar.set)
        
        self.templates_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Bind sele√ß√£o
        self.templates_tree.bind('<<TreeviewSelect>>', self.on_template_select)
        
        # Formul√°rio (direita)
        form_frame = ttk.LabelFrame(content_frame, text="Criar/Editar Template", padding="10")
        form_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        
        # Campos do formul√°rio
        ttk.Label(form_frame, text="Nome do Template:").grid(row=0, column=0, sticky="w", pady=2)
        self.name_var = tk.StringVar()
        self.name_entry = ttk.Entry(form_frame, textvariable=self.name_var, width=25)
        self.name_entry.grid(row=0, column=1, sticky="ew", pady=2)
        
        ttk.Label(form_frame, text="T√≠tulo da Reuni√£o:").grid(row=1, column=0, sticky="w", pady=2)
        self.title_var = tk.StringVar()
        self.title_entry = ttk.Entry(form_frame, textvariable=self.title_var, width=25)
        self.title_entry.grid(row=1, column=1, sticky="ew", pady=2)
        
        ttk.Label(form_frame, text="Dura√ß√£o (min):").grid(row=2, column=0, sticky="w", pady=2)
        self.duration_var = tk.StringVar(value="60")
        self.duration_entry = ttk.Entry(form_frame, textvariable=self.duration_var, width=25)
        self.duration_entry.grid(row=2, column=1, sticky="ew", pady=2)
        
        ttk.Label(form_frame, text="Plataforma:").grid(row=3, column=0, sticky="w", pady=2)
        self.platform_var = tk.StringVar(value="google_meet")
        platform_combo = ttk.Combobox(form_frame, textvariable=self.platform_var, 
                                     values=["google_meet", "zoom", "teams"], 
                                     state="readonly", width=22)
        platform_combo.grid(row=3, column=1, sticky="ew", pady=2)
        
        ttk.Label(form_frame, text="Fuso Hor√°rio:").grid(row=4, column=0, sticky="w", pady=2)
        self.timezone_var = tk.StringVar(value="America/Sao_Paulo")
        timezone_combo = ttk.Combobox(form_frame, textvariable=self.timezone_var,
                                     values=["America/Sao_Paulo", "America/New_York", "America/Los_Angeles", 
                                            "Europe/London", "Europe/Paris", "Asia/Tokyo", "Australia/Sydney", "UTC"],
                                     state="readonly", width=22)
        timezone_combo.grid(row=4, column=1, sticky="ew", pady=2)
        
        ttk.Label(form_frame, text="Descri√ß√£o:").grid(row=5, column=0, sticky="w", pady=2)
        self.description_text = tk.Text(form_frame, height=4, width=25)
        self.description_text.grid(row=5, column=1, sticky="ew", pady=2)
        
        # Bot√µes de a√ß√£o
        button_frame = ttk.Frame(form_frame)
        button_frame.grid(row=6, column=0, columnspan=2, pady=20)
        
        ttk.Button(button_frame, text="Salvar Template", 
                  command=self.save_template).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(button_frame, text="Usar Template", 
                  command=self.use_template).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(button_frame, text="Excluir", 
                  command=self.delete_template).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(button_frame, text="Limpar", 
                  command=self.clear_form).pack(side=tk.LEFT)
        
        # Configurar grid
        form_frame.columnconfigure(1, weight=1)
        
        # Carregar templates
        self.load_templates_list()
    
    def load_templates_list(self):
        """Carrega lista de templates"""
        # Limpar lista
        for item in self.templates_tree.get_children():
            self.templates_tree.delete(item)
        
        # Adicionar templates
        for template in self.templates:
            self.templates_tree.insert('', 'end', values=(
                template.get('name', ''),
                template.get('platform', ''),
                f"{template.get('duration', 60)} min"
            ))
    
    def on_template_select(self, event):
        """Quando um template √© selecionado"""
        selection = self.templates_tree.selection()
        if selection:
            item = self.templates_tree.item(selection[0])
            template_name = item['values'][0]
            
            # Encontrar template
            template = next((t for t in self.templates if t.get('name') == template_name), None)
            if template:
                self.load_template_to_form(template)
    
    def load_template_to_form(self, template):
        """Carrega template no formul√°rio"""
        self.name_var.set(template.get('name', ''))
        self.title_var.set(template.get('title', ''))
        self.duration_var.set(str(template.get('duration', 60)))
        self.platform_var.set(template.get('platform', 'google_meet'))
        self.timezone_var.set(template.get('timezone', 'America/Sao_Paulo'))
        
        # Limpar e inserir descri√ß√£o
        self.description_text.delete(1.0, tk.END)
        self.description_text.insert(1.0, template.get('description', ''))
    
    def save_template(self):
        """Salva template"""
        name = self.name_var.get().strip()
        title = self.title_var.get().strip()
        duration = self.duration_var.get().strip()
        
        if not name or not title or not duration:
            messagebox.showwarning("Aviso", "Preencha todos os campos obrigat√≥rios!")
            return
        
        try:
            duration = int(duration)
        except ValueError:
            messagebox.showerror("Erro", "Dura√ß√£o deve ser um n√∫mero!")
            return
        
        # Criar template
        template = {
            'name': name,
            'title': title,
            'duration': duration,
            'platform': self.platform_var.get(),
            'timezone': self.timezone_var.get(),
            'description': self.description_text.get(1.0, tk.END).strip()
        }
        
        # Verificar se j√° existe
        existing_index = next((i for i, t in enumerate(self.templates) 
                             if t.get('name') == name), None)
        
        if existing_index is not None:
            # Atualizar existente
            self.templates[existing_index] = template
            messagebox.showinfo("Sucesso", f"Template '{name}' atualizado!")
        else:
            # Adicionar novo
            self.templates.append(template)
            messagebox.showinfo("Sucesso", f"Template '{name}' criado!")
        
        # Salvar e recarregar
        self.save_templates()
        self.load_templates_list()
        self.clear_form()
    
    def use_template(self):
        """Usa template para criar reuni√£o"""
        selection = self.templates_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione um template!")
            return
        
        item = self.templates_tree.item(selection[0])
        template_name = item['values'][0]
        
        # Encontrar template
        template = next((t for t in self.templates if t.get('name') == template_name), None)
        if template:
            # Aplicar template na janela de reuni√£o
            if hasattr(self.parent, 'apply_template'):
                self.parent.apply_template(template)
                self.destroy()
            else:
                messagebox.showinfo("Template", f"Template '{template_name}' selecionado!\n"
                                   f"T√≠tulo: {template.get('title')}\n"
                                   f"Dura√ß√£o: {template.get('duration')} min\n"
                                   f"Plataforma: {template.get('platform')}")
    
    def delete_template(self):
        """Exclui template selecionado"""
        selection = self.templates_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione um template!")
            return
        
        item = self.templates_tree.item(selection[0])
        template_name = item['values'][0]
        
        if messagebox.askyesno("Confirmar", f"Excluir template '{template_name}'?"):
            # Remover template
            self.templates = [t for t in self.templates if t.get('name') != template_name]
            self.save_templates()
            self.load_templates_list()
            self.clear_form()
            messagebox.showinfo("Sucesso", f"Template '{template_name}' exclu√≠do!")
    
    def clear_form(self):
        """Limpa formul√°rio"""
        self.name_var.set('')
        self.title_var.set('')
        self.duration_var.set('60')
        self.platform_var.set('google_meet')
        self.timezone_var.set('America/Sao_Paulo')
        self.description_text.delete(1.0, tk.END)


# Sistema de Chat em Tempo Real Integrado ao PostgreSQL
class ChatSystem:
    """Sistema de chat em tempo real integrado ao PostgreSQL"""
    
    def __init__(self, app):
        self.app = app
        self.chat_windows = {}  # Janelas de chat por projeto
        self.comment_windows = {}  # Janelas de coment√°rios por cart√£o
        self.current_user_id = getattr(self.app.current_user, 'id', None)
        self.update_interval = 2000  # Atualizar a cada 2 segundos
        self.update_timer = None
        self.chat_data = {}  # Dados de chat por projeto/quadro
        
        # Inicializar sistema de atualiza√ß√£o em tempo real
        self.start_realtime_updates()
    
    def start_realtime_updates(self):
        """Inicia o sistema de atualiza√ß√µes em tempo real"""
        if self.update_timer:
            self.app.root.after_cancel(self.update_timer)
        self.update_timer = self.app.root.after(self.update_interval, self.update_realtime_data)
    
    def update_realtime_data(self):
        """Atualiza dados em tempo real"""
        try:
            # Atualizar notifica√ß√µes
            self.update_notifications()
            
            # Atualizar janelas de chat abertas
            for chat_window in self.chat_windows.values():
                if hasattr(chat_window, 'update_messages'):
                    chat_window.update_messages()
            
            # Agendar pr√≥xima atualiza√ß√£o
            self.update_timer = self.app.root.after(self.update_interval, self.update_realtime_data)
        except Exception as e:
            print(f"Erro na atualiza√ß√£o em tempo real: {e}")
            # Tentar novamente em 5 segundos
            self.update_timer = self.app.root.after(5000, self.update_realtime_data)
    
    def update_notifications(self):
        """Atualiza notifica√ß√µes n√£o lidas"""
        try:
            if self.current_user_id:
                unread_notifications = self.app.db.get_unread_notifications(self.current_user_id)
                if unread_notifications:
                    # Atualizar indicador de notifica√ß√µes na interface
                    self.update_notification_badge(len(unread_notifications))
        except Exception as e:
            print(f"Erro ao atualizar notifica√ß√µes: {e}")
    
    def update_notification_badge(self, count):
        """Atualiza o badge de notifica√ß√µes na interface"""
        try:
            # Implementar atualiza√ß√£o do badge de notifica√ß√µes
            pass
        except Exception as e:
            print(f"Erro ao atualizar badge: {e}")
    
    def get_board_names(self):
        """Retorna a lista de nomes dos quadros"""
        try:
            if hasattr(self.app, 'boodesk_data') and 'boards' in self.app.boodesk_data:
                return list(self.app.boodesk_data['boards'].keys())
            else:
                return []
        except Exception as e:
            print(f"Erro ao obter nomes dos quadros: {e}")
            return []
    
    def create_or_get_board_chat(self, board_name):
        """Cria ou obt√©m o chat de um quadro"""
        try:
            # Buscar board_id pelo nome
            boards = self.app.db.get_boards()
            board_id = None
            for board in boards:
                if board['name'] == board_name:
                    board_id = board['id']
                    break
            
            if not board_id:
                print(f"‚ùå Quadro '{board_name}' n√£o encontrado")
                return None
            
            # Verificar se j√° existe chat para este quadro
            chat = self.app.db.get_board_chat(board_id)
            if chat:
                return chat
            
            # Criar novo chat para o quadro
            chat_id = self.app.db.create_chat(
                name=f"Chat - {board_name}",
                chat_type='board',
                created_by=self.current_user_id,
                board_id=board_id
            )
            
            if chat_id:
                # Adicionar todos os membros do quadro ao chat
                self.add_board_members_to_chat(chat_id, board_name)
                return self.app.db.get_chat_by_id(chat_id)
            
            return None
        except Exception as e:
            print(f"Erro ao criar/obter chat do quadro: {e}")
            return None
    
    def create_or_get_card_chat(self, card_id, card_title):
        """Cria ou obt√©m o chat de um cart√£o"""
        try:
            # Verificar se j√° existe chat para este cart√£o
            chat = self.app.db.get_card_chat(card_id)
            if chat:
                return chat
            
            # Criar novo chat para o cart√£o
            chat_id = self.app.db.create_chat(
                name=f"Chat - {card_title}",
                chat_type='card',
                created_by=self.current_user_id,
                card_id=card_id
            )
            
            if chat_id:
                return self.app.db.get_chat_by_id(chat_id)
            
            return None
        except Exception as e:
            print(f"Erro ao criar/obter chat do cart√£o: {e}")
            return None
    
    def add_board_members_to_chat(self, chat_id, board_name):
        """Adiciona membros do quadro ao chat"""
        try:
            # Buscar membros do quadro
            if board_name in self.app.boodesk_data.get('boards', {}):
                board_data = self.app.boodesk_data['boards'][board_name]
                members = board_data.get('members', [])
                
                for member in members:
                    # Buscar user_id pelo username
                    users = self.app.db.get_all_users()
                    for user in users:
                        if user['username'] == member:
                            self.app.db.add_chat_participant(chat_id, user['id'])
                            break
        except Exception as e:
            print(f"Erro ao adicionar membros ao chat: {e}")
    
    def send_message_to_chat(self, chat_id, message):
        """Envia mensagem para um chat"""
        try:
            if not self.current_user_id:
                print("‚ùå Usu√°rio n√£o identificado")
                return False
            
            message_id = self.app.db.send_message(
                chat_id=chat_id,
                sender_id=self.current_user_id,
                message=message
            )
            
            if message_id:
                print(f"‚úÖ Mensagem enviada com ID: {message_id}")
                return True
            else:
                print("‚ùå Erro ao enviar mensagem")
                return False
        except Exception as e:
            print(f"Erro ao enviar mensagem: {e}")
            return False
    
    def open_project_chat(self, project_name):
        """Abre chat espec√≠fico para um projeto/quadro na interface principal"""
        try:
            # Criar ou obter chat do quadro
            chat = self.create_or_get_board_chat(project_name)
            if not chat:
                messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir o chat do quadro '{project_name}'")
                return
            
            # Carregar chat na interface principal
            if hasattr(self.app, 'load_chat_in_main_interface'):
                self.app.load_chat_in_main_interface(chat, f"Chat - {project_name}")
            else:
                # Fallback: mostrar mensagem de erro
                messagebox.showerror("Erro", "Interface de chat n√£o dispon√≠vel")
                
        except Exception as e:
            print(f"Erro ao abrir chat do projeto: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir chat: {str(e)}")
    
    def open_card_comments(self, card_id, card_title):
        """Abre coment√°rios de um cart√£o espec√≠fico na interface principal"""
        try:
            # Criar ou obter chat do cart√£o
            chat = self.create_or_get_card_chat(card_id, card_title)
            if not chat:
                messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir o chat do cart√£o '{card_title}'")
                return
            
            # Carregar chat na interface principal
            if hasattr(self.app, 'load_chat_in_main_interface'):
                self.app.load_chat_in_main_interface(chat, f"Coment√°rios - {card_title}")
            else:
                # Fallback: mostrar mensagem de erro
                messagebox.showerror("Erro", "Interface de chat n√£o dispon√≠vel")
                
        except Exception as e:
            print(f"Erro ao abrir coment√°rios do cart√£o: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir coment√°rios: {str(e)}")
    
    def open_direct_chat(self, target_user_id, target_username):
        """Abre chat direto com outro usu√°rio na interface principal"""
        try:
            # Verificar se j√° existe chat direto
            user_chats = self.app.db.get_chats_by_user(self.current_user_id)
            direct_chat = None
            
            for chat in user_chats:
                if chat['chat_type'] == 'direct':
                    participants = self.app.db.get_chat_participants(chat['id'])
                    if len(participants) == 2:
                        participant_ids = [p['user_id'] for p in participants]
                        if self.current_user_id in participant_ids and target_user_id in participant_ids:
                            direct_chat = chat
                            break
            
            if not direct_chat:
                # Criar novo chat direto
                chat_id = self.app.db.create_chat(
                    name=f"Chat com {target_username}",
                    chat_type='direct',
                    created_by=self.current_user_id
                )
                
                if chat_id:
                    # Adicionar ambos os usu√°rios como participantes
                    self.app.db.add_chat_participant(chat_id, self.current_user_id)
                    self.app.db.add_chat_participant(chat_id, target_user_id)
                    direct_chat = self.app.db.get_chat_by_id(chat_id)
            
            if direct_chat:
                # Carregar chat na interface principal
                if hasattr(self.app, 'load_chat_in_main_interface'):
                    self.app.load_chat_in_main_interface(direct_chat, f"Chat com {target_username}")
                else:
                    # Fallback: mostrar mensagem de erro
                    messagebox.showerror("Erro", "Interface de chat n√£o dispon√≠vel")
            else:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel criar o chat direto")
                
        except Exception as e:
            print(f"Erro ao abrir chat direto: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir chat direto: {str(e)}")
    
    def get_user_chats(self):
        """Retorna todos os chats do usu√°rio atual"""
        try:
            if self.current_user_id:
                return self.app.db.get_chats_by_user(self.current_user_id)
            return []
        except Exception as e:
            print(f"Erro ao obter chats do usu√°rio: {e}")
            return []
    
    def get_chat_messages(self, chat_id, limit=50):
        """Retorna mensagens de um chat"""
        try:
            return self.app.db.get_chat_messages(chat_id, limit=limit)
        except Exception as e:
            print(f"Erro ao obter mensagens do chat: {e}")
            return []
    
    def mark_chat_as_read(self, chat_id):
        """Marca mensagens de um chat como lidas"""
        try:
            if self.current_user_id:
                return self.app.db.mark_messages_as_read(chat_id, self.current_user_id)
            return False
        except Exception as e:
            print(f"Erro ao marcar chat como lido: {e}")
            return False
    
    def add_chat_message(self, chat_id, message):
        """Adiciona mensagem ao chat"""
        try:
            if not self.current_user_id:
                print("‚ùå Usu√°rio n√£o identificado")
                return False
            
            # Processar men√ß√µes (@usuario)
            processed_message, mentions = self.process_mentions(message)
            
            # Enviar mensagem para o banco
            message_id = self.app.db.send_message(
                chat_id=chat_id,
                sender_id=self.current_user_id,
                message=processed_message
            )
            
            if message_id:
                # Notificar usu√°rios mencionados
                self.notify_mentions(mentions, chat_id, message_id)
                
                # Atualizar janelas de chat abertas
                self.update_chat_windows(chat_id)
                
                return True
            else:
                print("‚ùå Erro ao enviar mensagem")
                return False
                
        except Exception as e:
            print(f"Erro ao adicionar mensagem: {e}")
            return False

    def send_message(self, chat_id, sender_id, message):
        """Envia mensagem ao chat (compatibilidade)"""
        try:
            # Usar o current_user_id da sess√£o se sender_id n√£o for fornecido
            if not sender_id:
                sender_id = self.current_user_id
            
            if not sender_id:
                print("‚ùå Usu√°rio n√£o identificado")
                return False
            
            # Enviar mensagem para o banco
            message_id = self.app.db.send_message(
                chat_id=chat_id,
                sender_id=sender_id,
                message=message
            )
            
            if message_id:
                # Atualizar janelas de chat abertas
                self.update_chat_windows(chat_id)
                return True
            else:
                print("‚ùå Erro ao enviar mensagem")
                return False
                
        except Exception as e:
            print(f"Erro ao enviar mensagem: {e}")
            return False
    
    def update_chat_windows(self, chat_id):
        """Atualiza janelas de chat abertas"""
        try:
            for window in self.chat_windows.values():
                if hasattr(window, 'chat_id') and window.chat_id == chat_id:
                    if hasattr(window, 'update_messages'):
                        window.update_messages()
        except Exception as e:
            print(f"Erro ao atualizar janelas de chat: {e}")
    
    def add_card_comment(self, card_id, comment):
        """Adiciona coment√°rio a um cart√£o"""
        try:
            if not self.current_user_id:
                print("‚ùå Usu√°rio n√£o identificado")
                return False
            
            # Buscar ou criar chat do cart√£o
            card_title = f"Cart√£o {card_id}"
            chat = self.create_or_get_card_chat(card_id, card_title)
            
            if not chat:
                print("‚ùå N√£o foi poss√≠vel criar/obter chat do cart√£o")
                return False
            
            # Processar men√ß√µes (@usuario)
            processed_comment, mentions = self.process_mentions(comment)
            
            # Enviar coment√°rio como mensagem no chat do cart√£o
            message_id = self.app.db.send_message(
                chat_id=chat['id'],
                sender_id=self.current_user_id,
                message=processed_comment
            )
            
            if message_id:
                # Notificar usu√°rios mencionados
                self.notify_mentions(mentions, chat['id'], message_id)
                
                # Atualizar janelas de coment√°rios abertas
                if card_id in self.comment_windows:
                    self.comment_windows[card_id].update_messages()
                
                return True
            else:
                print("‚ùå Erro ao enviar coment√°rio")
                return False
                
        except Exception as e:
            print(f"Erro ao adicionar coment√°rio: {e}")
            return False
    
    def process_mentions(self, text):
        """Processa men√ß√µes @usuario no texto"""
        mentions = []
        processed_text = text
        
        # Encontrar men√ß√µes @usuario
        import re
        mention_pattern = r'@(\w+)'
        matches = re.findall(mention_pattern, text)
        
        for match in matches:
            mentions.append(match)
            # Destacar men√ß√£o no texto
            processed_text = processed_text.replace(f'@{match}', f'@{match}')
        
        return processed_text, mentions
    
    def notify_mentions(self, mentions, chat_id, message_id):
        """Notifica usu√°rios mencionados"""
        try:
            for mention in mentions:
                # Buscar user_id pelo username
                users = self.app.db.get_all_users()
                mentioned_user_id = None
                
                for user in users:
                    if user['username'].lower() == mention.lower():
                        mentioned_user_id = user['id']
                        break
                
                if mentioned_user_id:
                    # Criar notifica√ß√£o espec√≠fica para men√ß√£o
                    self.app.db.execute_with_retry(lambda conn: conn.execute("""
                        INSERT INTO chat_notifications (user_id, chat_id, message_id, notification_type, created_at)
                        VALUES (%s, %s, %s, 'mention', %s)
                    """, (mentioned_user_id, chat_id, message_id, datetime.now())))
                    
                    print(f"‚úÖ Notifica√ß√£o de men√ß√£o enviada para @{mention}")
        except Exception as e:
            print(f"Erro ao notificar men√ß√µes: {e}")
    
    def search_chat_history(self, chat_id, search_term):
        """Busca no hist√≥rico de chat"""
        try:
            messages = self.app.db.get_chat_messages(chat_id, limit=1000)
            results = []
            search_term = search_term.lower()
            
            for message in messages:
                if (search_term in message['message'].lower() or 
                    search_term in message['username'].lower()):
                    results.append(message)
            
            return results
        except Exception as e:
            print(f"Erro na busca do hist√≥rico: {e}")
            return []
    
    def get_chat_participants(self, chat_id):
        """Retorna participantes de um chat"""
        try:
            return self.app.db.get_chat_participants(chat_id)
        except Exception as e:
            print(f"Erro ao obter participantes: {e}")
            return []
    
    def add_participant_to_chat(self, chat_id, username):
        """Adiciona participante a um chat"""
        try:
            # Buscar user_id pelo username
            users = self.app.db.get_all_users()
            user_id = None
            
            for user in users:
                if user['username'] == username:
                    user_id = user['id']
                    break
            
            if user_id:
                return self.app.db.add_chat_participant(chat_id, user_id)
            else:
                print(f"‚ùå Usu√°rio '{username}' n√£o encontrado")
                return False
        except Exception as e:
            print(f"Erro ao adicionar participante: {e}")
            return False
    
    def remove_participant_from_chat(self, chat_id, username):
        """Remove participante de um chat"""
        try:
            # Buscar user_id pelo username
            users = self.app.db.get_all_users()
            user_id = None
            
            for user in users:
                if user['username'] == username:
                    user_id = user['id']
                    break
            
            if user_id:
                return self.app.db.remove_chat_participant(chat_id, user_id)
            else:
                print(f"‚ùå Usu√°rio '{username}' n√£o encontrado")
                return False
        except Exception as e:
            print(f"Erro ao remover participante: {e}")
            return False
    
    def search_comment_history(self, card_id, search_term):
        """Busca no hist√≥rico de coment√°rios"""
        try:
            # Buscar chat do cart√£o
            card_title = f"Cart√£o {card_id}"
            chat = self.create_or_get_card_chat(card_id, card_title)
            
            if chat:
                return self.search_chat_history(chat['id'], search_term)
            return []
        except Exception as e:
            print(f"Erro na busca do hist√≥rico de coment√°rios: {e}")
            return []
    
    def get_user_chats(self):
        """Retorna todos os chats do usu√°rio atual"""
        try:
            if self.current_user_id:
                return self.app.db.get_chats_by_user(self.current_user_id)
            return []
        except Exception as e:
            print(f"Erro ao obter chats do usu√°rio: {e}")
            return []
    
    def get_chat_messages(self, chat_id):
        """Retorna mensagens de um chat espec√≠fico"""
        try:
            messages = self.app.db.get_chat_messages(chat_id)
            
            # Adicionar informa√ß√µes do remetente
            for message in messages:
                sender_id = message.get('sender_id')
                if sender_id:
                    users = self.app.db.get_all_users()
                    for user in users:
                        if user['id'] == sender_id:
                            message['sender_name'] = user['username']
                            break
                    else:
                        message['sender_name'] = 'Desconhecido'
                else:
                    message['sender_name'] = 'Sistema'
            
            return messages
        except Exception as e:
            print(f"Erro ao obter mensagens do chat: {e}")
            return []
    
    def get_unread_notifications(self):
        """Retorna notifica√ß√µes n√£o lidas do usu√°rio atual"""
        try:
            if self.current_user_id:
                notifications = self.app.db.get_unread_notifications(self.current_user_id)
                
                # Adicionar informa√ß√µes adicionais
                for notification in notifications:
                    # Buscar informa√ß√µes do chat
                    chat = self.app.db.get_chat_by_id(notification.get('chat_id'))
                    if chat:
                        notification['chat_name'] = chat['name']
                    
                    # Buscar informa√ß√µes do remetente
                    message = self.app.db.get_message_by_id(notification.get('message_id'))
                    if message:
                        sender_id = message.get('sender_id')
                        if sender_id:
                            users = self.app.db.get_all_users()
                            for user in users:
                                if user['id'] == sender_id:
                                    notification['sender_name'] = user['username']
                                    notification['message'] = message.get('message', 'Nova mensagem')
                                    break
                            else:
                                notification['sender_name'] = 'Desconhecido'
                                notification['message'] = message.get('message', 'Nova mensagem')
                        else:
                            notification['sender_name'] = 'Sistema'
                            notification['message'] = message.get('message', 'Nova mensagem')
                
                return notifications
            return []
        except Exception as e:
            print(f"Erro ao obter notifica√ß√µes: {e}")
            return []

    def get_or_create_direct_chat(self, target_user_id):
        """Obt√©m ou cria um chat direto com o usu√°rio especificado"""
        try:
            # Verificar se j√° existe chat direto
            user_chats = self.app.db.get_chats_by_user(self.current_user_id)
            direct_chat = None
            
            for chat in user_chats:
                if chat['chat_type'] == 'direct':
                    participants = self.app.db.get_chat_participants(chat['id'])
                    if len(participants) == 2:
                        participant_ids = [p['user_id'] for p in participants]
                        if self.current_user_id in participant_ids and target_user_id in participant_ids:
                            direct_chat = chat
                            break
            
            if not direct_chat:
                # Buscar username do usu√°rio alvo
                users = self.app.db.get_all_users()
                target_username = "Usu√°rio"
                for user in users:
                    if user['id'] == target_user_id:
                        target_username = user['username']
                        break
                
                # Criar novo chat direto
                chat_id = self.app.db.create_chat(
                    name=f"Chat com {target_username}",
                    chat_type='direct',
                    created_by=self.current_user_id
                )
                
                if chat_id:
                    # Adicionar ambos os usu√°rios como participantes
                    self.app.db.add_chat_participant(chat_id, self.current_user_id)
                    self.app.db.add_chat_participant(chat_id, target_user_id)
                    direct_chat = self.app.db.get_chat_by_id(chat_id)
            
            return direct_chat
        except Exception as e:
            print(f"Erro ao obter/criar chat direto: {e}")
            return None


# ============================================================================
# JANELAS DE CHAT
# ============================================================================

class BoardChatWindow:
    """Janela de chat para quadros/projetos"""
    
    def __init__(self, app, board_name, chat):
        self.app = app
        self.board_name = board_name
        self.chat = chat
        self.chat_id = chat['id']
        self.current_user_id = getattr(self.app.current_user, 'id', None)
        
        # Criar janela
        self.window = tk.Toplevel(self.app.root)
        self.window.title(f"Chat - {board_name}")
        self.window.geometry("600x500")
        self.window.resizable(True, True)
        
        # Configurar √≠cone
        if hasattr(self.app, 'icons') and self.app.icons.get('chat_icon'):
            self.window.iconphoto(False, self.app.icons['chat_icon'])
        
        # Marcar mensagens como lidas
        self.app.chat_system.mark_chat_as_read(self.chat_id)
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        self.load_messages()
        
        # Configurar protocolo de fechamento
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def create_widgets(self):
        """Cria os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Cabe√ßalho
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(header_frame, text=f"Chat do Quadro: {self.board_name}", 
                 font=("Arial", 12, "bold")).pack(side=tk.LEFT)
        
        # Bot√£o de participantes
        ttk.Button(header_frame, text="üë• Participantes", 
                  command=self.show_participants).pack(side=tk.RIGHT)
        
        # Frame de mensagens
        messages_frame = ttk.Frame(main_frame)
        messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # √Årea de mensagens com scrollbar
        messages_container = ttk.Frame(messages_frame)
        messages_container.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(messages_container)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de mensagens
        self.messages_text = tk.Text(messages_container, wrap=tk.WORD, 
                                   yscrollcommand=scrollbar.set, state=tk.DISABLED)
        self.messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.messages_text.yview)
        
        # Frame de entrada
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de mensagem
        self.message_entry = ttk.Entry(input_frame)
        self.message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.message_entry.bind("<Return>", self.send_message)
        
        # Bot√£o enviar
        ttk.Button(input_frame, text="Enviar", command=self.send_message).pack(side=tk.RIGHT)
        
        # Bot√£o de busca
        ttk.Button(input_frame, text="üîç Buscar", command=self.search_messages).pack(side=tk.RIGHT, padx=(0, 10))
    
    def load_messages(self):
        """Carrega mensagens do chat"""
        try:
            messages = self.app.chat_system.get_chat_messages(self.chat_id, limit=50)
            self.display_messages(messages)
        except Exception as e:
            print(f"Erro ao carregar mensagens: {e}")
    
    def display_messages(self, messages):
        """Exibe mensagens na interface"""
        self.messages_text.config(state=tk.NORMAL)
        self.messages_text.delete(1.0, tk.END)
        
        for message in reversed(messages):  # Ordem cronol√≥gica
            timestamp = message['created_at']
            if isinstance(timestamp, str):
                timestamp = timestamp
            else:
                timestamp = timestamp.strftime('%d/%m/%Y %H:%M')
            
            username = message['username']
            text = message['message']
            
            # Formatar mensagem
            formatted_message = f"[{timestamp}] {username}: {text}\n\n"
            
            self.messages_text.insert(tk.END, formatted_message)
        
        self.messages_text.config(state=tk.DISABLED)
        self.messages_text.see(tk.END)
    
    def send_message(self, event=None):
        """Envia mensagem"""
        message = self.message_entry.get().strip()
        if message:
            if self.app.chat_system.add_chat_message(self.chat_id, message):
                self.message_entry.delete(0, tk.END)
                self.load_messages()  # Recarregar mensagens
            else:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel enviar a mensagem")
    
    def update_messages(self):
        """Atualiza mensagens (chamado pelo sistema de tempo real)"""
        self.load_messages()
    
    def search_messages(self):
        """Abre di√°logo de busca"""
        search_term = simpledialog.askstring("Buscar Mensagens", "Digite o termo de busca:")
        if search_term:
            results = self.app.chat_system.search_chat_history(self.chat_id, search_term)
            if results:
                self.display_messages(results)
            else:
                messagebox.showinfo("Busca", "Nenhuma mensagem encontrada.")
    
    def show_participants(self):
        """Mostra lista de participantes"""
        participants = self.app.chat_system.get_chat_participants(self.chat_id)
        
        if participants:
            participant_list = "\n".join([f"‚Ä¢ {p['username']} ({p['role']})" for p in participants])
            messagebox.showinfo("Participantes", f"Participantes do chat:\n\n{participant_list}")
        else:
            messagebox.showinfo("Participantes", "Nenhum participante encontrado.")
    
    def on_closing(self):
        """Chamado quando a janela √© fechada"""
        # Remover da lista de janelas abertas
        if self.board_name in self.app.chat_system.chat_windows:
            del self.app.chat_system.chat_windows[self.board_name]
        self.window.destroy()


class CardCommentsWindow:
    """Janela de coment√°rios para cart√µes"""
    
    def __init__(self, app, card_id, card_title, chat):
        self.app = app
        self.card_id = card_id
        self.card_title = card_title
        self.chat = chat
        self.chat_id = chat['id']
        self.current_user_id = getattr(self.app.current_user, 'id', None)
        
        # Criar janela
        self.window = tk.Toplevel(self.app.root)
        self.window.title(f"Coment√°rios - {card_title}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Configurar √≠cone
        if hasattr(self.app, 'icons') and self.app.icons.get('comment_icon'):
            self.window.iconphoto(False, self.app.icons['comment_icon'])
        
        # Marcar mensagens como lidas
        self.app.chat_system.mark_chat_as_read(self.chat_id)
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        self.load_messages()
        
        # Configurar protocolo de fechamento
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def create_widgets(self):
        """Cria os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Cabe√ßalho
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(header_frame, text=f"Coment√°rios: {self.card_title}", 
                 font=("Arial", 12, "bold")).pack(side=tk.LEFT)
        
        # Frame de mensagens
        messages_frame = ttk.Frame(main_frame)
        messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # √Årea de mensagens com scrollbar
        messages_container = ttk.Frame(messages_frame)
        messages_container.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(messages_container)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de mensagens
        self.messages_text = tk.Text(messages_container, wrap=tk.WORD, 
                                   yscrollcommand=scrollbar.set, state=tk.DISABLED)
        self.messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.messages_text.yview)
        
        # Frame de entrada
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de coment√°rio
        self.comment_entry = ttk.Entry(input_frame)
        self.comment_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.comment_entry.bind("<Return>", self.add_comment)
        
        # Bot√£o enviar
        ttk.Button(input_frame, text="Comentar", command=self.add_comment).pack(side=tk.RIGHT)
    
    def load_messages(self):
        """Carrega coment√°rios do cart√£o"""
        try:
            messages = self.app.chat_system.get_chat_messages(self.chat_id, limit=50)
            self.display_messages(messages)
        except Exception as e:
            print(f"Erro ao carregar coment√°rios: {e}")
    
    def display_messages(self, messages):
        """Exibe coment√°rios na interface"""
        self.messages_text.config(state=tk.NORMAL)
        self.messages_text.delete(1.0, tk.END)
        
        for message in reversed(messages):  # Ordem cronol√≥gica
            timestamp = message['created_at']
            if isinstance(timestamp, str):
                timestamp = timestamp
            else:
                timestamp = timestamp.strftime('%d/%m/%Y %H:%M')
            
            username = message['username']
            text = message['message']
            
            # Formatar coment√°rio
            formatted_comment = f"[{timestamp}] {username}: {text}\n\n"
            
            self.messages_text.insert(tk.END, formatted_comment)
        
        self.messages_text.config(state=tk.DISABLED)
        self.messages_text.see(tk.END)
    
    def add_comment(self, event=None):
        """Adiciona coment√°rio"""
        comment = self.comment_entry.get().strip()
        if comment:
            if self.app.chat_system.add_card_comment(self.card_id, comment):
                self.comment_entry.delete(0, tk.END)
                self.load_messages()  # Recarregar coment√°rios
            else:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel adicionar o coment√°rio")
    
    def update_messages(self):
        """Atualiza coment√°rios (chamado pelo sistema de tempo real)"""
        self.load_messages()
    
    def on_closing(self):
        """Chamado quando a janela √© fechada"""
        # Remover da lista de janelas abertas
        if self.card_id in self.app.chat_system.comment_windows:
            del self.app.chat_system.comment_windows[self.card_id]
        self.window.destroy()


class DirectChatWindow:
    """Janela de chat direto entre usu√°rios"""
    
    def __init__(self, app, target_user_id, target_username, chat):
        self.app = app
        self.target_user_id = target_user_id
        self.target_username = target_username
        self.chat = chat
        self.chat_id = chat['id']
        self.current_user_id = getattr(self.app.current_user, 'id', None)
        
        # Criar janela
        self.window = tk.Toplevel(self.app.root)
        self.window.title(f"Chat com {target_username}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Configurar √≠cone
        if hasattr(self.app, 'icons') and self.app.icons.get('chat_icon'):
            self.window.iconphoto(False, self.app.icons['chat_icon'])
        
        # Marcar mensagens como lidas
        self.app.chat_system.mark_chat_as_read(self.chat_id)
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        self.load_messages()
        
        # Configurar protocolo de fechamento
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def create_widgets(self):
        """Cria os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Cabe√ßalho
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(header_frame, text=f"Chat com {self.target_username}", 
                 font=("Arial", 12, "bold")).pack(side=tk.LEFT)
        
        # Frame de mensagens
        messages_frame = ttk.Frame(main_frame)
        messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # √Årea de mensagens com scrollbar
        messages_container = ttk.Frame(messages_frame)
        messages_container.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(messages_container)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de mensagens
        self.messages_text = tk.Text(messages_container, wrap=tk.WORD, 
                                   yscrollcommand=scrollbar.set, state=tk.DISABLED)
        self.messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.messages_text.yview)
        
        # Frame de entrada
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de mensagem
        self.message_entry = ttk.Entry(input_frame)
        self.message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.message_entry.bind("<Return>", self.send_message)
        
        # Bot√£o enviar
        ttk.Button(input_frame, text="Enviar", command=self.send_message).pack(side=tk.RIGHT)
    
    def load_messages(self):
        """Carrega mensagens do chat direto"""
        try:
            messages = self.app.chat_system.get_chat_messages(self.chat_id, limit=50)
            self.display_messages(messages)
        except Exception as e:
            print(f"Erro ao carregar mensagens: {e}")
    
    def display_messages(self, messages):
        """Exibe mensagens na interface"""
        self.messages_text.config(state=tk.NORMAL)
        self.messages_text.delete(1.0, tk.END)
        
        for message in reversed(messages):  # Ordem cronol√≥gica
            timestamp = message['created_at']
            if isinstance(timestamp, str):
                timestamp = timestamp
            else:
                timestamp = timestamp.strftime('%d/%m/%Y %H:%M')
            
            username = message['username']
            text = message['message']
            
            # Formatar mensagem
            formatted_message = f"[{timestamp}] {username}: {text}\n\n"
            
            self.messages_text.insert(tk.END, formatted_message)
        
        self.messages_text.config(state=tk.DISABLED)
        self.messages_text.see(tk.END)
    
    def send_message(self, event=None):
        """Envia mensagem"""
        message = self.message_entry.get().strip()
        if message:
            if self.app.chat_system.add_chat_message(self.chat_id, message):
                self.message_entry.delete(0, tk.END)
                self.load_messages()  # Recarregar mensagens
            else:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel enviar a mensagem")
    
    def update_messages(self):
        """Atualiza mensagens (chamado pelo sistema de tempo real)"""
        self.load_messages()
    
    def on_closing(self):
        """Chamado quando a janela √© fechada"""
        # Remover da lista de janelas abertas
        chat_key = f"direct_{self.target_user_id}"
        if chat_key in self.app.chat_system.chat_windows:
            del self.app.chat_system.chat_windows[chat_key]
        self.window.destroy()
class ProjectChatWindow:
    """Janela de chat para projeto espec√≠fico"""
    
    def __init__(self, app, project_name):
        self.app = app
        self.project_name = project_name
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(app.root)
        self.window.title(f"Chat - {project_name}")
        self.window.geometry("600x500")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(app.root)
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        self.load_messages()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text=f"Chat - {self.project_name}", 
                 font=("Arial", 14, "bold")).pack(side=tk.LEFT)
        
        # Bot√µes de a√ß√£o
        ttk.Button(title_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.open_search).pack(side=tk.RIGHT, padx=5)
        ttk.Button(title_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.load_messages).pack(side=tk.RIGHT, padx=5)
        
        # Frame para mensagens
        messages_frame = ttk.LabelFrame(main_frame, text="Mensagens", padding="10")
        messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Text widget para mensagens
        self.messages_text = tk.Text(messages_frame, wrap=tk.WORD, state=tk.DISABLED)
        self.messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(messages_frame, orient="vertical", command=self.messages_text.yview)
        self.messages_text.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Frame para entrada de mensagem
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de entrada
        self.message_var = tk.StringVar()
        self.message_entry = ttk.Entry(input_frame, textvariable=self.message_var, font=("Arial", 10))
        self.message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.message_entry.bind("<Return>", self.send_message)
        self.message_entry.bind("<KeyRelease>", self.update_char_count)
        
        # Contador de caracteres
        self.char_count_label = ttk.Label(input_frame, text="0/1000", font=("Arial", 8), foreground="gray")
        self.char_count_label.pack(side=tk.LEFT, padx=(0, 10))
        
        # Bot√£o enviar
        ttk.Button(input_frame, text="Enviar", image=self.icons.get('forward_icon'), compound=tk.LEFT,
                  command=self.send_message).pack(side=tk.RIGHT)
        
        # Focar no campo de entrada
        self.message_entry.focus()
    
    def load_messages(self):
        """Carrega mensagens do chat"""
        self.messages_text.config(state=tk.NORMAL)
        self.messages_text.delete(1.0, tk.END)
        
        if self.project_name in self.app.chat_system.chat_data:
            for message in self.app.chat_system.chat_data[self.project_name]:
                self.display_message(message)
        
        self.messages_text.config(state=tk.DISABLED)
        self.messages_text.see(tk.END)
    
    def display_message(self, message):
        """Exibe uma mensagem no chat"""
        self.messages_text.config(state=tk.NORMAL)
        
        # Formatar mensagem
        timestamp = message['timestamp']
        username = message['username']
        text = message['message']
        
        # Adicionar timestamp
        self.messages_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
        
        # Adicionar username
        self.messages_text.insert(tk.END, f"{username}: ", "username")
        
        # Adicionar mensagem
        self.messages_text.insert(tk.END, f"{text}\n", "message")
        
        self.messages_text.config(state=tk.DISABLED)
        
        # Configurar tags para formata√ß√£o
        self.messages_text.tag_config("timestamp", foreground="gray")
        self.messages_text.tag_config("username", foreground="blue", font=("Arial", 10, "bold"))
        self.messages_text.tag_config("message", font=("Arial", 10))
    
    def send_message(self, event=None):
        """Envia mensagem"""
        message = self.message_var.get().strip()
        if not message:
            return
        
        # Verificar limite de caracteres (1000 caracteres)
        MAX_MESSAGE_LENGTH = 1000
        if len(message) > MAX_MESSAGE_LENGTH:
            messagebox.showwarning("Limite Excedido", 
                                 f"A mensagem deve ter no m√°ximo {MAX_MESSAGE_LENGTH} caracteres.\n"
                                 f"Sua mensagem tem {len(message)} caracteres.")
            return
        
        # Verificar se h√° usu√°rio logado
        if not hasattr(self.app, 'current_user') or not self.app.current_user:
            messagebox.showwarning("Aviso", "Voc√™ precisa estar logado para enviar mensagens!")
            return
        
        username = self.app.current_user.username
        
        # Adicionar mensagem ao sistema de chat
        self.app.chat_system.add_chat_message(self.project_name, username, message)
        
        # Limpar campo de entrada
        self.message_var.set("")
        
        # Focar novamente no campo
        self.message_entry.focus()
    
    def add_message(self, message):
        """Adiciona nova mensagem √† janela"""
        self.display_message(message)
        self.messages_text.see(tk.END)
    
    def update_char_count(self, event=None):
        """Atualiza contador de caracteres"""
        current_length = len(self.message_var.get())
        max_length = 1000
        
        # Atualizar contador
        self.char_count_label.config(text=f"{current_length}/{max_length}")
        
        # Mudar cor baseado no limite
        if current_length > max_length * 0.9:  # 90% do limite
            self.char_count_label.config(foreground="orange")
        elif current_length > max_length:
            self.char_count_label.config(foreground="red")
        else:
            self.char_count_label.config(foreground="gray")
    
    def open_search(self):
        """Abre janela de busca"""
        ChatSearchWindow(self.window, self.app, self.project_name)


class CardCommentsWindow:
    """Janela de coment√°rios para cart√£o espec√≠fico"""
    
    def __init__(self, app, card_id, card_title):
        self.app = app
        self.card_id = card_id
        self.card_title = card_title
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(app.root)
        self.window.title(f"Coment√°rios - {card_title}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(app.root)
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        self.load_comments()
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text=f"Coment√°rios - {self.card_title}", 
                 font=("Arial", 12, "bold")).pack(side=tk.LEFT)
        
        # Bot√µes de a√ß√£o
        ttk.Button(title_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.open_search).pack(side=tk.RIGHT, padx=5)
        ttk.Button(title_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.load_comments).pack(side=tk.RIGHT, padx=5)
        
        # Frame para coment√°rios
        comments_frame = ttk.LabelFrame(main_frame, text="Coment√°rios", padding="10")
        comments_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Text widget para coment√°rios
        self.comments_text = tk.Text(comments_frame, wrap=tk.WORD, state=tk.DISABLED)
        self.comments_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(comments_frame, orient="vertical", command=self.comments_text.yview)
        self.comments_text.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Frame para entrada de coment√°rio
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X)
        
        # Campo de entrada
        self.comment_var = tk.StringVar()
        self.comment_entry = ttk.Entry(input_frame, textvariable=self.comment_var, font=("Arial", 10))
        self.comment_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.comment_entry.bind("<Return>", self.send_comment)
        self.comment_entry.bind("<KeyRelease>", self.update_comment_char_count)
        
        # Contador de caracteres
        self.comment_char_count_label = ttk.Label(input_frame, text="0/500", font=("Arial", 8), foreground="gray")
        self.comment_char_count_label.pack(side=tk.LEFT, padx=(0, 10))
        
        # Bot√£o enviar
        ttk.Button(input_frame, text="Comentar", image=self.icons.get('add_icon'), compound=tk.LEFT,
                  command=self.send_comment).pack(side=tk.RIGHT)
        
        # Focar no campo de entrada
        self.comment_entry.focus()
    
    def load_comments(self):
        """Carrega coment√°rios do cart√£o"""
        self.comments_text.config(state=tk.NORMAL)
        self.comments_text.delete(1.0, tk.END)
        
        if self.card_id in self.app.chat_system.comment_data:
            for comment in self.app.chat_system.comment_data[self.card_id]:
                self.display_comment(comment)
        
        self.comments_text.config(state=tk.DISABLED)
        self.comments_text.see(tk.END)
    
    def display_comment(self, comment):
        """Exibe um coment√°rio"""
        self.comments_text.config(state=tk.NORMAL)
        
        # Formatar coment√°rio
        timestamp = comment['timestamp']
        username = comment['username']
        text = comment['comment']
        
        # Adicionar timestamp
        self.comments_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
        
        # Adicionar username
        self.comments_text.insert(tk.END, f"{username}: ", "username")
        
        # Adicionar coment√°rio
        self.comments_text.insert(tk.END, f"{text}\n", "comment")
        
        self.comments_text.config(state=tk.DISABLED)
        
        # Configurar tags para formata√ß√£o
        self.comments_text.tag_config("timestamp", foreground="gray")
        self.comments_text.tag_config("username", foreground="green", font=("Arial", 10, "bold"))
        self.comments_text.tag_config("comment", font=("Arial", 10))
    
    def send_comment(self, event=None):
        """Envia coment√°rio"""
        comment = self.comment_var.get().strip()
        if not comment:
            return
        
        # Verificar limite de caracteres (500 caracteres para coment√°rios)
        MAX_COMMENT_LENGTH = 500
        if len(comment) > MAX_COMMENT_LENGTH:
            messagebox.showwarning("Limite Excedido", 
                                 f"O coment√°rio deve ter no m√°ximo {MAX_COMMENT_LENGTH} caracteres.\n"
                                 f"Seu coment√°rio tem {len(comment)} caracteres.")
            return
        
        # Verificar se h√° usu√°rio logado
        if not hasattr(self.app, 'current_user') or not self.app.current_user:
            messagebox.showwarning("Aviso", "Voc√™ precisa estar logado para comentar!")
            return
        
        username = self.app.current_user.username
        
        # Adicionar coment√°rio ao sistema
        self.app.chat_system.add_card_comment(self.card_id, username, comment)
        
        # Limpar campo de entrada
        self.comment_var.set("")
        
        # Focar novamente no campo
        self.comment_entry.focus()
        
        # Limpar campo de entrada
        self.comment_var.set("")
        
        # Focar novamente no campo
        self.comment_entry.focus()
    
    def update_comment_char_count(self, event=None):
        """Atualiza contador de caracteres do coment√°rio"""
        current_length = len(self.comment_var.get())
        max_length = 500
        
        # Atualizar contador
        self.comment_char_count_label.config(text=f"{current_length}/{max_length}")
        
        # Mudar cor baseado no limite
        if current_length > max_length * 0.9:  # 90% do limite
            self.comment_char_count_label.config(foreground="orange")
        elif current_length > max_length:
            self.comment_char_count_label.config(foreground="red")
        else:
            self.comment_char_count_label.config(foreground="gray")
    
    def add_comment(self, comment):
        """Adiciona novo coment√°rio √† janela"""
        self.display_comment(comment)
        self.comments_text.see(tk.END)
    
    def open_search(self):
        """Abre janela de busca"""
        CommentSearchWindow(self.window, self.app, self.card_id)


class ChatSearchWindow:
    """Janela de busca no hist√≥rico de chat"""
    
    def __init__(self, parent, app, project_name):
        self.parent = parent
        self.app = app
        self.project_name = project_name
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title(f"Buscar no Chat - {project_name}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        ttk.Label(main_frame, text=f"Buscar no Chat - {self.project_name}", 
                 font=("Arial", 12, "bold")).pack(pady=(0, 10))
        
        # Frame de busca
        search_frame = ttk.Frame(main_frame)
        search_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(search_frame, text="Termo de busca:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.search_var = tk.StringVar()
        self.search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=30)
        self.search_entry.pack(side=tk.LEFT, padx=(0, 10))
        self.search_entry.bind("<Return>", self.perform_search)
        
        ttk.Button(search_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.perform_search).pack(side=tk.LEFT)
        
        # Frame para resultados
        results_frame = ttk.LabelFrame(main_frame, text="Resultados", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Treeview para resultados
        columns = ("Data", "Usu√°rio", "Mensagem")
        self.results_tree = ttk.Treeview(results_frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.results_tree.heading(col, text=col)
            self.results_tree.column(col, width=150, anchor="w")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=self.results_tree.yview)
        self.results_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.results_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Bot√µes
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X)
        
        ttk.Button(buttons_frame, text="Limpar", image=self.icons.get('clear_icon'), compound=tk.LEFT,
                  command=self.clear_results).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(buttons_frame, text="Fechar", image=self.icons.get('cancel_icon'), compound=tk.LEFT,
                  command=self.window.destroy).pack(side=tk.RIGHT)
        
        # Focar no campo de busca
        self.search_entry.focus()
    
    def perform_search(self, event=None):
        """Executa a busca"""
        search_term = self.search_var.get().strip()
        if not search_term:
            messagebox.showwarning("Aviso", "Digite um termo para buscar!")
            return
        
        # Limpar resultados anteriores
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        
        # Realizar busca
        results = self.app.chat_system.search_chat_history(self.project_name, search_term)
        
        # Exibir resultados
        for result in results:
            self.results_tree.insert("", "end", values=(
                result['timestamp'],
                result['username'],
                result['message'][:50] + "..." if len(result['message']) > 50 else result['message']
            ))
        
        # Mostrar quantidade de resultados
        messagebox.showinfo("Busca Conclu√≠da", f"Encontrados {len(results)} resultados para '{search_term}'")
    
    def clear_results(self):
        """Limpa resultados da busca"""
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        self.search_var.set("")
        self.search_entry.focus()


class CommentSearchWindow:
    """Janela de busca no hist√≥rico de coment√°rios"""
    
    def __init__(self, parent, app, card_id):
        self.parent = parent
        self.app = app
        self.card_id = card_id
        self.icons = app.icons
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title(f"Buscar Coment√°rios - Cart√£o {card_id}")
        self.window.geometry("500x400")
        self.window.resizable(True, True)
        
        # Centralizar janela
        self.center_window()
        
        # Configurar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Criar interface
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        
        # Focar na janela
        self.window.focus_force()
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        ttk.Label(main_frame, text=f"Buscar Coment√°rios - Cart√£o {self.card_id}", 
                 font=("Arial", 12, "bold")).pack(pady=(0, 10))
        
        # Frame de busca
        search_frame = ttk.Frame(main_frame)
        search_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(search_frame, text="Termo de busca:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.search_var = tk.StringVar()
        self.search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=30)
        self.search_entry.pack(side=tk.LEFT, padx=(0, 10))
        self.search_entry.bind("<Return>", self.perform_search)
        
        ttk.Button(search_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                  command=self.perform_search).pack(side=tk.LEFT)
        
        # Frame para resultados
        results_frame = ttk.LabelFrame(main_frame, text="Resultados", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Treeview para resultados
        columns = ("Data", "Usu√°rio", "Coment√°rio")
        self.results_tree = ttk.Treeview(results_frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.results_tree.heading(col, text=col)
            self.results_tree.column(col, width=150, anchor="w")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=self.results_tree.yview)
        self.results_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.results_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Bot√µes
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X)
        
        ttk.Button(buttons_frame, text="Limpar", image=self.icons.get('clear_icon'), compound=tk.LEFT,
                  command=self.clear_results).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(buttons_frame, text="Fechar", image=self.icons.get('cancel_icon'), compound=tk.LEFT,
                  command=self.window.destroy).pack(side=tk.RIGHT)
        
        # Focar no campo de busca
        self.search_entry.focus()
    
    def perform_search(self, event=None):
        """Executa a busca"""
        search_term = self.search_var.get().strip()
        if not search_term:
            messagebox.showwarning("Aviso", "Digite um termo para buscar!")
            return
        
        # Limpar resultados anteriores
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        
        # Realizar busca
        results = self.app.chat_system.search_comment_history(self.card_id, search_term)
        
        # Exibir resultados
        for result in results:
            self.results_tree.insert("", "end", values=(
                result['timestamp'],
                result['username'],
                result['comment'][:50] + "..." if len(result['comment']) > 50 else result['comment']
            ))
        
        # Mostrar quantidade de resultados
        messagebox.showinfo("Busca Conclu√≠da", f"Encontrados {len(results)} resultados para '{search_term}'")
    
    def clear_results(self):
        """Limpa resultados da busca"""
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        self.search_var.set("")
        self.search_entry.focus()



    def safe_notebook_add(self, notebook, window, text=None):
        """Adiciona uma janela ao notebook de forma segura"""
        try:
            if text is None:
                text = getattr(window, 'winfo_name', lambda: "Tab")()
            notebook.add(window, text=text)
            return True
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao adicionar ao notebook: {e}")
            try:
                notebook.add(window, text="Tab")
                return True
            except:
                print(f"‚ùå Falha ao adicionar ao notebook: {e}")
                return False


    def safe_tkinter_operation(self, operation, *args, **kwargs):
        """Executa opera√ß√µes Tkinter de forma segura"""
        try:
            return operation(*args, **kwargs)
        except Exception as e:
            print(f"‚ö†Ô∏è Erro em opera√ß√£o Tkinter: {e}")
            return None
    
    def safe_widget_config(self, widget, **kwargs):
        """Configura widget de forma segura"""
        try:
            if widget and widget.winfo_exists():
                widget.config(**kwargs)
                return True
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao configurar widget: {e}")
        return False
    
    def safe_widget_pack(self, widget, **kwargs):
        """Faz pack de widget de forma segura"""
        try:
            if widget and widget.winfo_exists():
                widget.pack(**kwargs)
                return True
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao fazer pack do widget: {e}")
        return False

class BoodeskApp:
    def on_main_tab_drag_start(self, event):
        try:
            tab_index = self.main_notebook.index(f"@{event.x},{event.y}")
            if tab_index == 0: # Prevent dragging the first tab (Menu Principal)
                return
            if tab_index != "":
                self._drag_data["item"] = self.main_notebook.tabs()[tab_index]
                self._drag_data["tab_index"] = tab_index
        except tk.TclError:
            pass

    def on_main_tab_drag_motion(self, event):
        if self._drag_data["item"]:
            pass # Visual feedback can be added here if needed

    def on_main_tab_drag_release(self, event):
        if self._drag_data["item"]:
            try:
                new_tab_index = self.main_notebook.index(f"@{event.x},{event.y}")
                if new_tab_index == "":
                    new_tab_index = len(self.main_notebook.tabs()) - 1
                if new_tab_index == 0: # Prevent dropping onto the first tab
                    new_tab_index = 1 # or revert

                old_tab_index = self._drag_data["tab_index"]

                if old_tab_index != new_tab_index:
                    self.main_notebook.insert(new_tab_index, self.main_notebook.tabs()[old_tab_index])
            except tk.TclError:
                pass # Invalid drop target
            finally:
                self._drag_data = {"item": None, "x": 0, "y": 0, "tab_index": -1}

    def __init__(self, root, current_user, icons):
        print("DEBUG: Iniciando BoodeskApp.__init__")
        self.root = root
        self.current_user = current_user
        self.icons = icons # Store icons
        self.app = self # For compatibility with the LoginWindow
        
        # Initialize database
        self.db = Database('postgresql')
        
        # Tentar criar tabelas, se falhar, fazer limpeza for√ßada
        try:
            self.db.create_tables()
            self.db.migrate_json_to_relational()
        except Exception as e:
            print(f"Erro ao criar tabelas: {e}")
            # Ignorar erros de tabelas opcionais
            if "bank_accounts" in str(e) or "historico_deploys" in str(e):
                print("‚ö†Ô∏è Tabelas opcionais n√£o encontradas, continuando...")
            else:
                print("Tentando limpeza for√ßada do banco...")
                self.db.force_cleanup()
                try:
                    self.db.create_tables()
                except Exception as e2:
                    print(f"Erro persistente: {e2}")
                    print("Resetando banco de dados...")
                    self.db.reset_database()

        # --- File Paths ---
        if getattr(sys, 'frozen', False):
            # Running as a PyInstaller bundle
            self.base_dir = sys._MEIPASS
        else:
            # Running as a normal script
            self.base_dir = os.path.dirname(os.path.abspath(__file__))
        sep = os.path.sep

        self.settings_file = f"{self.base_dir}{sep}pomodoro_settings.json"
        # self.data_file = f"{self.base_dir}{sep}boodesk_data.json"  # Removido - usando apenas banco de dados
        # self.messages_file = f"{self.base_dir}{sep}pomodoro_motivational_messages.json"  # Removido - usando apenas dados em mem√≥ria

        self.load_settings()
        print("DEBUG: load_settings conclu√≠do")
        self.load_trello_data()
        print("DEBUG: load_trello_data conclu√≠do")
        
        # Verificar m√©todos do banco de dados
        print("DEBUG: Verificando m√©todos do banco de dados...")
        try:
            self.check_database_methods()
        except AttributeError:
            print("DEBUG: M√©todo check_database_methods n√£o encontrado, pulando verifica√ß√£o")
        print("DEBUG: Verifica√ß√£o de m√©todos conclu√≠da")
        
        # Verificar consist√™ncia dos cards ap√≥s carregar dados
        print("DEBUG: Iniciando verifica√ß√£o de consist√™ncia dos cards...")
        try:
            self.verify_card_consistency()
        except AttributeError:
            print("DEBUG: M√©todo verify_card_consistency n√£o encontrado, pulando verifica√ß√£o")
        print("DEBUG: Verifica√ß√£o de consist√™ncia conclu√≠da")
        
        self.load_pomodoro_data()
        print("DEBUG: load_pomodoro_data conclu√≠do")
        try:
            self.load_aux_data()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao carregar dados auxiliares: {e}")
            # Usar dados padr√£o
            self.messages = ["Bem-vindo ao Boodesk!", "Foco total!", "Voc√™ consegue!"]
        print("DEBUG: load_aux_data conclu√≠do")
        self.load_members()
        print("DEBUG: load_members conclu√≠do")
        
        # Inicializar sistema de upload completo (Supabase + Cloudflare R2)
        if SISTEMA_UPLOAD_DISPONIVEL:
            try:
                # Configura√ß√µes do Supabase (j√° configuradas)
                supabase_url = os.getenv("SUPABASE_URL", "https://your-project.supabase.co")
                supabase_key = os.getenv("SUPABASE_ANON_KEY", "your-anon-key")
                
                # Inicializar sistema de upload
                self.sistema_upload = SistemaUploadCompleto(supabase_url, supabase_key)
                print("‚úÖ Sistema de upload completo inicializado (Supabase + Cloudflare R2)")
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao inicializar sistema de upload: {e}")
                self.sistema_upload = None
        else:
            self.sistema_upload = None
            print("‚ö†Ô∏è Sistema de upload completo n√£o dispon√≠vel")
        self.load_categories()
        print("DEBUG: load_categories conclu√≠do")

        # Set the application icon
        if self.icons.get('logo_icon'):
            self.root.iconphoto(False, self.icons['logo_icon'])

        # --- User Management ---
        self.user_management = UserManagement()
        
        # --- Timer State ---
        self.timer_running = False
        self.current_cycle = 0
        self.on_break = False
        self.timer_id = None
        self.time_left = 0
        self.active_pomodoro_task = None

        self.listbox_refs = {}
        self.current_chart_type = "income_vs_expense" # Default chart type

        # --- Integrations ---
        # Email Integration
        self.email_integration = EmailIntegration(self)
        
        # Google Calendar Integration
        self.google_calendar = GoogleCalendarIntegration(self)
        # Calendar Event Manager (PostgreSQL)
        try:
            from calendar_manager import CalendarEventManager
            self.calendar_manager = CalendarEventManager(self.db.connection)
            print("‚úÖ CalendarEventManager inicializado com sucesso")
        except ImportError as e:
            print(f"‚ö†Ô∏è CalendarEventManager n√£o dispon√≠vel: {e}")
            self.calendar_manager = None
        except Exception as e:
            print(f"‚ùå Erro ao inicializar CalendarEventManager: {e}")
            self.calendar_manager = None
        
        
        # Email Template Manager
        self.email_template_manager = EmailTemplateManager(self)
        
        # --- Chat System ---
        self.chat_system = ChatSystem(self)
        
        # --- Meeting Integration ---
        self.meeting_integration = MeetingIntegration(self)
        
        # --- Notification Manager ---
        self.notification_manager = NotificationManager(self)
        
        # Garantir que self.settings seja um dicion√°rio antes de usar
        print(f"DEBUG: Tipo de self.settings: {type(self.settings)}")
        if not isinstance(self.settings, dict):
            print("DEBUG: self.settings n√£o √© um dicion√°rio, usando padr√µes")
            self.settings = self.get_default_settings()
        print(f"DEBUG: Tipo de self.settings ap√≥s corre√ß√£o: {type(self.settings)}")
        
        # Converter valores JSON string para dicion√°rios
        self._fix_json_strings_in_settings()
        
        # Start integrations if enabled
        email_integration = self.settings.get('email_integration', {})
        if isinstance(email_integration, dict) and email_integration.get('enabled', False):
            self.email_integration.start_email_service()
        
        # Initialize Google Calendar if enabled
        google_calendar = self.settings.get('google_calendar', {})
        if isinstance(google_calendar, dict) and google_calendar.get('enabled', False):
            print("DEBUG: Inicializando integra√ß√£o com Google Calendar")
            # A autentica√ß√£o ser√° feita quando necess√°rio

    def _safe_json_loads(self, json_string, default_value=None):
        if default_value is None:
            default_value = []
        if not isinstance(json_string, str) or not json_string.strip():
            return default_value
        try:
            return json.loads(json_string)
        except json.JSONDecodeError as e:
            print(f"Alerta de JSON inv√°lido: {e} - String: '{json_string[:100]}...'")
            # Tentar corrigir barras invertidas e tentar novamente
            try:
                corrected_string = json_string.replace('\\', '\\\\')
                return json.loads(corrected_string)
            except json.JSONDecodeError as e2:
                print(f"Falha ao corrigir JSON: {e2} - String: '{corrected_string[:100]}...'")
                return default_value

    
    def get_current_executable_path(self):
        """Obt√©m o caminho do execut√°vel atual"""
        try:
            # Se for execut√°vel, usar sys.executable
            if getattr(sys, 'frozen', False):
                return sys.executable
            
            # Se for script Python, procurar por BoodeskApp.exe no diret√≥rio
            app_dir = self.get_app_directory()
            possible_paths = [
                os.path.join(app_dir, "BoodeskApp.exe"),
                os.path.join(app_dir, "app23a.py"),
                os.path.join(os.getcwd(), "BoodeskApp.exe"),
                os.path.join(os.getcwd(), "app23a.py")
            ]
            
            for path in possible_paths:
                if os.path.exists(path):
                    return path
            
            return None
        except:
            return None
    
    def get_app_directory(self):
        """Obt√©m o diret√≥rio onde o aplicativo est√° sendo executado"""
        try:
            # Se for execut√°vel, usar o diret√≥rio do execut√°vel
            if getattr(sys, 'frozen', False):
                return os.path.dirname(sys.executable)
            # Se for script Python, usar o diret√≥rio do script
            else:
                return os.path.dirname(os.path.abspath(__file__))
        except:
            return os.getcwd()
    
    
    def get_user_python_path(self):
        """Obt√©m o caminho do Python do usu√°rio"""
        try:
            # Tentar usar o Python atual
            if hasattr(sys, 'executable') and sys.executable:
                return sys.executable
            
            # Tentar encontrar Python no PATH
            import subprocess
            result = subprocess.run(['python', '--version'], 
                                  capture_output=True, text=True, shell=True)
            if result.returncode == 0:
                return 'python'
            
            # Tentar python3
            result = subprocess.run(['python3', '--version'], 
                                  capture_output=True, text=True, shell=True)
            if result.returncode == 0:
                return 'python3'
                
        except:
            pass
        
        # Fallback para python
        return 'python'
    
    def get_download_directory(self):
        """Obt√©m o diret√≥rio de download configurado ou usa Desktop/Boodesk como padr√£o"""
        try:
            print("üîç Iniciando get_download_directory...")
            # Tentar obter configura√ß√£o do banco de dados
            if hasattr(self, 'db') and self.db:
                conn = self.db.get_connection()
                if conn:
                    cursor = conn.cursor()
                    cursor.execute("""
                        SELECT download_directory FROM user_preferences 
                        WHERE user_id = %s
                    """, (self.get_current_user_id(),))
                    result = cursor.fetchone()
                    if result and result[0]:
                        download_dir = result[0]
                        # Se o diret√≥rio configurado n√£o tem a pasta Boodesk, adicionar
                        if not download_dir.endswith("Boodesk"):
                            download_dir = os.path.join(download_dir, "Boodesk")
                        if os.path.exists(download_dir):
                            print(f"‚úÖ Usando diret√≥rio configurado: {download_dir}")
                            return download_dir
                        else:
                            print(f"‚ö†Ô∏è Diret√≥rio configurado n√£o existe: {download_dir}")
            
            # Se n√£o h√° configura√ß√£o ou diret√≥rio n√£o existe, usar Desktop/Boodesk como padr√£o
            # 1. Usar Desktop do usu√°rio (caminho padr√£o)
            desktop_dir = os.path.expanduser("~/Desktop")
            if os.access(desktop_dir, os.W_OK):
                print(f"‚úÖ Usando Desktop padr√£o: {desktop_dir}")
                return desktop_dir
            
            # 2. Tentar diret√≥rio do execut√°vel atual (se v√°lido)
            current_exe = os.path.abspath(sys.argv[0])
            if current_exe and os.path.exists(current_exe):
                exe_dir = os.path.dirname(current_exe)
                # Verificar se √© um diret√≥rio v√°lido (n√£o Python da Microsoft Store)
                if not "WindowsApps" in exe_dir and os.access(exe_dir, os.W_OK):
                    return exe_dir
            
            # 3. Tentar diret√≥rio de trabalho atual
            current_dir = os.getcwd()
            if os.access(current_dir, os.W_OK):
                return current_dir
            
            # 4. Usar diret√≥rio de documentos do usu√°rio
            documents_dir = os.path.expanduser("~/Documents")
            if os.access(documents_dir, os.W_OK):
                print(f"‚úÖ Usando Documents padr√£o: {documents_dir}")
                return documents_dir
            
            # 5. √öltimo recurso: diret√≥rio tempor√°rio
            import tempfile
            temp_dir = tempfile.gettempdir()
            print(f"‚úÖ Usando diret√≥rio tempor√°rio: {temp_dir}")
            return temp_dir
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao obter diret√≥rio de download: {e}")
            # Fallback para Desktop
            try:
                desktop_dir = os.path.expanduser("~/Desktop")
                if os.access(desktop_dir, os.W_OK):
                    print(f"‚úÖ Usando Desktop como fallback: {desktop_dir}")
                    return desktop_dir
            except:
                pass
            # √öltimo fallback para diret√≥rio atual
            current_dir = os.getcwd()
            print(f"‚úÖ Usando diret√≥rio atual como fallback: {current_dir}")
            return current_dir

    def set_download_directory(self, directory):
        """Define o diret√≥rio de download para o usu√°rio atual"""
        try:
            if not os.path.exists(directory):
                os.makedirs(directory, exist_ok=True)
            
            if not os.access(directory, os.W_OK):
                raise Exception(f"Sem permiss√£o de escrita no diret√≥rio: {directory}")
            
            # Salvar no banco de dados
            if hasattr(self, 'db') and self.db:
                conn = self.db.get_connection()
                if conn:
                    cursor = conn.cursor()
                    cursor.execute("""
                        INSERT INTO user_preferences (user_id, download_directory, created_at)
                        VALUES (%s, %s, NOW())
                        ON CONFLICT (user_id) 
                        DO UPDATE SET download_directory = EXCLUDED.download_directory, updated_at = NOW()
                    """, (self.get_current_user_id(), directory))
                    conn.commit()
                    print(f"‚úÖ Diret√≥rio de download configurado: {directory}")
                    return True
            
            return False
            
        except Exception as e:
            print(f"‚ùå Erro ao configurar diret√≥rio de download: {e}")
            return False
    def _fix_json_strings_in_settings(self):
        """Converte valores JSON string para dicion√°rios no settings"""
        import json
        
        for key, value in self.settings.items():
            if isinstance(value, str) and value.startswith('{') and value.endswith('}'):
                try:
                    self.settings[key] = json.loads(value)
                    print(f"DEBUG: Convertido {key} de string para dicion√°rio")
                except:
                    pass  # Manter como string se n√£o for JSON v√°lido

        # self.create_menu() ser√° chamado ap√≥s a defini√ß√£o dos m√©todos
        
        # Aplicar permiss√µes baseadas no usu√°rio atual (s√≥ se houver usu√°rio)
        if hasattr(self, 'current_user') and self.current_user:
            self.apply_role_permissions()
        print("DEBUG: Chamando create_widgets")
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        print("DEBUG: create_widgets conclu√≠do")
        if self.current_user:
            self.apply_role_permissions()
        
        # Iniciar sistema de notifica√ß√µes
        self.notification_manager.start_notification_monitor()
        
        # Criar templates padr√£o se n√£o existirem
        try:
            self.db.create_default_templates()
            print("DEBUG: Templates padr√£o verificados/criados")
        except Exception as e:
            print(f"Erro ao criar templates padr√£o: {e}")
        
        # Criar widget de reuni√µes se habilitado
        if self.notification_manager.notification_settings['show_widget']:
            # O widget ser√° criado quando o menu principal for criado
            pass

        # Migrar subtarefas do JSON para o banco de dados (se necess√°rio)
        print("DEBUG: Iniciando migra√ß√£o de subtarefas...")
        self.migrate_subtasks_to_database()
        print("DEBUG: Migra√ß√£o de subtarefas conclu√≠da")

    def configure_download_directory(self):
        """Permite ao usu√°rio configurar o diret√≥rio de download"""
        try:
            import tkinter.filedialog as filedialog
            
            current_dir = self.get_download_directory()
            
            # Abrir di√°logo para selecionar diret√≥rio
            new_dir = filedialog.askdirectory(
                title="Selecionar Diret√≥rio de Download",
                initialdir=current_dir
            )
            
            if new_dir:
                if self.set_download_directory(new_dir):
                    messagebox.showinfo("Sucesso", f"Diret√≥rio de download configurado:\n{new_dir}")
                    self.update_download_dir_label()
                else:
                    messagebox.showerror("Erro", "N√£o foi poss√≠vel configurar o diret√≥rio de download")
            
        except Exception as e:
            print(f"‚ùå Erro ao configurar diret√≥rio: {e}")
            messagebox.showerror("Erro", f"Erro ao configurar diret√≥rio: {e}")

    def update_download_dir_label(self):
        """Atualiza o label mostrando o diret√≥rio de download atual"""
        try:
            if hasattr(self, 'download_dir_label'):
                current_dir = self.get_download_directory()
                # Mostrar apenas o nome do diret√≥rio ou caminho abreviado
                if len(current_dir) > 40:
                    display_dir = "..." + current_dir[-37:]
                else:
                    display_dir = current_dir
                self.download_dir_label.config(text=f"üìÅ {display_dir}")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao atualizar label: {e}")



    def parse_brazilian_date(self, date_str):
        """Converte data brasileira (DD/MM/YYYY) para datetime ou vice-versa"""
        if not date_str:
            return None
            
        try:
            # Se j√° √© um objeto datetime, retorna ele mesmo
            if isinstance(date_str, datetime):
                return date_str
                
            # Tentar formato brasileiro primeiro: DD/MM/YYYY
            try:
                return datetime.strptime(date_str, "%d/%m/%Y")
            except ValueError:
                pass
                
            # Tentar formato brasileiro com hora: DD/MM/YYYY HH:MM
            try:
                return datetime.strptime(date_str, "%d/%m/%Y %H:%M")
            except ValueError:
                pass
                
            # Tentar formato brasileiro com hora e segundos: DD/MM/YYYY HH:MM:SS
            try:
                return datetime.strptime(date_str, "%d/%m/%Y %H:%M:%S")
            except ValueError:
                pass
                
            # Tentar formato americano: YYYY-MM-DD
            try:
                return datetime.strptime(date_str, "%Y-%m-%d")
            except ValueError:
                pass
                
            # Tentar formato americano com hora: YYYY-MM-DD HH:MM
            try:
                return datetime.strptime(date_str, "%Y-%m-%d %H:%M")
            except ValueError:
                pass
                
            # Tentar formato americano com hora e segundos: YYYY-MM-DD HH:MM:SS
            try:
                return datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
            except ValueError:
                pass
                
            print(f"Formato de data n√£o reconhecido: {date_str}")
            return None
            
        except Exception as e:
            print(f"Erro ao processar data: {date_str} - {e}")
            return None

    def get_board_id_by_name(self, board_name):
        """Get board ID by name from SQL database"""
        try:
            if hasattr(self, 'db') and self.db:
                try:
                    # Para administradores, buscar todos os quadros
                    if hasattr(self, 'current_user') and getattr(self.current_user, 'role', None) in ['admin', 'Administrador']:
                        boards = self.db.get_boards()  # Sem user_id para buscar todos
                    else:
                        # Para usu√°rios normais, filtrar por user_id
                        user_id = self.get_current_user_id()
                        boards = self.db.get_boards(user_id)
                    
                    if isinstance(boards, list):
                        for board in boards:
                            if isinstance(board, dict) and board.get('name') == board_name:
                                # Retornar board_id (UUID) em vez de id (inteiro)
                                board_id = board.get('board_id')
                                if board_id:
                                    print(f"DEBUG: Encontrado board_id {board_id} para quadro '{board_name}'")
                                    return board_id
                                else:
                                    print(f"DEBUG: board_id n√£o encontrado para quadro '{board_name}'")
                                    return None
                    else:
                        print(f"DEBUG: get_boards retornou {type(boards)} em vez de lista")
                except Exception as db_error:
                    print(f"DEBUG: Erro ao acessar banco de dados: {db_error}")
            # Fallback: buscar quadro pelo nome usando m√©todo espec√≠fico
            print(f"DEBUG: Tentando buscar quadro '{board_name}' pelo nome...")
            board_data = self.db.get_board_by_name(board_name)
            if board_data and board_data.get('board_id'):
                print(f"DEBUG: Encontrado board_id {board_data['board_id']} via get_board_by_name")
                return board_data['board_id']
            
            print(f"DEBUG: Quadro '{board_name}' n√£o encontrado no banco")
            return None
        except Exception as e:
            print(f"Erro ao buscar board: {e}")
            return None
    
    def get_board_id_by_name_safe(self, board_name):
        """Vers√£o segura do get_board_id_by_name que sempre retorna um valor"""
        try:
            board_id = self.get_board_id_by_name(board_name)
            if board_id:
                return board_id
            else:
                print(f"DEBUG: get_board_id_by_name retornou None para '{board_name}'")
                return None
        except Exception as e:
            print(f"DEBUG: Erro no get_board_id_by_name_safe: {e}")
            return None
    
    def __getattr__(self, name):
        """Fallback para m√©todos n√£o encontrados"""
        if name == 'get_board_id_by_name':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda board_name: None  # Retorna None em vez de 1
        elif name == 'get_board_id_by_name_safe':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda board_name: None  # Retorna None em vez de 1
        elif name == 'time_left':
            print(f"DEBUG: Atributo {name} n√£o encontrado, inicializando com 0")
            self.time_left = 0
            return 0
        elif name == 'timer_running':
            print(f"DEBUG: Atributo {name} n√£o encontrado, inicializando com False")
            self.timer_running = False
            return False
        elif name == 'current_cycle':
            print(f"DEBUG: Atributo {name} n√£o encontrado, inicializando com 0")
            self.current_cycle = 0
            return 0
        elif name == 'on_break':
            print(f"DEBUG: Atributo {name} n√£o encontrado, inicializando com False")
            self.on_break = False
            return False
        elif name == 'timer_id':
            print(f"DEBUG: Atributo {name} n√£o encontrado, inicializando com None")
            self.timer_id = None
            return None
        elif name == 'active_pomodoro_task':
            print(f"DEBUG: Atributo {name} n√£o encontrado, inicializando com None")
            self.active_pomodoro_task = None
            return None
        elif name == 'pomodoro_timer_label':
            print(f"DEBUG: Widget {name} n√£o encontrado, retornando None")
            return None
        elif name == 'timer_label':
            print(f"DEBUG: Widget {name} n√£o encontrado, retornando None")
            return None
        elif name == 'pomodoro_frame':
            print(f"DEBUG: Widget {name} n√£o encontrado, retornando None")
            return None
        elif name == 'timer_frame':
            print(f"DEBUG: Widget {name} n√£o encontrado, retornando None")
            return None
        elif name == 'create_finance_dashboard_enterprise':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda parent: self._create_finance_dashboard_fallback(parent)
        elif name == 'create_enterprise_metric_card':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda parent, title, value, color, row, col: self._create_metric_card_fallback(parent, title, value, color, row, col)
        elif name == 'refresh_enterprise_dashboard':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._refresh_dashboard_fallback()
        elif name == 'show_enterprise_chart':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda chart_type: self._show_chart_fallback(chart_type)
        elif name == 'update_enterprise_alerts':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._update_alerts_fallback()
        elif name == 'create_clients_management_tab':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda parent: self._create_clients_tab_fallback(parent)
        elif name == 'save_client':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._save_client_fallback()
        elif name == 'clear_client_form':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._clear_client_form_fallback()
        elif name == 'load_clients':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._load_clients_fallback()
        elif name == 'on_client_select':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda event: self._on_client_select_fallback(event)
        elif name == 'delete_client':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._delete_client_fallback()
        elif name == 'open_new_client_window':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._open_new_client_window_fallback()
        elif name == 'create_suppliers_management_tab':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda parent: self._create_suppliers_tab_fallback(parent)
        elif name == 'create_receivables_management_tab':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda parent: self._create_receivables_tab_fallback(parent)
        elif name == 'open_new_receivable_window':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._open_new_receivable_window_fallback()
        elif name == 'load_receivables':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._load_receivables_fallback()
        elif name == 'filter_receivables':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._filter_receivables_fallback()
        elif name == 'on_receivable_select':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda event: self._on_receivable_select_fallback(event)
        elif name == 'delete_receivable':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._delete_receivable_fallback()
        elif name == 'open_new_payable_window':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._open_new_payable_window_fallback()
        elif name == 'load_payables':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._load_payables_fallback()
        elif name == 'filter_payables':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._filter_payables_fallback()
        elif name == 'on_payable_select':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda event: self._on_payable_select_fallback(event)
        elif name == 'delete_payable':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda: self._delete_payable_fallback()
        elif name == 'create_payables_management_tab':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda parent: self._create_payables_tab_fallback(parent)
        elif name == 'create_invoices_management_tab':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda parent: self._create_invoices_tab_fallback(parent)
        elif name == 'create_cashflow_management_tab':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda parent: self._create_cashflow_tab_fallback(parent)
        elif name == 'create_budgets_management_tab':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda parent: self._create_budgets_tab_fallback(parent)
        elif name == 'create_enterprise_reports_tab':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda parent: self._create_reports_tab_fallback(parent)
        elif name == 'create_finance_config_tab':
            print(f"DEBUG: M√©todo {name} n√£o encontrado, usando fallback")
            return lambda parent: self._create_config_tab_fallback(parent)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    # M√©todos de fallback para o sistema financeiro empresarial
    def _create_finance_dashboard_fallback(self, parent):
        """Fallback para o dashboard financeiro"""
        ttk.Label(parent, text="üè¢ Dashboard Financeiro - Carregando...", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _create_metric_card_fallback(self, parent, title, value, color, row, col):
        """Fallback para cards de m√©tricas"""
        pass
    
    def _refresh_dashboard_fallback(self):
        """Fallback para atualizar dashboard"""
        pass
    
    def _show_chart_fallback(self, chart_type):
        """Fallback para mostrar gr√°ficos"""
        messagebox.showinfo("Aviso", f"Gr√°fico {chart_type} - Em desenvolvimento")
    
    def _update_alerts_fallback(self):
        """Fallback para atualizar alertas"""
        pass
    
    def _create_clients_tab_fallback(self, parent):
        """Fallback para aba de clientes"""
        ttk.Label(parent, text="üë• Gest√£o de Clientes - Carregando...", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _save_client_fallback(self):
        """Fallback para salvar cliente"""
        messagebox.showinfo("Aviso", "Funcionalidade em desenvolvimento")
    
    def _clear_client_form_fallback(self):
        """Fallback para limpar formul√°rio"""
        pass
    
    def _load_clients_fallback(self):
        """Fallback para carregar clientes"""
        pass
    
    def _on_client_select_fallback(self, event):
        """Fallback para sele√ß√£o de cliente"""
        pass
    
    def _delete_client_fallback(self):
        """Fallback para deletar cliente"""
        messagebox.showinfo("Aviso", "Funcionalidade em desenvolvimento")
    
    def _open_new_client_window_fallback(self):
        """Fallback para nova janela de cliente"""
        pass
    
    def _create_suppliers_tab_fallback(self, parent):
        """Fallback para aba de fornecedores"""
        ttk.Label(parent, text="üè≠ Gest√£o de Fornecedores - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _create_receivables_tab_fallback(self, parent):
        """Fallback para aba de contas a receber"""
        # Frame principal
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text="üì• Contas a Receber", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        # Bot√µes de a√ß√£o
        buttons_frame = ttk.Frame(title_frame)
        buttons_frame.pack(side=tk.RIGHT)
        
        ttk.Button(buttons_frame, text="‚ûï Nova Conta", 
                  command=self.open_new_receivable_window).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(buttons_frame, text="üîÑ Atualizar", 
                  command=self.load_receivables).pack(side=tk.LEFT, padx=5)
        
        # Frame para filtros
        filters_frame = ttk.LabelFrame(main_frame, text="Filtros", padding="10")
        filters_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Filtros
        ttk.Label(filters_frame, text="Status:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.receivable_status_filter = ttk.Combobox(filters_frame, 
                                                   values=["Todos", "Pendente", "Pago", "Vencido", "Cancelado"],
                                                   state="readonly", width=15)
        self.receivable_status_filter.set("Todos")
        self.receivable_status_filter.grid(row=0, column=1, sticky="w", padx=5, pady=2)
        self.receivable_status_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_receivables())
        
        ttk.Label(filters_frame, text="Cliente:").grid(row=0, column=2, sticky="w", padx=5, pady=2)
        self.receivable_client_filter = ttk.Combobox(filters_frame, state="readonly", width=20)
        self.receivable_client_filter.grid(row=0, column=3, sticky="w", padx=5, pady=2)
        self.receivable_client_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_receivables())
        
        ttk.Label(filters_frame, text="Vencimento:").grid(row=0, column=4, sticky="w", padx=5, pady=2)
        self.receivable_due_filter = ttk.Combobox(filters_frame, 
                                                values=["Todos", "Hoje", "Esta Semana", "Este M√™s", "Vencidos"],
                                                state="readonly", width=15)
        self.receivable_due_filter.set("Todos")
        self.receivable_due_filter.grid(row=0, column=5, sticky="w", padx=5, pady=2)
        self.receivable_due_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_receivables())
        
        # Treeview para contas a receber
        tree_frame = ttk.Frame(main_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbars
        tree_scrollbar_y = ttk.Scrollbar(tree_frame)
        tree_scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        
        tree_scrollbar_x = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL)
        tree_scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Treeview
        columns = ("ID", "Cliente", "Descri√ß√£o", "Valor", "Vencimento", "Status", "Data Cria√ß√£o")
        self.receivables_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", 
                                           yscrollcommand=tree_scrollbar_y.set,
                                           xscrollcommand=tree_scrollbar_x.set)
        
        # Configurar colunas
        self.receivables_tree.heading("ID", text="ID")
        self.receivables_tree.heading("Cliente", text="Cliente")
        self.receivables_tree.heading("Descri√ß√£o", text="Descri√ß√£o")
        self.receivables_tree.heading("Valor", text="Valor")
        self.receivables_tree.heading("Vencimento", text="Vencimento")
        self.receivables_tree.heading("Status", text="Status")
        self.receivables_tree.heading("Data Cria√ß√£o", text="Data Cria√ß√£o")
        
        self.receivables_tree.column("ID", width=80, anchor="center")
        self.receivables_tree.column("Cliente", width=150, anchor="w")
        self.receivables_tree.column("Descri√ß√£o", width=200, anchor="w")
        self.receivables_tree.column("Valor", width=100, anchor="e")
        self.receivables_tree.column("Vencimento", width=100, anchor="center")
        self.receivables_tree.column("Status", width=100, anchor="center")
        self.receivables_tree.column("Data Cria√ß√£o", width=120, anchor="center")
        
        self.receivables_tree.pack(fill=tk.BOTH, expand=True)
        
        # Configurar scrollbars
        tree_scrollbar_y.config(command=self.receivables_tree.yview)
        tree_scrollbar_x.config(command=self.receivables_tree.xview)
        
        # Bind eventos
        self.receivables_tree.bind("<Double-1>", self.on_receivable_select)
        self.receivables_tree.bind("<Delete>", lambda e: self.delete_receivable())
        
        # Frame para estat√≠sticas
        stats_frame = ttk.LabelFrame(main_frame, text="Estat√≠sticas", padding="10")
        stats_frame.pack(fill=tk.X, pady=(10, 0))
        
        # Estat√≠sticas
        self.receivable_total_label = ttk.Label(stats_frame, text="Total: R$ 0,00", font=("Arial", 12, "bold"))
        self.receivable_total_label.pack(side=tk.LEFT, padx=10)
        
        self.receivable_pending_label = ttk.Label(stats_frame, text="Pendente: R$ 0,00", font=("Arial", 10))
        self.receivable_pending_label.pack(side=tk.LEFT, padx=10)
        
        self.receivable_overdue_label = ttk.Label(stats_frame, text="Vencido: R$ 0,00", font=("Arial", 10))
        self.receivable_overdue_label.pack(side=tk.LEFT, padx=10)
        
        self.receivable_paid_label = ttk.Label(stats_frame, text="Pago: R$ 0,00", font=("Arial", 10))
        self.receivable_paid_label.pack(side=tk.LEFT, padx=10)
        
        # Carregar dados
        self.load_receivables()
    
    def _open_new_receivable_window_fallback(self):
        """Fallback para abrir janela de nova conta a receber"""
        messagebox.showinfo("Funcionalidade", "Funcionalidade de contas a receber em desenvolvimento.")
    
    def _load_receivables_fallback(self):
        """Fallback para carregar contas a receber"""
        pass
    
    def _filter_receivables_fallback(self):
        """Fallback para filtrar contas a receber"""
        pass
    
    def _on_receivable_select_fallback(self, event):
        """Fallback para sele√ß√£o de conta a receber"""
        pass
    
    def _delete_receivable_fallback(self):
        """Fallback para deletar conta a receber"""
        pass
    
    def _open_new_payable_window_fallback(self):
        """Fallback para abrir janela de nova conta a pagar"""
        messagebox.showinfo("Funcionalidade", "Funcionalidade de contas a pagar em desenvolvimento.")
    
    def _load_payables_fallback(self):
        """Fallback para carregar contas a pagar"""
        pass
    
    def _filter_payables_fallback(self):
        """Fallback para filtrar contas a pagar"""
        pass
    
    def _on_payable_select_fallback(self, event):
        """Fallback para sele√ß√£o de conta a pagar"""
        pass
    
    def _delete_payable_fallback(self):
        """Fallback para deletar conta a pagar"""
        pass
    
    def _create_payables_tab_fallback(self, parent):
        """Fallback para aba de contas a pagar"""
        # Frame principal
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text="üì§ Contas a Pagar", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        # Bot√µes de a√ß√£o
        buttons_frame = ttk.Frame(title_frame)
        buttons_frame.pack(side=tk.RIGHT)
        
        ttk.Button(buttons_frame, text="‚ûï Nova Conta", 
                  command=self.open_new_payable_window).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(buttons_frame, text="üîÑ Atualizar", 
                  command=self.load_payables).pack(side=tk.LEFT, padx=5)
        
        # Frame para filtros
        filters_frame = ttk.LabelFrame(main_frame, text="Filtros", padding="10")
        filters_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Filtros
        ttk.Label(filters_frame, text="Status:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.payable_status_filter = ttk.Combobox(filters_frame, 
                                                values=["Todos", "Pendente", "Pago", "Vencido", "Cancelado"],
                                                state="readonly", width=15)
        self.payable_status_filter.set("Todos")
        self.payable_status_filter.grid(row=0, column=1, sticky="w", padx=5, pady=2)
        self.payable_status_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_payables())
        
        ttk.Label(filters_frame, text="Fornecedor:").grid(row=0, column=2, sticky="w", padx=5, pady=2)
        self.payable_supplier_filter = ttk.Combobox(filters_frame, state="readonly", width=20)
        self.payable_supplier_filter.grid(row=0, column=3, sticky="w", padx=5, pady=2)
        self.payable_supplier_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_payables())
        
        ttk.Label(filters_frame, text="Vencimento:").grid(row=0, column=4, sticky="w", padx=5, pady=2)
        self.payable_due_filter = ttk.Combobox(filters_frame, 
                                             values=["Todos", "Hoje", "Esta Semana", "Este M√™s", "Vencidos"],
                                             state="readonly", width=15)
        self.payable_due_filter.set("Todos")
        self.payable_due_filter.grid(row=0, column=5, sticky="w", padx=5, pady=2)
        self.payable_due_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_payables())
        
        # Treeview para contas a pagar
        tree_frame = ttk.Frame(main_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbars
        tree_scrollbar_y = ttk.Scrollbar(tree_frame)
        tree_scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        
        tree_scrollbar_x = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL)
        tree_scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Treeview
        columns = ("ID", "Fornecedor", "Descri√ß√£o", "Valor", "Vencimento", "Status", "Data Cria√ß√£o")
        self.payables_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", 
                                        yscrollcommand=tree_scrollbar_y.set,
                                        xscrollcommand=tree_scrollbar_x.set)
        
        # Configurar colunas
        self.payables_tree.heading("ID", text="ID")
        self.payables_tree.heading("Fornecedor", text="Fornecedor")
        self.payables_tree.heading("Descri√ß√£o", text="Descri√ß√£o")
        self.payables_tree.heading("Valor", text="Valor")
        self.payables_tree.heading("Vencimento", text="Vencimento")
        self.payables_tree.heading("Status", text="Status")
        self.payables_tree.heading("Data Cria√ß√£o", text="Data Cria√ß√£o")
        
        self.payables_tree.column("ID", width=80, anchor="center")
        self.payables_tree.column("Fornecedor", width=150, anchor="w")
        self.payables_tree.column("Descri√ß√£o", width=200, anchor="w")
        self.payables_tree.column("Valor", width=100, anchor="e")
        self.payables_tree.column("Vencimento", width=100, anchor="center")
        self.payables_tree.column("Status", width=100, anchor="center")
        self.payables_tree.column("Data Cria√ß√£o", width=120, anchor="center")
        
        self.payables_tree.pack(fill=tk.BOTH, expand=True)
        
        # Configurar scrollbars
        tree_scrollbar_y.config(command=self.payables_tree.yview)
        tree_scrollbar_x.config(command=self.payables_tree.xview)
        
        # Bind eventos
        self.payables_tree.bind("<Double-1>", self.on_payable_select)
        self.payables_tree.bind("<Delete>", lambda e: self.delete_payable())
        
        # Frame para estat√≠sticas
        stats_frame = ttk.LabelFrame(main_frame, text="Estat√≠sticas", padding="10")
        stats_frame.pack(fill=tk.X, pady=(10, 0))
        
        # Estat√≠sticas
        self.payable_total_label = ttk.Label(stats_frame, text="Total: R$ 0,00", font=("Arial", 12, "bold"))
        self.payable_total_label.pack(side=tk.LEFT, padx=10)
        
        self.payable_pending_label = ttk.Label(stats_frame, text="Pendente: R$ 0,00", font=("Arial", 10))
        self.payable_pending_label.pack(side=tk.LEFT, padx=10)
        
        self.payable_overdue_label = ttk.Label(stats_frame, text="Vencido: R$ 0,00", font=("Arial", 10))
        self.payable_overdue_label.pack(side=tk.LEFT, padx=10)
        
        self.payable_paid_label = ttk.Label(stats_frame, text="Pago: R$ 0,00", font=("Arial", 10))
        self.payable_paid_label.pack(side=tk.LEFT, padx=10)
        
        # Carregar dados
        self.load_payables()
    
    def _create_invoices_tab_fallback(self, parent):
        """Fallback para aba de faturas"""
        ttk.Label(parent, text="üßæ Gest√£o de Faturas - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _create_cashflow_tab_fallback(self, parent):
        """Fallback para aba de fluxo de caixa"""
        ttk.Label(parent, text="üíº Fluxo de Caixa - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _create_budgets_tab_fallback(self, parent):
        """Fallback para aba de or√ßamentos"""
        ttk.Label(parent, text="üìä Gest√£o de Or√ßamentos - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _create_reports_tab_fallback(self, parent):
        """Fallback para aba de relat√≥rios"""
        ttk.Label(parent, text="üìà Relat√≥rios Empresariais - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def _create_config_tab_fallback(self, parent):
        """Fallback para aba de configura√ß√µes"""
        ttk.Label(parent, text="‚öôÔ∏è Configura√ß√µes Financeiras - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)

    def notify_member_added_to_card(self, card_id, member_name, added_by):
        """Notifica membro quando adicionado a um card"""
        try:
            card = self.get_card_by_id(card_id)
            if not card:
                return
            
            notification = {
                'type': 'member_added',
                'card_title': card['title'],
                'card_id': card_id,
                'member': member_name,
                'added_by': added_by,
                'board': card.get('board_name', ''),
                'list': card.get('list_name', ''),
                'timestamp': datetime.now().isoformat(),
                'read': False
            }
            
            # Salvar notifica√ß√£o no banco (se m√©todo existir)
            if hasattr(self, 'db') and hasattr(self.db, 'save_notification'):
                self.db.save_notification(notification)
            
            # Mostrar notifica√ß√£o na interface
            self.show_notification_popup(notification)
            
            # Enviar email se configurado
            if hasattr(self, 'email_integration'):
                self.email_integration.notify_member_added(notification)
                
        except Exception as e:
            print(f"Erro ao notificar membro adicionado: {e}")

    def show_notification_popup(self, notification):
        """Mostra popup de notifica√ß√£o"""
        try:
            popup = tk.Toplevel(self.root)
            popup.title("Nova Notifica√ß√£o")
            popup.geometry("400x200")
            popup.resizable(False, False)
            
            # Centralizar popup
            popup.transient(self.root)
            popup.grab_set()
            
            message = f"Voc√™ foi adicionado ao card:\n'{notification['card_title']}'\n\nQuadro: {notification['board']}\nLista: {notification['list']}"
            
            ttk.Label(popup, text=message, wraplength=350, justify='center').pack(pady=20)
            
            button_frame = ttk.Frame(popup)
            button_frame.pack(pady=10)
            
            ttk.Button(button_frame, text="Ver Card", 
                      command=lambda: self.open_card_from_notification(notification['card_id'])).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Fechar", command=popup.destroy).pack(side=tk.LEFT, padx=5)
            
        except Exception as e:
            print(f"Erro ao mostrar popup de notifica√ß√£o: {e}")

    def open_card_from_notification(self, card_id):
        """Abre card a partir de notifica√ß√£o"""
        try:
            # Encontrar card nos dados
            for board_name, board_data in self.boodesk_data['boards'].items():
                for list_name, cards in board_data.items():
                    for card in cards:
                        if card.get('card_id') == card_id:
                            # Abrir janela do card
                            CardWindow(self.root, self, board_name, list_name, card_id, self.current_user)
                            return
            print(f"Card {card_id} n√£o encontrado")
        except Exception as e:
            print(f"Erro ao abrir card: {e}")

    def get_card_by_id(self, card_id):
        """Retorna card pelo ID - busca tanto no banco quanto na mem√≥ria"""
        try:
            # Primeiro, tentar buscar no banco de dados
            if hasattr(self, 'db') and self.db:
                try:
                    card_data = self.db.get_card_by_id(card_id)
                    if card_data:
                        # Converter para dicion√°rio se necess√°rio
                        if not isinstance(card_data, dict):
                            card_data = dict(card_data)
                        
                        # Adicionar informa√ß√µes do board e lista
                        board_name = self.db.get_board_name_by_id(card_data.get('board_id'))
                        card_data['board_name'] = board_name or 'Quadro Principal'
                        card_data['list_name'] = card_data.get('list_name', 'A Fazer')
                        return card_data
                except Exception as db_error:
                    print(f"Erro ao buscar card no banco: {db_error}")
            
            # Se n√£o encontrou no banco, buscar na estrutura em mem√≥ria
            for board_name, board_data in self.boodesk_data['boards'].items():
                if isinstance(board_data, dict):
                    for list_name, cards in board_data.items():
                        if list_name == 'workflow':  # Ignorar metadados
                            continue
                        if isinstance(cards, list):
                            for card in cards:
                                if card.get('card_id') == card_id:
                                    card['board_name'] = board_name
                                    card['list_name'] = list_name
                                    return card
            
            print(f"Card com ID {card_id} n√£o encontrado")
            return None
        except Exception as e:
            print(f"Erro ao buscar card por ID: {e}")
            return None

    def create_member_dashboard(self, member_name):
        """Cria dashboard personalizado para o membro"""
        dashboard = {
            'my_cards': self.get_cards_by_member(member_name),
            'my_boards': self.get_boards_for_member(member_name),
            'pending_tasks': self.get_pending_tasks(member_name),
            'completed_tasks': self.get_completed_tasks(member_name),
            'recent_activities': self.get_recent_activities(member_name),
            'upcoming_deadlines': self.get_upcoming_deadlines(member_name)
        }
        return dashboard

    def get_cards_by_member(self, member_name):
        """Retorna todos os cards onde o membro participa"""
        member = self.db.get_member_by_name(member_name)
        if member:
            return self.db.get_cards_by_member_id(member['id'])
        return []

    def get_pending_tasks(self, member_name):
        """Retorna tarefas pendentes do membro"""
        return [card for card in self.get_cards_by_member(member_name) 
                if card.get('status') != 'done']

    def get_completed_tasks(self, member_name, days=30):
        """Retorna tarefas completadas nos √∫ltimos X dias"""
        cutoff_date = datetime.now() - timedelta(days=days)
        completed = []
        for card in self.get_cards_by_member(member_name):
            if card.get('status') == 'done':
                completed_date = card.get('completed_at')
                if completed_date and completed_date > cutoff_date:
                    completed.append(card)
        return completed

    def get_recent_activities(self, member_name, limit=10):
        """Retorna atividades recentes relacionadas ao membro"""
        # Implementa√ß√£o b√°sica - pode ser expandida com banco de dados
        activities = []
        cards = self.get_cards_by_member(member_name)
        for card in cards[:limit]:
            activities.append({
                'action': 'Card atribu√≠do',
                'card_title': card['title'],
                'timestamp': card.get('created_at', 'Data n√£o dispon√≠vel')
            })
        return activities

    def get_upcoming_deadlines(self, member_name, days=7):
        """Retorna prazos pr√≥ximos do membro"""
        cutoff_date = datetime.now() + timedelta(days=days)
        upcoming = []
        for card in self.get_cards_by_member(member_name):
            if card.get('status') != 'done':
                due_date = card.get('due_date')
                if due_date and due_date <= cutoff_date:
                    upcoming.append(card)
        return upcoming

    def show_member_dashboard(self, member_name):
        """Mostra dashboard personalizado do membro"""
        try:
            dashboard = self.create_member_dashboard(member_name)
            
            # Criar janela do dashboard
            dashboard_window = tk.Toplevel(self.root)
            dashboard_window.title(f"Dashboard - {member_name}")
            dashboard_window.geometry("800x600")
            dashboard_window.resizable(True, True)
            
            # Notebook para organizar as se√ß√µes
            notebook = ttk.Notebook(dashboard_window)
            notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Aba de Cards Ativos
            active_frame = ttk.Frame(notebook)
            notebook.add(active_frame, text="Meus Cards")
            
            # Treeview para cards ativos
            columns = ("T√≠tulo", "Quadro", "Lista", "Status", "Prazo")
            tree = ttk.Treeview(active_frame, columns=columns, show="headings")
            
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=120)
            
            # Adicionar cards
            for card in dashboard['my_cards']:
                tree.insert("", "end", values=(
                    card['title'],
                    card['board_name'],
                    card['list_name'],
                    card.get('status', 'Pendente'),
                    card.get('due_date', '-')
                ))
            
            tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Aba de Estat√≠sticas
            stats_frame = ttk.Frame(notebook)
            notebook.add(stats_frame, text="Estat√≠sticas")
            
            stats_text = f"""
            üìä Estat√≠sticas de {member_name}
            
            üìã Total de Cards: {len(dashboard['my_cards'])}
            ‚è≥ Pendentes: {len(dashboard['pending_tasks'])}
            ‚úÖ Completados (30 dias): {len(dashboard['completed_tasks'])}
            üìÖ Prazos Pr√≥ximos: {len(dashboard['upcoming_deadlines'])}
            üìã Quadros Ativos: {len(dashboard['my_boards'])}
            """
            
            ttk.Label(stats_frame, text=stats_text, justify='left', font=('Arial', 12)).pack(pady=20)
            
        except Exception as e:
            print(f"Erro ao mostrar dashboard: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel mostrar o dashboard: {e}")

    def open_personal_dashboard(self):
        """Abre dashboard personalizado do usu√°rio atual"""
        try:
            # Obter membro do usu√°rio atual
            current_user_member = self._get_current_user_member()
            
            if not current_user_member:
                messagebox.showwarning("Aviso", "Usu√°rio n√£o tem membro associado. Dashboard n√£o dispon√≠vel.")
                return
            
            # Mostrar dashboard
            self.show_member_dashboard(current_user_member)
            
        except Exception as e:
            print(f"Erro ao abrir dashboard pessoal: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir o dashboard: {e}")

    def format_brazilian_date(self, date_obj):
        """Converte datetime para formato brasileiro (DD/MM/YYYY)"""
        if not date_obj:
            return ""
            
        try:
            if isinstance(date_obj, str):
                # Se j√° √© string, tentar converter primeiro
                date_obj = self.parse_brazilian_date(date_obj)
                
            if isinstance(date_obj, datetime):
                return date_obj.strftime("%d/%m/%Y")
            else:
                return str(date_obj)
                
        except Exception as e:
            print(f"Erro ao formatar data: {date_obj} - {e}")
            return str(date_obj) if date_obj else ""

    def format_brazilian_datetime(self, date_obj):
        """Converte datetime para formato brasileiro com hora (DD/MM/YYYY HH:MM)"""
        if not date_obj:
            return ""
            
        try:
            if isinstance(date_obj, str):
                # Se j√° √© string, tentar converter primeiro
                date_obj = self.parse_brazilian_date(date_obj)
                
            if isinstance(date_obj, datetime):
                return date_obj.strftime("%d/%m/%Y %H:%M")
            else:
                return str(date_obj)
                
        except Exception as e:
            print(f"Erro ao formatar data/hora: {date_obj} - {e}")
            return str(date_obj) if date_obj else ""

    
    def check_permission(self, permission):
        """Verifica se o usu√°rio atual tem uma determinada permiss√£o"""
        if not hasattr(self, 'current_user') or not self.current_user:
            return False
        
        # Verificar se o usu√°rio tem o m√©todo has_permission
        if not hasattr(self.current_user, 'has_permission'):
            print("DEBUG: Usu√°rio n√£o tem m√©todo has_permission")
            return False
        
        return self.current_user.has_permission(permission)
    
    def require_permission(self, permission, action_name="esta a√ß√£o"):
        """Verifica permiss√£o e mostra erro se n√£o tiver"""
        if not self.check_permission(permission):
            messagebox.showerror("Acesso Negado", 
                               f"Voc√™ n√£o tem permiss√£o para {action_name}.\n"
                               f"Contate um administrador se precisar de acesso.")
            return False
        return True
    
    def open_user_management(self):
        """Abre a janela de gerenciamento de usu√°rios"""
        try:
            # Verificar se o usu√°rio tem permiss√£o
            if not self.require_permission("manage_users", "gerenciar usu√°rios"):
                return
            
            # Verificar se user_management est√° dispon√≠vel
            if not hasattr(self, 'user_management') or self.user_management is None:
                messagebox.showerror("Erro", "Sistema de gerenciamento de usu√°rios n√£o dispon√≠vel.")
                return
            
            # Verificar se icons est√° dispon√≠vel
            if not hasattr(self, 'icons') or self.icons is None:
                messagebox.showerror("Erro", "√çcones n√£o dispon√≠veis.")
                return
            
            # Abrir janela de gerenciamento
            print("DEBUG: Abrindo janela de gerenciamento de usu√°rios...")
            UserRegistrationWindow(self.root, self.user_management, self.icons, app=self)
            print("DEBUG: Janela de gerenciamento de usu√°rios aberta com sucesso!")
            
        except Exception as e:
            print(f"DEBUG: Erro ao abrir gerenciamento de usu√°rios: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir a tela de gerenciar usu√°rios: {e}")
    
    def open_notification_settings(self):
        """Abre a janela de configura√ß√µes de notifica√ß√£o"""
        NotificationSettingsWindow(self)
    
    def toggle_meeting_widget(self):
        """Alterna a visibilidade do widget de reuni√µes"""
        if hasattr(self, 'meeting_widget') and self.meeting_widget:
            if self.meeting_widget.widget_frame:
                self.meeting_widget.widget_frame.destroy()
                self.meeting_widget = None
                self.notification_manager.notification_settings['show_widget'] = False
        else:
            # Encontrar o frame do menu principal
            for child in self.main_notebook.winfo_children():
                if self.main_notebook.tab(child, "text") == "Menu Principal":
                    self.meeting_widget = MeetingWidget(self, child)
                    self.notification_manager.notification_settings['show_widget'] = True
                    break
        
        # Salvar configura√ß√£o
        self.notification_manager.save_notification_settings()
    
    def on_closing(self):
        """Chamado quando a aplica√ß√£o est√° sendo fechada"""
        try:
            # Parar sistema de notifica√ß√µes
            if hasattr(self, 'notification_manager'):
                self.notification_manager.stop_notification_monitor()
            
            # Salvar configura√ß√µes
            self.save_settings_file()
            
            # Salvar dados do Boodesk
            self.save_trello_data()
            
            # Salvar dados do Pomodoro
            self.save_pomodoro_data()
            
            # Salvar dados financeiros
            self.save_finance_data()
            
            # Salvar dados de estudo
            self.save_study_data()
            
            # Salvar dados de objetivos
            self.save_goals_data()
            
            # Salvar dados de membros
            self.save_members_data()
            
            # Salvar dados de assuntos
            self.save_subjects_data()
            
            print("DEBUG: Todos os dados foram salvos com sucesso")
            
        except Exception as e:
            print(f"Erro ao salvar dados: {e}")
        
        finally:
            # Fechar aplica√ß√£o
            self.root.destroy()
    
    def logout(self):
        """Faz logout do usu√°rio atual"""
        if messagebox.askyesno("Logout", "Tem certeza que deseja fazer logout?"):
            # Limpar dados do usu√°rio atual
            self.current_user = None
            
            # Ocultar janela principal
            self.root.withdraw()
            
            # Mostrar tela de login novamente
            login_window = LoginWindow(self.root, self.user_management, self.icons)
            self.root.wait_window(login_window)
            
            # Verificar se o login foi bem-sucedido
            if hasattr(self.root, 'login_successful') and self.root.login_successful and self.root.current_user:
                # Configurar novo usu√°rio na aplica√ß√£o
                self.current_user = self.root.current_user
                self.apply_role_permissions()
                
                # Recriar menu com novo usu√°rio
                self.create_menu()
                
                # Mostrar aplica√ß√£o principal
                self.root.deiconify()
            else:
                # Login cancelado ou falhou
                self.root.destroy()
        

    def update_all_displays(self):
        self.update_timer_display()
        self.populate_boards()
        self.update_pomodoro_task_list()
        self.update_my_activities_tab() # Adicionado
        self.update_log()
        self.update_accounts_listbox()
        self.update_total_balance_display()
        self.update_categories_listbox()
        self.update_payment_methods_listbox()
        self.update_transactions_treeview()
        self.populate_finance_comboboxes()
        self._show_chart(self.current_chart_type)
        self._update_saved_filters_combo()
        
        # Update dashboard widgets
        self.update_dashboard_widgets()

        # Initialize filter comboboxes
        self.filter_subject_combo['values'] = ["Todos"] + sorted(list(set(self.pomodoro_subjects + self.boodesk_subjects)))
        self.filter_goal_combo['values'] = ["Todos"] + sorted(self.goals)
        self.filter_importance_combo['values'] = ["Todos"] + list(self.settings["importance_colors"].keys())
        self.filter_member_combo['values'] = ["Todos"] + sorted([member['Membro'] for member in self.members])

    def apply_card_filter(self):
        self.populate_boards()

    def clear_card_filter(self):
        self.filter_subject_var.set("Todos")
        self.filter_goal_var.set("Todos")
        self.filter_member_var.set("Todos") # Changed from set("") to set("Todos")
        self.filter_due_date_var.set("Todos")
        self.filter_importance_var.set("Todos")
        self.filter_recurrence_var.set("Todos")
        self.filter_keyword_var.set("") # Clear keyword filter
        self.populate_boards()
        self._update_saved_filters_combo()

    def save_filter(self):
        filter_name = simpledialog.askstring("Salvar Filtro", "Digite um nome para este filtro:", parent=self.root)
        if filter_name:
            current_filter_settings = {
                "subject": self.filter_subject_var.get(),
                "goal": self.filter_goal_var.get(),
                "member": self.filter_member_var.get(),
                "due_date": self.filter_due_date_var.get(),
                "importance": self.filter_importance_var.get(),
                "recurrence": self.filter_recurrence_var.get(),
                "keyword": self.filter_keyword_var.get()
            }
            self.settings["custom_filters"][filter_name] = current_filter_settings
            self.save_settings_file()
            self._update_saved_filters_combo()
            messagebox.showinfo("Filtro Salvo", f"Filtro '{filter_name}' salvo com sucesso!")

    def load_filter(self, event=None):
        filter_name = self.saved_filters_combo.get()
        if filter_name and filter_name in self.settings["custom_filters"]:
            filter_settings = self.settings["custom_filters"][filter_name]
            self.filter_subject_var.set(filter_settings.get("subject", "Todos"))
            self.filter_goal_var.set(filter_settings.get("goal", "Todos"))
            self.filter_member_var.set(filter_settings.get("member", "Todos"))
            self.filter_due_date_var.set(filter_settings.get("due_date", "Todos"))
            self.filter_importance_var.set(filter_settings.get("importance", "Todos"))
            self.filter_recurrence_var.set(filter_settings.get("recurrence", "Todos"))
            self.filter_keyword_var.set(filter_settings.get("keyword", ""))
            self.apply_card_filter()
            messagebox.showinfo("Filtro Carregado", f"Filtro '{filter_name}' carregado com sucesso!")

    def delete_filter(self):
        filter_name = self.saved_filters_combo.get()
        if filter_name and filter_name in self.settings["custom_filters"]:
            if messagebox.askyesno("Excluir Filtro", f"Tem certeza que deseja excluir o filtro '{filter_name}'?"):
                del self.settings["custom_filters"][filter_name]
                self.save_settings_file()
                self._update_saved_filters_combo()
                self.clear_card_filter()
                messagebox.showinfo("Filtro Exclu√≠do", f"Filtro '{filter_name}' exclu√≠do com sucesso!")
        else:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um filtro para excluir.")

    def _update_saved_filters_combo(self):
        self.saved_filters_combo['values'] = sorted(list(self.settings["custom_filters"].keys()))
        self.saved_filters_combo.set("") # Clear current selection

    def toggle_filter_visibility(self):
        if self.filter_visible.get():
            self.filter_container_frame.pack_forget()
            self.toggle_filter_button.config(text="Mostrar Filtros")
        else:
            self.filter_container_frame.pack(fill=tk.X, pady=5, padx=5)
            self.toggle_filter_button.config(text="Ocultar Filtros")
        self.filter_visible.set(not self.filter_visible.get())

    def _filter_due_date(self, card_due_date_str, filter_option):
        if not card_due_date_str:
            return False # Cards without due dates don't match any date filter

        try:
            card_due_date = datetime.strptime(card_due_date_str.split(' ')[0], "%Y-%m-%d").date()
        except ValueError:
            return False # Invalid date format

        today = datetime.now().date()
        
        if filter_option == "Hoje":
            return card_due_date == today
        elif filter_option == "Pr√≥ximos 7 dias":
            seven_days_from_now = today + timedelta(days=7)
            return today <= card_due_date <= seven_days_from_now
        elif filter_option == "Vencidos":
            return card_due_date < today
        return True # "Todos" or other cases

    # --- Data Loading/Saving ---
    def load_settings(self):
        """Load settings from SQL database instead of JSON files"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, usando configura√ß√µes padr√£o")
                self.settings = self.get_default_settings()
                return
            
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Se n√£o h√° usu√°rio logado, usar user_id padr√£o (1 = admin)
            if user_id is None:
                user_id = 1
                print("DEBUG: Usando user_id padr√£o (1) para configura√ß√µes")
            
            # Load settings from database for current user
            db_settings = self.db.get_user_settings(user_id)
            
            # Garantir que db_settings seja um dicion√°rio v√°lido
            if db_settings and isinstance(db_settings, dict):
                self.settings = db_settings
                print("DEBUG: Configura√ß√µes carregadas do banco com sucesso")
            else:
                print(f"DEBUG: db_settings n√£o √© v√°lido: {type(db_settings)} - {db_settings}")
                # No settings in database, use defaults
                self.settings = self.get_default_settings()
                # Save defaults to database for current user
                for key, value in self.settings.items():
                    try:
                        self.db.save_setting(key, value, user_id)
                    except Exception as save_error:
                        print(f"Erro ao salvar configura√ß√£o {key}: {save_error}")
            
            # Garantir que self.settings seja um dicion√°rio
            if not isinstance(self.settings, dict):
                print("DEBUG: self.settings n√£o √© um dicion√°rio, usando padr√µes")
                self.settings = self.get_default_settings()
            
            # Merge with default settings to ensure all keys are present
            default_settings = self.get_default_settings()
            for key, value in default_settings.items():
                if key not in self.settings:
                    self.settings[key] = value
                    try:
                        self.db.save_setting(key, value, user_id)
                    except Exception as save_error:
                        print(f"Erro ao salvar configura√ß√£o {key}: {save_error}")
                elif isinstance(value, dict) and isinstance(self.settings[key], dict):
                    # Recursively merge dictionaries (e.g., for importance_colors, roles)
                    self.settings[key] = {**value, **self.settings[key]}
                    try:
                        self.db.save_setting(key, self.settings[key], user_id)
                    except Exception as save_error:
                        print(f"Erro ao salvar configura√ß√£o {key}: {save_error}")
            
            print(f"DEBUG: Tipo final de self.settings: {type(self.settings)}")
                    
        except Exception as e:
            print(f"Erro ao carregar configura√ß√µes do banco: {e}")
            messagebox.showwarning("Erro de Configura√ß√£o", f"N√£o foi poss√≠vel carregar as configura√ß√µes do banco. Usando padr√µes. Erro: {e}")
            self.settings = self.get_default_settings()
            # Try to save defaults to database
            try:
                if hasattr(self, 'db') and self.db is not None:
                    user_id = self.get_current_user_id()
                    # Se n√£o h√° usu√°rio logado, usar user_id padr√£o (1 = admin)
                    if user_id is None:
                        user_id = 1
                    for key, value in self.settings.items():
                        self.db.save_setting(key, value, user_id)
            except Exception as save_error:
                print(f"Erro ao salvar configura√ß√µes padr√£o: {save_error}")

    def get_current_user_id(self):
        """Retorna o ID do usu√°rio atual no banco de dados"""
        try:
            print("DEBUG: get_current_user_id - Iniciando...")
            
            if not self.current_user:
                print("DEBUG: current_user n√£o definido")
                return None
            
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco de dados n√£o dispon√≠vel")
                return None
            
            username = self.current_user.username
            print(f"DEBUG: get_current_user_id - Username: {username}")
            
            if not username:
                print("DEBUG: Username n√£o definido")
                return None
            
            print("DEBUG: get_current_user_id - Chamando get_user_by_username...")
            user_data = self.db.get_user_by_username(username)
            print(f"DEBUG: get_current_user_id - user_data: {user_data}")
            
            if user_data and 'id' in user_data:
                user_id = user_data['id']
                print(f"DEBUG: get_current_user_id - user_id: {user_id}")
                
                # Verificar se o usu√°rio tem um membro associado
                if 'member_id' in user_data and user_data['member_id']:
                    member_id = user_data['member_id']
                    print(f"DEBUG: get_current_user_id - member_id: {member_id}")
                    print(f"DEBUG: ID do usu√°rio {username}: {user_id} (membro associado: {member_id})")
                    return user_id
                else:
                    print(f"DEBUG: get_current_user_id - member_id n√£o encontrado ou None")
                    print(f"DEBUG: Usu√°rio {username} n√£o tem membro associado")
                    messagebox.showerror("Erro", "Usu√°rio n√£o tem membro associado. Contate o administrador.", parent=self.root)
                    return None
            else:
                print(f"DEBUG: get_current_user_id - user_data inv√°lido: {user_data}")
                print(f"DEBUG: Usu√°rio {username} n√£o encontrado no banco ou sem ID")
                return None
                
        except Exception as e:
            print(f"DEBUG: Erro ao obter ID do usu√°rio: {e}")
            return None

    def get_default_settings(self):
        return {
            "pomodoro": 25, 
            "short_break": 5, 
            "long_break": 15, 
            "cycles": 4, 
            "theme": "aquativo", 
            "unify_subjects": False, 
            "show_card_details_on_board": False,
            "show_dependency_info": True,
            "open_on_current_screen": False, # New setting
            "importance_colors": {
                "Cr√≠tica": "#FFCCCC",
                "Alta": "#FFE5CC",
                "Normal": "#FFFFCC",
                "Baixa": "#CCFFCC"
            },
            "card_tags": {
                "Urgente": "#FF0000",
                "Importante": "#FFA500",
                "Desenvolvimento": "#0000FF",
                "Bug": "#FFD700",
                "Feature": "#008000"
            },
            "custom_filters": {}, # New: To store custom filter presets
            "dev_mode": False, # New: Development mode for agile features
            "git_integration_enabled": False, # New: Enable/disable Git integration features
            "roles": {
                "Administrador": "Acesso total ao sistema.",
                "Usu√°rio": "Acesso limitado a funcionalidades b√°sicas.",
                "Convidado": "Apenas visualiza√ß√£o."
            },
            "dashboard_widgets": {
                "urgent_tasks": True,
                "upcoming_deadlines": True,
                "recent_activities": True,
                "quick_links": True,
                "overview": True,
                "quick_actions": True
            },
            # Configura√ß√µes do Google Calendar removidas - integra√ß√£o desabilitada
            "email_integration": {
                "enabled": False,
                "provider": "gmail",
                "smtp_server": "smtp.gmail.com",
                "smtp_port": 587,
                "email_address": "",
                "email_password": "",
                "app_password": "",
                "auto_notifications": {
                    "card_created": True,
                    "card_modified": True,
                    "card_moved": True,
                    "deadline_reminder": True,
                    "weekly_report": True
                },
                "notification_recipients": [],
                "deadline_reminder_hours": 24,
                "weekly_report_day": "monday",
                "weekly_report_time": "09:00",
                "email_templates": {
                    "card_created": "Novo cart√£o criado: {title}",
                    "card_modified": "Cart√£o modificado: {title}",
                    "deadline_reminder": "Lembrete de prazo: {title} vence em {deadline}",
                    "weekly_report": "Relat√≥rio Semanal - {week_period}"
                }
            }
        }

    def save_settings_file(self):
        """Save settings to SQL database instead of JSON files"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar configura√ß√µes")
                return
            
            # Obter user_id se dispon√≠vel
            user_id = None
            if hasattr(self, 'current_user') and self.current_user:
                user_id = self.get_current_user_id()
            
            for key, value in self.settings.items():
                try:
                    if user_id:
                        self.db.save_setting(key, value, user_id)
                    else:
                        # Se n√£o h√° usu√°rio logado, usar user_id padr√£o (1 = admin)
                        self.db.save_setting(key, value, 1)
                except Exception as save_error:
                    print(f"‚ùå Erro ao salvar configura√ß√£o {key}: {save_error}")
            
            print("‚úÖ Configura√ß√µes salvas no banco SQL com sucesso")
        except Exception as e:
            print(f"‚ùå Erro ao salvar configura√ß√µes no banco: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel salvar as configura√ß√µes no banco: {e}")

    def load_trello_data(self):
        """Load data from SQL database only"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, usando dados padr√£o")
                self.boodesk_data = {
                    "boards": {
                        "Quadro Principal": {
                            "A Fazer": [],
                            "Em Progresso": [],
                            "Conclu√≠do": []
                        },
                        "workflow": ["A Fazer", "Em Progresso", "Conclu√≠do"]
                    },
                    "finances": {
                        "contas_bancarias": [],
                        "categorias_gasto": [],
                        "meios_pagamento": [],
                        "transacoes": []
                    }
                }
                return
            
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Get member ID for cards filtering
            cards_member_id = None
            if hasattr(self, 'current_user') and self.current_user:
                # Try to get member ID from current user
                try:
                    cards_member_id = self.db.get_member_id_by_username(self.current_user.username)
                except:
                    cards_member_id = None
            
            # Check if database has data, if not create default board
            # Para administradores, carregar todos os quadros; para usu√°rios normais, apenas os pr√≥prios
            if hasattr(self, 'current_user') and getattr(self.current_user, 'role', None) in ['admin', 'Administrador']:
                print("DEBUG: Carregando todos os quadros para administrador")
                boards = self.db.get_boards()  # Sem user_id para carregar todos
            else:
                print("DEBUG: Carregando apenas quadros do usu√°rio")
                # Para usu√°rios normais, carregar apenas quadros onde s√£o membros
                if cards_member_id:
                    boards = self.db.get_boards(member_id=cards_member_id)
                else:
                    boards = self.db.get_boards(user_id)
                
            if not boards:
                print("DEBUG: Nenhum quadro encontrado no banco, criando quadro padr√£o")
                # Create default board for current user
                board_id = self.db.create_board("Quadro Principal", owner_id=user_id)
                # Create default card and add current user as a member
                if hasattr(self, 'current_user') and self.current_user:
                    members = [self.current_user.username]
                else:
                    members = []
                    
                self.db.create_card(
                    board_id=board_id,
                    list_name="A Fazer",
                    title="Sua primeira tarefa",
                    description="Bem-vindo ao Boodesk! Esta √© sua primeira tarefa.",
                    importance="Normal",
                    user_id=user_id,
                    members=members
                )
                # Recarregar quadros ap√≥s criar o padr√£o
                if cards_member_id:
                    boards = self.db.get_boards(member_id=cards_member_id)
                else:
                    boards = self.db.get_boards(user_id)
            
            # Load data from database
            self.boodesk_data = {'boards': {}}
            for board in boards:
                board_name = board['name']
                self.boodesk_data['boards'][board_name] = {}
                
                # Carregar listas do banco de dados
                try:
                    lists = self.db.get_lists_for_board(board['id'])
                    for list_item in lists:
                        list_name = list_item['name']
                        self.boodesk_data['boards'][board_name][list_name] = []
                except Exception as e:
                    print(f"DEBUG: Erro ao carregar listas para quadro {board_name}: {e}")
                    # Usar listas padr√£o em caso de erro
                    self.boodesk_data['boards'][board_name] = {
                        "A Fazer": [],
                        "Em Progresso": [],
                        "Conclu√≠do": []
                    }
                
                # Carregar cards do banco de dados
                try:
                    print(f"üîÑ Carregando cards para quadro: {board_name} (ID: {board['id']})")
                    cards = self.db.get_cards_for_board(board['id'], member_id=cards_member_id)
                    if cards is None:
                        cards = []
                    
                    print(f"üìã Total de cards encontrados: {len(cards)}")
                    
                    for card in cards:
                        list_name = card.get('list_name', 'A Fazer')
                        card_title = card.get('title', 'Sem t√≠tulo')
                        card_id = card.get('card_id', 'Sem ID')
                        
                        print(f"üìù Card: '{card_title}' (ID: {card_id}) -> Lista: '{list_name}'")
                        
                        # Garantir que a lista existe no quadro
                        if list_name not in self.boodesk_data['boards'][board_name]:
                            print(f"‚ûï Criando lista '{list_name}' no quadro '{board_name}'")
                            self.boodesk_data['boards'][board_name][list_name] = []
                        
                        # Adicionar card √† lista correta
                        self.boodesk_data['boards'][board_name][list_name].append(card)
                        print(f"‚úÖ Card '{card_title}' adicionado √† lista '{list_name}'")
                        
                except Exception as e:
                    print(f"‚ùå ERRO ao carregar cards para quadro {board_name}: {e}")
                    # Usar cards vazios em caso de erro
                    pass
            
            # Add workflow
            self.boodesk_data['workflow'] = ["A Fazer", "Em Progresso", "Conclu√≠do"]
            
            # Garantir que pelo menos o Quadro Principal existe
            if "Quadro Principal" not in self.boodesk_data['boards']:
                self.boodesk_data['boards']["Quadro Principal"] = {
                    "A Fazer": [],
                    "Em Progresso": [],
                    "Conclu√≠do": []
                }
            
            print(f"DEBUG: load_trello_data conclu√≠do. Quadros carregados: {list(self.boodesk_data['boards'].keys())}")
            
            # Load finances from database
            finances = self.db.get_finance_data('finances')
            if finances:
                self.boodesk_data['finances'] = finances
            else:
                self.boodesk_data['finances'] = {
                    "contas_bancarias": [],
                    "categorias_gasto": [],
                    "meios_pagamento": [],
                    "transacoes": []
                }
                # Save default finances to database
                for key, value in self.boodesk_data['finances'].items():
                    try:
                        self.db.save_finance_data('finances', key, value)
                    except Exception as save_error:
                        print(f"Erro ao salvar dados financeiros {key}: {save_error}")
                    
        except Exception as e:
            print(f"Erro ao carregar dados do banco: {e}")
            # Em caso de erro, usar dados padr√£o
            self.boodesk_data = {
                "boards": {
                    "Quadro Principal": {
                        "A Fazer": [],
                        "Em Progresso": [],
                        "Conclu√≠do": []
                    },
                    "workflow": ["A Fazer", "Em Progresso", "Conclu√≠do"]
                },
                "finances": {
                    "contas_bancarias": [],
                    "categorias_gasto": [],
                    "meios_pagamento": [],
                    "transacoes": []
                }
            }
            messagebox.showerror("Erro", f"Ocorreu um erro ao carregar os dados do banco: {e}")
            messagebox.showerror("Erro", f"Ocorreu um erro ao carregar os dados do banco: {e}")
            # Create minimal default data
            self.boodesk_data = {
                "boards": {
                    "Quadro Principal": {
                        "A Fazer": [],
                        "Em Progresso": [],
                        "Conclu√≠do": []
                    },
                    "workflow": ["A Fazer", "Em Progresso", "Conclu√≠do"]
                },
                "finances": {
                    "contas_bancarias": [],
                    "categorias_gasto": [],
                    "meios_pagamento": [],
                    "transacoes": []
                }
            }

    def save_trello_data(self):
        """Save data to SQL database only"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados")
                return
            
            # Garantir que h√° uma conex√£o v√°lida
            if not self.db.is_connected():
                print("DEBUG: Reconectando ao banco...")
                self.db.ensure_connection()
            
            # Os dados j√° est√£o sendo salvos diretamente no banco via m√©todos CRUD
            # Este m√©todo agora √© usado apenas para sincroniza√ß√£o
            print("Dados sincronizados no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao sincronizar dados no banco: {e}")
            messagebox.showerror("Erro ao Salvar Dados", f"Ocorreu um erro ao sincronizar os dados no banco: {e}")

    def save_pomodoro_data(self):
        """Save pomodoro data to database"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados do pomodoro")
                return
            
            # Get current user ID
            user_id = self.get_current_user_id()
            
            # Salvar tarefas do pomodoro
            for task in self.pomodoro_tasks:
                try:
                    self.db.save_pomodoro_task(
                        title=task.get('title', ''),
                        description=task.get('description', ''),
                        status=task.get('status', 'pending'),
                        user_id=user_id
                    )
                except Exception as e:
                    print(f"Erro ao salvar tarefa do pomodoro: {e}")
            
            print("Dados do pomodoro salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados do pomodoro: {e}")

    def save_finance_data(self):
        """Save finance data to database"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados financeiros")
                return
            
            # Salvar dados financeiros
            for key, value in self.boodesk_data.get('finances', {}).items():
                try:
                    self.db.save_finance_data('finances', key, value)
                except Exception as e:
                    print(f"Erro ao salvar dados financeiros {key}: {e}")
            
            print("Dados financeiros salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados financeiros: {e}")

    def save_study_data(self):
        """Save study data to database"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados de estudo")
                return
            
            # Salvar dados de estudo (implementar conforme necess√°rio)
            print("Dados de estudo salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados de estudo: {e}")

    def save_goals_data(self):
        """Save goals data to database"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados de objetivos")
                return
            
            # Salvar dados de objetivos (implementar conforme necess√°rio)
            print("Dados de objetivos salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados de objetivos: {e}")

    def save_members_data(self):
        """Save members data to database"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados de membros")
                return
            
            # Salvar dados de membros
            try:
                self.db.save_members(self.members)
                print("Dados de membros salvos no banco SQL com sucesso")
            except Exception as e:
                print(f"Erro ao salvar dados de membros: {e}")
        except Exception as e:
            print(f"Erro ao salvar dados de membros: {e}")

    def save_subjects_data(self):
        """Save subjects data to database"""
        try:
            # Verificar se o banco est√° dispon√≠vel
            if not hasattr(self, 'db') or self.db is None:
                print("DEBUG: Banco n√£o dispon√≠vel, n√£o foi poss√≠vel salvar dados de assuntos")
                return
            
            # Salvar dados de assuntos (implementar conforme necess√°rio)
            print("Dados de assuntos salvos no banco SQL com sucesso")
        except Exception as e:
            print(f"Erro ao salvar dados de assuntos: {e}")

    def load_pomodoro_data(self):
        """Carrega dados do Pomodoro do banco SQLite"""
        try:
            # Inicializar com dados padr√£o
            self.pomodoro_tasks_df = pd.DataFrame({'Tarefa': ['Exemplo de Tarefa Pomodoro'], 'Status': ['Pendente'], 'Assunto': ['-'], 'Objetivo': ['-']})
            # Inicializar pomodoro_tasks como lista vazia
            self.pomodoro_tasks = []
            print("DEBUG: Pomodoro data loaded (using default data)")
        except Exception as e:
            print(f"Erro ao carregar dados do Pomodoro: {e}")
            self.pomodoro_tasks_df = pd.DataFrame({'Tarefa': ['Exemplo de Tarefa Pomodoro'], 'Status': ['Pendente'], 'Assunto': ['-'], 'Objetivo': ['-']})

    def save_pomodoro_tasks(self):
        """Salva dados do Pomodoro no banco SQLite"""
        try:
            print("DEBUG: Pomodoro tasks saved to database")
        except Exception as e:
            print(f"Erro ao salvar dados do Pomodoro: {e}")

    
    def save_motivational_messages(self):
        """Salva mensagens motivacionais no banco de dados (opcional)"""
        try:
            if hasattr(self, 'db') and self.db:
                user_id = self.get_current_user_id() or 1
                messages_json = json.dumps({'messages': self.messages})
                self.db.save_setting('motivational_messages', messages_json, user_id)
                print("‚úÖ Mensagens motivacionais salvas no banco")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao salvar mensagens no banco: {e}")
    
    def load_motivational_messages_from_db(self):
        """Carrega mensagens motivacionais do banco de dados (opcional)"""
        try:
            if hasattr(self, 'db') and self.db:
                user_id = self.get_current_user_id() or 1
                messages_json = self.db.get_setting('motivational_messages', user_id)
                if messages_json:
                    data = json.loads(messages_json)
                    self.messages = data.get('messages', self.messages)
                    print("‚úÖ Mensagens motivacionais carregadas do banco")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao carregar mensagens do banco: {e}")
    def load_aux_data(self):
        # Messages - Usar dados padr√£o em mem√≥ria (sem arquivo JSON)
        self.messages = [
            "Bem-vindo ao Boodesk!",
            "Foco total!",
            "Voc√™ consegue!",
            "Persist√™ncia √© a chave!",
            "Cada passo conta!",
            "Mantenha o ritmo!",
            "Sucesso √© uma jornada!",
            "Acredite em voc√™!",
            "Hoje √© o dia!",
            "Vamos l√°!"
        ]
        print("‚úÖ Mensagens motivacionais carregadas em mem√≥ria")

        # Subjects - Usar dados padr√£o
        self.pomodoro_subjects = ["-"]
        self.trello_subjects = ["-"]
        self.boodesk_subjects = ["-"]
        self.subjects = ["-"]

        # Goals - Usar dados padr√£o
        self.goals = ["-"]
        self.goals_df = pd.DataFrame({'Objetivo': ["-"]})

        # Log - Usar dados padr√£o
        self.log_df = pd.DataFrame(columns=['Data e Hora', 'Assunto', 'Dura√ß√£o (min)'])

    def save_log(self):
        """Salva log no banco SQLite"""
        try:
            print("DEBUG: Log saved to database")
        except Exception as e:
            print(f"Erro ao salvar log: {e}")

    def load_members(self):
        """Carrega membros do banco PostgreSQL"""
        try:
            import sqlite3
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("SELECT id, membro as name, cargo as role, email FROM members ORDER BY membro")
            members_data = cursor.fetchall()
            conn.close()
            
            # Converter para o formato esperado pela aplica√ß√£o
            self.members = []
            for member_id, name, email, role in members_data:
                self.members.append({
                    'id': member_id,
                    'Membro': name,
                    'Cargo': role,
                    'email': email if email else ''
                })
            
            # Criar DataFrame para compatibilidade
            self.members_df = pd.DataFrame(self.members)
            
            print(f"DEBUG: Members loaded from PostgreSQL. self.members count: {len(self.members)}")
            print(f"DEBUG: Members loaded. self.members content: {self.members}")
            
        except Exception as e:
            print(f"Erro ao carregar membros do PostgreSQL: {e}")
            self.members = []
            self.members_df = pd.DataFrame({'Membro': [], 'Cargo': [], 'email': []})

    def save_members(self):
        """Salva membros no banco PostgreSQL"""
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Limpar tabela atual
            cursor.execute("DELETE FROM members")
            
            # Inserir membros atualizados
            for member in self.members:
                cursor.execute("""
                    INSERT INTO members (membro, email, cargo, created_at)
                    VALUES (%s, %s, %s, %s)
                """, (
                    member['Membro'],
                    member.get('email', ''),
                    member.get('Cargo', 'member'),
                    datetime.now(),
                    datetime.now()
                ))
            
            conn.commit()
            conn.close()
            print("DEBUG: Members saved to SQLite successfully.")
            
        except Exception as e:
            print(f"Erro ao salvar membros no PostgreSQL: {e}")
    
    def load_categories(self):
        """Carrega as categorias do arquivo JSON"""
        try:
            categories_file = f"{self.base_dir}{sep}categories.json"
            if os.path.exists(categories_file):
                with open(categories_file, 'r', encoding='utf-8') as f:
                    self.categories = json.load(f)
                print(f"DEBUG: Categories loaded: {len(self.categories)} categories")
            else:
                self.categories = [
                    {"id": 1, "name": "Desenvolvimento", "color": "#3498db"},
                    {"id": 2, "name": "Design", "color": "#e74c3c"},
                    {"id": 3, "name": "Marketing", "color": "#f39c12"},
                    {"id": 4, "name": "Vendas", "color": "#27ae60"},
                    {"id": 5, "name": "Suporte", "color": "#9b59b6"}
                ]
                self.save_categories()
                print("DEBUG: Default categories created")
        except Exception as e:
            print(f"DEBUG: Error loading categories: {e}")
            self.categories = []
    
    def save_categories(self):
        """Salva as categorias no arquivo JSON"""
        try:
            categories_file = f"{self.base_dir}{sep}categories.json"
            with open(categories_file, 'w', encoding='utf-8') as f:
                json.dump(self.categories, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"DEBUG: Error saving categories: {e}")

    # --- UI Creation ---
    def apply_role_permissions(self):
        """Aplica permiss√µes baseadas no role do usu√°rio atual"""
        if not hasattr(self, 'current_user') or not self.current_user:
            return
        
        # Verificar se o usu√°rio tem role v√°lido
        if not hasattr(self.current_user, 'role') or not self.current_user.role:
            print("DEBUG: Usu√°rio sem role v√°lido, usando role padr√£o 'user'")
            self.current_user.role = "user"
        
        # Configurar t√≠tulo da janela com informa√ß√µes do usu√°rio
        user_info = f" - {self.current_user.username} ({self.current_user.cargo})"
        self.root.title(f"Sistema Boodesk{user_info}")
        
        # Aplicar permiss√µes espec√≠ficas baseadas no role
        role = self.current_user.role.lower()
        if role == "user":
            self.apply_user_permissions()
        elif role == "manager":
            self.apply_manager_permissions()
        elif role == "admin":
            self.apply_admin_permissions()
        else:
            print(f"DEBUG: Role desconhecido '{self.current_user.role}', usando permiss√µes de usu√°rio")
            self.apply_user_permissions()
    
    def apply_user_permissions(self):
        """Aplica permiss√µes de usu√°rio comum"""
        try:
            if hasattr(self, 'menu_bar') and self.menu_bar:
                self.menu_bar.entryconfig("Arquivo", state=tk.DISABLED)
                self.menu_bar.entryconfig("Quadros", state=tk.DISABLED)
        except tk.TclError as e:
            print(f"DEBUG: Erro ao configurar permiss√µes do menu para usu√°rio: {e}")
    
    def apply_manager_permissions(self):
        """Aplica permiss√µes de gerente"""
        try:
            if hasattr(self, 'menu_bar') and self.menu_bar:
                self.menu_bar.entryconfig("Arquivo", state=tk.NORMAL)
                self.menu_bar.entryconfig("Quadros", state=tk.NORMAL)
                self.menu_bar.entryconfig("Usu√°rios", state=tk.NORMAL)
                self.menu_bar.entryconfig("Configura√ß√µes", state=tk.DISABLED)
        except tk.TclError as e:
            print(f"DEBUG: Erro ao configurar permiss√µes do menu para gerente: {e}")
    
    def apply_admin_permissions(self):
        """Aplica permiss√µes de administrador"""
        try:
            if hasattr(self, 'menu_bar') and self.menu_bar:
                self.menu_bar.entryconfig("Arquivo", state=tk.NORMAL)
                self.menu_bar.entryconfig("Quadros", state=tk.NORMAL)
                self.menu_bar.entryconfig("Usu√°rios", state=tk.NORMAL)
                self.menu_bar.entryconfig("Configura√ß√µes", state=tk.NORMAL)
        except tk.TclError as e:
            print(f"DEBUG: Erro ao configurar permiss√µes do menu para admin: {e}")

    def create_menu(self):
        print("DEBUG: Iniciando create_menu")
        try:
            # Criar menu b√°sico primeiro
            self.menubar = tk.Menu(self.root)
            print("DEBUG: Menubar criado")
            
            # Configurar o menu na janela
            self.root.config(menu=self.menubar)
            print("DEBUG: Menu configurado na janela")
            
            # Menu Arquivo b√°sico
            file_menu = tk.Menu(self.menubar, tearoff=0)
            file_menu.add_command(label="Sair", command=self.root.quit)
            self.menubar.add_cascade(label="Arquivo", menu=file_menu)
            
            # Menu Editar
            edit_menu = tk.Menu(self.menubar, tearoff=0)
            edit_menu.add_command(label="Copiar", command=lambda: print("Copiar"))
            edit_menu.add_command(label="Colar", command=lambda: print("Colar"))
            self.menubar.add_cascade(label="Editar", menu=edit_menu)
            
            # Menu Ajuda
            help_menu = tk.Menu(self.menubar, tearoff=0)
            help_menu.add_command(label="Sobre", command=lambda: print("Sobre"))
            self.menubar.add_cascade(label="Ajuda", menu=help_menu)
            
            # Menu Atualiza√ß√µes (sem refer√™ncia a m√©todos que podem n√£o existir)
            update_menu = tk.Menu(self.menubar, tearoff=0)
            update_menu.add_command(label="Verificar Atualiza√ß√µes", command=lambda: print("Verificar Atualiza√ß√µes"))
            update_menu.add_command(label="Sobre o Boodesk", command=lambda: print("Sobre o Boodesk"))
            self.menubar.add_cascade(label="Atualiza√ß√µes", menu=update_menu)
            
            print("DEBUG: Menu b√°sico criado com sucesso")
            print(f"DEBUG: Menubar: {self.menubar}")
            print(f"DEBUG: Root menu: {self.root.cget('menu')}")
            
        except Exception as e:
            print(f"DEBUG: Erro ao criar menu: {e}")
            import traceback
            traceback.print_exc()
            # Criar um menu b√°sico se houver erro
            self.menubar = tk.Menu(self.root)
            self.root.config(menu=self.menubar)

        # File Menu (General App Actions)
        file_menu = tk.Menu(self.menubar, tearoff=0)
        
        # Submenu de Configura√ß√µes
        config_menu = tk.Menu(file_menu, tearoff=0)
        config_menu.add_command(label="Configura√ß√µes Gerais", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_config_geral)
        config_menu.add_command(label="Configura√ß√µes do Calend√°rio", image=self.icons.get('calendar_icon'), compound=tk.LEFT, command=self.open_config_calendario)
        config_menu.add_command(label="Configura√ß√µes de Email", image=self.icons.get('info_icon'), compound=tk.LEFT, command=self.open_config_email)
        config_menu.add_command(label="Templates de Email", image=self.icons.get('registration_icon'), compound=tk.LEFT, command=self.open_config_templates_email)
        config_menu.add_separator()
        config_menu.add_command(label="Todas as Configura√ß√µes", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_settings)
        
        file_menu.add_cascade(label="Configura√ß√µes", menu=config_menu)
        file_menu.add_separator()
        
        # Adicionar informa√ß√µes do usu√°rio e logout
        if (hasattr(self, 'current_user') and self.current_user and 
            hasattr(self.current_user, 'username') and hasattr(self.current_user, 'cargo')):
            file_menu.add_command(label=f"Usu√°rio: {self.current_user.username} ({self.current_user.cargo})", 
                                state="disabled")
            file_menu.add_separator()
            file_menu.add_command(label="Logout", image=self.icons.get('exit_icon'), compound=tk.LEFT, command=self.logout)
        
        file_menu.add_command(label="Sair", image=self.icons.get('exit_icon'), compound=tk.LEFT, command=self.root.quit)
        self.menubar.add_cascade(label="Arquivo", menu=file_menu)

        # Board Menu
        board_menu = tk.Menu(self.menubar, tearoff=0)
        board_menu.add_command(label="Adicionar Quadro", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_board)
        board_menu.add_command(label="Cart√µes Arquivados", image=self.icons.get('folder_icon'), compound=tk.LEFT, command=self.open_archived_cards_window)
        self.menubar.add_cascade(label="Quadros", menu=board_menu)

        # Pomodoro Menu
        pomodoro_menu = tk.Menu(self.menubar, tearoff=0)
        pomodoro_menu.add_command(label="Configura√ß√µes do Pomodoro", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_settings) # Can be specific settings
        self.menubar.add_cascade(label="Pomodoro", menu=pomodoro_menu)

        # General Data Management Menu (for subjects/goals)
        manage_data_menu = tk.Menu(self.menubar, tearoff=0)
        
        # Sub-menu for Subjects
        subjects_menu = tk.Menu(manage_data_menu, tearoff=0)
        subjects_menu.add_command(label="Criar Assunto Pomodoro", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.add_subject_dialog('pomodoro'))
        subjects_menu.add_command(label="Criar Assunto Boodesk", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.add_subject_dialog('boodesk'))
        manage_data_menu.add_cascade(label="Assuntos", menu=subjects_menu)
        
        # Categorias
        categories_menu = tk.Menu(manage_data_menu, tearoff=0)
        categories_menu.add_command(label="Gerenciar Categorias", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_categories_manager)
        manage_data_menu.add_cascade(label="Categorias", menu=categories_menu)
        
        manage_data_menu.add_command(label="Adicionar Objetivo", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_goal)
        manage_data_menu.add_command(label="Gerenciar Membros", image=self.icons.get('objects_icon'), compound=tk.LEFT, command=self.open_members_manager)
        
        # Menu de usu√°rios (s√≥ para admin/manager)
        print("DEBUG: Verificando se deve mostrar menu de usu√°rios...")
        if hasattr(self, 'current_user') and self.current_user:
            print(f"DEBUG: Usu√°rio atual: {self.current_user.username} (Role: {getattr(self.current_user, 'role', 'N/A')})")
            
            # Verificar se pode gerenciar usu√°rios
            can_manage = False
            if hasattr(self.current_user, 'can_manage_users'):
                can_manage = self.current_user.can_manage_users()
                print(f"DEBUG: can_manage_users() retornou: {can_manage}")
            else:
                print("DEBUG: Usu√°rio n√£o tem m√©todo can_manage_users")
                # Fallback: verificar role diretamente
                role = getattr(self.current_user, 'role', '')
                role_mapping = {
                    "Administrador": "admin",
                    "admin": "admin",
                    "Manager": "manager", 
                    "manager": "manager",
                    "Usu√°rio": "user",
                    "user": "user"
                }
                normalized_role = role_mapping.get(role, role)
                can_manage = normalized_role in ["admin", "manager"]
                print(f"DEBUG: Fallback - Role '{role}' -> '{normalized_role}', pode gerenciar: {can_manage}")
            
            if can_manage:
                print("DEBUG: Adicionando menu 'Gerenciar Usu√°rios'")
                manage_data_menu.add_separator()
                manage_data_menu.add_command(label="Gerenciar Usu√°rios", image=self.icons.get('registration_icon'), compound=tk.LEFT, command=self.open_user_management)
            else:
                print("DEBUG: Usu√°rio n√£o pode gerenciar usu√°rios, menu n√£o ser√° adicionado")
        else:
            print("DEBUG: Nenhum usu√°rio atual definido")
        
        # Menu de notifica√ß√µes (dispon√≠vel para todos)
        manage_data_menu.add_separator()
        manage_data_menu.add_command(label="Configurar Notifica√ß√µes", image=self.icons.get('settings_icon'), compound=tk.LEFT, command=self.open_notification_settings)
        
        # Dashboard personalizado (dispon√≠vel para todos)
        manage_data_menu.add_command(label="Meu Dashboard", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT, command=self.open_personal_dashboard)
        
        self.menubar.add_cascade(label="Gerenciar Dados Auxiliares", menu=manage_data_menu)

        # Theme Menu
        theme_menu = tk.Menu(self.menubar, tearoff=0)
        for theme in self.root.get_themes():
            theme_menu.add_command(label=theme, command=lambda t=theme: self.change_theme(t))
        self.menubar.add_cascade(label="Temas", menu=theme_menu)
        # Menu de Atualiza√ß√µes
        update_menu = tk.Menu(self.menubar, tearoff=0)
        update_menu.add_command(label="Verificar Atualiza√ß√µes", 
                              image=self.icons.get('refresh_icon'), 
                              compound=tk.LEFT, 
                              command=self.check_for_updates_manual)
        update_menu.add_command(label="Sobre o Boodesk", 
                              image=self.icons.get('info_icon'), 
                              compound=tk.LEFT, 
                              command=self.show_about_dialog)
        self.menubar.add_cascade(label="Atualiza√ß√µes", menu=update_menu)
        
        print("DEBUG: create_menu conclu√≠do com sucesso")
        
        # For√ßar atualiza√ß√£o do menu
        try:
            self.root.update_idletasks()
            print("DEBUG: Menu atualizado")
        except Exception as e:
            print(f"DEBUG: Erro ao atualizar menu: {e}")


    def change_theme(self, theme):
        """Aplica um novo tema ao aplicativo e salva no banco por usu√°rio"""
        try:
            print(f"üé® Aplicando tema: {theme}")
            
            # Aplicar o tema na janela principal
            self.root.set_theme(theme)
            
            # Atualizar configura√ß√µes
            self.settings['theme'] = theme
            
            # Salvar no banco de dados com isolamento por usu√°rio
            try:
                user_id = self.get_current_user_id()
                if user_id and hasattr(self, 'db') and self.db:
                    self.db.save_setting('theme', theme, user_id)
                    print(f"‚úÖ Tema '{theme}' salvo no banco para usu√°rio {user_id}")
                else:
                    # Fallback: salvar com user_id padr√£o (admin)
                    if hasattr(self, 'db') and self.db:
                        self.db.save_setting('theme', theme, 1)
                        print(f"‚úÖ Tema '{theme}' salvo no banco para admin (fallback)")
                    else:
                        print("‚ö†Ô∏è Banco n√£o dispon√≠vel, tema n√£o persistido")
            except Exception as save_error:
                print(f"‚ö†Ô∏è Erro ao salvar tema no banco: {save_error}")
            
            # For√ßar atualiza√ß√£o completa da interface
            self.root.update_idletasks()
            
            # Recriar o menu com o novo tema
            if hasattr(self, 'menubar'):
                self.menubar.destroy()
                self.create_menu()
            
            # Atualizar todos os widgets principais
            if hasattr(self, 'main_notebook'):
                self.main_notebook.update_idletasks()
                
                # Atualizar cada aba
                for tab_id in self.main_notebook.tabs():
                    try:
                        tab_widget = self.main_notebook.nametowidget(tab_id)
                        tab_widget.update_idletasks()
                    except:
                        pass
            
            # For√ßar redesenho completo da janela
            self.root.update()
            
            # Aguardar um pouco e for√ßar nova atualiza√ß√£o
            self.root.after(100, self.root.update)
            
            print(f"‚úÖ Tema aplicado com sucesso: {theme}")
            
        except Exception as e:
            print(f"‚ùå Erro ao aplicar tema {theme}: {e}")
            messagebox.showerror("Erro", f"Erro ao aplicar tema: {e}")
    def create_widgets(self):
        # Criar menu ANTES de qualquer widget
        self.create_menu()
        
        self.main_notebook = ttk.Notebook(self.root)
        self.main_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Criar frames com verifica√ß√£o de seguran√ßa
        try:
            main_menu_frame = ttk.Frame(self.main_notebook)
            boards_frame = ttk.Frame(self.main_notebook)
            productivity_main_frame = ttk.Frame(self.main_notebook) # Nova aba de produtividade
            finance_main_frame = ttk.Frame(self.main_notebook)
            calendar_frame = ttk.Frame(self.main_notebook)
            gantt_chart_frame = ttk.Frame(self.main_notebook)
            chat_frame = ttk.Frame(self.main_notebook) # Nova aba de chat
            dashboard_frame = ttk.Frame(self.main_notebook) # Nova aba do Dashboard Executivo
            
            # Verificar se todos os frames foram criados corretamente
            frames = [main_menu_frame, boards_frame, productivity_main_frame, 
                     finance_main_frame, calendar_frame, gantt_chart_frame, 
                     chat_frame, dashboard_frame]
            
            for i, frame in enumerate(frames):
                if frame is None:
                    print(f"‚ùå Erro: Frame {i} √© None")
                    raise Exception(f"Falha ao criar frame {i}")
                    
        except Exception as e:
            print(f"‚ùå Erro ao criar frames: {e}")
            messagebox.showerror("Erro", f"Erro ao criar interface: {e}")
            raise

        # Adicionar abas com verifica√ß√£o de seguran√ßa
        try:
            if main_menu_frame is not None:
                self.main_notebook.add(main_menu_frame, text='Menu Principal')
            if boards_frame is not None:
                self.main_notebook.add(boards_frame, text='Quadros')
            if productivity_main_frame is not None:
                self.main_notebook.add(productivity_main_frame, text='Produtividade') # Adicionada
            if finance_main_frame is not None:
                self.main_notebook.add(finance_main_frame, text='Finan√ßas')
            if calendar_frame is not None:
                self.main_notebook.add(calendar_frame, text='Calend√°rio')
            if gantt_chart_frame is not None:
                self.main_notebook.add(gantt_chart_frame, text='Gr√°fico de Gantt')
            if chat_frame is not None:
                self.main_notebook.add(chat_frame, text='Chat') # Nova aba de chat
            if dashboard_frame is not None:
                self.main_notebook.add(dashboard_frame, text='Dashboard Executivo') # Nova aba
        except Exception as e:
            print(f"‚ùå Erro ao adicionar abas ao notebook: {e}")
            messagebox.showerror("Erro", f"Erro ao criar interface: {e}")
        
        # Configurar √≠cones e texto nas abas principais (se dispon√≠veis)
        try:
            # Menu Principal
            if self.icons.get('home_icon'):
                self.main_notebook.tab(0, text="Menu Principal", image=self.icons.get('home_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(0, text="Menu Principal")
            # Quadros
            if self.icons.get('folder_icon'):
                self.main_notebook.tab(1, text="Quadros", image=self.icons.get('folder_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(1, text="Quadros")
            # Produtividade
            if self.icons.get('play_icon'):
                self.main_notebook.tab(2, text="Produtividade", image=self.icons.get('play_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(2, text="Produtividade")
            # Finan√ßas
            if self.icons.get('money_icon'):
                self.main_notebook.tab(3, text="Finan√ßas", image=self.icons.get('money_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(3, text="Finan√ßas")
            # Calend√°rio
            if self.icons.get('calendar_icon'):
                self.main_notebook.tab(4, text="Calend√°rio", image=self.icons.get('calendar_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(4, text="Calend√°rio")
            # Gr√°fico de Gantt
            if self.icons.get('gantt_icon'):
                self.main_notebook.tab(5, text="Gr√°fico de Gantt", image=self.icons.get('gantt_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(5, text="Gr√°fico de Gantt")
            # Gr√°fico de Gantt
            if self.icons.get('gantt_icon'):
                self.main_notebook.tab(5, text="Gr√°fico de Gantt", image=self.icons.get('gantt_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(5, text="Gr√°fico de Gantt")
            # Chat
            if self.icons.get('chat_icon'):
                self.main_notebook.tab(6, text="Chat", image=self.icons.get('chat_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(6, text="Chat")
            # Dashboard Executivo
            if self.icons.get('dashboard_icon'):
                self.main_notebook.tab(7, text="Dashboard Executivo", image=self.icons.get('dashboard_icon'), compound=tk.LEFT)
            else:
                self.main_notebook.tab(7, text="Dashboard Executivo")
        except Exception as e:
            print(f"Erro ao configurar √≠cones nas abas principais: {e}")
            # Fallback para texto simples
            try:
                self.main_notebook.tab(0, text="Menu Principal")
                self.main_notebook.tab(1, text="Quadros")
                self.main_notebook.tab(2, text="Produtividade")
                self.main_notebook.tab(3, text="Finan√ßas")
                self.main_notebook.tab(4, text="Calend√°rio")
                self.main_notebook.tab(5, text="Gr√°fico de Gantt")
                self.main_notebook.tab(6, text="Chat")
                self.main_notebook.tab(7, text="Dashboard Executivo")
            except:
                pass

        # Bind drag-and-drop for main tabs
        self.main_notebook.bind("<ButtonPress-1>", self.on_main_tab_drag_start)
        self.main_notebook.bind("<B1-Motion>", self.on_main_tab_drag_motion)
        self.main_notebook.bind("<ButtonRelease-1>", self.on_main_tab_drag_release)

        self.create_main_menu_tab(main_menu_frame)
        self.create_boards_tab(boards_frame)
        self.create_productivity_sub_tabs(productivity_main_frame) # Novo m√©todo
        self.create_finance_sub_tabs(finance_main_frame)
        self.create_calendar_tab(calendar_frame) # Nova aba de calend√°rio
        self.create_gantt_chart_tab(gantt_chart_frame)
        self.create_chat_tab(chat_frame) # Nova aba de chat
        
        # Criar dashboard dinamicamente quando a aba for selecionada
        self.dashboard_frame = dashboard_frame
        self.dashboard_created = False
        self.main_notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
        
        # Ocultar aba do Dashboard Executivo para usu√°rios n√£o-admin
        self.hide_dashboard_for_non_admin()

        # Verifica√ß√£o de prazos ser√° feita AP√ìS o login

    def on_tab_changed(self, event):
        """Chamado quando uma aba √© selecionada"""
        try:
            if not hasattr(self, 'main_notebook') or not self.main_notebook:
                return
                
            current_tab = self.main_notebook.select()
            if not current_tab:
                return
                
            tab_text = self.main_notebook.tab(current_tab, "text")
            if not tab_text:
                return
            
            # Se a aba do Dashboard Executivo foi selecionada e ainda n√£o foi criada
            if tab_text == "Dashboard Executivo" and not self.dashboard_created:
                if hasattr(self, 'dashboard_frame') and self.dashboard_frame:
                    self.create_dashboard_tab(self.dashboard_frame)
                    self.dashboard_created = True
                
        except Exception as e:
            print(f"Erro ao mudar aba: {e}")

    def hide_dashboard_for_non_admin(self):
        """Oculta a aba do Dashboard Executivo para usu√°rios n√£o-admin"""
        try:
            # Encontrar o √≠ndice da aba do Dashboard Executivo
            for i in range(self.main_notebook.index("end")):
                tab_text = self.main_notebook.tab(i, "text")
                if tab_text == "Dashboard Executivo":
                    # Verificar se o usu√°rio atual √© admin
                    if hasattr(self, 'current_user') and self.current_user:
                        if self.check_admin_access():
                            # Mostrar aba para admin
                            self.main_notebook.tab(i, state="normal")
                        else:
                            # Ocultar aba para usu√°rios n√£o-admin
                            self.main_notebook.tab(i, state="hidden")
                    else:
                        # Se n√£o h√° usu√°rio logado, ocultar a aba
                        self.main_notebook.tab(i, state="hidden")
                    break
        except Exception as e:
            print(f"Erro ao ocultar dashboard: {e}")

    def show_dashboard_for_admin(self):
        """Mostra a aba do Dashboard Executivo para admins ap√≥s login"""
        try:
            for i in range(self.main_notebook.index("end")):
                tab_text = self.main_notebook.tab(i, "text")
                if tab_text == "Dashboard Executivo":
                    if self.check_admin_access():
                        self.main_notebook.tab(i, state="normal")
                    else:
                        self.main_notebook.tab(i, state="hidden")
                    break
        except Exception as e:
            print(f"Erro ao mostrar dashboard: {e}")

    def create_calendar_tab(self, parent):
        """Cria a aba de calend√°rio com integra√ß√£o Google Calendar"""
        # Main container
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Top control panel
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Google Calendar connection status
        self.calendar_status_var = tk.StringVar(value="Desconectado")
        status_frame = ttk.LabelFrame(control_frame, text="Status do Google Calendar", padding=5)
        status_frame.pack(side=tk.LEFT, padx=(0, 10))
        
        ttk.Label(status_frame, textvariable=self.calendar_status_var).pack(side=tk.LEFT, padx=5)
        ttk.Button(status_frame, text="Conectar", command=self.connect_google_calendar).pack(side=tk.LEFT, padx=5)
        ttk.Button(status_frame, text="Sincronizar", command=self.sync_calendar_events).pack(side=tk.LEFT, padx=5)
        
        # Calendar controls
        calendar_controls = ttk.Frame(control_frame)
        calendar_controls.pack(side=tk.RIGHT)
        
        ttk.Button(calendar_controls, text="Hoje", command=self.go_to_today).pack(side=tk.LEFT, padx=2)
        ttk.Button(calendar_controls, text="‚óÄ", command=self.prev_month).pack(side=tk.LEFT, padx=2)
        ttk.Button(calendar_controls, text="‚ñ∂", command=self.next_month).pack(side=tk.LEFT, padx=2)
        
        # Calendar display - ocupando toda a largura na parte superior
        calendar_display_frame = ttk.Frame(main_frame)
        calendar_display_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Calendar widget - ocupando toda a largura
        self.calendar_widget = Calendar(
            calendar_display_frame,
            selectmode='day',
            year=datetime.now().year,
            month=datetime.now().month,
            day=datetime.now().day,
            locale='pt_BR'
        )
        self.calendar_widget.pack(fill=tk.X, expand=True)
        
        # Events panel - na parte inferior, ocupando toda a largura
        events_frame = ttk.LabelFrame(main_frame, text="Eventos do Dia", padding=10)
        events_frame.pack(fill=tk.BOTH, expand=True)
        
        # Events list com coluna para tarefas Boodesk
        self.events_tree = ttk.Treeview(events_frame, columns=("Hora", "Evento", "Tarefa Boodesk", "Tipo"), show="headings", height=8)
        self.events_tree.heading("Hora", text="Hora")
        self.events_tree.heading("Evento", text="Evento")
        self.events_tree.heading("Tarefa Boodesk", text="Tarefa Boodesk")
        self.events_tree.heading("Tipo", text="Tipo")
        self.events_tree.column("Hora", width=80)
        self.events_tree.column("Evento", width=300)
        self.events_tree.column("Tarefa Boodesk", width=200)
        self.events_tree.column("Tipo", width=100)
        self.events_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Event actions
        event_actions = ttk.Frame(events_frame)
        event_actions.pack(fill=tk.X)
        
        ttk.Button(event_actions, text="Novo Evento", command=self.create_calendar_event).pack(side=tk.LEFT, padx=2)
        ttk.Button(event_actions, text="Editar", command=self.edit_calendar_event).pack(side=tk.LEFT, padx=2)
        ttk.Button(event_actions, text="Excluir", command=self.delete_calendar_event).pack(side=tk.LEFT, padx=2)
        
        # Bind calendar selection
        self.calendar_widget.bind("<<CalendarSelected>>", self.on_calendar_date_selected)
        
        # Load initial events (sem carregar eventos automaticamente para evitar erros)
        self.mark_due_dates_on_calendar()

    def connect_google_calendar(self):
        """Conecta ao Google Calendar"""
        try:
            if self.google_calendar.authenticate():
                self.calendar_status_var.set("Conectado")
                messagebox.showinfo("Sucesso", "Conectado ao Google Calendar com sucesso!")
                self.load_calendar_events()
            else:
                self.calendar_status_var.set("Erro na conex√£o")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao conectar ao Google Calendar:\n{e}")

    def sync_calendar_events(self):
        """Sincroniza eventos do Google Calendar"""
        try:
            if self.calendar_status_var.get() == "Conectado":
                events = self.google_calendar.get_upcoming_events(30)  # Pr√≥ximos 30 dias
                self.load_calendar_events()
                messagebox.showinfo("Sucesso", f"Sincronizados {len(events)} eventos!")
            else:
                messagebox.showwarning("Aviso", "Conecte-se ao Google Calendar primeiro!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao sincronizar eventos:\n{e}")

    def go_to_today(self):
        """Vai para a data de hoje no calend√°rio"""
        today = datetime.now()
        self.calendar_widget.selection_set(today.date())
        self.on_calendar_date_selected()

    def prev_month(self):
        """M√™s anterior"""
        current_date = self.calendar_widget.get_date()
        if current_date:
            year, month, day = current_date.split('-')
            prev_month = datetime(int(year), int(month), 1) - timedelta(days=1)
            self.calendar_widget.selection_set(prev_month.date())
            self.on_calendar_date_selected()

    def next_month(self):
        """Pr√≥ximo m√™s"""
        current_date = self.calendar_widget.get_date()
        if current_date:
            year, month, day = current_date.split('-')
            next_month = datetime(int(year), int(month), 28) + timedelta(days=4)
            self.calendar_widget.selection_set(next_month.date())
            self.on_calendar_date_selected()

    def on_calendar_date_selected(self, event=None):
        """Chamado quando uma data √© selecionada no calend√°rio"""
        try:
            selected_date = self.calendar_widget.get_date()
            if selected_date:
                self.load_events_for_date(selected_date)
        except Exception as e:
            print(f"Erro ao selecionar data no calend√°rio: {e}")

    def load_calendar_events(self):
        """Carrega eventos do calend√°rio"""
        try:
            if self.calendar_status_var.get() == "Conectado":
                events = self.google_calendar.get_upcoming_events(7)  # Pr√≥ximos 7 dias
                # Aqui voc√™ pode processar e exibir os eventos
                pass
            
            # Marcar datas de vencimento dos cards
            self.mark_due_dates_on_calendar()
            
        except Exception as e:
            print(f"Erro ao carregar eventos do calend√°rio: {e}")

    def mark_due_dates_on_calendar(self):
        """Marca as datas de vencimento dos cards no calend√°rio com cores baseadas na import√¢ncia"""
        try:
            if not hasattr(self, 'calendar_widget') or not self.calendar_widget:
                return
                
            # Limpar eventos existentes de vencimento
            self.calendar_widget.calevent_remove('all')
            
            # Obter cores de import√¢ncia
            importance_colors = self.settings.get("importance_colors", {})
            
            # Adicionar eventos para cada card com data de vencimento
            for board_name, lists in self.boodesk_data["boards"].items():
                if isinstance(lists, dict):
                    for list_name, cards in lists.items():
                        if isinstance(cards, list):
                            for card in cards:
                                if card.get("due_date") and not card.get("is_archived", False):
                                    try:
                                        # Usar fun√ß√£o auxiliar para processar data brasileira
                                        due_date_obj = self.parse_brazilian_date(card["due_date"])
                                        if due_date_obj:
                                            # Obter import√¢ncia do card
                                            importance = card.get("importance", "Normal")
                                            
                                            # Criar evento no calend√°rio com tag baseada na import√¢ncia
                                            event_text = f"üìã {card['title']}"
                                            tag_name = f'due_date_{importance.lower().replace(" ", "_")}'
                                            self.calendar_widget.calevent_create(due_date_obj.date(), event_text, tag_name)
                                            
                                            # Configurar cor baseada na import√¢ncia
                                            bg_color = importance_colors.get(importance, "#FF6B6B")
                                            self.calendar_widget.tag_config(tag_name, background=bg_color, foreground='black')
                                    
                                    except Exception as e:
                                        print(f"Erro ao processar data do card {card.get('title', '')}: {e}")
                                        continue
            
        except Exception as e:
            print(f"Erro ao marcar datas de vencimento no calend√°rio: {e}")

    def load_events_for_date(self, date_str):
        """Carrega eventos para uma data espec√≠fica"""
        try:
            # Limpar lista atual
            for item in self.events_tree.get_children():
                self.events_tree.delete(item)
            
            # Converter string para datetime usando fun√ß√£o auxiliar
            date_obj = self.parse_brazilian_date(date_str)
            if not date_obj:
                print(f"Formato de data inv√°lido: {date_str}")
                return
            
            # Buscar eventos do Google Calendar (apenas se estiver conectado)
            if hasattr(self, 'calendar_status_var') and self.calendar_status_var.get() == "Conectado":
                try:
                    events = self.google_calendar.get_upcoming_events(1)  # Apenas o dia selecionado
                    
                    for event in events:
                        start = event.get('start', {}).get('dateTime', '')
                        if start:
                            try:
                                start_time = datetime.fromisoformat(start.replace('Z', '+00:00'))
                                if start_time.date() == date_obj.date():
                                    self.events_tree.insert("", "end", values=(
                                        start_time.strftime("%H:%M"),
                                        event.get('summary', 'Sem t√≠tulo'),
                                        "Google Calendar"
                                    ))
                            except Exception as e:
                                print(f"Erro ao processar evento do Google Calendar: {e}")
                                continue
                except Exception as e:
                    print(f"Erro ao buscar eventos do Google Calendar: {e}")
            
            # Buscar tarefas do Boodesk para esta data
            if hasattr(self, 'boodesk_data') and self.boodesk_data:
                importance_colors = self.settings.get("importance_colors", {})
                
                for board_name, board_data in self.boodesk_data.get('boards', {}).items():
                    if isinstance(board_data, dict):
                        for list_name, cards in board_data.items():
                            if list_name != 'workflow' and isinstance(cards, list):
                                for card in cards:
                                    due_date = card.get('due_date', '')
                                    if due_date:
                                        try:
                                            # Usar fun√ß√£o auxiliar para processar data brasileira
                                            card_date = self.parse_brazilian_date(due_date)
                                            
                                            if card_date and card_date.date() == date_obj.date():
                                                # Determinar hor√°rio para exibi√ß√£o
                                                display_time = "09:00"  # Hor√°rio padr√£o
                                                if ' ' in due_date and len(due_date.split(' ')) > 1:
                                                    time_part = due_date.split(' ')[1]
                                                    if ':' in time_part:
                                                        display_time = time_part[:5]  # HH:MM
                                                
                                                # Obter import√¢ncia do card
                                                importance = card.get("importance", "Normal")
                                                
                                                # Inserir item na treeview
                                                item_id = self.events_tree.insert("", "end", values=(
                                                    display_time,
                                                    f"[{board_name}] {card['title']}",
                                                    card.get('title', ''),
                                                    "Tarefa Boodesk"
                                                ))
                                                
                                                # Aplicar cor baseada na import√¢ncia
                                                bg_color = importance_colors.get(importance, "#FFFFFF")
                                                self.events_tree.tag_configure(f"importance_{importance.lower().replace(' ', '_')}", background=bg_color)
                                                self.events_tree.item(item_id, tags=(f"importance_{importance.lower().replace(' ', '_')}",))
                                                
                                        except Exception as e:
                                            print(f"Erro ao processar data do card {card.get('title', '')}: {e}")
                                            continue
                                    
        except Exception as e:
            print(f"Erro ao carregar eventos para a data: {e}")

    def create_calendar_event(self):
        """Cria um novo evento no calend√°rio"""
        try:
            selected_date = self.calendar_widget.get_date()
            if not selected_date:
                messagebox.showwarning("Aviso", "Selecione uma data primeiro!")
                return
            
            # Abrir janela de cria√ß√£o de evento
            self.open_event_creation_window(selected_date)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao criar evento:\n{e}")

    def edit_calendar_event(self):
        """Edita um evento selecionado"""
        try:
            selected_item = self.events_tree.selection()
            if not selected_item:
                messagebox.showwarning("Aviso", "Selecione um evento para editar!")
                return
            
            # Implementar edi√ß√£o de evento
            messagebox.showinfo("Info", "Funcionalidade de edi√ß√£o ser√° implementada em breve!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao editar evento:\n{e}")

    def delete_calendar_event(self):
        """Exclui um evento selecionado"""
        try:
            selected_item = self.events_tree.selection()
            if not selected_item:
                messagebox.showwarning("Aviso", "Selecione um evento para excluir!")
                return
            
            if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir este evento?"):
                # Implementar exclus√£o de evento
                self.events_tree.delete(selected_item)
                messagebox.showinfo("Sucesso", "Evento exclu√≠do com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao excluir evento:\n{e}")

    def open_event_creation_window(self, date_str):
        """Abre janela para criar novo evento"""
        try:
            event_window = CalendarEventWindow(self, date_str)
            event_window.grab_set()
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir janela de evento:\n{e}")

    def create_dashboard_tab(self, parent):
        """Cria a aba do Dashboard Executivo com m√©tricas avan√ßadas (apenas para administradores)"""
        # Verificar se j√° foi criado para evitar duplica√ß√£o
        if hasattr(self, 'dashboard_created') and self.dashboard_created:
            return
            
        # Verificar se o usu√°rio √© administrador
        if not self.check_admin_access():
            # Se n√£o for admin, mostrar mensagem de acesso negado
            access_denied_frame = ttk.Frame(parent)
            access_denied_frame.pack(fill=tk.BOTH, expand=True)
            
            ttk.Label(access_denied_frame, 
                     text="üîí Acesso Restrito", 
                     font=("Arial", 24, "bold"),
                     foreground="red").pack(pady=50)
            
            ttk.Label(access_denied_frame, 
                     text="Esta √°rea √© restrita apenas para administradores.\n\n"
                          "O Dashboard Executivo cont√©m m√©tricas sens√≠veis e\n"
                          "an√°lises avan√ßadas de produtividade da equipe.",
                     font=("Arial", 12),
                     justify=tk.CENTER).pack(pady=20)
            
            ttk.Button(access_denied_frame, 
                      text="Voltar ao Menu Principal",
                      command=lambda: self.main_notebook.select(0)).pack(pady=20)
            return

        # Limpar o frame pai antes de criar o dashboard
        for widget in parent.winfo_children():
            widget.destroy()
            
        # Main container para o dashboard com estilo melhorado
        main_frame = ttk.Frame(parent, style="Dashboard.TFrame")
        main_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=15)
        
        # T√≠tulo do dashboard com estilo moderno
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 25))
        
        # T√≠tulo com √≠cone e estilo melhorado
        title_label = ttk.Label(title_frame, 
                 text="üìä Dashboard Executivo", 
                               font=("Arial", 24, "bold"),
                               foreground="#2c3e50")
        title_label.pack(side=tk.LEFT)
        
        # Bot√µes de controle com √≠cones
        control_frame = ttk.Frame(title_frame)
        control_frame.pack(side=tk.RIGHT)
        
        # Bot√£o Atualizar com √≠cone
        refresh_btn = ttk.Button(control_frame, 
                                text="Atualizar", 
                                image=self.icons.get('refresh_icon_32'), 
                                compound=tk.LEFT,
                                command=self.refresh_dashboard)
        refresh_btn.pack(side=tk.LEFT, padx=5)
        
        # Bot√£o Exportar com √≠cone
        export_btn = ttk.Button(control_frame, 
                               text="Exportar Relat√≥rio", 
                               image=self.icons.get('export_icon_32'), 
                               compound=tk.LEFT,
                               command=self.export_dashboard_report)
        export_btn.pack(side=tk.LEFT, padx=5)
        
        # Notebook para organizar as se√ß√µes do dashboard
        dashboard_notebook = ttk.Notebook(main_frame)
        dashboard_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Aba 1: M√©tricas Gerais com √≠cone
        metrics_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(metrics_frame, 
                              text="M√©tricas Gerais", 
                              image=self.icons.get('chart_icon_32'), 
                              compound=tk.LEFT)
        self.create_metrics_tab(metrics_frame)
        
        # Aba 2: Performance da Equipe com √≠cone
        team_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(team_frame, 
                              text="Performance da Equipe", 
                              image=self.icons.get('team_icon_32'), 
                              compound=tk.LEFT)
        self.create_team_performance_tab(team_frame)
        
        # Aba 3: An√°lise de Tempo com √≠cone
        time_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(time_frame, 
                              text="An√°lise de Tempo", 
                              image=self.icons.get('clock_icon_32'), 
                              compound=tk.LEFT)
        self.create_time_analysis_tab(time_frame)
        
        # Aba 4: Gr√°ficos de Burndown com √≠cone
        burndown_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(burndown_frame, 
                              text="Gr√°ficos de Burndown", 
                              image=self.icons.get('burndown_icon_32'), 
                              compound=tk.LEFT)
        self.create_burndown_tab(burndown_frame)
        
        # Aba 5: Previs√µes IA com √≠cone
        predictions_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(predictions_frame, 
                              text="Previs√µes IA", 
                              image=self.icons.get('ai_icon_32'), 
                              compound=tk.LEFT)
        self.create_predictions_tab(predictions_frame)
        
        # Aba 6: Pr√≥ximas Reuni√µes com √≠cone
        meetings_frame = ttk.Frame(dashboard_notebook)
        dashboard_notebook.add(meetings_frame, 
                              text="Pr√≥ximas Reuni√µes", 
                              image=self.icons.get('meeting_icon_32'), 
                              compound=tk.LEFT)
        self.create_meetings_tab(meetings_frame)
        
        # Marcar como criado para evitar duplica√ß√£o
        self.dashboard_created = True

    def check_admin_access(self):
        """Verifica se o usu√°rio atual tem acesso de administrador"""
        if not hasattr(self, 'current_user') or not self.current_user:
            return False
        
        # Verificar se o usu√°rio tem role de administrador
        user_role = getattr(self.current_user, 'role', None)
        if user_role in ['admin', 'Administrador', 'manager']:
            return True
        
        # Verificar se o usu√°rio tem cargo de administrador
        user_cargo = getattr(self.current_user, 'cargo', None)
        if user_cargo in ['Administrador', 'Gerente', 'Manager']:
            return True
        
        # Verificar se o username √© 'admin' (fallback)
        username = getattr(self.current_user, 'username', None)
        if username == 'admin':
            return True
        
        return False

    def create_metrics_tab(self, parent):
        """Cria a aba de m√©tricas gerais com design moderno"""
        # Frame principal com scroll e estilo melhorado
        canvas = tk.Canvas(parent, bg="#f8f9fa", highlightthickness=0)
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # M√©tricas em tempo real com estilo moderno
        metrics_frame = ttk.LabelFrame(scrollable_frame, text="üìä M√©tricas em Tempo Real", padding=15)
        metrics_frame.pack(fill=tk.X, pady=15, padx=15)
        
        # Grid para m√©tricas com espa√ßamento melhorado
        metrics_frame.columnconfigure(0, weight=1)
        metrics_frame.columnconfigure(1, weight=1)
        metrics_frame.columnconfigure(2, weight=1)
        metrics_frame.columnconfigure(3, weight=1)
        
        # M√©tricas calculadas
        total_cards, completed_cards, pending_cards, overdue_cards = self.calculate_card_metrics()
        total_members = len(self.members)
        avg_completion_time = self.calculate_avg_completion_time()
        productivity_score = self.calculate_productivity_score()
        
        # Exibir m√©tricas com √≠cones
        self.create_metric_card(metrics_frame, "üìã Total de Tarefas", total_cards, 0, 0, "#3498db")
        self.create_metric_card(metrics_frame, "‚úÖ Conclu√≠das", completed_cards, 0, 1, "#27ae60")
        self.create_metric_card(metrics_frame, "‚è≥ Pendentes", pending_cards, 0, 2, "#f39c12")
        self.create_metric_card(metrics_frame, "‚ö†Ô∏è Vencidas", overdue_cards, 0, 3, "#e74c3c")
        
        self.create_metric_card(metrics_frame, "üë• Membros Ativos", total_members, 1, 0, "#9b59b6")
        self.create_metric_card(metrics_frame, "‚è±Ô∏è Tempo M√©dio", f"{avg_completion_time:.1f}h", 1, 1, "#34495e")
        self.create_metric_card(metrics_frame, "üìà Produtividade", f"{productivity_score:.1f}%", 1, 2, "#1abc9c")
        self.create_metric_card(metrics_frame, "üéØ Taxa de Sucesso", f"{(completed_cards/total_cards*100):.1f}%" if total_cards > 0 else "0%", 1, 3, "#e67e22")
        
        # Gr√°fico de pizza para distribui√ß√£o de tarefas
        chart_frame = ttk.LabelFrame(scrollable_frame, text="üìä Distribui√ß√£o por Status", padding=15)
        chart_frame.pack(fill=tk.X, pady=15, padx=15)
        
        self.create_pie_chart(chart_frame, completed_cards, pending_cards, overdue_cards)
        
        # Bot√µes de a√ß√£o com estilo moderno
        button_frame = ttk.Frame(scrollable_frame)
        button_frame.pack(fill=tk.X, pady=15, padx=15)
        
        # Bot√µes com √≠cones e cores
        refresh_btn = ttk.Button(button_frame, 
                                text="Atualizar Dados", 
                                image=self.icons.get('refresh_icon_32'), 
                                compound=tk.LEFT, 
                                command=self.refresh_dashboard)
        refresh_btn.pack(side=tk.LEFT, padx=8)
        
        export_btn = ttk.Button(button_frame, 
                               text="Exportar Relat√≥rio", 
                               image=self.icons.get('export_icon_32'), 
                               compound=tk.LEFT, 
                               command=self.export_dashboard_report)
        export_btn.pack(side=tk.LEFT, padx=8)
        
        chart_btn = ttk.Button(button_frame, 
                              text="Gerar Gr√°fico", 
                              image=self.icons.get('chart_xy_icon_32'), 
                              compound=tk.LEFT, 
                              command=self.generate_metrics_chart)
        chart_btn.pack(side=tk.LEFT, padx=8)

    def create_metric_card(self, parent, title, value, row, col, color="#3498db"):
        """Cria um card de m√©trica com design moderno"""
        # Frame principal do card com estilo moderno
        card_frame = tk.Frame(parent, bg=color, relief="flat", bd=0, highlightthickness=1, highlightbackground="#bdc3c7")
        card_frame.grid(row=row, column=col, padx=8, pady=8, sticky="nsew")
        
        # Configurar peso das colunas para distribui√ß√£o uniforme
        parent.columnconfigure(col, weight=1)
        parent.rowconfigure(row, weight=1)
        
        # Frame interno com padding
        inner_frame = tk.Frame(card_frame, bg="white", relief="flat", bd=0)
        inner_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        # T√≠tulo com estilo moderno
        title_label = tk.Label(inner_frame, 
                              text=title, 
                              font=("Arial", 11, "bold"),
                              bg="white",
                              fg="#2c3e50",
                              wraplength=120,
                              justify=tk.CENTER)
        title_label.pack(pady=(12, 8))
        
        # Valor com estilo destacado
        value_label = tk.Label(inner_frame, 
                              text=str(value), 
                              font=("Arial", 20, "bold"),
                              bg="white",
                              fg=color)
        value_label.pack(pady=(0, 12))
        
        # Efeito hover (opcional)
        def on_enter(e):
            card_frame.configure(highlightbackground=color, highlightthickness=2)
            
        def on_leave(e):
            card_frame.configure(highlightbackground="#bdc3c7", highlightthickness=1)
            
        card_frame.bind("<Enter>", on_enter)
        card_frame.bind("<Leave>", on_leave)
        title_label.bind("<Enter>", on_enter)
        title_label.bind("<Leave>", on_leave)
        value_label.bind("<Enter>", on_enter)
        value_label.bind("<Leave>", on_leave)

    def calculate_card_metrics(self):
        """Calcula m√©tricas b√°sicas dos cards"""
        total_cards = 0
        completed_cards = 0
        pending_cards = 0
        overdue_cards = 0
        
        today = datetime.now().date()
        
        for board_name, lists in self.boodesk_data["boards"].items():
            for list_name, cards in lists.items():
                for card in cards:
                    if not card.get("is_archived", False):
                        total_cards += 1
                        
                        # Verificar status baseado na lista
                        if list_name in ["Conclu√≠do", "Done", "Finalizado"]:
                            completed_cards += 1
                        else:
                            pending_cards += 1
                            
                            # Verificar se est√° vencido
                            due_date = card.get("due_date", "")
                            if due_date:
                                try:
                                    due_date_obj = self.parse_brazilian_date(due_date)
                                    if due_date_obj and due_date_obj.date() < today:
                                        overdue_cards += 1
                                except:
                                    pass
        
        return total_cards, completed_cards, pending_cards, overdue_cards

    def calculate_avg_completion_time(self):
        """Calcula tempo m√©dio de conclus√£o (simulado)"""
        # Simula√ß√£o baseada em dados hist√≥ricos
        return 4.5  # horas

    def calculate_productivity_score(self):
        """Calcula score de produtividade"""
        total_cards, completed_cards, pending_cards, overdue_cards = self.calculate_card_metrics()
        
        if total_cards == 0:
            return 0
        
        # Score baseado em conclus√µes vs vencimentos
        completion_rate = completed_cards / total_cards * 100
        overdue_penalty = (overdue_cards / total_cards * 100) if total_cards > 0 else 0
        
        return max(0, completion_rate - overdue_penalty)

    def create_pie_chart(self, parent, completed, pending, overdue):
        """Cria gr√°fico de pizza moderno com barras horizontais"""
        # Frame para o gr√°fico com estilo moderno
        chart_frame = tk.Frame(parent, bg="white", relief="flat", bd=0)
        chart_frame.pack(fill=tk.X, pady=15)
        
        # Dados para o gr√°fico
        data = [completed, pending, overdue]
        labels = ["‚úÖ Conclu√≠das", "‚è≥ Pendentes", "‚ö†Ô∏è Vencidas"]
        colors = ["#27ae60", "#f39c12", "#e74c3c"]
        
        # Criar representa√ß√£o visual moderna
        total = sum(data)
        if total == 0:
            no_data_frame = tk.Frame(chart_frame, bg="white")
            no_data_frame.pack(fill=tk.X, pady=20)
            
            no_data_label = tk.Label(no_data_frame, 
                                   text="üìä Nenhum dado dispon√≠vel", 
                                   font=("Arial", 14, "bold"),
                                   bg="white",
                                   fg="#7f8c8d")
            no_data_label.pack()
            return
        
        # Criar barras horizontais modernas
        for i, (value, label, color) in enumerate(zip(data, labels, colors)):
            if value > 0:
                percentage = (value / total) * 100
                
                # Container para cada barra
                bar_container = tk.Frame(chart_frame, bg="white", relief="flat", bd=0)
                bar_container.pack(fill=tk.X, pady=8)
                
                # Frame para label e valor
                label_frame = tk.Frame(bar_container, bg="white")
                label_frame.pack(fill=tk.X, pady=(0, 5))
                
                # Label com √≠cone
                label_widget = tk.Label(label_frame, 
                                       text=f"{label}: {value} ({percentage:.1f}%)", 
                                       font=("Arial", 11, "bold"),
                                       bg="white",
                                       fg="#2c3e50",
                                       anchor="w")
                label_widget.pack(side=tk.LEFT)
                
                # Frame para a barra
                bar_frame = tk.Frame(bar_container, bg="#ecf0f1", relief="flat", bd=0, height=25)
                bar_frame.pack(fill=tk.X)
                bar_frame.pack_propagate(False)
                
                # Barra colorida com bordas arredondadas
                bar_width = int((percentage / 100) * 400)  # Largura m√°xima de 400px
                bar = tk.Frame(bar_frame, bg=color, relief="flat", bd=0, width=bar_width, height=20)
                bar.pack(side=tk.LEFT, padx=2, pady=2)
                
                # Efeito hover na barra
                def on_enter(e, bar=bar, color=color):
                    bar.configure(bg=self.lighten_color(color))
                    
                def on_leave(e, bar=bar, color=color):
                    bar.configure(bg=color)
                    
                bar.bind("<Enter>", on_enter)
                bar.bind("<Leave>", on_leave)
                label_widget.bind("<Enter>", on_enter)
                label_widget.bind("<Leave>", on_leave)
    
    def lighten_color(self, color):
        """Clareia uma cor para efeito hover"""
        # Converter cor hex para RGB
        color = color.lstrip('#')
        r, g, b = tuple(int(color[i:i+2], 16) for i in (0, 2, 4))
        
        # Clarear a cor
        r = min(255, int(r * 1.2))
        g = min(255, int(g * 1.2))
        b = min(255, int(b * 1.2))
        
        # Converter de volta para hex
        return f"#{r:02x}{g:02x}{b:02x}"

    def create_team_performance_tab(self, parent):
        """Cria a aba de performance da equipe"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # T√≠tulo
        ttk.Label(main_frame, text="üë• Performance Individual da Equipe", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Treeview para performance dos membros
        columns = ("Membro", "Tarefas Conclu√≠das", "Tarefas Pendentes", "Taxa de Conclus√£o", "Tempo M√©dio", "Score")
        self.team_tree = ttk.Treeview(main_frame, columns=columns, show="headings", height=10)
        
        for col in columns:
            self.team_tree.heading(col, text=col)
            self.team_tree.column(col, width=150, anchor="center")
        
        self.team_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=self.team_tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.team_tree.configure(yscrollcommand=scrollbar.set)
        
        # Bot√µes de a√ß√£o
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(button_frame, text="Atualizar Dados", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_team_performance).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(button_frame, text="Gerar Relat√≥rio", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.generate_team_report).pack(side=tk.LEFT, padx=5)
        
        # Carregar dados iniciais
        self.load_team_performance_data()

    def load_team_performance_data(self):
        """Carrega dados de performance da equipe"""
        # Limpar dados existentes
        for item in self.team_tree.get_children():
            self.team_tree.delete(item)
        
        # Calcular performance para cada membro
        for member in self.members:
            member_name = member['Membro']
            completed, pending, avg_time, completion_rate = self.calculate_member_performance(member_name)
            
            # Calcular score baseado em performance
            score = self.calculate_member_score(completed, pending, completion_rate)
            
            self.team_tree.insert("", "end", values=(
                member_name,
                completed,
                pending,
                f"{completion_rate:.1f}%",
                f"{avg_time:.1f}h",
                f"{score:.1f}"
            ))

    def calculate_member_performance(self, member_name):
        """Calcula performance de um membro espec√≠fico"""
        completed = 0
        pending = 0
        total_time = 0
        completed_tasks = 0
        
        for board_name, lists in self.boodesk_data["boards"].items():
            for list_name, cards in lists.items():
                for card in cards:
                    if not card.get("is_archived", False):
                        card_members = card.get("members", [])
                        if member_name in card_members:
                            if list_name in ["Conclu√≠do", "Done", "Finalizado"]:
                                completed += 1
                                completed_tasks += 1
                                # Simular tempo de conclus√£o
                                total_time += 4.5  # horas m√©dias
                            else:
                                pending += 1
        
        avg_time = total_time / completed_tasks if completed_tasks > 0 else 0
        completion_rate = (completed / (completed + pending)) * 100 if (completed + pending) > 0 else 0
        
        return completed, pending, avg_time, completion_rate

    def calculate_member_score(self, completed, pending, completion_rate):
        """Calcula score de um membro"""
        base_score = completion_rate
        efficiency_bonus = min(completed * 2, 20)  # B√¥nus por tarefas conclu√≠das
        return min(100, base_score + efficiency_bonus)

    def create_time_analysis_tab(self, parent):
        """Cria a aba de an√°lise de tempo"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # T√≠tulo
        ttk.Label(main_frame, text="An√°lise de Tempo por Categoria/Projeto", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(control_frame, text="Per√≠odo:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.time_period_var = tk.StringVar(value="√öltimos 30 dias")
        period_combo = ttk.Combobox(control_frame, 
                                   textvariable=self.time_period_var,
                                   values=["√öltimos 7 dias", "√öltimos 30 dias", "√öltimos 90 dias", "Este ano"],
                                   state="readonly")
        period_combo.pack(side=tk.LEFT, padx=(0, 20))
        period_combo.bind("<<ComboboxSelected>>", lambda e: self.refresh_time_analysis())
        
        ttk.Button(control_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_time_analysis).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Exportar Dados", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.export_time_analysis).pack(side=tk.LEFT, padx=5)
        
        # Notebook para diferentes visualiza√ß√µes
        time_notebook = ttk.Notebook(main_frame)
        time_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Aba 1: Tempo por Categoria
        category_frame = ttk.Frame(time_notebook)
        time_notebook.add(category_frame, text="Por Categoria")
        self.create_time_category_view(category_frame)
        
        # Aba 2: Tempo por Projeto
        project_frame = ttk.Frame(time_notebook)
        time_notebook.add(project_frame, text="Por Projeto")
        self.create_time_project_view(project_frame)
        
        # Aba 3: Tend√™ncias
        trends_frame = ttk.Frame(time_notebook)
        time_notebook.add(trends_frame, text="Tend√™ncias")
        self.create_time_trends_view(trends_frame)

    def create_time_category_view(self, parent):
        """Cria visualiza√ß√£o de tempo por categoria"""
        # Treeview para categorias
        columns = ("Categoria", "Tempo Total (h)", "Tarefas", "Tempo M√©dio", "Porcentagem")
        self.category_tree = ttk.Treeview(parent, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.category_tree.heading(col, text=col)
            self.category_tree.column(col, width=150, anchor="center")
        
        self.category_tree.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Carregar dados
        self.load_time_category_data()

    def load_time_category_data(self):
        """Carrega dados de tempo por categoria"""
        # Limpar dados existentes
        for item in self.category_tree.get_children():
            self.category_tree.delete(item)
        
        # Calcular tempo por categoria (simulado)
        categories = {}
        total_time = 0
        
        for board_name, lists in self.boodesk_data["boards"].items():
            for list_name, cards in lists.items():
                for card in cards:
                    if not card.get("is_archived", False):
                        category = card.get("subject", "Sem categoria")
                        if category not in categories:
                            categories[category] = {"time": 0, "tasks": 0}
                        
                        # Simular tempo baseado na import√¢ncia
                        importance = card.get("importance", "Normal")
                        time_multiplier = {"Cr√≠tica": 8, "Alta": 6, "Normal": 4, "Baixa": 2}
                        estimated_time = time_multiplier.get(importance, 4)
                        
                        categories[category]["time"] += estimated_time
                        categories[category]["tasks"] += 1
                        total_time += estimated_time
        
        # Inserir dados na treeview
        for category, data in categories.items():
            percentage = (data["time"] / total_time * 100) if total_time > 0 else 0
            avg_time = data["time"] / data["tasks"] if data["tasks"] > 0 else 0
            
            self.category_tree.insert("", "end", values=(
                category,
                f"{data['time']:.1f}",
                data["tasks"],
                f"{avg_time:.1f}h",
                f"{percentage:.1f}%"
            ))

    def create_time_project_view(self, parent):
        """Cria visualiza√ß√£o de tempo por projeto"""
        # Treeview para projetos
        columns = ("Projeto", "Tempo Total (h)", "Tarefas", "Progresso", "Prazo")
        self.project_tree = ttk.Treeview(parent, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.project_tree.heading(col, text=col)
            self.project_tree.column(col, width=150, anchor="center")
        
        self.project_tree.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Carregar dados
        self.load_time_project_data()

    def load_time_project_data(self):
        """Carrega dados de tempo por projeto"""
        # Limpar dados existentes
        for item in self.project_tree.get_children():
            self.project_tree.delete(item)
        
        # Calcular tempo por projeto (baseado nos quadros)
        projects = {}
        
        for board_name, lists in self.boodesk_data["boards"].items():
            if board_name not in projects:
                projects[board_name] = {"time": 0, "tasks": 0, "completed": 0, "total": 0}
            
            for list_name, cards in lists.items():
                for card in cards:
                    if not card.get("is_archived", False):
                        projects[board_name]["total"] += 1
                        
                        if list_name in ["Conclu√≠do", "Done", "Finalizado"]:
                            projects[board_name]["completed"] += 1
                        
                        # Simular tempo
                        importance = card.get("importance", "Normal")
                        time_multiplier = {"Cr√≠tica": 8, "Alta": 6, "Normal": 4, "Baixa": 2}
                        estimated_time = time_multiplier.get(importance, 4)
                        
                        projects[board_name]["time"] += estimated_time
                        projects[board_name]["tasks"] += 1
        
        # Inserir dados na treeview
        for project, data in projects.items():
            progress = (data["completed"] / data["total"] * 100) if data["total"] > 0 else 0
            
            self.project_tree.insert("", "end", values=(
                project,
                f"{data['time']:.1f}",
                data["tasks"],
                f"{progress:.1f}%",
                "Em andamento"
            ))

    def create_time_trends_view(self, parent):
        """Cria visualiza√ß√£o de tend√™ncias de tempo"""
        # Frame para gr√°fico de tend√™ncias
        trends_frame = ttk.Frame(parent)
        trends_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        ttk.Label(trends_frame, text="üìà Tend√™ncias de Produtividade", 
                 font=("Arial", 14, "bold")).pack(pady=(0, 20))
        
        # Simular dados de tend√™ncia
        weeks = ["Semana 1", "Semana 2", "Semana 3", "Semana 4"]
        productivity = [75, 82, 78, 85]
        
        # Criar gr√°fico simples
        chart_frame = ttk.Frame(trends_frame)
        chart_frame.pack(fill=tk.BOTH, expand=True)
        
        # Criar barras para cada semana
        for i, (week, prod) in enumerate(zip(weeks, productivity)):
            week_frame = ttk.Frame(chart_frame)
            week_frame.pack(fill=tk.X, pady=5)
            
            ttk.Label(week_frame, text=week, width=15).pack(side=tk.LEFT)
            
            # Barra de produtividade
            bar = tk.Frame(week_frame, bg="#4CAF50", height=20)
            bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(10, 0))
            
            # Configurar largura baseada na produtividade
            bar.configure(width=int(prod * 3))
            
            ttk.Label(week_frame, text=f"{prod}%", width=8).pack(side=tk.LEFT, padx=(10, 0))

    def create_burndown_tab(self, parent):
        """Cria a aba de gr√°ficos de burndown"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # T√≠tulo
        ttk.Label(main_frame, text="Gr√°ficos de Burndown - Metodologia √Ågil", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(control_frame, text="Sprint:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.sprint_var = tk.StringVar(value="Sprint Atual")
        sprint_combo = ttk.Combobox(control_frame, 
                                   textvariable=self.sprint_var,
                                   values=["Sprint Atual", "Sprint Anterior", "Pr√≥ximo Sprint"],
                                   state="readonly")
        sprint_combo.pack(side=tk.LEFT, padx=(0, 20))
        sprint_combo.bind("<<ComboboxSelected>>", lambda e: self.refresh_burndown())
        
        ttk.Button(control_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_burndown).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Gerar Relat√≥rio", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT,
                  command=self.generate_burndown_report).pack(side=tk.LEFT, padx=5)
        
        # Frame para o gr√°fico
        chart_frame = ttk.LabelFrame(main_frame, text="Gr√°fico de Burndown", padding=10)
        chart_frame.pack(fill=tk.BOTH, expand=True)
        
        # Criar gr√°fico de burndown simples
        self.create_burndown_chart(chart_frame)

    def create_burndown_chart(self, parent):
        """Cria gr√°fico de burndown"""
        # Frame para o gr√°fico
        chart_frame = ttk.Frame(parent)
        chart_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Dados simulados para burndown
        days = ["Dia 1", "Dia 2", "Dia 3", "Dia 4", "Dia 5", "Dia 6", "Dia 7", "Dia 8", "Dia 9", "Dia 10"]
        ideal = [100, 90, 80, 70, 60, 50, 40, 30, 20, 10]  # Linha ideal
        actual = [100, 95, 85, 75, 70, 60, 50, 45, 35, 25]  # Linha real
        
        # Criar representa√ß√£o visual
        for i, (day, ideal_val, actual_val) in enumerate(zip(days, ideal, actual)):
            day_frame = ttk.Frame(chart_frame)
            day_frame.pack(fill=tk.X, pady=2)
            
            ttk.Label(day_frame, text=day, width=10).pack(side=tk.LEFT)
            
            # Linha ideal (verde)
            ideal_bar = tk.Frame(day_frame, bg="#4CAF50", height=15)
            ideal_bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 2))
            ideal_bar.configure(width=int(ideal_val * 2))
            
            # Linha real (azul)
            actual_bar = tk.Frame(day_frame, bg="#2196F3", height=15)
            actual_bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(2, 5))
            actual_bar.configure(width=int(actual_val * 2))
            
            # Valores
            ttk.Label(day_frame, text=f"I: {ideal_val}%", width=8).pack(side=tk.LEFT, padx=(5, 0))
            ttk.Label(day_frame, text=f"R: {actual_val}%", width=8).pack(side=tk.LEFT, padx=(5, 0))
        
        # Legenda
        legend_frame = ttk.Frame(chart_frame)
        legend_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(legend_frame, text="Legenda:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        
        ideal_legend = tk.Frame(legend_frame, bg="#4CAF50", width=20, height=15)
        ideal_legend.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Label(legend_frame, text="Ideal").pack(side=tk.LEFT, padx=(0, 20))
        
        actual_legend = tk.Frame(legend_frame, bg="#2196F3", width=20, height=15)
        actual_legend.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Label(legend_frame, text="Real").pack(side=tk.LEFT)

    def create_predictions_tab(self, parent):
        """Cria a aba de previs√µes IA"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # T√≠tulo
        ttk.Label(main_frame, text="Previs√µes de IA - Estimativas Inteligentes", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Button(control_frame, text="Gerar Previs√µes", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT,
                  command=self.generate_ai_predictions).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Atualizar Modelo", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.update_ai_model).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Exportar Previs√µes", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.export_ai_predictions).pack(side=tk.LEFT, padx=5)
        
        # Frame para previs√µes
        predictions_frame = ttk.LabelFrame(main_frame, text="Previs√µes de Conclus√£o", padding=10)
        predictions_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para previs√µes
        columns = ("Projeto", "Tarefas Restantes", "Tempo Estimado", "Data Prevista", "Confian√ßa", "Risco")
        self.predictions_tree = ttk.Treeview(predictions_frame, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.predictions_tree.heading(col, text=col)
            self.predictions_tree.column(col, width=120, anchor="center")
        
        self.predictions_tree.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Carregar previs√µes iniciais
        self.load_ai_predictions()

    def load_ai_predictions(self):
        """Carrega previs√µes de IA"""
        # Limpar dados existentes
        for item in self.predictions_tree.get_children():
            self.predictions_tree.delete(item)
        
        # Gerar previs√µes simuladas
        predictions = self.generate_simulated_predictions()
        
        for prediction in predictions:
            self.predictions_tree.insert("", "end", values=prediction)

    def generate_simulated_predictions(self):
        """Gera previs√µes simuladas baseadas nos dados atuais"""
        predictions = []
        
        for board_name, lists in self.boodesk_data["boards"].items():
            pending_tasks = 0
            total_estimated_time = 0
            
            for list_name, cards in lists.items():
                if list_name not in ["Conclu√≠do", "Done", "Finalizado"]:
                    for card in cards:
                        if not card.get("is_archived", False):
                            pending_tasks += 1
                            
                            # Estimativa baseada na import√¢ncia
                            importance = card.get("importance", "Normal")
                            time_multiplier = {"Cr√≠tica": 8, "Alta": 6, "Normal": 4, "Baixa": 2}
                            estimated_time = time_multiplier.get(importance, 4)
                            total_estimated_time += estimated_time
            
            if pending_tasks > 0:
                # Calcular data prevista
                avg_time_per_task = total_estimated_time / pending_tasks
                days_to_complete = (total_estimated_time / 8)  # 8 horas por dia
                
                from datetime import timedelta
                predicted_date = datetime.now() + timedelta(days=days_to_complete)
                
                # Calcular confian√ßa baseada na consist√™ncia dos dados
                confidence = min(95, 70 + (pending_tasks * 2))  # Mais tarefas = mais dados = mais confian√ßa
                
                # Determinar risco
                if days_to_complete > 30:
                    risk = "Alto"
                elif days_to_complete > 15:
                    risk = "M√©dio"
                else:
                    risk = "Baixo"
                
                predictions.append((
                    board_name,
                    pending_tasks,
                    f"{total_estimated_time:.1f}h",
                    predicted_date.strftime("%d/%m/%Y"),
                    f"{confidence:.0f}%",
                    risk
                ))
    
    def create_meetings_tab(self, parent):
        """Cria a aba de pr√≥ximas reuni√µes"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # T√≠tulo
        ttk.Label(main_frame, text="Pr√≥ximas Reuni√µes - Agendamento e Links", 
                 font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Frame para controles
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Button(control_frame, text="Nova Reuni√£o", image=self.icons.get('add_icon'), compound=tk.LEFT,
                  command=self.create_new_meeting).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                  command=self.refresh_meetings).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text="Exportar Agenda", image=self.icons.get('export_icon'), compound=tk.LEFT,
                  command=self.export_meetings_agenda).pack(side=tk.LEFT, padx=5)
        
        # Frame para reuni√µes
        meetings_frame = ttk.LabelFrame(main_frame, text="Reuni√µes Agendadas", padding=10)
        meetings_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para reuni√µes
        columns = ("Data", "Hora", "T√≠tulo", "Projeto", "Plataforma", "Criado por", "Link")
        self.meetings_tree = ttk.Treeview(meetings_frame, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.meetings_tree.heading(col, text=col)
            self.meetings_tree.column(col, width=100, anchor="center")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(meetings_frame, orient="vertical", command=self.meetings_tree.yview)
        self.meetings_tree.configure(yscrollcommand=scrollbar.set)
        
        # Posicionar
        self.meetings_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Frame para a√ß√µes
        actions_frame = ttk.Frame(main_frame)
        actions_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(actions_frame, text="Copiar Link", image=self.icons.get('copy_icon'), compound=tk.LEFT,
                  command=self.copy_meeting_link_dashboard).pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(actions_frame, text="Excluir Reuni√£o", image=self.icons.get('delete_icon'), compound=tk.LEFT,
                  command=self.delete_meeting_dashboard).pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(actions_frame, text="Abrir Reuni√£o", image=self.icons.get('forward_icon'), compound=tk.LEFT,
                  command=self.open_meeting_link).pack(side=tk.LEFT)
        
        # Carregar reuni√µes iniciais
        self.load_dashboard_meetings()
    
    def load_dashboard_meetings(self):
        """Carrega reuni√µes no dashboard"""
        # Limpar dados existentes
        for item in self.meetings_tree.get_children():
            self.meetings_tree.delete(item)
        
        # Carregar pr√≥ximas reuni√µes
        upcoming_meetings = self.meeting_integration.get_upcoming_meetings()
        
        for meeting in upcoming_meetings:
            # Converter nome da plataforma para exibi√ß√£o
            platform = meeting.get('platform', '')
            platform_display = {
                'zoom': 'ZOOM',
                'teams': 'TEAMS', 
                'google_meet': 'GOOGLE MEET'
            }.get(platform, platform.upper())
            
            self.meetings_tree.insert("", "end", values=(
                meeting.get('date', ''),
                meeting.get('time', ''),
                meeting.get('title', ''),
                meeting.get('project', 'Geral'),
                platform_display,
                meeting.get('created_by', ''),
                meeting.get('link', '')[:50] + "..." if len(meeting.get('link', '')) > 50 else meeting.get('link', '')
            ), tags=(meeting['id'],))
    
    def create_new_meeting(self):
        """Abre janela para criar nova reuni√£o"""
        MeetingWindow(self.root, self)
    
    def refresh_meetings(self):
        """Atualiza lista de reuni√µes"""
        self.load_dashboard_meetings()
    
    def copy_meeting_link_dashboard(self):
        """Copia link da reuni√£o selecionada no dashboard"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reuni√£o!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        
        if meeting_id in self.meeting_integration.meeting_data:
            meeting = self.meeting_integration.meeting_data[meeting_id]
            link = meeting['link']
            
            # Copiar para √°rea de transfer√™ncia
            self.root.clipboard_clear()
            self.root.clipboard_append(link)
            
            messagebox.showinfo("Link Copiado", f"Link copiado para a √°rea de transfer√™ncia:\n{link}")
    
    def delete_meeting_dashboard(self):
        """Exclui reuni√£o selecionada no dashboard"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reuni√£o!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        meeting_title = item['values'][2]
        
        if messagebox.askyesno("Confirmar Exclus√£o", 
                              f"Tem certeza que deseja excluir a reuni√£o '{meeting_title}'?\n\n"
                              f"Isso tamb√©m cancelar√° a reuni√£o no Google Calendar."):
            if meeting_id in self.meeting_integration.meeting_data:
                meeting = self.meeting_integration.meeting_data[meeting_id]
                
                # Tentar cancelar no Google Calendar se for Google Meet
                google_canceled = False
                if meeting.get('platform') == 'google_meet' and meeting.get('google_event_id'):
                    try:
                        if not hasattr(self, 'google_calendar_manager'):
                            self.google_calendar_manager = GoogleCalendarManager()
                        
                        google_canceled = self.google_calendar_manager.cancel_meeting(
                            meeting.get('google_event_id')
                        )
                    except Exception as e:
                        print(f"Erro ao cancelar no Google Calendar: {e}")
                
                # Remover do sistema local
                del self.meeting_integration.meeting_data[meeting_id]
                self.meeting_integration.save_meeting_data()
                self.load_dashboard_meetings()
                
                # Mostrar resultado
                if google_canceled:
                    messagebox.showinfo("Sucesso", 
                                      f"Reuni√£o '{meeting_title}' exclu√≠da com sucesso!\n"
                                      f"‚úÖ Tamb√©m cancelada no Google Calendar.")
                elif meeting.get('platform') == 'google_meet':
                    messagebox.showwarning("Parcialmente Bem-sucedido", 
                                         f"Reuni√£o '{meeting_title}' exclu√≠da do sistema.\n"
                                         f"‚ö†Ô∏è N√£o foi poss√≠vel cancelar no Google Calendar.\n"
                                         f"Cancele manualmente no Google Calendar.")
                else:
                    messagebox.showinfo("Sucesso", f"Reuni√£o '{meeting_title}' exclu√≠da com sucesso!")
    
    def open_meeting_link(self):
        """Abre link da reuni√£o no navegador"""
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma reuni√£o!")
            return
        
        item = self.meetings_tree.item(selection[0])
        meeting_id = item['tags'][0]
        
        if meeting_id in self.meeting_integration.meeting_data:
            meeting = self.meeting_integration.meeting_data[meeting_id]
            link = meeting['link']
            
            try:
                import webbrowser
                webbrowser.open(link)
                messagebox.showinfo("Reuni√£o Aberta", f"Link da reuni√£o aberto no navegador!")
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao abrir link: {e}")
    
    def export_meetings_agenda(self):
        """Exporta agenda de reuni√µes"""
        try:
            upcoming_meetings = self.meeting_integration.get_upcoming_meetings()
            
            if not upcoming_meetings:
                messagebox.showinfo("Agenda Vazia", "N√£o h√° reuni√µes agendadas para exportar.")
                return
            
            # Criar conte√∫do da agenda
            agenda_content = "AGENDA DE REUNI√ïES\n"
            agenda_content += "=" * 50 + "\n\n"
            
            for meeting in upcoming_meetings:
                # Converter nome da plataforma para exibi√ß√£o
                platform = meeting.get('platform', '')
                platform_display = {
                    'zoom': 'ZOOM',
                    'teams': 'TEAMS', 
                    'google_meet': 'GOOGLE MEET'
                }.get(platform, platform.upper())
                
                agenda_content += f"üìÖ {meeting['title']}\n"
                agenda_content += f"   Data: {meeting['date']} √†s {meeting['time']}\n"
                agenda_content += f"   Dura√ß√£o: {meeting['duration']} minutos\n"
                agenda_content += f"   Plataforma: {platform_display}\n"
                agenda_content += f"   Link: {meeting['link']}\n"
                if meeting.get('project'):
                    agenda_content += f"   Projeto: {meeting['project']}\n"
                agenda_content += f"   Criado por: {meeting['created_by']}\n"
                agenda_content += "\n"
            
            # Salvar arquivo
            filename = f"agenda_reunioes_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(agenda_content)
            
            messagebox.showinfo("Agenda Exportada", f"Agenda salva como '{filename}'")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar agenda: {e}")
        
        return predictions

    def refresh_dashboard(self):
        """Atualiza todos os dados do dashboard"""
        try:
            # Atualizar m√©tricas gerais
            if hasattr(self, 'category_tree'):
                self.load_time_category_data()
            
            if hasattr(self, 'project_tree'):
                self.load_time_project_data()
            
            if hasattr(self, 'team_tree'):
                self.load_team_performance_data()
            
            if hasattr(self, 'predictions_tree'):
                self.load_ai_predictions()
            
            messagebox.showinfo("Sucesso", "Dashboard atualizado com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao atualizar dashboard:\n{e}")

    def refresh_team_performance(self):
        """Atualiza dados de performance da equipe"""
        self.load_team_performance_data()

    def refresh_time_analysis(self):
        """Atualiza an√°lise de tempo"""
        if hasattr(self, 'category_tree'):
            self.load_time_category_data()
        if hasattr(self, 'project_tree'):
            self.load_time_project_data()

    def refresh_burndown(self):
        """Atualiza gr√°fico de burndown"""
        # Recriar o gr√°fico
        pass

    def generate_ai_predictions(self):
        """Gera novas previs√µes de IA"""
        self.load_ai_predictions()
        messagebox.showinfo("Sucesso", "Previs√µes de IA geradas com sucesso!")

    def update_ai_model(self):
        """Atualiza o modelo de IA"""
        messagebox.showinfo("Info", "Modelo de IA atualizado com dados mais recentes!")

    def generate_team_report(self):
        """Gera relat√≥rio de performance da equipe"""
        try:
            # Simular gera√ß√£o de relat√≥rio
            report_content = "Relat√≥rio de Performance da Equipe\n"
            report_content += "=" * 40 + "\n\n"
            
            for member in self.members:
                completed, pending, avg_time, completion_rate = self.calculate_member_performance(member['Membro'])
                report_content += f"Membro: {member['Membro']}\n"
                report_content += f"Tarefas Conclu√≠das: {completed}\n"
                report_content += f"Tarefas Pendentes: {pending}\n"
                report_content += f"Taxa de Conclus√£o: {completion_rate:.1f}%\n"
                report_content += f"Tempo M√©dio: {avg_time:.1f}h\n\n"
            
            # Salvar relat√≥rio
            filename = f"relatorio_equipe_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            messagebox.showinfo("Sucesso", f"Relat√≥rio gerado com sucesso!\nArquivo: {filename}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar relat√≥rio:\n{e}")

    def export_dashboard_report(self):
        """Exporta relat√≥rio completo do dashboard"""
        try:
            # Gerar relat√≥rio completo
            report_content = "Dashboard Executivo - Relat√≥rio Completo\n"
            report_content += "=" * 50 + "\n\n"
            
            # M√©tricas gerais
            total_cards, completed_cards, pending_cards, overdue_cards = self.calculate_card_metrics()
            report_content += "M√âTRICAS GERAIS:\n"
            report_content += f"Total de Tarefas: {total_cards}\n"
            report_content += f"Conclu√≠das: {completed_cards}\n"
            report_content += f"Pendentes: {pending_cards}\n"
            report_content += f"Vencidas: {overdue_cards}\n"
            report_content += f"Taxa de Sucesso: {(completed_cards/total_cards*100):.1f}%\n\n"
            
            # Performance da equipe
            report_content += "PERFORMANCE DA EQUIPE:\n"
            for member in self.members:
                completed, pending, avg_time, completion_rate = self.calculate_member_performance(member['Membro'])
                report_content += f"{member['Membro']}: {completion_rate:.1f}% de conclus√£o\n"
            
            # Salvar relat√≥rio
            filename = f"dashboard_executivo_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            messagebox.showinfo("Sucesso", f"Relat√≥rio exportado com sucesso!\nArquivo: {filename}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar relat√≥rio:\n{e}")

    def generate_metrics_chart(self):
        """Gera gr√°fico detalhado das m√©tricas"""
        try:
            messagebox.showinfo("Gr√°fico", "Gr√°fico detalhado das m√©tricas gerado com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar gr√°fico: {e}")

    def export_time_analysis(self):
        """Exporta an√°lise de tempo"""
        try:
            messagebox.showinfo("Exportar", "An√°lise de tempo exportada com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar an√°lise: {e}")

    def generate_burndown_report(self):
        """Gera relat√≥rio de burndown"""
        try:
            messagebox.showinfo("Relat√≥rio", "Relat√≥rio de burndown gerado com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar relat√≥rio: {e}")

    def export_ai_predictions(self):
        """Exporta previs√µes de IA"""
        try:
            messagebox.showinfo("Exportar", "Previs√µes de IA exportadas com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar previs√µes: {e}")

    def create_boards_tab(self, parent):
        board_management_frame = ttk.Frame(parent)
        board_management_frame.pack(fill=tk.X, pady=5, padx=5)

        # Re-insert buttons for board management with icons
        ttk.Button(board_management_frame, text="Novo Quadro", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_board).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Renomear Quadro", image=self.icons.get('pencil_icon'), compound=tk.LEFT, command=self.rename_current_board).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Excluir Quadro", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.delete_current_board).pack(side=tk.LEFT, padx=5)
        ttk.Button(board_management_frame, text="Criar Reuni√£o", image=self.icons.get('reuniao_icon'), compound=tk.LEFT, command=self.open_meeting_window).pack(side=tk.LEFT, padx=5)

        # --- Filter Toggle Button ---
        self.filter_visible = tk.BooleanVar(value=False)
        # Use self.search_icon for the filter button
        self.toggle_filter_button = ttk.Button(board_management_frame, text="Mostrar Filtros", image=self.icons.get('search_icon'), compound=tk.LEFT, command=self.toggle_filter_visibility)
        self.toggle_filter_button.pack(side=tk.LEFT, padx=5)

        # --- Card Filtering UI (initially hidden) ---
        self.filter_container_frame = ttk.Frame(parent) # Container to hide/show
        # self.filter_container_frame.pack(fill=tk.X, pady=5, padx=5) # Don't pack initially

        filter_frame = ttk.LabelFrame(self.filter_container_frame, text="Filtrar Cart√µes", padding=10)
        filter_frame.pack(fill=tk.X, expand=True)

        filter_frame.columnconfigure(1, weight=1) # Make the entry/combobox columns expandable

        ttk.Label(filter_frame, text="Assunto:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.filter_subject_var = tk.StringVar()
        self.filter_subject_combo = ttk.Combobox(filter_frame, textvariable=self.filter_subject_var, state="readonly")
        self.filter_subject_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        self.filter_subject_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Objetivo:").grid(row=0, column=2, sticky="w", padx=5, pady=2)
        self.filter_goal_var = tk.StringVar()
        self.filter_goal_combo = ttk.Combobox(filter_frame, textvariable=self.filter_goal_var, state="readonly")
        self.filter_goal_combo.grid(row=0, column=3, sticky="ew", padx=5, pady=2)
        self.filter_goal_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Membro:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.filter_member_var = tk.StringVar()
        self.filter_member_combo = ttk.Combobox(filter_frame, textvariable=self.filter_member_var, state="readonly")
        self.filter_member_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        self.filter_member_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())
        self.filter_member_combo['values'] = ["Todos"] + sorted([member['Membro'] for member in self.members])

        ttk.Label(filter_frame, text="Prazo:").grid(row=1, column=2, sticky="w", padx=5, pady=2)
        self.filter_due_date_var = tk.StringVar()
        self.filter_due_date_options = ["Todos", "Hoje", "Pr√≥ximos 7 dias", "Vencidos"]
        self.filter_due_date_combo = ttk.Combobox(filter_frame, textvariable=self.filter_due_date_var, values=self.filter_due_date_options, state="readonly")
        self.filter_due_date_combo.grid(row=1, column=3, sticky="ew", padx=5, pady=2)
        # N√£o definir valor padr√£o - deixar vazio
        self.filter_due_date_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Import√¢ncia:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        self.filter_importance_var = tk.StringVar()
        self.filter_importance_combo = ttk.Combobox(filter_frame, textvariable=self.filter_importance_var, state="readonly")
        self.filter_importance_combo.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        self.filter_importance_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Recorr√™ncia:").grid(row=2, column=2, sticky="w", padx=5, pady=2)
        self.filter_recurrence_var = tk.StringVar()
        self.filter_recurrence_options = ["Todos", "Nenhuma", "Diariamente", "Semanalmente", "Mensalmente", "Anualmente"]
        self.filter_recurrence_combo = ttk.Combobox(filter_frame, textvariable=self.filter_recurrence_var, values=self.filter_recurrence_options, state="readonly")
        self.filter_recurrence_combo.grid(row=2, column=3, sticky="ew", padx=5, pady=2)
        # N√£o definir valor padr√£o - deixar vazio
        self.filter_recurrence_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_card_filter())

        ttk.Label(filter_frame, text="Palavra-chave:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.filter_keyword_var = tk.StringVar()
        self.filter_keyword_entry = ttk.Entry(filter_frame, textvariable=self.filter_keyword_var)
        self.filter_keyword_entry.grid(row=3, column=1, columnspan=3, sticky="ew", padx=5, pady=2)
        self.filter_keyword_entry.bind("<KeyRelease>", lambda e: self.apply_card_filter())

        filter_buttons_frame = ttk.Frame(filter_frame)
        filter_buttons_frame.grid(row=4, column=0, columnspan=4, sticky="e", padx=5, pady=2)

        # Filter management UI
        filter_management_frame = ttk.Frame(filter_frame)
        filter_management_frame.grid(row=5, column=0, columnspan=4, sticky="ew", padx=5, pady=2)
        filter_management_frame.columnconfigure(0, weight=1)

        self.saved_filters_combo = ttk.Combobox(filter_management_frame, state="readonly")
        self.saved_filters_combo.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        self.saved_filters_combo.bind("<<ComboboxSelected>>", self.load_filter)

        ttk.Button(filter_management_frame, text="Salvar Filtro", image=self.icons.get('save_icon'), compound=tk.LEFT, command=self.save_filter).grid(row=0, column=1, padx=2)
        ttk.Button(filter_management_frame, text="Excluir Filtro", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.delete_filter).grid(row=0, column=2, padx=2)

        ttk.Button(filter_buttons_frame, text="Limpar Filtros", image=self.icons.get('clear_icon'), compound=tk.LEFT, command=self.clear_card_filter).pack(side=tk.RIGHT, padx=2)
        ttk.Button(filter_buttons_frame, text="Aplicar Filtro", image=self.icons.get('apply_icon'), compound=tk.LEFT, command=self.apply_card_filter).pack(side=tk.RIGHT, padx=2)

        self.board_notebook = ttk.Notebook(parent)
        self.board_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Bind right-click to the notebook itself to identify the tab
        self.board_notebook.bind("<Button-3>", self.show_board_tab_context_menu)
        # Bind drag-and-drop for tabs
        self.board_notebook.bind("<ButtonPress-1>", self.on_tab_drag_start)
        self.board_notebook.bind("<B1-Motion>", self.on_tab_drag_motion)
        self.board_notebook.bind("<ButtonRelease-1>", self.on_tab_drag_release)

        self._drag_data = {"item": None, "x": 0, "y": 0, "tab_index": -1}

        # Card details frame (initially hidden)
        self.card_details_frame = ttk.Frame(parent, relief="solid", borderwidth=1)
        self.create_card_details_widgets()

        # Add a small legend for importance colors at the bottom of the boards tab
        self.legend_frame = ttk.Frame(parent)
        self.legend_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=5)
        self.update_legend()

    def create_card_details_widgets(self):
        """Cria os widgets para exibir detalhes do cart√£o selecionado"""
        # Basic info frame
        basic_frame = ttk.Frame(self.card_details_frame)
        basic_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Row 1: Title and Due Date
        title_frame = ttk.Frame(basic_frame)
        title_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(title_frame, text="T√≠tulo:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_title_label = ttk.Label(title_frame, text="", font=("Helvetica", 9))
        self.card_title_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(title_frame, text="Prazo:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_due_date_label = ttk.Label(title_frame, text="", font=("Helvetica", 9))
        self.card_due_date_label.pack(side=tk.LEFT)
        
        # Row 2: Members and Creation Date
        info_frame = ttk.Frame(basic_frame)
        info_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(info_frame, text="Membros:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_members_label = ttk.Label(info_frame, text="", font=("Helvetica", 9))
        self.card_members_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(info_frame, text="Criado em:", font=("Helvetica", 9, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_creation_date_label = ttk.Label(info_frame, text="", font=("Helvetica", 9))
        self.card_creation_date_label.pack(side=tk.LEFT)
        
        # Row 3: Buttons
        button_frame = ttk.Frame(basic_frame)
        button_frame.pack(fill=tk.X, pady=2)
        
        self.ver_mais_button = ttk.Button(button_frame, text="Ver Mais", 
                                         command=self.toggle_detailed_view)
        self.ver_mais_button.pack(side=tk.LEFT, padx=(0, 5))
        
        ttk.Button(button_frame, text="Editar", 
                  command=self.edit_selected_card).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(button_frame, text="Coment√°rios", 
                  command=self.open_card_comments).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(button_frame, text="Limpar", 
                  command=self.clear_card_selection).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(button_frame, text="Fechar", 
                  command=self.hide_card_details).pack(side=tk.RIGHT, padx=2)
        
        # Detailed info frame (initially hidden)
        self.detailed_frame = ttk.LabelFrame(self.card_details_frame, text="Informa√ß√µes Detalhadas", padding=5)
        
        # Subject and Importance
        detail_row1 = ttk.Frame(self.detailed_frame)
        detail_row1.pack(fill=tk.X, pady=2)
        
        ttk.Label(detail_row1, text="Assunto:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_subject_label = ttk.Label(detail_row1, text="", font=("Helvetica", 8))
        self.card_subject_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(detail_row1, text="Import√¢ncia:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_importance_label = ttk.Label(detail_row1, text="", font=("Helvetica", 8))
        self.card_importance_label.pack(side=tk.LEFT)
        
        # Goal and Recurrence
        detail_row2 = ttk.Frame(self.detailed_frame)
        detail_row2.pack(fill=tk.X, pady=2)
        
        ttk.Label(detail_row2, text="Objetivo:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(0, 5))
        self.card_goal_label = ttk.Label(detail_row2, text="", font=("Helvetica", 8))
        self.card_goal_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        ttk.Label(detail_row2, text="Recorr√™ncia:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=(20, 5))
        self.card_recurrence_label = ttk.Label(detail_row2, text="", font=("Helvetica", 8))
        self.card_recurrence_label.pack(side=tk.LEFT)
        
        # Description
        detail_row3 = ttk.Frame(self.detailed_frame)
        detail_row3.pack(fill=tk.X, pady=2)
        
        ttk.Label(detail_row3, text="Descri√ß√£o:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W, padx=(0, 5))
        
        # Advanced text editor for description
        desc_frame = ttk.Frame(self.detailed_frame)
        desc_frame.pack(fill=tk.X, pady=2)
        
        # Import advanced text editor
        try:
            from advanced_text_editor import AdvancedTextEditor
            self.card_description_editor = AdvancedTextEditor(desc_frame, height=8, width=50)
            self.card_description_editor.pack(fill=tk.BOTH, expand=True)
            self.card_description_text = self.card_description_editor.text_widget
        except ImportError:
            # Fallback to simple text widget if advanced editor is not available
            self.card_description_text = tk.Text(desc_frame, height=3, wrap=tk.WORD, font=("Helvetica", 8))
            desc_scrollbar = ttk.Scrollbar(desc_frame, orient="vertical", command=self.card_description_text.yview)
            self.card_description_text.configure(yscrollcommand=desc_scrollbar.set)
            
            self.card_description_text.pack(side=tk.LEFT, fill=tk.X, expand=True)
            desc_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Additional info frame
        info_frame = ttk.LabelFrame(self.detailed_frame, text="Informa√ß√µes Adicionais", padding=5)
        info_frame.pack(fill=tk.X, pady=2)
        
        # Subtasks
        subtasks_frame = ttk.Frame(info_frame)
        subtasks_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(subtasks_frame, text="Subtarefas:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W)
        self.card_subtasks_text = tk.Text(subtasks_frame, height=2, wrap=tk.WORD, font=("Helvetica", 8))
        self.card_subtasks_text.pack(fill=tk.X, expand=True)
        
        # Dependencies
        deps_frame = ttk.Frame(info_frame)
        deps_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(deps_frame, text="Depend√™ncias:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W)
        self.card_dependencies_text = tk.Text(deps_frame, height=2, wrap=tk.WORD, font=("Helvetica", 8))
        self.card_dependencies_text.pack(fill=tk.X, expand=True)
        
        # Git info
        git_frame = ttk.Frame(info_frame)
        git_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(git_frame, text="Git:", font=("Helvetica", 8, "bold")).pack(anchor=tk.W)
        self.card_git_text = tk.Text(git_frame, height=2, wrap=tk.WORD, font=("Helvetica", 8))
        self.card_git_text.pack(fill=tk.X, expand=True)

    def show_card_details(self, card_data):
        """Exibe os detalhes do cart√£o selecionado"""
        self.card_details_frame.pack(before=self.legend_frame, fill=tk.X, pady=2)
        
        # Update basic info
        self.card_title_label.config(text=card_data.get('title', ''))
        
        due_date = card_data.get('due_date', '')
        if due_date:
            try:
                due_date_obj = datetime.strptime(due_date, '%Y-%m-%d %H:%M')
                formatted_due_date = due_date_obj.strftime('%d/%m/%Y %H:%M')
            except ValueError:
                formatted_due_date = due_date
        else:
            formatted_due_date = 'N√£o definido'
        self.card_due_date_label.config(text=formatted_due_date)
        
        members = card_data.get('members', [])
        self.card_members_label.config(text=', '.join(members) if members else 'Nenhum')
        
        creation_date = card_data.get('creation_date', '')
        if creation_date:
            try:
                # Verificar se j√° √© um objeto datetime
                if isinstance(creation_date, datetime):
                    creation_date_obj = creation_date
                else:
                    creation_date_obj = datetime.strptime(creation_date, '%Y-%m-%d %H:%M:%S')
                formatted_creation_date = creation_date_obj.strftime('%d/%m/%Y %H:%M')
            except (ValueError, TypeError):
                formatted_creation_date = str(creation_date) if creation_date else 'N√£o dispon√≠vel'
        else:
            formatted_creation_date = 'N√£o dispon√≠vel'
        self.card_creation_date_label.config(text=formatted_creation_date)
        
        # Update additional info
        self.update_additional_info(card_data)
        
        # Store current card data
        self.current_card_data = card_data

    def hide_card_details(self):
        """Esconde o frame de detalhes do cart√£o"""
        self.card_details_frame.pack_forget()
        self.current_card_data = None

    def toggle_detailed_view(self):
        """Alterna a visibilidade da view detalhada"""
        if self.detailed_frame.winfo_ismapped():
            self.detailed_frame.pack_forget()
            self.ver_mais_button.config(text="Ver Mais")
        else:
            self.detailed_frame.pack(fill=tk.X, padx=5, pady=5)
            self.ver_mais_button.config(text="Ver Menos")

    def update_additional_info(self, card_data):
        """Atualiza as informa√ß√µes adicionais do cart√£o"""
        # Subject and Importance
        self.card_subject_label.config(text=card_data.get('subject', 'N√£o definido'))
        self.card_importance_label.config(text=card_data.get('importance', 'Normal'))
        
        # Goal and Recurrence
        self.card_goal_label.config(text=card_data.get('goal', 'N√£o definido'))
        self.card_recurrence_label.config(text=card_data.get('recurrence', 'Nenhuma'))
        
        # Description
        self.card_description_text.delete('1.0', tk.END)
        self.card_description_text.insert('1.0', card_data.get('desc', ''))
        
        # Subtasks
        self.card_subtasks_text.delete('1.0', tk.END)
        subtasks = card_data.get('subtasks', [])
        if subtasks:
            subtasks_text = '\n'.join([f"‚Ä¢ {subtask}" for subtask in subtasks])
            self.card_subtasks_text.insert('1.0', subtasks_text)
        
        # Dependencies
        self.card_dependencies_text.delete('1.0', tk.END)
        dependencies = card_data.get('dependencies', [])
        if dependencies:
            deps_text = '\n'.join([f"‚Ä¢ {dep}" for dep in dependencies])
            self.card_dependencies_text.insert('1.0', deps_text)
        
        # Git info
        self.card_git_text.delete('1.0', tk.END)
        git_info = card_data.get('git_info', {})
        if git_info:
            git_text = f"Branch: {git_info.get('branch', 'N/A')}\n"
            git_text += f"Status: {git_info.get('status', 'N/A')}"
            self.card_git_text.insert('1.0', git_text)

    def clear_card_selection(self):
        """Limpa a sele√ß√£o do cart√£o e esconde os detalhes"""
        # Clear selection in all treeviews
        for board_name in self.boodesk_data["boards"]:
            if board_name != "workflow":
                treeview = self.listbox_refs.get(board_name)
                if treeview:
                    treeview.selection_remove(treeview.selection())
        
        self.hide_card_details()

    def edit_selected_card(self):
        """Abre a janela de edi√ß√£o do cart√£o selecionado"""
        if hasattr(self, 'current_card_data') and self.current_card_data:
            # Find the card in the data structure
            card_id = self.current_card_data.get('card_id')
            if card_id:
                for board_name, board_data in self.boodesk_data["boards"].items():
                    for list_name, cards in board_data.items():
                        if list_name != "workflow":
                            for card in cards:
                                if card.get('card_id') == card_id:
                                    # Open card window for editing
                                    CardWindow(self.root, self, board_name, list_name, card, 
                                             lambda saved=False: self.update_card_details_if_visible())
                                    return
            
            messagebox.showwarning("Aviso", "Cart√£o n√£o encontrado para edi√ß√£o.")
    
    def open_card_comments(self):
        """Abre a janela de coment√°rios do cart√£o selecionado"""
        if hasattr(self, 'current_card_data') and self.current_card_data:
            card_id = self.current_card_data.get('card_id')
            card_title = self.current_card_data.get('title', 'Cart√£o')
            if card_id:
                self.chat_system.open_card_comments(card_id, card_title)
            else:
                messagebox.showwarning("Aviso", "Cart√£o n√£o encontrado para coment√°rios.")
        else:
            messagebox.showwarning("Aviso", "Nenhum cart√£o selecionado!")

    def update_card_details_if_visible(self):
        """Atualiza os detalhes do cart√£o se estiverem vis√≠veis"""
        if hasattr(self, 'current_card_data') and self.current_card_data:
            # Refresh the current card data
            card_id = self.current_card_data.get('card_id')
            if card_id:
                for board_name, board_data in self.boodesk_data["boards"].items():
                    for list_name, cards in board_data.items():
                        if list_name != "workflow":
                            for card in cards:
                                if card.get('card_id') == card_id:
                                    self.show_card_details(card)
                                    return

    def update_legend(self):
        for widget in self.legend_frame.winfo_children():
            widget.destroy()

        ttk.Label(self.legend_frame, text="Legenda Import√¢ncia:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=5)
        for imp, color in self.settings["importance_colors"].items():
            ttk.Label(self.legend_frame, text=imp, background=color, font=("Helvetica", 8)).pack(side=tk.LEFT, padx=2)

    # Fun√ß√£o create_calendar_tab removida - integra√ß√£o com Google Calendar desabilitada

    # Fun√ß√µes relacionadas ao calend√°rio removidas - integra√ß√£o com Google Calendar desabilitada
    
    def get_all_cards(self):
        all_cards = []
        for board_name, lists in self.boodesk_data["boards"].items():
            # Verificar se lists √© um dicion√°rio ou lista
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    for card in cards:
                        if not card.get("is_archived", False):
                            all_cards.append({
                                "board_name": board_name,
                                "list_name": list_name,
                                "card": card
                            })
        return all_cards

    def create_gantt_chart_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        self.gantt_canvas_frame = ttk.Frame(main_frame)
        self.gantt_canvas_frame.pack(fill=tk.BOTH, expand=True)

        self.update_gantt_chart()

    def update_gantt_chart(self):
        # Clear previous chart
        for widget in self.gantt_canvas_frame.winfo_children():
            widget.destroy()

        fig, ax = plt.subplots(figsize=(10, 6))

        tasks = []
        for board_name, lists in self.boodesk_data["boards"].items():
            # Verificar se lists √© um dicion√°rio ou lista
            if isinstance(lists, dict):
                for list_name, cards in lists.items():
                    for card in cards:
                        if not card.get("is_archived", False) and card.get("due_date"):
                            try:
                                # Corrigir tratamento da data de cria√ß√£o
                                creation_date = card.get("creation_date")
                                if isinstance(creation_date, str):
                                    start_date = datetime.strptime(creation_date.split(' ')[0], "%Y-%m-%d")
                                elif hasattr(creation_date, 'strftime'):
                                    start_date = creation_date
                                else:
                                    start_date = datetime.now()
                                end_date = datetime.strptime(card["due_date"].split(' ')[0], "%Y-%m-%d")
                                duration = (end_date - start_date).days
                                if duration < 0: # Handle cases where due date is before creation date
                                    duration = 0
                                tasks.append({
                                    "task": card["title"],
                                    "start": start_date,
                                    "end": end_date,
                                    "duration": duration,
                                    "list": list_name
                                })
                            except ValueError:
                                continue # Skip cards with invalid date formats

        if not tasks:
            ax.text(0.5, 0.5, "Nenhum cart√£o com prazo definido para exibir no Gr√°fico de Gantt.",
                    horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=12, color='gray')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            # Sort tasks by start date
            tasks.sort(key=lambda x: x["start"])

            # Create a mapping for task names to y-axis positions
            task_names = [task["task"] for task in tasks]
            y_pos = range(len(task_names))

            # Plot bars
            for i, task in enumerate(tasks):
                color = 'skyblue'
                if task["list"] == "Conclu√≠do":
                    color = 'lightgreen'
                elif task["end"].date() < datetime.now().date():
                    color = 'lightcoral' # Overdue
                
                ax.barh(i, task["duration"], left=task["start"], height=0.8, align='center', color=color)
                
                # Add task name and dates
                ax.text(task["start"], i, f" {task['task']}", va='center', ha='left', fontsize=8)
                ax.text(task["end"], i, f" {task['end'].strftime('%Y-%m-%d')}", va='center', ha='left', fontsize=8)


            ax.set_yticks(y_pos)
            ax.set_yticklabels(task_names, fontsize=8)
            ax.set_xlabel("Data")
            ax.set_title("Gr√°fico de Gantt dos Cart√µes")
            ax.grid(True, linestyle='--', alpha=0.7)
            fig.autofmt_xdate() # Rotate x-axis labels for better readability

        canvas = FigureCanvasTkAgg(fig, master=self.gantt_canvas_frame)
        canvas_widget = canvas.get_tk_widget()
        canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        canvas.draw()

    def create_chat_tab(self, parent):
        """Cria a aba principal de chat com interface melhorada"""
        main_frame = ttk.Frame(parent, padding="5")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Frame principal com layout horizontal
        content_frame = ttk.Frame(main_frame)
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        # ===== COLUNA ESQUERDA - NAVEGA√á√ÉO E CONTROLES =====
        left_panel = ttk.Frame(content_frame, width=300)
        left_panel.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 5))
        left_panel.pack_propagate(False)  # Manter largura fixa
        
        # T√≠tulo do painel esquerdo
        title_frame = ttk.Frame(left_panel)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text="Chat", image=self.icons.get('chat_icon'), 
                 compound=tk.LEFT, font=("Arial", 14, "bold")).pack(side=tk.LEFT)
        
        # Bot√£o de atualizar
        refresh_btn = ttk.Button(title_frame, image=self.icons.get('refresh_icon'), 
                                width=3, command=self.refresh_chat_data)
        refresh_btn.pack(side=tk.RIGHT)
        
        # Tooltip para o bot√£o de atualizar
        # self.create_tooltip(refresh_btn, "Atualizar dados do chat")
        
        # ===== ABAS DE NAVEGA√á√ÉO =====
        # Notebook para abas
        self.chat_notebook = ttk.Notebook(left_panel)
        self.chat_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Aba 1: Meus Chats
        self.create_my_chats_tab()
        
        # Aba 2: Quadros
        self.create_chat_boards_tab()
        
        # Aba 3: Usu√°rios
        self.create_chat_users_tab()
        
        # Aba 4: Notifica√ß√µes
        self.create_chat_notifications_tab()
        
        # ===== COLUNA DIREITA - √ÅREA DE CHAT =====
        right_panel = ttk.Frame(content_frame)
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        
        # Cabe√ßalho da √°rea de chat
        chat_header = ttk.Frame(right_panel)
        chat_header.pack(fill=tk.X, pady=(0, 5))
        
        self.chat_title_label = ttk.Label(chat_header, text="Selecione um chat para come√ßar", 
                                         font=("Arial", 12, "bold"))
        self.chat_title_label.pack(side=tk.LEFT)
        
        # Bot√µes de a√ß√£o do chat
        chat_actions_frame = ttk.Frame(chat_header)
        chat_actions_frame.pack(side=tk.RIGHT)
        
        self.search_btn = ttk.Button(chat_actions_frame, image=self.icons.get('search_icon'), 
                                    width=3, command=self.search_chat_messages)
        self.search_btn.pack(side=tk.LEFT, padx=(0, 5))
        # self.create_tooltip(self.search_btn, "Buscar mensagens no chat")
        
        self.participants_btn = ttk.Button(chat_actions_frame, image=self.icons.get('objects_icon'), 
                                          width=3, command=self.show_chat_participants)
        self.participants_btn.pack(side=tk.LEFT)
        self.create_tooltip(self.participants_btn, "Ver participantes do chat")
        
        # √Årea de mensagens
        messages_frame = ttk.Frame(right_panel)
        messages_frame.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbar para mensagens
        messages_scrollbar = ttk.Scrollbar(messages_frame)
        messages_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Text widget para mensagens
        self.messages_text = tk.Text(messages_frame, wrap=tk.WORD, state=tk.DISABLED,
                                    font=("Arial", 10), yscrollcommand=messages_scrollbar.set,
                                    bg="white", relief=tk.SUNKEN, borderwidth=1)
        self.messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        messages_scrollbar.config(command=self.messages_text.yview)
        
        # √Årea de entrada de mensagem
        input_frame = ttk.Frame(right_panel)
        input_frame.pack(fill=tk.X, pady=(5, 0))
        
        # Frame para entrada e bot√µes
        entry_frame = ttk.Frame(input_frame)
        entry_frame.pack(fill=tk.X)
        
        # Campo de entrada
        self.message_entry = ttk.Entry(entry_frame, font=("Arial", 10))
        self.message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
        self.message_entry.bind("<Return>", self.send_message_from_main)
        
        # Bot√£o de enviar
        send_btn = ttk.Button(entry_frame, text="Enviar", 
                             image=self.icons.get('forward_icon'), compound=tk.LEFT,
                             command=self.send_message_from_main)
        send_btn.pack(side=tk.RIGHT)
        self.create_tooltip(send_btn, "Enviar mensagem")
        
        # Carregar dados iniciais
        self.load_chat_data()
        
        # Configurar atualiza√ß√µes autom√°ticas
        self.schedule_chat_updates()
    
    def create_my_chats_tab(self):
        """Cria a aba 'Meus Chats'"""
        my_chats_frame = ttk.Frame(self.chat_notebook)
        self.chat_notebook.add(my_chats_frame, text="Meus Chats", 
                              image=self.icons.get('chat_icon'), compound=tk.LEFT)
        
        # Frame para lista de chats
        chats_container = ttk.Frame(my_chats_frame)
        chats_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Scrollbar para lista de chats
        chats_scrollbar = ttk.Scrollbar(chats_container)
        chats_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de chats
        self.chats_listbox = tk.Listbox(chats_container, yscrollcommand=chats_scrollbar.set,
                                       font=("Arial", 10), selectmode=tk.SINGLE,
                                       bg="white", relief=tk.SUNKEN, borderwidth=1)
        self.chats_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        chats_scrollbar.config(command=self.chats_listbox.yview)
        
        # Bind para sele√ß√£o de chat
        self.chats_listbox.bind("<Double-Button-1>", self.on_chat_selected)
        self.chats_listbox.bind("<ButtonRelease-1>", self.on_chat_selected)
        
        # Bot√µes de a√ß√£o
        buttons_frame = ttk.Frame(my_chats_frame)
        buttons_frame.pack(fill=tk.X, padx=5, pady=(0, 5))
        
        novo_chat_btn = ttk.Button(buttons_frame, text="Novo Chat Direto", 
                                  image=self.icons.get('add_icon'), compound=tk.LEFT,
                                  command=self.create_direct_chat)
        novo_chat_btn.pack(side=tk.LEFT)
        self.create_tooltip(novo_chat_btn, "Criar novo chat direto com usu√°rio")
        
        limpar_btn = ttk.Button(buttons_frame, text="Limpar Hist√≥rico", 
                               image=self.icons.get('clear_icon'), compound=tk.LEFT,
                               command=self.clear_chat_history)
        limpar_btn.pack(side=tk.RIGHT)
        self.create_tooltip(limpar_btn, "Limpar hist√≥rico do chat selecionado")
    
    def create_chat_boards_tab(self):
        """Cria a aba 'Quadros' no chat"""
        boards_frame = ttk.Frame(self.chat_notebook)
        self.chat_notebook.add(boards_frame, text="Quadros", 
                              image=self.icons.get('folder_icon'), compound=tk.LEFT)
        
        # Frame para lista de quadros
        boards_container = ttk.Frame(boards_frame)
        boards_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Scrollbar para lista de quadros
        boards_scrollbar = ttk.Scrollbar(boards_container)
        boards_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de quadros
        self.boards_listbox = tk.Listbox(boards_container, yscrollcommand=boards_scrollbar.set,
                                        font=("Arial", 10), selectmode=tk.SINGLE,
                                        bg="white", relief=tk.SUNKEN, borderwidth=1)
        self.boards_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        boards_scrollbar.config(command=self.boards_listbox.yview)
        
        # Bind para sele√ß√£o de quadro
        self.boards_listbox.bind("<Double-Button-1>", self.open_board_chat)
        
        # Bot√µes de a√ß√£o
        buttons_frame = ttk.Frame(boards_frame)
        buttons_frame.pack(fill=tk.X, padx=5, pady=(0, 5))
        
        abrir_chat_btn = ttk.Button(buttons_frame, text="Abrir Chat do Quadro", 
                                   image=self.icons.get('chat_icon'), compound=tk.LEFT,
                                   command=self.open_board_chat)
        abrir_chat_btn.pack(fill=tk.X)
        self.create_tooltip(abrir_chat_btn, "Abrir chat do quadro selecionado")
    
    def create_chat_users_tab(self):
        """Cria a aba 'Usu√°rios' no chat"""
        users_frame = ttk.Frame(self.chat_notebook)
        self.chat_notebook.add(users_frame, text="Usu√°rios", 
                              image=self.icons.get('objects_icon'), compound=tk.LEFT)
        
        # Frame para lista de usu√°rios
        users_container = ttk.Frame(users_frame)
        users_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Scrollbar para lista de usu√°rios
        users_scrollbar = ttk.Scrollbar(users_container)
        users_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de usu√°rios
        self.users_listbox = tk.Listbox(users_container, yscrollcommand=users_scrollbar.set,
                                       font=("Arial", 10), selectmode=tk.SINGLE,
                                       bg="white", relief=tk.SUNKEN, borderwidth=1)
        self.users_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        users_scrollbar.config(command=self.users_listbox.yview)
        
        # Bind para sele√ß√£o de usu√°rio
        self.users_listbox.bind("<Double-Button-1>", self.start_direct_chat)
        self.users_listbox.bind("<<ListboxSelect>>", self.on_user_selected)
        
        # Bot√µes de a√ß√£o
        buttons_frame = ttk.Frame(users_frame)
        buttons_frame.pack(fill=tk.X, padx=5, pady=(0, 5))
        
        iniciar_chat_btn = ttk.Button(buttons_frame, text="Iniciar Chat Direto", 
                                     image=self.icons.get('chat_icon'), compound=tk.LEFT,
                                     command=self.start_direct_chat)
        iniciar_chat_btn.pack(fill=tk.X)
        self.create_tooltip(iniciar_chat_btn, "Iniciar chat direto com usu√°rio selecionado")
    
    def create_chat_notifications_tab(self):
        """Cria a aba 'Notifica√ß√µes' no chat"""
        notifications_frame = ttk.Frame(self.chat_notebook)
        self.chat_notebook.add(notifications_frame, text="Notifica√ß√µes", 
                              image=self.icons.get('info_icon'), compound=tk.LEFT)
        
        # Label para status das notifica√ß√µes
        self.notifications_label = tk.Label(notifications_frame, text="Nenhuma notifica√ß√£o", 
                                           font=("Arial", 10), foreground="gray")
        self.notifications_label.pack(anchor="w", padx=5, pady=(5, 0))
        
        # Frame para lista de notifica√ß√µes
        notifications_container = ttk.Frame(notifications_frame)
        notifications_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Scrollbar para lista de notifica√ß√µes
        notifications_scrollbar = ttk.Scrollbar(notifications_container)
        notifications_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Lista de notifica√ß√µes
        self.notifications_listbox = tk.Listbox(notifications_container, 
                                               yscrollcommand=notifications_scrollbar.set,
                                               font=("Arial", 10), selectmode=tk.SINGLE,
                                               bg="white", relief=tk.SUNKEN, borderwidth=1)
        self.notifications_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        notifications_scrollbar.config(command=self.notifications_listbox.yview)
        
        # Bot√µes de a√ß√£o
        buttons_frame = ttk.Frame(notifications_frame)
        buttons_frame.pack(fill=tk.X, padx=5, pady=(0, 5))
        
        ver_todas_btn = ttk.Button(buttons_frame, text="Ver Todas", 
                                  image=self.icons.get('info_icon'), compound=tk.LEFT,
                                  command=self.show_all_notifications)
        ver_todas_btn.pack(side=tk.LEFT)
        self.create_tooltip(ver_todas_btn, "Ver todas as notifica√ß√µes")
        
        marcar_lidas_btn = ttk.Button(buttons_frame, text="Marcar como Lidas", 
                                     image=self.icons.get('ok_icon'), compound=tk.LEFT,
                                     command=self.mark_all_notifications_read)
        marcar_lidas_btn.pack(side=tk.RIGHT)
        self.create_tooltip(marcar_lidas_btn, "Marcar todas as notifica√ß√µes como lidas")
    
    def load_chat_data(self):
        """Carrega dados iniciais da aba de chat"""
        try:
            # Carregar lista de chats do usu√°rio
            self.refresh_chats_list()
            
            # Carregar lista de quadros
            self.load_boards_list()
            
            # Carregar lista de usu√°rios
            self.load_users_list()
            
            # Carregar notifica√ß√µes
            self.update_notifications()
        except Exception as e:
            print(f"Erro ao carregar dados do chat: {e}")

    def load_chat_in_main_interface(self, chat, title):
        """Carrega um chat na interface principal"""
        try:
            # Atualizar t√≠tulo
            self.chat_title_label.config(text=title)
            
            # Armazenar chat atual
            self.current_chat = chat
            self.current_chat_id = chat['id']
            
            # Limpar mensagens anteriores
            self.messages_text.config(state=tk.NORMAL)
            self.messages_text.delete(1.0, tk.END)
            self.messages_text.config(state=tk.DISABLED)
            
            # Carregar mensagens do chat
            messages = self.chat_system.get_chat_messages(chat['id'])
            self.display_messages(messages)
            
            # Marcar mensagens como lidas
            self.chat_system.mark_chat_as_read(chat['id'])
            
            # Focar no campo de entrada
            self.message_entry.focus()
            
        except Exception as e:
            print(f"Erro ao carregar chat na interface principal: {e}")
            messagebox.showerror("Erro", f"Erro ao carregar chat: {e}")

    def display_messages(self, messages):
        """Exibe mensagens na interface principal"""
        try:
            self.messages_text.config(state=tk.NORMAL)
            self.messages_text.delete(1.0, tk.END)  # Limpar mensagens anteriores
            
            # Ordenar mensagens por data (mais recentes primeiro para exibi√ß√£o)
            sorted_messages = sorted(messages, key=lambda x: x.get('created_at', ''), reverse=True)
            
            for message in sorted_messages:
                # Formatar mensagem
                sender_name = message.get('sender_name', 'Usu√°rio')
                timestamp = message.get('created_at', '')
                content = message.get('message', '')
                
                # Converter timestamp se necess√°rio
                if isinstance(timestamp, str):
                    try:
                        from datetime import datetime
                        timestamp = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                    except:
                        timestamp = timestamp
                
                if isinstance(timestamp, datetime):
                    timestamp_str = timestamp.strftime("%d/%m/%Y %H:%M")
                else:
                    timestamp_str = str(timestamp)
                
                # Inserir mensagem formatada
                message_text = f"[{timestamp_str}] {sender_name}: {content}\n\n"
                self.messages_text.insert(tk.END, message_text)
            
            # Rolar para o final
            self.messages_text.see(tk.END)
            self.messages_text.config(state=tk.DISABLED)
            
        except Exception as e:
            print(f"Erro ao exibir mensagens: {e}")

    def send_message_from_main(self, event=None):
        """Envia mensagem a partir da interface principal"""
        try:
            if not hasattr(self, 'current_chat_id') or not self.current_chat_id:
                messagebox.showwarning("Aviso", "Selecione um chat primeiro")
                return
            
            message = self.message_entry.get().strip()
            if not message:
                return
            
            # Enviar mensagem
            current_user_id = getattr(self.current_user, 'id', 1)
            success = self.chat_system.send_message(
                chat_id=self.current_chat_id,
                sender_id=current_user_id,
                message=message
            )
            
            if success:
                # Limpar campo de entrada
                self.message_entry.delete(0, tk.END)
                
                # Atualizar mensagens
                messages = self.chat_system.get_chat_messages(self.current_chat_id)
                self.display_messages(messages)
                
                # Marcar como lida
                self.chat_system.mark_chat_as_read(self.current_chat_id)
            else:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel enviar a mensagem")
                
        except Exception as e:
            print(f"Erro ao enviar mensagem: {e}")
            messagebox.showerror("Erro", f"Erro ao enviar mensagem: {e}")
            self.load_notifications_list()
            
        except Exception as e:
            print(f"Erro ao carregar dados do chat: {e}")
    
    def refresh_chat_data(self):
        """Atualiza todos os dados do chat"""
        try:
            self.refresh_chats_list()
            self.load_boards_list()
            self.load_users_list()
            self.update_notifications()
            self.load_notifications_list()
            print("‚úÖ Dados do chat atualizados")
        except Exception as e:
            print(f"Erro ao atualizar dados do chat: {e}")
    
    def load_notifications_list(self):
        """Carrega lista de notifica√ß√µes na aba de notifica√ß√µes"""
        try:
            if hasattr(self, 'notifications_listbox'):
                self.notifications_listbox.delete(0, tk.END)
                
                if hasattr(self, 'chat_system') and self.chat_system:
                    notifications = self.chat_system.get_unread_notifications()
                    
                    for notification in notifications:
                        notification_text = f"üì¢ {notification.get('sender_name', 'Sistema')}: {notification.get('message', 'Nova mensagem')}"
                        self.notifications_listbox.insert(tk.END, notification_text)
                        
        except Exception as e:
            print(f"Erro ao carregar notifica√ß√µes: {e}")
    

    
    def load_chat_messages(self):
        """Carrega mensagens do chat atual"""
        try:
            if not hasattr(self, 'current_chat_id') or not self.current_chat_id:
                return
            
            # Limpar √°rea de mensagens
            self.messages_text.config(state=tk.NORMAL)
            self.messages_text.delete(1.0, tk.END)
            
            # Buscar mensagens do chat
            if hasattr(self, 'chat_system') and self.chat_system:
                messages = self.chat_system.get_chat_messages(self.current_chat_id)
                
                for message in messages:
                    # Formatar mensagem
                    timestamp = message.get('created_at', '')
                    sender = message.get('sender_name', 'Desconhecido')
                    content = message.get('message', '')
                    
                    # Adicionar mensagem formatada
                    message_text = f"[{timestamp}] {sender}: {content}\n\n"
                    self.messages_text.insert(tk.END, message_text)
                
                # Rolar para o final
                self.messages_text.see(tk.END)
            
            self.messages_text.config(state=tk.DISABLED)
            
        except Exception as e:
            print(f"Erro ao carregar mensagens: {e}")
    
    def search_chat_messages(self):
        """Busca mensagens no chat atual"""
        try:
            if not hasattr(self, 'current_chat_id') or not self.current_chat_id:
                messagebox.showwarning("Aviso", "Selecione um chat primeiro.")
                return
            
            search_term = simpledialog.askstring("Buscar Mensagens", "Digite o termo de busca:")
            if not search_term:
                return
            
            # Buscar mensagens
            if hasattr(self, 'chat_system') and self.chat_system:
                results = self.chat_system.search_chat_history(self.current_chat_id, search_term)
                
                if results:
                    # Mostrar resultados em nova janela
                    self.show_search_results(results, search_term)
                else:
                    messagebox.showinfo("Busca", "Nenhuma mensagem encontrada.")
                    
        except Exception as e:
            print(f"Erro na busca: {e}")
    
    def show_search_results(self, results, search_term):
        """Mostra resultados da busca"""
        try:
            # Criar janela de resultados
            results_window = tk.Toplevel(self.root)
            results_window.title(f"Resultados da busca: '{search_term}'")
            results_window.geometry("600x400")
            
            # Frame principal
            main_frame = ttk.Frame(results_window, padding="10")
            main_frame.pack(fill=tk.BOTH, expand=True)
            
            # T√≠tulo
            ttk.Label(main_frame, text=f"Resultados para '{search_term}':", 
                     font=("Arial", 12, "bold")).pack(pady=(0, 10))
            
            # Lista de resultados
            results_frame = ttk.Frame(main_frame)
            results_frame.pack(fill=tk.BOTH, expand=True)
            
            # Scrollbar
            scrollbar = ttk.Scrollbar(results_frame)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # Listbox para resultados
            results_listbox = tk.Listbox(results_frame, yscrollcommand=scrollbar.set,
                                        font=("Arial", 10))
            results_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            scrollbar.config(command=results_listbox.yview)
            
            # Adicionar resultados
            for result in results:
                timestamp = result.get('created_at', '')
                sender = result.get('sender_name', 'Desconhecido')
                content = result.get('message', '')
                
                result_text = f"[{timestamp}] {sender}: {content}"
                results_listbox.insert(tk.END, result_text)
            
            # Bot√£o fechar
            ttk.Button(main_frame, text="Fechar", 
                      command=results_window.destroy).pack(pady=(10, 0))
            
        except Exception as e:
            print(f"Erro ao mostrar resultados: {e}")
    
    def show_chat_participants(self):
        """Mostra participantes do chat atual"""
        try:
            if not hasattr(self, 'current_chat_id') or not self.current_chat_id:
                messagebox.showwarning("Aviso", "Selecione um chat primeiro.")
                return
            
            # Buscar participantes
            if hasattr(self, 'chat_system') and self.chat_system:
                participants = self.chat_system.get_chat_participants(self.current_chat_id)
                
                if participants:
                    # Criar janela de participantes
                    participants_window = tk.Toplevel(self.root)
                    participants_window.title("Participantes do Chat")
                    participants_window.geometry("400x300")
                    
                    # Frame principal
                    main_frame = ttk.Frame(participants_window, padding="10")
                    main_frame.pack(fill=tk.BOTH, expand=True)
                    
                    # T√≠tulo
                    ttk.Label(main_frame, text="Participantes:", 
                             font=("Arial", 12, "bold")).pack(pady=(0, 10))
                    
                    # Lista de participantes
                    participants_frame = ttk.Frame(main_frame)
                    participants_frame.pack(fill=tk.BOTH, expand=True)
                    
                    # Scrollbar
                    scrollbar = ttk.Scrollbar(participants_frame)
                    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                    
                    # Listbox para participantes
                    participants_listbox = tk.Listbox(participants_frame, 
                                                     yscrollcommand=scrollbar.set,
                                                     font=("Arial", 10))
                    participants_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                    scrollbar.config(command=participants_listbox.yview)
                    
                    # Adicionar participantes
                    for participant in participants:
                        username = participant.get('username', 'Desconhecido')
                        role = participant.get('role', 'Usu√°rio')
                        is_admin = participant.get('is_admin', False)
                        
                        admin_icon = "üëë" if is_admin else ""
                        participant_text = f"{admin_icon} {username} ({role})"
                        participants_listbox.insert(tk.END, participant_text)
                    
                    # Bot√£o fechar
                    ttk.Button(main_frame, text="Fechar", 
                              command=participants_window.destroy).pack(pady=(10, 0))
                else:
                    messagebox.showinfo("Participantes", "Nenhum participante encontrado.")
                    
        except Exception as e:
            print(f"Erro ao mostrar participantes: {e}")
    
    def clear_chat_history(self):
        """Limpa hist√≥rico do chat selecionado"""
        try:
            if not hasattr(self, 'current_chat_id') or not self.current_chat_id:
                messagebox.showwarning("Aviso", "Selecione um chat primeiro.")
                return
            
            # Confirmar a√ß√£o
            confirm = messagebox.askyesno("Confirmar", 
                                        "Tem certeza que deseja limpar o hist√≥rico deste chat?")
            if not confirm:
                return
            
            # Limpar hist√≥rico (implementar no chat_system)
            if hasattr(self, 'chat_system') and self.chat_system:
                # TODO: Implementar m√©todo para limpar hist√≥rico
                messagebox.showinfo("Info", "Funcionalidade em desenvolvimento.")
            
        except Exception as e:
            print(f"Erro ao limpar hist√≥rico: {e}")
    
    def mark_all_notifications_read(self):
        """Marca todas as notifica√ß√µes como lidas"""
        try:
            if hasattr(self, 'chat_system') and self.chat_system:
                # TODO: Implementar m√©todo para marcar todas como lidas
                messagebox.showinfo("Info", "Funcionalidade em desenvolvimento.")
            
        except Exception as e:
            print(f"Erro ao marcar notifica√ß√µes: {e}")
    
    def schedule_chat_updates(self):
        """Agenda atualiza√ß√µes autom√°ticas do chat"""
        try:
            # Atualizar dados a cada 5 segundos
            self.root.after(5000, self.update_chat_interface)
        except Exception as e:
            print(f"Erro ao agendar atualiza√ß√µes: {e}")
    
    def update_chat_interface(self):
        """Atualiza interface do chat"""
        try:
            # Atualizar mensagens se houver chat ativo
            if hasattr(self, 'current_chat_id') and self.current_chat_id:
                self.load_chat_messages()
            
            # Atualizar notifica√ß√µes
            self.update_notifications()
            self.load_notifications_list()
            
            # Agendar pr√≥xima atualiza√ß√£o
            self.schedule_chat_updates()
            
        except Exception as e:
            print(f"Erro ao atualizar interface: {e}")
    
    def on_chat_selected(self, event):
        """Chamado quando um chat √© selecionado na lista"""
        try:
            selection = self.chats_listbox.curselection()
            if selection:
                index = selection[0]
                chats = self.chat_system.get_user_chats()
                
                if index < len(chats):
                    chat = chats[index]
                    # Carregar chat na interface principal
                    self.load_chat_in_main_interface(chat, f"üí¨ {chat['name']}")
                    
        except Exception as e:
            print(f"Erro ao selecionar chat: {e}")
    
    def refresh_chats_list(self):
        """Atualiza a lista de chats do usu√°rio"""
        try:
            self.chats_listbox.delete(0, tk.END)
            
            if hasattr(self, 'chat_system') and self.chat_system:
                chats = self.chat_system.get_user_chats()
                
                for chat in chats:
                    chat_name = chat['name']
                    chat_type = chat['chat_type']
                    
                    # Adicionar √≠cone baseado no tipo
                    if chat_type == 'board':
                        icon = "üè¢"
                    elif chat_type == 'card':
                        icon = "üìã"
                    elif chat_type == 'direct':
                        icon = "üí¨"
                    else:
                        icon = "üí¨"
                    
                    self.chats_listbox.insert(tk.END, f"{icon} {chat_name}")
                    
        except Exception as e:
            print(f"Erro ao atualizar lista de chats: {e}")
    
    def load_boards_list(self):
        """Carrega lista de quadros dispon√≠veis"""
        try:
            self.boards_listbox.delete(0, tk.END)
            
            if hasattr(self, 'boodesk_data') and 'boards' in self.boodesk_data:
                for board_name in self.boodesk_data['boards'].keys():
                    if board_name != "Vazio":
                        self.boards_listbox.insert(tk.END, board_name)
                        
        except Exception as e:
            print(f"Erro ao carregar lista de quadros: {e}")
    
    def load_users_list(self):
        """Carrega lista de usu√°rios"""
        try:
            self.users_listbox.delete(0, tk.END)
            
            if hasattr(self, 'db') and self.db:
                users = self.db.get_all_users()
                
                for user in users:
                    if user['id'] != getattr(self.current_user, 'id', None):
                        self.users_listbox.insert(tk.END, f"{user['username']} ({user['role']})")
                        
        except Exception as e:
            print(f"Erro ao carregar lista de usu√°rios: {e}")
    
    def update_notifications(self):
        """Atualiza notifica√ß√µes"""
        try:
            if hasattr(self, 'chat_system') and self.chat_system:
                unread_notifications = self.chat_system.get_unread_notifications()
                
                if unread_notifications:
                    count = len(unread_notifications)
                    self.notifications_label.config(
                        text=f"{count} notifica√ß√£o(s) n√£o lida(s)",
                        foreground="red"
                    )
                else:
                    self.notifications_label.config(
                        text="Nenhuma notifica√ß√£o",
                        foreground="gray"
                    )
                    
        except Exception as e:
            print(f"Erro ao atualizar notifica√ß√µes: {e}")
    
    def on_chat_selected(self, event):
        """Chamado quando um chat √© selecionado na lista"""
        try:
            selection = self.chats_listbox.curselection()
            if selection:
                index = selection[0]
                chats = self.chat_system.get_user_chats()
                
                if index < len(chats):
                    chat = chats[index]
                    self.open_chat_window(chat)
                    
        except Exception as e:
            print(f"Erro ao selecionar chat: {e}")
    
    def open_chat_window(self, chat):
        """Abre janela de chat"""
        try:
            chat_type = chat['chat_type']
            
            if chat_type == 'board':
                # Buscar nome do quadro
                board_name = "Quadro"
                if chat.get('board_id'):
                    boards = self.db.get_boards()
                    for board in boards:
                        if board['id'] == chat['board_id']:
                            board_name = board['name']
                            break
                
                self.chat_system.open_project_chat(board_name)
                
            elif chat_type == 'card':
                # Buscar t√≠tulo do cart√£o
                card_title = chat['name'].replace("Chat - ", "")
                card_id = chat.get('card_id', 0)
                
                self.chat_system.open_card_comments(card_id, card_title)
                
            elif chat_type == 'direct':
                # Extrair username do nome do chat
                username = chat['name'].replace("Chat com ", "")
                
                # Buscar user_id pelo username
                users = self.db.get_all_users()
                target_user_id = None
                
                for user in users:
                    if user['username'] == username:
                        target_user_id = user['id']
                        break
                
                if target_user_id:
                    self.chat_system.open_direct_chat(target_user_id, username)
                    
        except Exception as e:
            print(f"Erro ao abrir chat: {e}")
    
    def open_board_chat(self):
        """Abre chat de um quadro selecionado"""
        try:
            selection = self.boards_listbox.curselection()
            if selection:
                board_name = self.boards_listbox.get(selection[0])
                self.chat_system.open_project_chat(board_name)
            else:
                messagebox.showwarning("Aviso", "Selecione um quadro primeiro.")
                
        except Exception as e:
            print(f"Erro ao abrir chat do quadro: {e}")
    
    def start_direct_chat(self, event=None):
        """Inicia chat direto com usu√°rio selecionado"""
        try:
            selection = self.users_listbox.curselection()
            if selection:
                user_info = self.users_listbox.get(selection[0])
                username = user_info.split(" (")[0]  # Extrair username
                
                # Buscar user_id pelo username
                users = self.db.get_all_users()
                target_user_id = None
                
                for user in users:
                    if user['username'] == username:
                        target_user_id = user['id']
                        break
                
                if target_user_id:
                    self.chat_system.open_direct_chat(target_user_id, username)
                else:
                    messagebox.showerror("Erro", "Usu√°rio n√£o encontrado.")
            else:
                messagebox.showwarning("Aviso", "Selecione um usu√°rio primeiro.")
                
        except Exception as e:
            print(f"Erro ao iniciar chat direto: {e}")

    def on_user_selected(self, event=None):
        """Chamado quando um usu√°rio √© selecionado na lista"""
        try:
            selection = self.users_listbox.curselection()
            if selection:
                user_info = self.users_listbox.get(selection[0])
                username = user_info.split(" (")[0]  # Extrair username
                
                # Buscar user_id pelo username
                users = self.db.get_all_users()
                target_user_id = None
                
                for user in users:
                    if user['username'] == username:
                        target_user_id = user['id']
                        break
                
                if target_user_id:
                    # Criar ou obter chat direto
                    direct_chat = self.chat_system.get_or_create_direct_chat(target_user_id)
                    if direct_chat:
                        self.load_chat_in_main_interface(direct_chat, f"Chat com {username}")
                    else:
                        messagebox.showerror("Erro", "N√£o foi poss√≠vel criar o chat direto.")
                else:
                    messagebox.showerror("Erro", "Usu√°rio n√£o encontrado.")
                    
        except Exception as e:
            print(f"Erro ao selecionar usu√°rio: {e}")
    
    def create_direct_chat(self):
        """Cria novo chat direto"""
        try:
            # Mostrar di√°logo para selecionar usu√°rio
            users = self.db.get_all_users()
            user_names = [f"{user['username']} ({user['role']})" for user in users 
                         if user['id'] != getattr(self.current_user, 'id', None)]
            
            if user_names:
                selected_user = simpledialog.askstring(
                    "Novo Chat Direto",
                    "Digite o nome do usu√°rio para iniciar um chat:"
                )
                
                if selected_user:
                    # Extrair username
                    username = selected_user.split(" (")[0]
                    
                    # Buscar user_id
                    target_user_id = None
                    for user in users:
                        if user['username'] == username:
                            target_user_id = user['id']
                            break
                    
                    if target_user_id:
                        self.chat_system.open_direct_chat(target_user_id, username)
                    else:
                        messagebox.showerror("Erro", "Usu√°rio n√£o encontrado.")
            else:
                messagebox.showinfo("Info", "N√£o h√° outros usu√°rios dispon√≠veis.")
                
        except Exception as e:
            print(f"Erro ao criar chat direto: {e}")
    
    def show_all_notifications(self):
        """Mostra todas as notifica√ß√µes"""
        try:
            if hasattr(self, 'chat_system') and self.chat_system:
                unread_notifications = self.chat_system.get_unread_notifications()
                
                if unread_notifications:
                    notification_text = "Notifica√ß√µes n√£o lidas:\n\n"
                    for notification in unread_notifications:
                        notification_text += f"‚Ä¢ {notification['sender_name']}: {notification['chat_name']}\n"
                    
                    messagebox.showinfo("Notifica√ß√µes", notification_text)
                else:
                    messagebox.showinfo("Notifica√ß√µes", "Nenhuma notifica√ß√£o n√£o lida.")
                    
        except Exception as e:
            print(f"Erro ao mostrar notifica√ß√µes: {e}")
    
    def get_unread_notifications(self):
        """Retorna notifica√ß√µes n√£o lidas (m√©todo de compatibilidade)"""
        try:
            if hasattr(self, 'chat_system') and self.chat_system:
                return self.chat_system.get_unread_notifications()
            return []
        except Exception as e:
            print(f"Erro ao obter notifica√ß√µes: {e}")
            return []

    def check_deadlines(self):
        overdue_cards = []
        due_soon_cards = []
        today = datetime.now().date()
        tomorrow = today + timedelta(days=1)

        all_cards = self.get_all_cards()
        for card_info in all_cards:
            card = card_info['card']
            if card.get("due_date"):
                try:
                    due_date = datetime.strptime(card["due_date"].split(" ")[0], "%Y-%m-%d").date()
                    if due_date < today:
                        overdue_cards.append(card['title'])
                    elif due_date == today or due_date == tomorrow:
                        due_soon_cards.append(card['title'])
                except (ValueError, TypeError):
                    continue

        notification_message = ""
        if overdue_cards:
            notification_message += "Cart√µes Vencidos:\n" + "\n".join(f"- {title}" for title in overdue_cards) + "\n\n"
        
        if due_soon_cards:
            notification_message += "Cart√µes Vencendo Hoje ou Amanh√£:\n" + "\n".join(f"- {title}" for title in due_soon_cards)

        if notification_message:
            messagebox.showwarning("Notifica√ß√£o de Prazos", notification_message, parent=self.root)
    
    def show_deadline_notifications(self):
        """Mostra notifica√ß√µes de prazos ap√≥s o login"""
        print("DEBUG: Verificando notifica√ß√µes de prazos...")
        self.check_deadlines()

    def on_card_select_treeview(self, board_name, list_name, event):
        treeview = event.widget
        selected_item_id = treeview.focus() # Get the ID of the selected item

        if not selected_item_id:
            return

        # Get the card_id from the tags of the selected item
        card_id = treeview.item(selected_item_id, "tags")[0]
        
        # Find the actual card object using its card_id
        selected_card = None
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card.get('card_id') == card_id:
                selected_card = card
                break
        
        if not selected_card:
            return

        # Clear any previously expanded details for this treeview
        for child in treeview.get_children(selected_item_id): # Only clear children of the selected item
            treeview.delete(child)

        if self.settings.get('show_card_details_on_board', False):
            # If details are already expanded, collapse them
            if treeview.item(selected_item_id, 'open'):
                treeview.item(selected_item_id, open=False)
            else:
                # Expand details
                treeview.item(selected_item_id, open=True)

                # Add description
                desc = selected_card.get('desc', 'Sem descri√ß√£o')
                treeview.insert(selected_item_id, "end", text="", values=("Descri√ß√£o:", desc, "", ""), tags=("detail_row",))

                # Add members
                members = ", ".join(selected_card.get('members', []))
                if not members: members = "Nenhum membro atribu√≠do"
                treeview.insert(selected_item_id, "end", text="", values=("Membros:", members, "", ""), tags=("detail_row",))

                # Add creation date
                creation_date = selected_card.get('creation_date', 'N/A')
                treeview.insert(selected_item_id, "end", text="", values=("Cria√ß√£o:", creation_date, "", ""), tags=("detail_row",))

                # Add subtasks
                subtasks = selected_card.get('subtasks', [])
                if subtasks:
                    subtask_summary = f"{sum(1 for s in subtasks if s['completed'])}/{len(subtasks)} subtarefas conclu√≠das"
                    treeview.insert(selected_item_id, "end", text="", values=("Subtarefas:", subtask_summary, "", ""), tags=("detail_row",))
                    for subtask in subtasks:
                        status = "[X]" if subtask['completed'] else "[ ]"
                        treeview.insert(selected_item_id, "end", text="", values=("", f"{status} {subtask['text']}", "", ""), tags=("subtask_row",))
                else:
                    treeview.insert(selected_item_id, "end", text="", values=("Subtarefas:", "Nenhuma subtarefa", "", ""), tags=("detail_row",))

                # Add dependencies
                dependencies = selected_card.get('dependencies', [])
                if dependencies:
                    dep_status = self.get_card_dependency_status(selected_card)
                    dep_summary = f"{dep_status['completed']}/{dep_status['total']} depend√™ncias conclu√≠das"
                    treeview.insert(selected_item_id, "end", text="", values=("Depend√™ncias:", dep_summary, "", ""), tags=("detail_row",))
                    for dep in dependencies:
                        is_completed = self._is_card_completed(dep)
                        status = "[X]" if is_completed else "[ ]"
                        treeview.insert(selected_item_id, "end", text="", values=("", f"{status} {dep}", "", ""), tags=("dependency_row",))
                else:
                    treeview.insert(selected_item_id, "end", text="", values=("Depend√™ncias:", "Nenhuma depend√™ncia", "", ""), tags=("detail_row",))

                # Add History
                history = selected_card.get('history', [])
                print(f"DEBUG: History for card {selected_card.get('title')}: {history}")
                if history:
                    treeview.insert(selected_item_id, "end", text="", values=("Hist√≥rico:", "", "", ""), tags=("detail_row",))
                    for entry in history:
                        timestamp = entry.get('timestamp', 'N/A')
                        action = entry.get('action', 'A√ß√£o desconhecida')
                        user = entry.get('user', 'Sistema')
                        treeview.insert(selected_item_id, "end", text="", values=("", f"{timestamp} - {action} (por {user})", "", ""), tags=("history_row",))
                else:
                    treeview.insert(selected_item_id, "end", text="", values=("Hist√≥rico:", "Nenhum hist√≥rico de atividade", "", ""), tags=("detail_row",))

        # Apply styling for detail rows
        treeview.tag_configure("detail_row", background="#e0e0e0", foreground="#333333")
        treeview.tag_configure("subtask_row", background="#f0f0f0", foreground="#555555")
        treeview.tag_configure("dependency_row", background="#f0f0f0", foreground="#555555")
        treeview.tag_configure("history_row", background="#f0f0f0", foreground="#555555")

        treeview.bind("<Double-1>", lambda event, c=selected_card: self.on_detail_treeview_double_click(event, c))

    def on_detail_treeview_double_click(self, event, card):
        treeview = event.widget
        item_id = treeview.identify_row(event.y)
        if not item_id:
            return

        # A simple way to check if it's a subtask row
        if treeview.item(item_id, "tags")[0] == "subtask_row":
            # This is tricky because we don't have the subtask ID here directly.
            # We'll have to find it by its text, which is not ideal but works for now.
            subtask_text_with_status = treeview.item(item_id, "values")[1]
            subtask_text = subtask_text_with_status.split("] ", 1)[1]
            
            subtask_to_edit = None
            for subtask in card.get("subtasks", []):
                if subtask["text"] == subtask_text:
                    subtask_to_edit = subtask
                    break
            
            if subtask_to_edit:
                SubtaskEditorWindow(self.root, self, card, subtask_to_edit)

    def on_tab_drag_start(self, event):
        try:
            tab_index = self.board_notebook.index(f"@{event.x},{event.y}")
            if tab_index != "": # Check if a tab was actually clicked
                self._drag_data["item"] = self.board_notebook.tabs()[tab_index]
                self._drag_data["x"] = event.x
                self._drag_data["y"] = event.y
                self._drag_data["tab_index"] = tab_index
        except tk.TclError:
            pass # No tab clicked

    def on_tab_drag_motion(self, event):
        if self._drag_data["item"]:
            # This part is for visual feedback, not actual reordering yet
            # For a simple visual, we don't need complex logic here
            pass

    def on_tab_drag_release(self, event):
        if self._drag_data["item"]:
            try:
                # Get the new tab index where the mouse was released
                new_tab_index = self.board_notebook.index(f"@{event.x},{event.y}")
                if new_tab_index == "": # Dropped outside a tab, or on empty space
                    new_tab_index = len(self.board_notebook.tabs()) -1 # Move to end
                
                old_tab_index = self._drag_data["tab_index"]

                if old_tab_index != new_tab_index:
                    # Get the actual board name from the old position
                    board_name_to_move = self.board_notebook.tab(old_tab_index, "text")
                    
                    # Reorder the internal data model (self.boodesk_data["boards"])
                    # Convert dict to ordered list of (name, data) pairs
                    ordered_boards = list(self.boodesk_data["boards"].items())
                    
                    # Find and remove the board to move
                    board_data_to_move = None
                    for i, (name, data) in enumerate(ordered_boards):
                        if name == board_name_to_move:
                            board_data_to_move = ordered_boards.pop(i)
                            break
                    
                    if board_data_to_move:
                        # Insert the board at the new position
                        ordered_boards.insert(new_tab_index, board_data_to_move)
                        
                        # Reconstruct the boards dictionary to maintain order
                        self.boodesk_data["boards"] = {name: data for name, data in ordered_boards}
                        self.save_trello_data()
                        self.populate_boards() # Refresh UI
                        self.board_notebook.select(new_tab_index) # Select the moved tab

            except tk.TclError:
                pass # Invalid drop target
            finally:
                self._drag_data = {"item": None, "x": 0, "y": 0, "tab_index": -1}

    def rename_current_board(self):
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado para renomear.", parent=self.root)
                return
            old_name = self.board_notebook.tab(current_tab_index, "text")
            if old_name == "Vazio": # Cannot rename empty tab
                messagebox.showwarning("Aviso", "N√£o √© poss√≠vel renomear o quadro vazio.", parent=self.root)
                return
            self.rename_board(old_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado para renomear.", parent=self.root)

    def delete_current_board(self):
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado para excluir.", parent=self.root)
                return
            board_name = self.board_notebook.tab(current_tab_index, "text")
            if board_name == "Vazio": # Cannot delete empty tab
                messagebox.showwarning("Aviso", "N√£o √© poss√≠vel excluir o quadro vazio.", parent=self.root)
                return
            self.delete_board(board_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado para excluir.", parent=self.root)
    
    def open_project_chat(self):
        """Abre o chat do projeto atual (seleciona a aba de chat no quadro)"""
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)
                return
            board_name = self.board_notebook.tab(current_tab_index, "text")
            if board_name == "Vazio": # Cannot chat empty tab
                messagebox.showwarning("Aviso", "N√£o √© poss√≠vel abrir chat para o quadro vazio.", parent=self.root)
                return
            
            # Selecionar a aba de chat no quadro atual
            board_frame = self.board_notebook.select()
            board_widget = self.board_notebook.nametowidget(board_frame)
            
            # Encontrar o notebook interno e selecionar a aba de chat
            for child in board_widget.winfo_children():
                if isinstance(child, ttk.Notebook):
                    child.select(1)  # Selecionar a segunda aba (Chat)
                    break
                    
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)
    
    def open_meeting_window(self):
        """Abre a janela de cria√ß√£o de reuni√µes"""
        try:
            current_tab_index = self.board_notebook.index(self.board_notebook.select())
            if current_tab_index == "": # No tab selected
                messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)
                return
            board_name = self.board_notebook.tab(current_tab_index, "text")
            if board_name == "Vazio": # Cannot create meeting for empty tab
                messagebox.showwarning("Aviso", "N√£o √© poss√≠vel criar reuni√£o para o quadro vazio.", parent=self.root)
                return
            MeetingWindow(self.root, self, board_name)
        except tk.TclError:
            messagebox.showwarning("Aviso", "Nenhum quadro selecionado!", parent=self.root)

    def show_board_tab_context_menu(self, event):
        try:
            tab_id = self.board_notebook.identify(event.x, event.y)
            if tab_id and tab_id != "":
                tab_name = self.board_notebook.tab(tab_id, "text")
                if tab_name == "Vazio":
                    return

                board_context_menu = tk.Menu(self.root, tearoff=0)
                board_context_menu.add_command(label=f"Renomear Quadro: {tab_name}", image=self.icons.get('pencil_icon'), compound=tk.LEFT, command=partial(self.rename_board, tab_name))
                board_context_menu.add_command(label=f"Excluir Quadro: {tab_name}", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=partial(self.delete_board, tab_name))
                board_context_menu.post(event.x_root, event.y_root)
        except tk.TclError:
            pass

    def create_productivity_sub_tabs(self, parent):
        self.productivity_notebook = ttk.Notebook(parent)
        self.productivity_notebook.pack(fill=tk.BOTH, expand=True)

        pomodoro_timer_frame = ttk.Frame(self.productivity_notebook)
        my_activities_frame = ttk.Frame(self.productivity_notebook)
        my_subtasks_frame = ttk.Frame(self.productivity_notebook)

        # Adicionar abas com √≠cones (ordem alterada)
        if hasattr(self, 'icons') and self.icons.get('minhas_atividades_icon'):
            self.productivity_notebook.add(my_activities_frame, text='Minhas Atividades', image=self.icons['minhas_atividades_icon'], compound=tk.LEFT)
        else:
            self.productivity_notebook.add(my_activities_frame, text='Minhas Atividades')
            
        if hasattr(self, 'icons') and self.icons.get('pomodoro_icon'):
            self.productivity_notebook.add(pomodoro_timer_frame, text='Timer Pomodoro', image=self.icons['pomodoro_icon'], compound=tk.LEFT)
        else:
            self.productivity_notebook.add(pomodoro_timer_frame, text='Timer Pomodoro')
        
        # Nova aba para subtarefas delegadas
        if hasattr(self, 'icons') and self.icons.get('subtask_icon'):
            self.productivity_notebook.add(my_subtasks_frame, text='Minhas Subtarefas', image=self.icons['subtask_icon'], compound=tk.LEFT)
        else:
            self.productivity_notebook.add(my_subtasks_frame, text='Minhas Subtarefas')

        # Create a new notebook for the Pomodoro Timer and History
        pomodoro_notebook = ttk.Notebook(pomodoro_timer_frame)
        pomodoro_notebook.pack(fill=tk.BOTH, expand=True)

        timer_tab_frame = ttk.Frame(pomodoro_notebook)
        history_tab_frame = ttk.Frame(pomodoro_notebook)

        pomodoro_notebook.add(timer_tab_frame, text='Timer')
        pomodoro_notebook.add(history_tab_frame, text='Hist√≥rico')

        self.create_pomodoro_timer_tab(timer_tab_frame)
        self.create_my_activities_tab(my_activities_frame)
        self.create_my_subtasks_tab(my_subtasks_frame)
        self.create_history_tab(history_tab_frame)
    
    def create_my_subtasks_tab(self, parent):
        """Cria aba para mostrar subtarefas delegadas ao usu√°rio"""
        # Frame principal
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(title_frame, text="üìã Minhas Subtarefas Delegadas", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        # Bot√µes de a√ß√£o
        btn_frame = ttk.Frame(title_frame)
        btn_frame.pack(side=tk.RIGHT)
        
        ttk.Button(btn_frame, text="üîÑ Atualizar", 
                  command=self.refresh_my_subtasks).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(btn_frame, text="üìä Relat√≥rio", 
                  command=self.show_subtasks_report).pack(side=tk.LEFT, padx=5)
        
        # Frame para filtros
        filters_frame = ttk.LabelFrame(main_frame, text="Filtros", padding="10")
        filters_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Filtro por status
        ttk.Label(filters_frame, text="Status:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.subtask_status_filter = ttk.Combobox(filters_frame, 
                                                values=["Todas", "Pendentes", "Em Progresso", "Conclu√≠das"],
                                                state="readonly", width=15)
        self.subtask_status_filter.set("Todas")
        self.subtask_status_filter.grid(row=0, column=1, sticky="w", padx=5, pady=2)
        self.subtask_status_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_my_subtasks())
        
        # Filtro por prioridade
        ttk.Label(filters_frame, text="Prioridade:").grid(row=0, column=2, sticky="w", padx=5, pady=2)
        self.subtask_priority_filter = ttk.Combobox(filters_frame, 
                                                  values=["Todas", "Baixa", "Normal", "Alta", "Cr√≠tica"],
                                                  state="readonly", width=15)
        self.subtask_priority_filter.set("Todas")
        self.subtask_priority_filter.grid(row=0, column=3, sticky="w", padx=5, pady=2)
        self.subtask_priority_filter.bind("<<ComboboxSelected>>", lambda e: self.filter_my_subtasks())
        
        # Treeview para subtarefas
        tree_frame = ttk.Frame(main_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbars
        tree_scrollbar_y = ttk.Scrollbar(tree_frame)
        tree_scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        
        tree_scrollbar_x = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL)
        tree_scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Treeview
        columns = ("ID", "T√≠tulo", "Card Pai", "Status", "Prioridade", "Data Cria√ß√£o", "Respons√°vel")
        self.my_subtasks_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", 
                                           yscrollcommand=tree_scrollbar_y.set,
                                           xscrollcommand=tree_scrollbar_x.set)
        
        # Configurar colunas
        self.my_subtasks_tree.heading("ID", text="ID")
        self.my_subtasks_tree.heading("T√≠tulo", text="T√≠tulo da Subtarefa")
        self.my_subtasks_tree.heading("Card Pai", text="Card Pai")
        self.my_subtasks_tree.heading("Status", text="Status")
        self.my_subtasks_tree.heading("Prioridade", text="Prioridade")
        self.my_subtasks_tree.heading("Data Cria√ß√£o", text="Data Cria√ß√£o")
        self.my_subtasks_tree.heading("Respons√°vel", text="Respons√°vel")
        
        self.my_subtasks_tree.column("ID", width=80, anchor="center")
        self.my_subtasks_tree.column("T√≠tulo", width=200, anchor="w")
        self.my_subtasks_tree.column("Card Pai", width=150, anchor="w")
        self.my_subtasks_tree.column("Status", width=100, anchor="center")
        self.my_subtasks_tree.column("Prioridade", width=100, anchor="center")
        self.my_subtasks_tree.column("Data Cria√ß√£o", width=120, anchor="center")
        self.my_subtasks_tree.column("Respons√°vel", width=120, anchor="w")
        
        self.my_subtasks_tree.pack(fill=tk.BOTH, expand=True)
        
        # Configurar scrollbars
        tree_scrollbar_y.config(command=self.my_subtasks_tree.yview)
        tree_scrollbar_x.config(command=self.my_subtasks_tree.xview)
        
        # Bind eventos
        self.my_subtasks_tree.bind("<Double-1>", self.open_subtask_from_tree)
        self.my_subtasks_tree.bind("<Delete>", lambda e: self.delete_subtask_from_tree())
        
        # Frame para estat√≠sticas
        stats_frame = ttk.LabelFrame(main_frame, text="Estat√≠sticas", padding="10")
        stats_frame.pack(fill=tk.X, pady=(10, 0))
        
        # Estat√≠sticas
        self.subtask_total_label = ttk.Label(stats_frame, text="Total: 0", font=("Arial", 12, "bold"))
        self.subtask_total_label.pack(side=tk.LEFT, padx=10)
        
        self.subtask_pending_label = ttk.Label(stats_frame, text="Pendentes: 0", font=("Arial", 10))
        self.subtask_pending_label.pack(side=tk.LEFT, padx=10)
        
        self.subtask_in_progress_label = ttk.Label(stats_frame, text="Em Progresso: 0", font=("Arial", 10))
        self.subtask_in_progress_label.pack(side=tk.LEFT, padx=10)
        
        self.subtask_completed_label = ttk.Label(stats_frame, text="Conclu√≠das: 0", font=("Arial", 10))
        self.subtask_completed_label.pack(side=tk.LEFT, padx=10)
        
        # Carregar dados iniciais
        self.load_my_subtasks()
    
    def create_integrated_chat(self, parent_frame, board_name):
        """Cria chat integrado dentro do quadro"""
        try:
            # Frame principal do chat
            chat_main_frame = ttk.Frame(parent_frame)
            chat_main_frame.pack(fill=tk.BOTH, expand=True)
            
            # T√≠tulo do chat
            title_frame = ttk.Frame(chat_main_frame)
            title_frame.pack(fill=tk.X, pady=(0, 10))
            
            ttk.Label(title_frame, text=f"Chat - {board_name}", 
                     font=("Arial", 12, "bold")).pack(side=tk.LEFT)
            
            # Bot√µes de a√ß√£o
            ttk.Button(title_frame, text="Buscar", image=self.icons.get('search_icon'), compound=tk.LEFT,
                      command=lambda: self.open_chat_search(board_name)).pack(side=tk.RIGHT, padx=5)
            ttk.Button(title_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT,
                      command=lambda: self.refresh_integrated_chat(board_name)).pack(side=tk.RIGHT, padx=5)
            
            # Frame para mensagens
            messages_frame = ttk.LabelFrame(chat_main_frame, text="Mensagens", padding="10")
            messages_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
            
            # Text widget para mensagens
            messages_text = tk.Text(messages_frame, wrap=tk.WORD, state=tk.DISABLED, height=15)
            messages_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Scrollbar
            scrollbar = ttk.Scrollbar(messages_frame, orient="vertical", command=messages_text.yview)
            messages_text.configure(yscrollcommand=scrollbar.set)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # Frame para entrada de mensagem
            input_frame = ttk.Frame(chat_main_frame)
            input_frame.pack(fill=tk.X)
            
            # Campo de entrada
            message_var = tk.StringVar()
            message_entry = ttk.Entry(input_frame, textvariable=message_var, font=("Arial", 10))
            message_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
            message_entry.bind("<Return>", lambda e: self.send_integrated_chat_message(board_name, message_var, message_entry))
            
            # Contador de caracteres
            char_count_label = ttk.Label(input_frame, text="0/1000", font=("Arial", 8), foreground="gray")
            char_count_label.pack(side=tk.LEFT, padx=(0, 10))
            
            # Bot√£o enviar
            ttk.Button(input_frame, text="Enviar", image=self.icons.get('forward_icon'), compound=tk.LEFT,
                      command=lambda: self.send_integrated_chat_message(board_name, message_var, message_entry)).pack(side=tk.RIGHT)
            
            # Configurar tags para formata√ß√£o
            messages_text.tag_config("timestamp", foreground="gray")
            messages_text.tag_config("username", foreground="blue", font=("Arial", 10, "bold"))
            messages_text.tag_config("message", font=("Arial", 10))
            
            # Armazenar refer√™ncias para uso posterior
            chat_widgets = {
                'messages_text': messages_text,
                'message_var': message_var,
                'message_entry': message_entry,
                'char_count_label': char_count_label
            }
            
            # Armazenar widgets do chat para este quadro
            if not hasattr(self, 'integrated_chat_widgets'):
                self.integrated_chat_widgets = {}
            self.integrated_chat_widgets[board_name] = chat_widgets
            
            # Bind para contador de caracteres
            message_entry.bind("<KeyRelease>", lambda e: self.update_integrated_char_count(board_name))
            
            # Carregar mensagens existentes
            self.load_integrated_chat_messages(board_name)
            
            # Focar no campo de entrada
            message_entry.focus()
            
        except Exception as e:
            print(f"Erro ao criar chat integrado: {e}")
            ttk.Label(parent_frame, text=f"Erro ao carregar chat: {e}", foreground="red").pack()
    
    def send_integrated_chat_message(self, board_name, message_var, message_entry):
        """Envia mensagem no chat integrado"""
        message = message_var.get().strip()
        if not message:
            return
        
        # Verificar limite de caracteres (1000 caracteres)
        MAX_MESSAGE_LENGTH = 1000
        if len(message) > MAX_MESSAGE_LENGTH:
            messagebox.showwarning("Limite Excedido", 
                                 f"A mensagem deve ter no m√°ximo {MAX_MESSAGE_LENGTH} caracteres.\n"
                                 f"Sua mensagem tem {len(message)} caracteres.")
            return
        
        # Verificar se h√° usu√°rio logado
        if not hasattr(self, 'current_user') or not self.current_user:
            messagebox.showwarning("Aviso", "Voc√™ precisa estar logado para enviar mensagens!")
            return
        
        username = self.current_user.username
        
        # Adicionar mensagem ao sistema de chat
        self.chat_system.add_chat_message(board_name, username, message)
        
        # Limpar campo de entrada
        message_var.set("")
        
        # Atualizar contador
        self.update_integrated_char_count(board_name)
        
        # Recarregar mensagens
        self.load_integrated_chat_messages(board_name)
        
        # Focar novamente no campo
        message_entry.focus()
    
    def update_integrated_char_count(self, board_name):
        """Atualiza contador de caracteres do chat integrado"""
        if board_name in self.integrated_chat_widgets:
            widgets = self.integrated_chat_widgets[board_name]
            current_length = len(widgets['message_var'].get())
            max_length = 1000
            
            # Atualizar contador
            widgets['char_count_label'].config(text=f"{current_length}/{max_length}")
            
            # Mudar cor baseado no limite
            if current_length > max_length * 0.9:  # 90% do limite
                widgets['char_count_label'].config(foreground="orange")
            elif current_length > max_length:
                widgets['char_count_label'].config(foreground="red")
            else:
                widgets['char_count_label'].config(foreground="gray")
    
    def load_integrated_chat_messages(self, board_name):
        """Carrega mensagens do chat integrado"""
        if board_name in self.integrated_chat_widgets:
            widgets = self.integrated_chat_widgets[board_name]
            messages_text = widgets['messages_text']
            
            messages_text.config(state=tk.NORMAL)
            messages_text.delete(1.0, tk.END)
            
            if board_name in self.chat_system.chat_data:
                for message in self.chat_system.chat_data[board_name]:
                    self.display_integrated_message(messages_text, message)
            
            messages_text.config(state=tk.DISABLED)
            messages_text.see(tk.END)
    
    def display_integrated_message(self, messages_text, message):
        """Exibe uma mensagem no chat integrado"""
        # Formatar mensagem
        timestamp = message['timestamp']
        username = message['username']
        text = message['message']
        
        # Adicionar timestamp
        messages_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
        
        # Adicionar username
        messages_text.insert(tk.END, f"{username}: ", "username")
        
        # Adicionar mensagem
        messages_text.insert(tk.END, f"{text}\n", "message")
    
    def refresh_integrated_chat(self, board_name):
        """Atualiza o chat integrado"""
        self.load_integrated_chat_messages(board_name)
    
    def open_chat_search(self, board_name):
        """Abre busca no chat integrado"""
        ChatSearchWindow(self.root, self, board_name)
    
    def open_chat_tab(self, board_name):
        """Abre a aba de chat do quadro especificado"""
        try:
            # Encontrar o quadro no notebook
            for i, tab in enumerate(self.board_notebook.tabs()):
                if self.board_notebook.tab(i, "text") == board_name:
                    # Selecionar o quadro
                    self.board_notebook.select(i)
                    
                    # Obter o widget do quadro
                    board_frame = self.board_notebook.select()
                    board_widget = self.board_notebook.nametowidget(board_frame)
                    
                    # Encontrar o notebook interno e selecionar a aba de chat
                    for child in board_widget.winfo_children():
                        if isinstance(child, ttk.Notebook):
                            child.select(1)  # Selecionar a segunda aba (Chat)
                            break
                    break
                    
        except Exception as e:
            print(f"Erro ao abrir aba de chat: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir chat: {e}", parent=self.root)

    def create_finance_sub_tabs(self, parent):
        """Cria as abas do sistema financeiro empresarial"""
        self.finance_notebook = ttk.Notebook(parent)
        self.finance_notebook.pack(fill=tk.BOTH, expand=True)

        # Vis√£o Geral Financeira
        overview_frame = ttk.Frame(self.finance_notebook)
        self.create_overview_tab(overview_frame)
        self.finance_notebook.add(overview_frame, text="üìä Vis√£o Geral")

        # Gest√£o de Clientes
        clients_frame = ttk.Frame(self.finance_notebook)
        self.create_clients_management_tab(clients_frame)
        self.finance_notebook.add(clients_frame, text="üë• Clientes")

        # Gest√£o de Fornecedores
        suppliers_frame = ttk.Frame(self.finance_notebook)
        self.create_suppliers_management_tab(suppliers_frame)
        self.finance_notebook.add(suppliers_frame, text="üè≠ Fornecedores")

        # Contas a Receber
        receivables_frame = ttk.Frame(self.finance_notebook)
        self.create_receivables_management_tab(receivables_frame)
        self.finance_notebook.add(receivables_frame, text="üì• Contas a Receber")

        # Contas a Pagar
        payables_frame = ttk.Frame(self.finance_notebook)
        self.create_payables_management_tab(payables_frame)
        self.finance_notebook.add(payables_frame, text="üì§ Contas a Pagar")

        # Faturas/Notas Fiscais
        invoices_frame = ttk.Frame(self.finance_notebook)
        self.create_invoices_management_tab(invoices_frame)
        self.finance_notebook.add(invoices_frame, text="üßæ Faturas")

        # Fluxo de Caixa
        cashflow_frame = ttk.Frame(self.finance_notebook)
        self.create_cashflow_management_tab(cashflow_frame)
        self.finance_notebook.add(cashflow_frame, text="üíº Fluxo de Caixa")

        # Or√ßamentos
        budgets_frame = ttk.Frame(self.finance_notebook)
        self.create_budgets_management_tab(budgets_frame)
        self.finance_notebook.add(budgets_frame, text="üìä Or√ßamentos")

        # Relat√≥rios Empresariais
        reports_frame = ttk.Frame(self.finance_notebook)
        self.create_enterprise_reports_tab(reports_frame)
        self.finance_notebook.add(reports_frame, text="üìà Relat√≥rios")

        # Registro (Contas, Categorias, Meios de Pagamento)
        registration_frame = ttk.Frame(self.finance_notebook)
        self.create_registration_tab(registration_frame)
        self.finance_notebook.add(registration_frame, text="üìù Registro")

        # Entradas
        incomes_frame = ttk.Frame(self.finance_notebook)
        self.create_incomes_tab(incomes_frame)
        self.finance_notebook.add(incomes_frame, text="üí∞ Entradas")

        # Sa√≠das
        expenses_frame = ttk.Frame(self.finance_notebook)
        self.create_expenses_tab(expenses_frame)
        self.finance_notebook.add(expenses_frame, text="üí∏ Sa√≠das")

        # Configura√ß√µes
        config_frame = ttk.Frame(self.finance_notebook)
        self.create_finance_config_tab(config_frame)
        self.finance_notebook.add(config_frame, text="‚öôÔ∏è Configura√ß√µes")

    def select_tab_by_text(self, tab_text):
        """Seleciona uma aba do notebook principal pelo seu texto."""
        for i, tab in enumerate(self.main_notebook.tabs()):
            if self.main_notebook.tab(i, "text") == tab_text:
                self.main_notebook.select(i)
                return

    def update_dashboard_widgets(self):
        """Atualiza todos os widgets no dashboard."""
        # Update overview
        self.update_main_menu_overview()
        
        # Update urgent tasks
        self.update_urgent_tasks_widget()
        
        # Update upcoming deadlines
        self.update_upcoming_deadlines_widget()
        
        # Update recent activities
        self.update_recent_activities_widget()

    def update_dashboard_activities_widget(self):
        """Atualiza o widget 'Minhas Atividades' no dashboard."""
        if not hasattr(self, 'dashboard_activities_tree'):
            return

        for i in self.dashboard_activities_tree.get_children():
            self.dashboard_activities_tree.delete(i)

        if not self.current_user:
            return
        
        user_name = self.current_user.username
        all_cards = self.get_all_cards()
        user_cards = [
            card_info for card_info in all_cards 
            if user_name in card_info['card'].get("members", []) and 
               "conclu√≠do" not in card_info['list_name'].lower()
        ]

        importance_order = {level: i for i, level in enumerate(self.settings["importance_colors"].keys())}
        
        def sort_key(card_info):
            card = card_info['card']
            due_date_str = card.get("due_date", "")
            due_date = datetime.max
            if due_date_str:
                try:
                    due_date = datetime.strptime(due_date_str.split(' ')[0], "%Y-%m-%d")
                except ValueError:
                    pass
            importance_level = card.get("importance", "Normal")
            importance_val = importance_order.get(importance_level, 99)
            return (due_date, importance_val)

        user_cards.sort(key=sort_key)

        for card_info in user_cards:
            card = card_info['card']
            # Adiciona card_id √†s tags. A primeira tag √© para a cor.
            tags = (card.get("importance", "Normal"), card.get('card_id'))
            self.dashboard_activities_tree.insert("", "end", values=(
                card['title'],
                card_info['board_name'],
                card.get("due_date", "N/A")
            ), tags=tags)

        # Apply colors based on importance tags
        for importance, color in self.settings["importance_colors"].items():
            self.dashboard_activities_tree.tag_configure(importance, background=color)

    def on_dashboard_activity_double_click(self, event):
        item_id = self.dashboard_activities_tree.focus()
        if not item_id:
            return

        tags = self.dashboard_activities_tree.item(item_id, "tags")
        if len(tags) < 2:
            return # Should have importance and card_id

        card_id = tags[1]

        # Find the card, its list and board
        found_card = None
        for board_name, lists in self.boodesk_data["boards"].items():
            if board_name == "workflow": continue
            for list_name, cards in lists.items():
                for card in cards:
                    if card.get("card_id") == card_id:
                        found_card = card
                        # Find the card_id for the found card
                        card_id = found_card.get('card_id')
                        if card_id:
                            # Dynamically get the class from the module to avoid NameError at definition time
                            CardDetailsWindow = getattr(sys.modules[__name__], 'CardDetailsWindow')
                            CardDetailsWindow(self.root, self, board_name, list_name, card_id, self.current_user)
                        else:
                            messagebox.showerror("Erro", "ID do cart√£o n√£o encontrado.")
                        return

    def create_main_menu_tab(self, parent):
        # Main frame for the dashboard
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- Widgets ---
        # This frame will hold the widgets and allow for a grid layout
        widgets_frame = ttk.Frame(main_frame)
        widgets_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure grid for 2 columns and 2 rows
        widgets_frame.columnconfigure(0, weight=1)
        widgets_frame.columnconfigure(1, weight=1)
        widgets_frame.rowconfigure(0, weight=1)
        widgets_frame.rowconfigure(1, weight=1)

        # Store widget references for visibility control
        self.dashboard_widgets = {}

        # Create all widgets
        self.create_overview_widget(widgets_frame, 0, 0)
        self.create_urgent_tasks_widget(widgets_frame, 0, 1)
        self.create_upcoming_deadlines_widget(widgets_frame, 1, 0)
        self.create_recent_activities_widget(widgets_frame, 1, 1)
        self.create_quick_links_widget(widgets_frame, 2, 0)
        self.create_quick_actions_widget(widgets_frame, 2, 1)
        
        # Criar widget de reuni√µes se habilitado (ap√≥s a vis√£o geral)
        if self.notification_manager.notification_settings['show_widget']:
            # Criar o widget ap√≥s a vis√£o geral ser criada
            self.meeting_widget = None  # Ser√° criado ap√≥s os widgets principais

        # Apply widget visibility settings
        self.apply_dashboard_widget_settings()

        # --- Update call ---
        self.update_dashboard_widgets()

    def create_overview_widget(self, parent, row, col):
        """Cria o widget de vis√£o geral"""
        overview_frame = ttk.LabelFrame(parent, text="Vis√£o Geral", padding="10")
        overview_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        self.dashboard_widgets['overview'] = overview_frame

        # T√≠tulo com √≠cone
        title_frame = ttk.Frame(overview_frame)
        title_frame.pack(fill=tk.X, pady=5)
        
        if hasattr(self, 'icons') and self.icons.get('dashboard_icon'):
            ttk.Label(title_frame, text="Bem-vindo ao seu Dashboard!", image=self.icons['dashboard_icon'], compound=tk.LEFT).pack(anchor="w")
        else:
            ttk.Label(title_frame, text="Bem-vindo ao seu Dashboard!").pack(anchor="w")
        
        # Estat√≠sticas com √≠cones
        if hasattr(self, 'icons') and self.icons.get('folder_icon'):
            self.total_boards_label = ttk.Label(overview_frame, text="Total de Quadros: 0", image=self.icons['folder_icon'], compound=tk.LEFT)
        else:
            self.total_boards_label = ttk.Label(overview_frame, text="Total de Quadros: 0")
        self.total_boards_label.pack(pady=2, anchor="w")
        
        if hasattr(self, 'icons') and self.icons.get('pomodoro_icon'):
            self.total_tasks_label = ttk.Label(overview_frame, text="Total de Tarefas Pomodoro: 0", image=self.icons['pomodoro_icon'], compound=tk.LEFT)
        else:
            self.total_tasks_label = ttk.Label(overview_frame, text="Total de Tarefas Pomodoro: 0")
        self.total_tasks_label.pack(pady=2, anchor="w")
        
        if hasattr(self, 'icons') and self.icons.get('team_icon_32'):
            self.total_members_label = ttk.Label(overview_frame, text="Total de Membros: 0", image=self.icons['team_icon_32'], compound=tk.LEFT)
        else:
            self.total_members_label = ttk.Label(overview_frame, text="Total de Membros: 0")
        self.total_members_label.pack(pady=2, anchor="w")
        
        # Criar widget de reuni√µes discreto abaixo da vis√£o geral
        if self.notification_manager.notification_settings['show_widget']:
            self.meeting_widget = MeetingWidget(self, overview_frame)

    def create_urgent_tasks_widget(self, parent, row, col):
        """Cria o widget de tarefas urgentes"""
        urgent_frame = ttk.LabelFrame(parent, text="Tarefas Urgentes", padding="10")
        urgent_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        urgent_frame.rowconfigure(0, weight=1)
        urgent_frame.columnconfigure(0, weight=1)
        self.dashboard_widgets['urgent_tasks'] = urgent_frame

        # Treeview for urgent tasks
        self.urgent_tasks_tree = ttk.Treeview(urgent_frame, columns=("Tarefa", "Quadro", "Import√¢ncia"), show="headings", height=6)
        self.urgent_tasks_tree.heading("Tarefa", text="Tarefa")
        self.urgent_tasks_tree.heading("Quadro", text="Quadro")
        self.urgent_tasks_tree.heading("Import√¢ncia", text="Import√¢ncia")

        self.urgent_tasks_tree.column("Tarefa", width=200)
        self.urgent_tasks_tree.column("Quadro", width=100)
        self.urgent_tasks_tree.column("Import√¢ncia", width=80, anchor="center")
        
        self.urgent_tasks_tree.bind("<Double-1>", self.on_urgent_task_double_click)

        # Add a scrollbar
        scrollbar = ttk.Scrollbar(urgent_frame, orient="vertical", command=self.urgent_tasks_tree.yview)
        self.urgent_tasks_tree.configure(yscrollcommand=scrollbar.set)
        
        self.urgent_tasks_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def create_upcoming_deadlines_widget(self, parent, row, col):
        """Cria o widget de prazos pr√≥ximos"""
        deadlines_frame = ttk.LabelFrame(parent, text="Pr√≥ximos Prazos", padding="10")
        deadlines_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        deadlines_frame.rowconfigure(0, weight=1)
        deadlines_frame.columnconfigure(0, weight=1)
        self.dashboard_widgets['upcoming_deadlines'] = deadlines_frame

        # Treeview for upcoming deadlines
        self.deadlines_tree = ttk.Treeview(deadlines_frame, columns=("Tarefa", "Prazo", "Dias"), show="headings", height=6)
        self.deadlines_tree.heading("Tarefa", text="Tarefa")
        self.deadlines_tree.heading("Prazo", text="Prazo")
        self.deadlines_tree.heading("Dias", text="Dias")

        self.deadlines_tree.column("Tarefa", width=200)
        self.deadlines_tree.column("Prazo", width=100)
        self.deadlines_tree.column("Dias", width=60, anchor="center")
        
        self.deadlines_tree.bind("<Double-1>", self.on_deadline_double_click)

        # Add a scrollbar
        scrollbar = ttk.Scrollbar(deadlines_frame, orient="vertical", command=self.deadlines_tree.yview)
        self.deadlines_tree.configure(yscrollcommand=scrollbar.set)
        
        self.deadlines_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def create_recent_activities_widget(self, parent, row, col):
        """Cria o widget de atividades recentes"""
        activities_frame = ttk.LabelFrame(parent, text="Atividades Recentes", padding="10")
        activities_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        activities_frame.rowconfigure(0, weight=1)
        activities_frame.columnconfigure(0, weight=1)
        self.dashboard_widgets['recent_activities'] = activities_frame

        # Treeview for recent activities
        self.recent_activities_tree = ttk.Treeview(activities_frame, columns=("A√ß√£o", "Data"), show="headings", height=6)
        self.recent_activities_tree.heading("A√ß√£o", text="A√ß√£o")
        self.recent_activities_tree.heading("Data", text="Data")

        self.recent_activities_tree.column("A√ß√£o", width=250)
        self.recent_activities_tree.column("Data", width=100)
        
        self.recent_activities_tree.bind("<Double-1>", self.on_activity_double_click)

        # Add a scrollbar
        scrollbar = ttk.Scrollbar(activities_frame, orient="vertical", command=self.recent_activities_tree.yview)
        self.recent_activities_tree.configure(yscrollcommand=scrollbar.set)
        
        self.recent_activities_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def create_quick_links_widget(self, parent, row, col):
        """Cria o widget de links r√°pidos"""
        links_frame = ttk.LabelFrame(parent, text="Links Frequentes", padding="10")
        links_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        self.dashboard_widgets['quick_links'] = links_frame

        ttk.Button(links_frame, text="Quadros", image=self.icons.get('folder_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Quadros')).pack(fill=tk.X, pady=2)
        ttk.Button(links_frame, text="Produtividade", image=self.icons.get('play_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Produtividade')).pack(fill=tk.X, pady=2)
        ttk.Button(links_frame, text="Finan√ßas", image=self.icons.get('money_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Finan√ßas')).pack(fill=tk.X, pady=2)
        ttk.Button(links_frame, text="Relat√≥rios", image=self.icons.get('pie_chart_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Relat√≥rios')).pack(fill=tk.X, pady=2)

    def create_quick_actions_widget(self, parent, row, col):
        """Cria o widget de a√ß√µes r√°pidas"""
        actions_frame = ttk.LabelFrame(parent, text="A√ß√µes R√°pidas", padding="10")
        actions_frame.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        self.dashboard_widgets['quick_actions'] = actions_frame

        ttk.Button(actions_frame, text="Adicionar Quadro", image=self.icons.get('add_folder_icon'), compound=tk.LEFT, 
                  command=self.add_board).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Iniciar Pomodoro", image=self.icons.get('play_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Produtividade')).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Nova Transa√ß√£o", image=self.icons.get('add_icon'), compound=tk.LEFT, 
                  command=lambda: self.select_tab_by_text('Finan√ßas')).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Gerenciar Usu√°rios", image=self.icons.get('key_icon'), compound=tk.LEFT, 
                  command=self.open_user_management).pack(fill=tk.X, pady=2)
        ttk.Button(actions_frame, text="Configurar Notifica√ß√µes", image=self.icons.get('settings_icon'), compound=tk.LEFT, 
                  command=self.open_notification_settings).pack(fill=tk.X, pady=2)
        
        # Bot√£o para alternar widget de reuni√µes ser√° movido para configura√ß√µes do dashboard
        
        # Widget de reuni√µes ser√° criado no m√©todo create_main_menu_tab
        ttk.Button(actions_frame, text="Atualizar", image=self.icons.get('refresh_icon'), compound=tk.LEFT, 
                  command=self.update_dashboard_widgets).pack(fill=tk.X, pady=2)

    def apply_dashboard_widget_settings(self):
        """Aplica as configura√ß√µes de visibilidade dos widgets"""
        widget_settings = self.settings.get('dashboard_widgets', {})
        
        # Converter string JSON para dicion√°rio se necess√°rio
        if isinstance(widget_settings, str):
            try:
                import json
                widget_settings = json.loads(widget_settings)
            except:
                widget_settings = {}
        
        for widget_name, frame in self.dashboard_widgets.items():
            if widget_settings.get(widget_name, True):
                frame.grid()
            else:
                frame.grid_remove()

    def on_urgent_task_double_click(self, event):
        """Handler para duplo clique em tarefa urgente"""
        selection = self.urgent_tasks_tree.selection()
        if selection:
            item = self.urgent_tasks_tree.item(selection[0])
            task_title = item['values'][0]
            # Aqui voc√™ pode implementar a navega√ß√£o para o cart√£o espec√≠fico
            self.select_tab_by_text('Quadros')
            messagebox.showinfo("Navega√ß√£o", f"Navegando para a tarefa: {task_title}")

    def on_deadline_double_click(self, event):
        """Handler para duplo clique em prazo"""
        selection = self.deadlines_tree.selection()
        if selection:
            item = self.deadlines_tree.item(selection[0])
            task_title = item['values'][0]
            # Aqui voc√™ pode implementar a navega√ß√£o para o cart√£o espec√≠fico
            self.select_tab_by_text('Quadros')
            messagebox.showinfo("Navega√ß√£o", f"Navegando para a tarefa: {task_title}")

    def on_activity_double_click(self, event):
        """Handler para duplo clique em atividade"""
        selection = self.recent_activities_tree.selection()
        if selection:
            item = self.recent_activities_tree.item(selection[0])
            activity = item['values'][0]
            messagebox.showinfo("Atividade", f"Detalhes da atividade: {activity}")

    def update_main_menu_overview(self):
        # Update the quick overview labels
        total_boards = len(self.boodesk_data["boards"])
        total_tasks = len(self.pomodoro_tasks_df)
        total_members = len(self.members_df)

        self.total_boards_label.config(text=f"Total de Quadros: {total_boards}")
        self.total_tasks_label.config(text=f"Total de Tarefas Pomodoro: {total_tasks}")
        self.total_members_label.config(text=f"Total de Membros: {total_members}")

    def update_urgent_tasks_widget(self):
        """Atualiza o widget de tarefas urgentes com isolamento por usu√°rio (membros + criador)"""
        if not hasattr(self, 'urgent_tasks_tree'):
            return
            
        self.urgent_tasks_tree.delete(*self.urgent_tasks_tree.get_children())
        
        # Obter ID do usu√°rio atual
        current_user_id = self.get_current_user_id()
        if not current_user_id:
            print("‚ö†Ô∏è Usu√°rio atual n√£o identificado")
            return
        
        urgent_tasks = []
        
        try:
            # Buscar cards urgentes onde o usu√°rio participa (via PostgreSQL)
            from supabase_setup import supabase_config
            conn = supabase_config.get_connection()
            if conn:
                cursor = conn.cursor()
                
                # Query com isolamento por quadros (mostra todos os cards cr√≠ticos/altos dos quadros do usu√°rio)
                cursor.execute("""
                    SELECT c.id, c.title, c.importance, c.priority, b.name as board_name, c.list_name
                    FROM cards c
                    LEFT JOIN card_members cm ON c.id = cm.card_id
                    LEFT JOIN boards b ON c.board_id = b.board_id
                    WHERE b.board_id IN (
                        SELECT DISTINCT b2.board_id
                        FROM boards b2
                        LEFT JOIN board_members bm ON b2.board_id = bm.board_id
                        WHERE b2.owner_id = %s OR bm.user_id = %s
                    )
                    AND (c.importance IN ('Alta', 'Cr√≠tica') OR c.priority IN ('Alta', 'Cr√≠tica'))
                    AND NOT c.is_archived
                    ORDER BY 
                        CASE 
                            WHEN c.importance = 'Cr√≠tica' THEN 0
                            WHEN c.importance = 'Alta' THEN 1
                            WHEN c.priority = 'Cr√≠tica' THEN 2
                            WHEN c.priority = 'Alta' THEN 3
                            ELSE 4
                        END,
                        c.title
                    LIMIT 5
                """, (current_user_id, current_user_id))
                
                cards_urgentes = cursor.fetchall()
                
                for card in cards_urgentes:
                    card_id, title, importance, priority, board_name, list_name = card
                    
                    # Determinar a import√¢ncia mais alta
                    final_importance = importance if importance in ['Alta', 'Cr√≠tica'] else priority
                    
                    urgent_tasks.append({
                        "title": title,
                        "board": board_name,  # Usar nome do quadro
                        "importance": final_importance,
                        "card": {"id": card_id}
                    })
                
                conn.close()
                
        except Exception as e:
            print(f"‚ùå Erro ao buscar tarefas urgentes: {e}")
            # Fallback para o m√©todo antigo (sem isolamento)
            for board_name, board_data in self.boodesk_data["boards"].items():
                if isinstance(board_data, dict):
                    for list_name, cards in board_data.items():
                        if list_name != "workflow":
                            for card in cards:
                                if not card.get("is_archived", False):
                                    importance = card.get("importance", "Normal")
                                    if importance in ["Alta", "Cr√≠tica"]:
                                        urgent_tasks.append({
                                            "title": card.get("title", ""),
                                            "board": board_name,
                                            "importance": importance,
                                            "card": card
                                        })
        
        # Sort by importance (Cr√≠tica first, then Alta)
        importance_order = {"Cr√≠tica": 0, "Alta": 1}
        urgent_tasks.sort(key=lambda x: importance_order.get(x["importance"], 2))
        
        # Add to treeview (top 5)
        for i, task in enumerate(urgent_tasks[:5]):
            item = self.urgent_tasks_tree.insert("", "end", values=(
                task["title"],
                task["board"],
                task["importance"]
            ))
            
            # Apply background color based on importance
            if task["importance"] == "Cr√≠tica":
                self.urgent_tasks_tree.tag_configure("critical", background="#FFCCCC")
                self.urgent_tasks_tree.item(item, tags=("critical",))
            elif task["importance"] == "Alta":
                self.urgent_tasks_tree.tag_configure("high", background="#FFE5CC")
                self.urgent_tasks_tree.item(item, tags=("high",))

    def update_upcoming_deadlines_widget(self):
        """Atualiza o widget de prazos pr√≥ximos com isolamento por usu√°rio (quadros onde √© participante/criador)"""
        if not hasattr(self, 'deadlines_tree'):
            return
            
        self.deadlines_tree.delete(*self.deadlines_tree.get_children())
        
        current_user_id = self.get_current_user_id()
        if not current_user_id:
            print("‚ö†Ô∏è Usu√°rio atual n√£o identificado")
            return
        
        deadline_tasks = []
        try:
            from supabase_setup import supabase_config
            conn = supabase_config.get_connection()
            if conn:
                cursor = conn.cursor()
                # Query com isolamento por quadros (mostra todos os cards com prazo dos quadros do usu√°rio)
                cursor.execute("""
                    SELECT c.id, c.title, c.due_date, b.name as board_name, c.list_name
                    FROM cards c
                    LEFT JOIN card_members cm ON c.id = cm.card_id
                    LEFT JOIN boards b ON c.board_id = b.board_id
                    WHERE b.board_id IN (
                        SELECT DISTINCT b2.board_id
                        FROM boards b2
                        LEFT JOIN board_members bm ON b2.board_id = bm.board_id
                        WHERE b2.owner_id = %s OR bm.user_id = %s
                    )
                    AND c.due_date IS NOT NULL
                    AND c.due_date::text != ''
                    AND c.due_date::text != 'None'
                    AND c.due_date > CURRENT_TIMESTAMP
                    AND NOT c.is_archived
                    ORDER BY c.due_date
                    LIMIT 5
                """, (current_user_id, current_user_id))
                
                cards_prazos = cursor.fetchall()
                for card in cards_prazos:
                    card_id, title, due_date, board_name, list_name = card
                    if due_date:
                        try:
                            from datetime import datetime
                            due_date_obj = datetime.strptime(str(due_date), '%Y-%m-%d %H:%M:%S')
                            today = datetime.now()
                            days_until = (due_date_obj - today).days
                            deadline_tasks.append({
                                "title": title,
                                "due_date": str(due_date),
                                "days": days_until,
                                "board_name": board_name
                            })
                        except ValueError:
                            continue
                conn.close()
        except Exception as e:
            print(f"‚ùå Erro ao buscar prazos pr√≥ximos: {e}")
            # Fallback to old logic if DB query fails
            from datetime import datetime
            today = datetime.now()
            for board_name, board_data in self.boodesk_data["boards"].items():
                if isinstance(board_data, dict):
                    for list_name, cards in board_data.items():
                        if list_name != "workflow":
                            for card in cards:
                                if not card.get("is_archived", False):
                                    due_date_str = card.get("due_date", "")
                                    if due_date_str:
                                        try:
                                            due_date = datetime.strptime(due_date_str, '%Y-%m-%d %H:%M')
                                            if due_date > today:
                                                days_until = (due_date - today).days
                                                deadline_tasks.append({
                                                    "title": card.get("title", ""),
                                                    "due_date": due_date_str,
                                                    "days": days_until,
                                                    "board_name": board_name
                                                })
                                        except ValueError:
                                            continue
        
        # Sort by days until deadline
        deadline_tasks.sort(key=lambda x: x["days"])
        
        # Add to treeview (top 5)
        for i, task in enumerate(deadline_tasks[:5]):
            item = self.deadlines_tree.insert("", "end", values=(
                task["title"],
                task["due_date"],
                f"{task['days']} dias"
            ))
            
            # Aplicar cor baseada na urg√™ncia
            if task["days"] <= 1:
                self.deadlines_tree.tag_configure("urgent", background="#FFCCCC")
                self.deadlines_tree.item(item, tags=("urgent",))
            elif task["days"] <= 3:
                self.deadlines_tree.tag_configure("soon", background="#FFE5CC")
                self.deadlines_tree.item(item, tags=("soon",))

    def update_recent_activities_widget(self):
        """Atualiza o widget de atividades recentes"""
        if not hasattr(self, 'recent_activities_tree'):
            return
            
        self.recent_activities_tree.delete(*self.recent_activities_tree.get_children())
        
        activities = []
        
        # Collect activities from card history
        for board_name, board_data in self.boodesk_data["boards"].items():
            # Verificar se board_data √© um dicion√°rio ou lista
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                    if list_name != "workflow":
                        for card in cards:
                            history = card.get("history", [])
                            for entry in history[-3:]:  # Last 3 entries per card
                                activities.append({
                                    "action": entry.get("action", ""),
                                    "timestamp": entry.get("timestamp", ""),
                                    "user": entry.get("user", "")
                                })
        
        # Sort by timestamp (most recent first)
        activities.sort(key=lambda x: x["timestamp"], reverse=True)
        
        # Add to treeview (top 10)
        for activity in activities[:10]:
            self.recent_activities_tree.insert("", "end", values=(
                activity["action"],
                activity["timestamp"]
            ))

    def open_user_management_window(self):
        """Abre a janela de gerenciamento de usu√°rios (alias para open_user_management)"""
        # Usar a fun√ß√£o principal que j√° est√° implementada e funcionando
        self.open_user_management()

    def open_management_reports(self):
        # Placeholder for Management Reports
        messagebox.showinfo("Relat√≥rios Gerenciais", "Funcionalidade de Relat√≥rios Gerenciais em desenvolvimento!")

    def create_accounts_registration_tab(self, parent):
        # Accounts Section
        accounts_frame = ttk.Frame(parent, padding="10")
        accounts_frame.pack(fill=tk.BOTH, expand=True)
        accounts_frame.columnconfigure(1, weight=1)

        ttk.Label(accounts_frame, text="Nome da Conta:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.account_name_entry = ttk.Entry(accounts_frame, width=40)
        self.account_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        button_frame_acc = ttk.Frame(accounts_frame)
        button_frame_acc.grid(row=1, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame_acc, text="Adicionar Conta", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_account).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_acc, text="Remover Selecionada", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_account).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_acc, text="Atualizar Saldo", image=self.icons.get('refresh_icon'), compound=tk.LEFT, command=self.update_selected_account_balance).pack(side=tk.LEFT, padx=5)

        accounts_list_frame = ttk.LabelFrame(accounts_frame, text="Contas Existentes", padding="10")
        accounts_list_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=10)
        accounts_list_frame.columnconfigure(0, weight=1)
        accounts_list_frame.rowconfigure(0, weight=1)

        self.accounts_listbox = tk.Listbox(accounts_list_frame, selectmode=tk.SINGLE, height=5)
        self.accounts_listbox.grid(row=0, column=0, sticky="nsew", pady=5)
        self.accounts_listbox.bind("<<ListboxSelect>>", self.on_account_select)
        acc_scrollbar = ttk.Scrollbar(accounts_list_frame, orient="vertical", command=self.accounts_listbox.yview)
        acc_scrollbar.grid(row=0, column=1, sticky="ns")
        self.accounts_listbox.config(yscrollcommand=acc_scrollbar.set)

    def create_categories_registration_tab(self, parent):
        # Categories Section
        categories_frame = ttk.Frame(parent, padding="10")
        categories_frame.pack(fill=tk.BOTH, expand=True)
        categories_frame.columnconfigure(1, weight=1)

        ttk.Label(categories_frame, text="Nome da Categoria:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.category_name_entry = ttk.Entry(categories_frame, width=40)
        self.category_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        button_frame_cat = ttk.Frame(categories_frame)
        button_frame_cat.grid(row=1, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame_cat, text="Adicionar Categoria", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_cat, text="Remover Selecionada", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_category).pack(side=tk.LEFT, padx=5)

        categories_list_frame = ttk.LabelFrame(categories_frame, text="Categorias Existentes", padding="10")
        categories_list_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=10)
        categories_list_frame.columnconfigure(0, weight=1)
        categories_list_frame.rowconfigure(0, weight=1)

        self.categories_listbox = tk.Listbox(categories_list_frame, selectmode=tk.SINGLE, height=5)
        self.categories_listbox.grid(row=0, column=0, sticky="nsew", pady=5)
        cat_scrollbar = ttk.Scrollbar(categories_list_frame, orient="vertical", command=self.categories_listbox.yview)
        cat_scrollbar.grid(row=0, column=1, sticky="ns")
        self.categories_listbox.config(yscrollcommand=cat_scrollbar.set)

    def create_payment_methods_registration_tab(self, parent):
        # Payment Methods Section
        payment_methods_frame = ttk.Frame(parent, padding="10")
        payment_methods_frame.pack(fill=tk.BOTH, expand=True)
        payment_methods_frame.columnconfigure(1, weight=1)

        ttk.Label(payment_methods_frame, text="Nome do Meio de Pagamento:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.payment_method_name_entry = ttk.Entry(payment_methods_frame, width=40)
        self.payment_method_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        button_frame_pm = ttk.Frame(payment_methods_frame)
        button_frame_pm.grid(row=1, column=0, columnspan=2, pady=10)
        ttk.Button(button_frame_pm, text="Adicionar Meio de Pagamento", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_payment_method).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame_pm, text="Remover Selecionado", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_payment_method).pack(side=tk.LEFT, padx=5)

        payment_methods_list_frame = ttk.LabelFrame(payment_methods_frame, text="Meios de Pagamento Existentes", padding="10")
        payment_methods_list_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=10)
        payment_methods_list_frame.columnconfigure(0, weight=1)
        payment_methods_list_frame.rowconfigure(0, weight=1)

        self.payment_methods_listbox = tk.Listbox(payment_methods_list_frame, selectmode=tk.SINGLE, height=5)
        self.payment_methods_listbox.grid(row=0, column=0, sticky="nsew", pady=5)
        pm_scrollbar = ttk.Scrollbar(payment_methods_list_frame, orient="vertical", command=self.payment_methods_listbox.yview)
        pm_scrollbar.grid(row=0, column=1, sticky="ns")
        self.payment_methods_listbox.config(yscrollcommand=pm_scrollbar.set)

    def create_incomes_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Input fields for new income transaction
        input_frame = ttk.LabelFrame(main_frame, text="Registrar Nova Entrada", padding="10")
        input_frame.pack(fill=tk.X, pady=10)

        input_frame.columnconfigure(1, weight=1)

        ttk.Label(input_frame, text="Descri√ß√£o:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.income_description_entry = ttk.Entry(input_frame, width=40)
        self.income_description_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(input_frame, text="Valor:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.income_amount_entry = NumericEntryWithButtons(input_frame, self.icons)
        self.income_amount_entry.grid(row=1, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Data:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        income_date_frame = ttk.Frame(input_frame)
        income_date_frame.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        self.income_date_entry = ttk.Entry(income_date_frame, width=15, state="readonly")
        self.income_date_entry.pack(side=tk.LEFT)
        ttk.Button(income_date_frame, image=self.icons.get('time_icon'), width=3, command=partial(self._open_finance_date_picker, self.income_date_entry)).pack(side=tk.LEFT, padx=2)
        self.income_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d")) # Default to today

        ttk.Label(input_frame, text="Categoria:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.income_category_combo = ttk.Combobox(input_frame, state="readonly")
        self.income_category_combo.grid(row=3, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Meio de Pagamento:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.income_payment_method_combo = ttk.Combobox(input_frame, state="readonly")
        self.income_payment_method_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Conta Banc√°ria:").grid(row=5, column=0, sticky="w", padx=5, pady=2)
        self.income_account_combo = ttk.Combobox(input_frame, state="readonly")
        self.income_account_combo.grid(row=5, column=1, sticky="w", padx=5, pady=2)

        ttk.Button(input_frame, text="Registrar Entrada", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.register_income).grid(row=6, column=0, columnspan=2, pady=10)

        # Treeview for displaying income transactions
        incomes_treeview_frame = ttk.LabelFrame(main_frame, text="Entradas Registradas", padding="10")
        incomes_treeview_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.incomes_treeview = ttk.Treeview(incomes_treeview_frame, columns=("Data", "Descri√ß√£o", "Valor", "Categoria", "Meio de Pagamento", "Conta"), show="headings")
        self.incomes_treeview.heading("Data", text="Data")
        self.incomes_treeview.heading("Descri√ß√£o", text="Descri√ß√£o")
        self.incomes_treeview.heading("Valor", text="Valor")
        self.incomes_treeview.heading("Categoria", text="Categoria")
        self.incomes_treeview.heading("Meio de Pagamento", text="Meio de Pagamento")
        self.incomes_treeview.heading("Conta", text="Conta")

        self.incomes_treeview.column("Data", width=100, anchor="center")
        self.incomes_treeview.column("Descri√ß√£o", width=200, anchor="w")
        self.incomes_treeview.column("Valor", width=100, anchor="e")
        self.incomes_treeview.column("Categoria", width=120, anchor="w")
        self.incomes_treeview.column("Meio de Pagamento", width=120, anchor="w")
        self.incomes_treeview.column("Conta", width=120, anchor="w")

        self.incomes_treeview.pack(fill=tk.BOTH, expand=True)

    def register_income(self):
        description = self.income_description_entry.get().strip()
        amount = self.income_amount_entry.get()
        date = self.income_date_entry.get()
        category = self.income_category_combo.get()
        payment_method = self.income_payment_method_combo.get()
        account = self.income_account_combo.get()

        if not description or amount <= 0 or not date or not category or not payment_method or not account:
            messagebox.showwarning("Campos Obrigat√≥rios", "Por favor, preencha todos os campos da entrada e o valor deve ser positivo.")
            return

        new_transaction = {
            "descricao": description,
            "valor": amount,
            "tipo": "Entrada",
            "data": date,
            "categoria": category,
            "meio_pagamento": payment_method,
            "conta_bancaria": account,
            "timestamp": datetime.now().isoformat()
        }

        self.boodesk_data["finances"]["transacoes"].append(new_transaction)
        
        for acc in self.boodesk_data['finances']['contas_bancarias']:
            if acc['name'] == account:
                acc['balance'] += amount
                break
        
        self.save_trello_data()
        self.update_transactions_treeview()
        self.update_incomes_treeview()
        self.update_accounts_listbox()
        self.update_total_balance_display()

        self.income_description_entry.delete(0, tk.END)
        self.income_amount_entry.set(0.00)
        self.income_date_entry.delete(0, tk.END)
        self.income_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.income_category_combo.set("")
        self.income_payment_method_combo.set("")
        self.income_account_combo.set("")
        messagebox.showinfo("Sucesso", "Entrada registrada com sucesso!")
        self._show_chart(self.current_chart_type)

    def update_incomes_treeview(self):
        for i in self.incomes_treeview.get_children():
            self.incomes_treeview.delete(i)
        for transaction in self.boodesk_data["finances"]["transacoes"]:
            if transaction["tipo"] == "Entrada":
                self.incomes_treeview.insert("", "end", values=(
                    transaction["data"],
                    transaction["descricao"],
                    f"{transaction["valor"]:.2f}",
                    transaction["categoria"],
                    transaction["meio_pagamento"],
                    transaction["conta_bancaria"]
                ))

    def create_expenses_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Input fields for new expense transaction
        input_frame = ttk.LabelFrame(main_frame, text="Registrar Nova Sa√≠da", padding="10")
        input_frame.pack(fill=tk.X, pady=10)

        input_frame.columnconfigure(1, weight=1)

        ttk.Label(input_frame, text="Descri√ß√£o:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.expense_description_entry = ttk.Entry(input_frame, width=40)
        self.expense_description_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(input_frame, text="Valor:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.expense_amount_entry = NumericEntryWithButtons(input_frame, self.icons)
        self.expense_amount_entry.grid(row=1, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Data:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        expense_date_frame = ttk.Frame(input_frame)
        expense_date_frame.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        self.expense_date_entry = ttk.Entry(expense_date_frame, width=15, state="readonly")
        self.expense_date_entry.pack(side=tk.LEFT)
        ttk.Button(expense_date_frame, image=self.icons.get('time_icon'), width=3, command=partial(self._open_finance_date_picker, self.expense_date_entry)).pack(side=tk.LEFT, padx=2)
        self.expense_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d")) # Default to today

        ttk.Label(input_frame, text="Categoria:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.expense_category_combo = ttk.Combobox(input_frame, state="readonly")
        self.expense_category_combo.grid(row=3, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Meio de Pagamento:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.expense_payment_method_combo = ttk.Combobox(input_frame, state="readonly")
        self.expense_payment_method_combo.grid(row=4, column=1, sticky="w", padx=5, pady=2)

        ttk.Label(input_frame, text="Conta Banc√°ria:").grid(row=5, column=0, sticky="w", padx=5, pady=2)
        self.expense_account_combo = ttk.Combobox(input_frame, state="readonly")
        self.expense_account_combo.grid(row=5, column=1, sticky="w", padx=5, pady=2)

        ttk.Button(input_frame, text="Registrar Sa√≠da", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.register_expense).grid(row=6, column=0, columnspan=2, pady=10)

        # Treeview for displaying expense transactions
        expenses_treeview_frame = ttk.LabelFrame(main_frame, text="Sa√≠das Registradas", padding="10")
        expenses_treeview_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.expenses_treeview = ttk.Treeview(expenses_treeview_frame, columns=("Data", "Descri√ß√£o", "Valor", "Categoria", "Meio de Pagamento", "Conta"), show="headings")
        self.expenses_treeview.heading("Data", text="Data")
        self.expenses_treeview.heading("Descri√ß√£o", text="Descri√ß√£o")
        self.expenses_treeview.heading("Valor", text="Valor")
        self.expenses_treeview.heading("Categoria", text="Categoria")
        self.expenses_treeview.heading("Meio de Pagamento", text="Meio de Pagamento")
        self.expenses_treeview.heading("Conta", text="Conta")

        self.expenses_treeview.column("Data", width=100, anchor="center")
        self.expenses_treeview.column("Descri√ß√£o", width=200, anchor="w")
        self.expenses_treeview.column("Valor", width=100, anchor="e")
        self.expenses_treeview.column("Categoria", width=120, anchor="w")
        self.expenses_treeview.column("Meio de Pagamento", width=120, anchor="w")
        self.expenses_treeview.column("Conta", width=120, anchor="w")

        self.expenses_treeview.pack(fill=tk.BOTH, expand=True)

    def register_expense(self):
        description = self.expense_description_entry.get().strip()
        amount = self.expense_amount_entry.get()
        date = self.expense_date_entry.get()
        category = self.expense_category_combo.get()
        payment_method = self.expense_payment_method_combo.get()
        account = self.expense_account_combo.get()

        if not description or amount <= 0 or not date or not category or not payment_method or not account:
            messagebox.showwarning("Campos Obrigat√≥rios", "Por favor, preencha todos os campos da sa√≠da e o valor deve ser positivo.")
            return

        new_transaction = {
            "descricao": description,
            "valor": amount,
            "tipo": "Sa√≠da",
            "data": date,
            "categoria": category,
            "meio_pagamento": payment_method,
            "conta_bancaria": account,
            "timestamp": datetime.now().isoformat()
        }

        self.boodesk_data["finances"]["transacoes"].append(new_transaction)
        
        for acc in self.boodesk_data['finances']['contas_bancarias']:
            if acc['name'] == account:
                acc['balance'] -= amount
                break
        
        self.save_trello_data()
        self.update_transactions_treeview()
        self.update_expenses_treeview()
        self.update_accounts_listbox()
        self.update_total_balance_display()

        self.expense_description_entry.delete(0, tk.END)
        self.expense_amount_entry.set(0.00)
        self.expense_date_entry.delete(0, tk.END)
        self.expense_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.expense_category_combo.set("")
        self.expense_payment_method_combo.set("")
        self.expense_account_combo.set("")
        messagebox.showinfo("Sucesso", "Sa√≠da registrada com sucesso!")
        self._show_chart(self.current_chart_type)

    def update_expenses_treeview(self):
        for i in self.expenses_treeview.get_children():
            self.expenses_treeview.delete(i)
        for transaction in self.boodesk_data["finances"]["transacoes"]:
            if transaction["tipo"] == "Sa√≠da":
                self.expenses_treeview.insert("", "end", values=(
                    transaction["data"],
                    transaction["descricao"],
                    f"{transaction["valor"]:.2f}",
                    transaction["categoria"],
                    transaction["meio_pagamento"],
                    transaction["conta_bancaria"]
                ))

    def create_transactions_history_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Treeview for displaying all transactions
        transactions_frame = ttk.LabelFrame(main_frame, text="Hist√≥rico de Transa√ß√µes", padding="10")
        transactions_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.transactions_treeview = ttk.Treeview(transactions_frame, columns=("Data", "Descri√ß√£o", "Tipo", "Valor", "Categoria", "Meio de Pagamento", "Conta"), show="headings")
        self.transactions_treeview.heading("Data", text="Data")
        self.transactions_treeview.heading("Descri√ß√£o", text="Descri√ß√£o")
        self.transactions_treeview.heading("Tipo", text="Tipo")
        self.transactions_treeview.heading("Valor", text="Valor")
        self.transactions_treeview.heading("Categoria", text="Categoria")
        self.transactions_treeview.heading("Meio de Pagamento", text="Meio de Pagamento")
        self.transactions_treeview.heading("Conta", text="Conta")

        self.transactions_treeview.column("Data", width=100, anchor="center")
        self.transactions_treeview.column("Descri√ß√£o", width=200, anchor="w")
        self.transactions_treeview.column("Tipo", width=80, anchor="center")
        self.transactions_treeview.column("Valor", width=100, anchor="e")
        self.transactions_treeview.column("Categoria", width=120, anchor="w")
        self.transactions_treeview.column("Meio de Pagamento", width=120, anchor="w")
        self.transactions_treeview.column("Conta", width=120, anchor="w")

        self.transactions_treeview.pack(fill=tk.BOTH, expand=True)

    def _open_finance_date_picker(self, entry_widget):
        current_date_str = entry_widget.get()
        dialog = DatePickerDialog(self.root, current_date=current_date_str, icons=self.icons)
        self.root.wait_window(dialog)
        if dialog.result_date:
            entry_widget.config(state="normal")
            entry_widget.delete(0, tk.END)
            entry_widget.insert(0, dialog.result_date.strftime("%Y-%m-%d"))
            entry_widget.config(state="readonly")

    def update_transactions_treeview(self):
        try:
            if hasattr(self, 'transactions_treeview'):
                for i in self.transactions_treeview.get_children():
                    self.transactions_treeview.delete(i)
                for transaction in self.boodesk_data["finances"]["transacoes"]:
                    self.transactions_treeview.insert("", "end", values=(
                        transaction["data"],
                        transaction["descricao"],
                        transaction["tipo"],
                        transaction["valor"], # No f-string here, it's already a float
                        transaction["categoria"],
                        transaction["meio_pagamento"],
                        transaction["conta_bancaria"]
                    ))
        except Exception as e:
            print(f"Erro ao atualizar transactions_treeview: {e}")

    def populate_finance_comboboxes(self):
        try:
            if hasattr(self, 'income_category_combo'):
                self.income_category_combo['values'] = self.boodesk_data["finances"]["categorias_gasto"]
            if hasattr(self, 'expense_category_combo'):
                self.expense_category_combo['values'] = self.boodesk_data["finances"]["categorias_gasto"]
            if hasattr(self, 'income_payment_method_combo'):
                self.income_payment_method_combo['values'] = self.boodesk_data["finances"]["meios_pagamento"]
            if hasattr(self, 'expense_payment_method_combo'):
                self.expense_payment_method_combo['values'] = self.boodesk_data["finances"]["meios_pagamento"]
            if hasattr(self, 'income_account_combo'):
                self.income_account_combo['values'] = [acc['name'] for acc in self.boodesk_data["finances"]["contas_bancarias"]]
            if hasattr(self, 'expense_account_combo'):
                self.expense_account_combo['values'] = [acc['name'] for acc in self.boodesk_data["finances"]["contas_bancarias"]]
        except Exception as e:
            print(f"Erro ao popular comboboxes financeiros: {e}")

    def create_registration_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Frame para os bot√µes de navega√ß√£o
        button_nav_frame = ttk.Frame(main_frame)
        button_nav_frame.pack(pady=10)

        ttk.Button(button_nav_frame, text="Cadastrar Contas", image=self.icons.get('add_folder_icon'), compound=tk.LEFT, command=lambda: self.registration_notebook.select(0)).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_nav_frame, text="Cadastrar Categorias", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.registration_notebook.select(1)).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_nav_frame, text="Cadastrar Meios de Pagamento", image=self.icons.get('add_icon'), compound=tk.LEFT, command=lambda: self.registration_notebook.select(2)).pack(side=tk.LEFT, padx=5)

        self.registration_notebook = ttk.Notebook(main_frame)
        self.registration_notebook.pack(fill=tk.BOTH, expand=True)

        accounts_frame = ttk.Frame(self.registration_notebook)
        categories_frame = ttk.Frame(self.registration_notebook)
        payment_methods_frame = ttk.Frame(self.registration_notebook)

        self.registration_notebook.add(accounts_frame, text='Contas Banc√°rias')
        self.registration_notebook.add(categories_frame, text='Categorias de Gasto')
        self.registration_notebook.add(payment_methods_frame, text='Meios de Pagamento')

        self.create_accounts_registration_tab(accounts_frame)
        self.create_categories_registration_tab(categories_frame)
        self.create_payment_methods_registration_tab(payment_methods_frame)

    def add_account(self):
        name = self.account_name_entry.get().strip()

        if not name:
            messagebox.showwarning("Campo Obrigat√≥rio", "Por favor, insira o nome da conta.")
            return

        if any(acc['name'] == name for acc in self.boodesk_data['finances']['contas_bancarias']):
            messagebox.showwarning("Conta Existente", f"Uma conta com o nome '{name}' j√° existe.")
            return

        self.boodesk_data['finances']['contas_bancarias'].append({"name": name, "balance": 0.00})
        self.save_trello_data()
        self.update_accounts_listbox()
        self.populate_finance_comboboxes()
        self.update_total_balance_display()
        self.account_name_entry.delete(0, tk.END)
        messagebox.showinfo("Sucesso", f"Conta '{name}' adicionada com sucesso!")
        self._show_chart(self.current_chart_type)

    def remove_account(self):
        selected_index = self.accounts_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione uma conta para remover.")
            return

        account_name_display = self.accounts_listbox.get(selected_index[0])
        account_name = account_name_display.split(" (R$")[0]

        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover a conta '{account_name}'?"):
            self.boodesk_data['finances']['contas_bancarias'] = [
                acc for acc in self.boodesk_data['finances']['contas_bancarias'] if acc['name'] != account_name
            ]
            self.save_trello_data()
            self.update_accounts_listbox()
            self.populate_finance_comboboxes()
            self.update_total_balance_display()
            messagebox.showinfo("Sucesso", f"Conta '{account_name}' removida com sucesso!")
            self._show_chart(self.current_chart_type)

    def update_selected_account_balance(self):
        selected_index = self.accounts_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione uma conta para atualizar o saldo.")
            return

        account_name_display = self.accounts_listbox.get(selected_index[0])
        account_name = account_name_display.split(" (R$")[0]

        new_balance_str = simpledialog.askstring("Atualizar Saldo", f"Digite o novo saldo para '{account_name}':", parent=self.root)
        if new_balance_str is None:
            return

        try:
            new_balance = float(new_balance_str.replace(",", "."))
        except ValueError:
            messagebox.showwarning("Entrada Inv√°lida", "O saldo deve ser um n√∫mero v√°lido.")
            return

        found = False
        for account in self.boodesk_data['finances']['contas_bancarias']:
            if acc['name'] == account_name: # Bug in original code: 'acc' instead of 'account'
                account['balance'] = new_balance
                found = True
                break
        
        if found:
            self.save_trello_data()
            self.update_accounts_listbox()
            self.update_total_balance_display()
            messagebox.showinfo("Sucesso", f"Saldo da conta '{account_name}' atualizado para R$ {new_balance:.2f}.")
        else:
            messagebox.showerror("Erro", "Conta n√£o encontrada. Por favor, selecione uma conta v√°lida.")

    def update_accounts_listbox(self):
        self.accounts_listbox.delete(0, tk.END)
        for account in self.boodesk_data['finances']['contas_bancarias']:
            self.accounts_listbox.insert(tk.END, f"{account['name']} (R$ {account['balance']:.2f})")

    def on_account_select(self, event):
        selected_index = self.accounts_listbox.curselection()
        if selected_index:
            account_name_display = self.accounts_listbox.get(selected_index[0])
            account_name = account_name_display.split(" (R$")[0]
            
            for account in self.boodesk_data['finances']['contas_bancarias']:
                if account['name'] == account_name:
                    self.account_name_entry.delete(0, tk.END)
                    self.account_name_entry.insert(0, account['name'])
                    break

    def add_category(self):
        name = self.category_name_entry.get().strip()
        if not name:
            messagebox.showwarning("Campo Obrigat√≥rio", "Por favor, insira o nome da categoria.")
            return

        if name in self.boodesk_data['finances']['categorias_gasto']:
            messagebox.showwarning("Categoria Existente", f"A categoria '{name}' j√° existe.")
            return

        self.boodesk_data['finances']['categorias_gasto'].append(name)
        self.save_trello_data()
        self.update_categories_listbox()
        self.populate_finance_comboboxes()
        self.category_name_entry.delete(0, tk.END)
        messagebox.showinfo("Sucesso", f"Categoria '{name}' adicionada com sucesso!")

    def remove_category(self):
        selected_index = self.categories_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione uma categoria para remover.")
            return

        category_name = self.categories_listbox.get(selected_index[0])

        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover a categoria '{category_name}'?"):
            self.boodesk_data['finances']['categorias_gasto'].remove(category_name)
            self.save_trello_data()
            self.update_categories_listbox()
            self.populate_finance_comboboxes()
            messagebox.showinfo("Sucesso", f"Categoria '{category_name}' removida com sucesso!")

    def update_categories_listbox(self):
        self.categories_listbox.delete(0, tk.END)
        for category in self.boodesk_data['finances']['categorias_gasto']:
            self.categories_listbox.insert(tk.END, category)

    def add_payment_method(self):
        name = self.payment_method_name_entry.get().strip()
        if not name:
            messagebox.showwarning("Campo Obrigat√≥rio", "Por favor, insira o nome do meio de pagamento.")
            return

        if name in self.boodesk_data['finances']['meios_pagamento']:
            messagebox.showwarning("Meio de Pagamento Existente", f"O meio de pagamento '{name}' j√° existe.")
            return

        self.boodesk_data['finances']['meios_pagamento'].append(name)
        self.save_trello_data()
        self.update_payment_methods_listbox()
        self.populate_finance_comboboxes()
        self.payment_method_name_entry.delete(0, tk.END)
        messagebox.showinfo("Sucesso", f"Meio de pagamento '{name}' adicionado com sucesso!")

    def remove_payment_method(self):
        selected_index = self.payment_methods_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um meio de pagamento para remover.")
            return

        payment_method_name = self.payment_methods_listbox.get(selected_index[0])

        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover o meio de pagamento '{payment_method_name}'?"):
            self.boodesk_data['finances']['meios_pagamento'].remove(payment_method_name)
            self.save_trello_data()
            self.update_payment_methods_listbox()
            self.populate_finance_comboboxes()
            messagebox.showinfo("Sucesso", f"Meio de pagamento '{payment_method_name}' removido com sucesso!")

    def update_payment_methods_listbox(self):
        self.payment_methods_listbox.delete(0, tk.END)
        for method in self.boodesk_data['finances']['meios_pagamento']:
            self.payment_methods_listbox.insert(tk.END, method)

    def create_overview_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        overview_label_frame = ttk.LabelFrame(main_frame, text="Vis√£o Geral Financeira", padding="10")
        overview_label_frame.pack(fill=tk.X, pady=10)

        self.total_balance_label = ttk.Label(overview_label_frame, text="Saldo Total: R$ 0.00", font=("Helvetica", 16, "bold"))
        self.total_balance_label.pack(pady=10)

        # Menu de Relat√≥rios
        reports_menu_frame = ttk.Frame(main_frame)
        reports_menu_frame.pack(pady=5)

        reports_menubutton = ttk.Menubutton(reports_menu_frame, text="Relat√≥rios Financeiros", image=self.icons.get('chart_xy_icon'), compound=tk.LEFT, direction="below")
        reports_menubutton.pack()

        reports_menu = tk.Menu(reports_menubutton, tearoff=0)
        reports_menubutton["menu"] = reports_menu

        reports_menu.add_command(label="Relat√≥rio de Entradas (Em Breve)", command=lambda: messagebox.showinfo("Relat√≥rio", "Funcionalidade de Relat√≥rio de Entradas em desenvolvimento!"))
        reports_menu.add_command(label="Relat√≥rio de Sa√≠das (Em Breve)", command=lambda: messagebox.showinfo("Relat√≥rio", "Funcionalidade de Relat√≥rio de Sa√≠das em desenvolvimento!"))
        reports_menu.add_command(label="Relat√≥rio por Categoria (Em Breve)", command=lambda: messagebox.showinfo("Relat√≥rio", "Funcionalidade de Relat√≥rio por Categoria em desenvolvimento!"))
        reports_menu.add_command(label="Relat√≥rio de Contas (Em Breve)", command=lambda: messagebox.showinfo("Relat√≥rio", "Funcionalidade de Relat√≥rio de Contas em desenvolvimento!"))

        # Chart display area
        self.chart_frame = ttk.Frame(main_frame)
        self.chart_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        # Chart selection buttons
        chart_buttons_frame = ttk.Frame(main_frame)
        chart_buttons_frame.pack(pady=5)

        ttk.Button(chart_buttons_frame, text="Entradas vs Sa√≠das", image=self.icons.get('pie_chart_icon'), compound=tk.LEFT, command=lambda: self._show_chart("income_vs_expense")).pack(side=tk.LEFT, padx=5)
        ttk.Button(chart_buttons_frame, text="Entradas por Categoria", image=self.icons.get('bar_chart_icon'), compound=tk.LEFT, command=lambda: self._show_chart("income_by_category")).pack(side=tk.LEFT, padx=5)
        ttk.Button(chart_buttons_frame, text="Sa√≠das por Categoria", image=self.icons.get('bar_chart_icon'), compound=tk.LEFT, command=lambda: self._show_chart("expense_by_category")).pack(side=tk.LEFT, padx=5)

        self.current_chart_canvas = None
        self.current_chart_toolbar = None

        # Initial chart display
        self._show_chart("income_vs_expense")

    def update_total_balance_display(self):
        try:
            total_balance = sum(account['balance'] for account in self.boodesk_data['finances']['contas_bancarias'])
            if hasattr(self, 'total_balance_label'):
                self.total_balance_label.config(text=f"Saldo Total: R$ {total_balance:.2f}")
        except Exception as e:
            print(f"Erro ao atualizar saldo total: {e}")

    def _show_chart(self, chart_type):
        # Clear previous chart
        if self.current_chart_canvas:
            self.current_chart_canvas.get_tk_widget().destroy()
        if self.current_chart_toolbar:
            self.current_chart_toolbar.destroy()

        fig = None
        if chart_type == "income_vs_expense":
            fig = self._create_income_vs_expense_pie_chart()
        elif chart_type == "income_by_category":
            fig = self._create_income_by_category_bar_chart()
        elif chart_type == "expense_by_category":
            fig = self._create_expense_by_category_bar_chart()

        if fig:
            canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
            canvas_widget = canvas.get_tk_widget()
            canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
            self.current_chart_canvas = canvas

            toolbar = NavigationToolbar2Tk(canvas, self.chart_frame)
            toolbar.update()
            toolbar.pack(side=tk.BOTTOM, fill=tk.X)
            self.current_chart_toolbar = toolbar
            canvas.draw()

    def _create_income_vs_expense_pie_chart(self):
        incomes = sum(t['valor'] for t in self.boodesk_data['finances']['transacoes'] if t['tipo'] == 'Entrada')
        expenses = sum(t['valor'] for t in self.boodesk_data['finances']['transacoes'] if t['tipo'] == 'Sa√≠da')

        labels = ['Entradas', 'Sa√≠das']
        sizes = [incomes, expenses]
        colors = ['#4CAF50', '#F44336'] # Green for income, Red for expenses
        explode = (0.1, 0)  # explode 1st slice

        fig, ax = plt.subplots(figsize=(5, 4))

        if sum(sizes) == 0:
            ax.text(0.5, 0.5, "Sem dados para exibir", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=14, color='gray')
            ax.set_title('Entradas vs Sa√≠das')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            # Ensure sizes are not zero to prevent RuntimeWarning: invalid value encountered in divide
            # if sum(sizes) is 0.0, the warning occurs. Already handled by `if sum(sizes) == 0:`
            ax.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%',
                   shadow=True, startangle=140)
            ax.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
            ax.set_title('Entradas vs Sa√≠das')
        return fig

    def _create_income_by_category_bar_chart(self):
        income_by_category = {}
        for t in self.boodesk_data['finances']['transacoes']:
            if t['tipo'] == 'Entrada':
                category = t.get('categoria', 'Outros')
                income_by_category[category] = income_by_category.get(category, 0) + t['valor']

        categories = list(income_by_category.keys())
        values = list(income_by_category.values())

        fig, ax = plt.subplots(figsize=(7, 5))
        if not categories:
            ax.text(0.5, 0.5, "Sem dados de entrada por categoria", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=12, color='gray')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            ax.bar(categories, values, color='#4CAF50')
            ax.set_ylabel('Valor (R$)')
            ax.set_title('Entradas por Categoria')
            ax.tick_params(axis='x', rotation=45)
        plt.tight_layout()
        return fig

    def _create_expense_by_category_bar_chart(self):
        expense_by_category = {}
        for t in self.boodesk_data['finances']['transacoes']:
            if t['tipo'] == 'Sa√≠da':
                category = t.get('categoria', 'Outros')
                expense_by_category[category] = expense_by_category.get(category, 0) + t['valor']

        categories = list(expense_by_category.keys())
        values = list(expense_by_category.values())

        fig, ax = plt.subplots(figsize=(7, 5))
        if not categories:
            ax.text(0.5, 0.5, "Sem dados de sa√≠da por categoria", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, fontsize=12, color='gray')
            ax.set_xticks([])
            ax.set_yticks([])
        else:
            ax.bar(categories, values, color='#F44336')
            ax.set_ylabel('Valor (R$)')
            ax.set_title('Sa√≠das por Categoria')
            ax.tick_params(axis='x', rotation=45)
        plt.tight_layout()
        return fig

    def create_pomodoro_timer_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        top_frame = ttk.Frame(main_frame)
        top_frame.pack(fill=tk.X, pady=10)

        timer_frame = ttk.Frame(top_frame)
        timer_frame.pack(side=tk.LEFT, expand=True, fill=tk.X)
        self.pomodoro_timer_label = ttk.Label(timer_frame, text="", font=("Helvetica", 48))
        self.pomodoro_timer_label.pack()
        self.pomodoro_cycle_label = ttk.Label(timer_frame, text="", font=("Helvetica", 14))
        self.pomodoro_cycle_label.pack()

        stats_frame = ttk.LabelFrame(top_frame, text="Estat√≠sticas do Pomodoro")
        stats_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
        self.pomodoro_completed_label = ttk.Label(stats_frame, text="", font=("Helvetica", 12))
        self.pomodoro_completed_label.pack(padx=10, pady=5)
        self.pomodoro_pending_label = ttk.Label(stats_frame, text="", font=("Helvetica", 12))
        self.pomodoro_pending_label.pack(padx=10, pady=5)

        self.message_label = ttk.Label(main_frame, text="", font=("Helvetica", 12, "italic"))
        self.message_label.pack(pady=10)

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=10)
        self.start_button = ttk.Button(button_frame, text="Iniciar", image=self.icons.get('play_icon'), compound=tk.LEFT, command=self.start_timer)
        self.start_button.pack(side=tk.LEFT, padx=5)
        self.pause_button = ttk.Button(button_frame, text="Pausar", image=self.icons.get('stop_icon'), compound=tk.LEFT, command=self.pause_timer, state=tk.DISABLED)
        self.pause_button.pack(side=tk.LEFT, padx=5)
        self.reset_button = ttk.Button(button_frame, text="Reiniciar", image=self.icons.get('refresh_icon'), compound=tk.LEFT, command=self.reset_timer)
        self.reset_button.pack(side=tk.LEFT, padx=5)
        self.skip_button = ttk.Button(button_frame, text="Pular", image=self.icons.get('forward_icon'), compound=tk.LEFT, command=self.skip_cycle)
        self.skip_button.pack(side=tk.LEFT, padx=5)

        task_frame = ttk.LabelFrame(main_frame, text="Tarefas do Pomodoro")
        task_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        self.pomodoro_task_list = ttk.Treeview(task_frame, columns=("Tarefa", "Status", "Assunto", "Objetivo"), show="headings")
        self.pomodoro_task_list.heading("Tarefa", text="Tarefa")
        self.pomodoro_task_list.heading("Status", text="Status")
        self.pomodoro_task_list.heading("Assunto", text="Assunto")
        self.pomodoro_task_list.heading("Objetivo", text="Objetivo")
        self.pomodoro_task_list.column("Tarefa", width=250, anchor="w")
        self.pomodoro_task_list.column("Status", width=100, anchor="center")
        self.pomodoro_task_list.column("Assunto", width=150, anchor="w")
        self.pomodoro_task_list.column("Objetivo", width=150, anchor="w")
        self.pomodoro_task_list.pack(fill=tk.BOTH, expand=True)
        self.pomodoro_task_list.bind("<<TreeviewSelect>>", self.on_pomodoro_task_select)

        task_button_frame = ttk.Frame(task_frame)
        task_button_frame.pack(pady=5)
        self.add_task_entry = ttk.Entry(task_button_frame, width=40)
        self.add_task_entry.pack(side=tk.LEFT, padx=5)
        ttk.Button(task_button_frame, text="Adicionar Tarefa", image=self.icons.get('add_icon'), compound=tk.LEFT, command=self.add_pomodoro_task).pack(side=tk.LEFT, padx=5)
        ttk.Button(task_button_frame, text="Remover Selecionada", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=self.remove_pomodoro_task).pack(side=tk.LEFT, padx=5)
        ttk.Button(task_button_frame, text="Concluir Selecionada", image=self.icons.get('ok_icon'), compound=tk.LEFT, command=self.complete_pomodoro_task).pack(side=tk.LEFT, padx=5)

    def create_my_activities_tab(self, parent):
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # PanedWindow para dividir a tela elegantemente
        paned_window = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        paned_window.pack(fill=tk.BOTH, expand=True)

        # Frame da esquerda para a tabela
        left_frame = ttk.Frame(paned_window, padding="5")
        paned_window.add(left_frame, weight=2)

        # Frame da direita para as informa√ß√µes
        right_frame = ttk.LabelFrame(paned_window, text="Detalhes da Atividade", padding="10")
        paned_window.add(right_frame, weight=1)

        # Tabela de atividades (esquerda) - exatamente como no app23a copy 13.py
        self.activities_tree = ttk.Treeview(left_frame, columns=("Tipo", "T√≠tulo", "Sub"), show="headings")
        self.activities_tree.heading("Tipo", text="Tipo")
        self.activities_tree.heading("T√≠tulo", text="T√≠tulo")
        self.activities_tree.heading("Sub", text="Sub")
        self.activities_tree.column("Tipo", width=80, anchor="w")
        self.activities_tree.column("T√≠tulo", width=250, anchor="w")
        self.activities_tree.column("Sub", width=40, anchor="center")

        # Configurar tags de cor para import√¢ncia
        for importance, color in self.settings.get("importance_colors", {}).items():
            self.activities_tree.tag_configure(importance, background=color)

        self.activities_tree.pack(fill=tk.BOTH, expand=True)

        self.activities_tree.bind("<<TreeviewSelect>>", self.on_activity_select)
        self.activities_tree.bind("<Double-1>", self.on_activity_double_click)

        bold_font = ("Helvetica", 9, "bold")

        # === WIDGETS PARA DETALHES (baseado no app23a copy 13.py) ===
        # Labels para informa√ß√µes (direita)
        ttk.Label(right_frame, text="Descri√ß√£o:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_desc_text = tk.Text(right_frame, height=5, wrap=tk.WORD, state="disabled")
        self.activity_desc_text.pack(fill=tk.X, pady=2)

        ttk.Label(right_frame, text="Prazo:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_due_date_label = ttk.Label(right_frame, text="-")
        self.activity_due_date_label.pack(anchor="w", pady=2)

        ttk.Label(right_frame, text="Membros:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_members_label = ttk.Label(right_frame, text="-")
        self.activity_members_label.pack(anchor="w", pady=2)

        ttk.Label(right_frame, text="Depend√™ncias:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_dependencies_label = ttk.Label(right_frame, text="-")
        self.activity_dependencies_label.pack(anchor="w", pady=2)

        ttk.Label(right_frame, text="Subtarefas:", font=bold_font).pack(anchor="w", pady=2)
        self.activity_subtasks_text = tk.Text(right_frame, height=5, wrap=tk.WORD, state="disabled")
        self.activity_subtasks_text.pack(fill=tk.X, pady=2)

        # Bot√µes de A√ß√£o
        action_frame = ttk.Frame(right_frame)
        action_frame.pack(fill=tk.X, pady=10)
        ttk.Button(action_frame, text="Ir para o Quadro", image=self.icons.get('forward_icon_32'), compound=tk.LEFT, command=self.go_to_board_from_activity, style='Uniform.TButton').pack(side=tk.LEFT, padx=5)
        ttk.Button(action_frame, text="Abrir Card", image=self.icons.get('open_file_icon_32'), compound=tk.LEFT, command=self.open_card_from_activity, style='Uniform.TButton').pack(side=tk.LEFT, padx=5)
        ttk.Button(action_frame, text="Anota√ß√µes", image=self.icons.get('save_icon_32'), compound=tk.LEFT, command=self.open_notes_editor, style='Uniform.TButton').pack(side=tk.LEFT, padx=5)
        
        # Bot√£o para detalhes da subtarefa (vis√≠vel apenas quando uma subtarefa est√° selecionada)
        self.subtask_details_button = ttk.Button(action_frame, text="Detalhes da Subtarefa", image=self.icons.get('ai_icon_32'), compound=tk.LEFT, command=self.show_subtask_detailed_info, style='Uniform.TButton')
        self.subtask_details_button.pack(side=tk.LEFT, padx=5)
        self.subtask_details_button.pack_forget()  # Inicialmente oculto
        
        # Bot√£o para concluir subtarefa (vis√≠vel apenas quando uma subtarefa est√° selecionada)
        self.complete_subtask_button = ttk.Button(action_frame, text="Concluir Subtarefa", image=self.icons.get('check_white_icon_32'), compound=tk.LEFT, command=self.complete_selected_subtask, style='Uniform.TButton')
        self.complete_subtask_button.pack(side=tk.LEFT, padx=5)
        self.complete_subtask_button.pack_forget()  # Inicialmente oculto

        # Bot√£o para atualizar
        ttk.Button(main_frame, text="Atualizar", image=self.icons.get('refresh_icon_32'), compound=tk.LEFT, command=self.update_my_activities_tab).pack(pady=5)

        # Legenda de Cores
        legend_frame = ttk.Frame(main_frame)
        legend_frame.pack(fill=tk.X, pady=5, side=tk.BOTTOM)
        ttk.Label(legend_frame, text="Legenda:", font=("Helvetica", 8, "bold")).pack(side=tk.LEFT, padx=5)
        for imp, color in self.settings.get("importance_colors", {}).items():
            ttk.Label(legend_frame, text=imp, background=color, font=("Helvetica", 8)).pack(side=tk.LEFT, padx=2)

        self.update_my_activities_tab()

    def update_my_activities_tab(self):
        """Atualiza a aba 'Minhas Atividades' com os cards e subtarefas do usu√°rio logado"""
        for i in self.activities_tree.get_children():
            self.activities_tree.delete(i)

        if not self.current_user:
            return

        # Obter o membro associado ao usu√°rio logado
        current_user_member = self._get_current_user_member()
        
        all_cards = self.get_all_cards()

        # Filtrar cards baseado no papel do usu√°rio
        if self.check_admin_access():
            # Administradores veem todos os cards
            user_cards = all_cards
        else:
            # Usu√°rios normais veem apenas cards onde s√£o membros
            if current_user_member:
                user_cards = [
                    card_info for card_info in all_cards
                    if current_user_member in card_info['card'].get('members', []) and
                    not card_info['card'].get("is_archived", False)
                ]
            else:
                # Se n√£o tem membro associado, n√£o mostra nenhum card
                user_cards = []

        row_count = 0

        for card_info in user_cards:
            card = card_info['card']
            card_id = card.get('card_id')
            if not card_id:
                continue

            importance_tag = card.get("importance", "Normal")
            
            # Buscar subtarefas do banco de dados para este card
            subtasks = self.get_subtasks_for_card(card_id)
            has_subtasks_indicator = f"({len(subtasks)})" if subtasks else ""

            # Definir tags para linha alternada
            row_tag = "evenrow" if row_count % 2 == 0 else "oddrow"

            # Insert the parent card, using its card_id as the iid and in the tags
            self.activities_tree.insert(
                "", "end",
                iid=card_id,
                values=("Tarefa", card['title'], has_subtasks_indicator),
                tags=(card_id, importance_tag, row_tag)
            )
            row_count += 1

            # Add subtasks from database, also tagging them with the parent card_id
            if subtasks:
                for subtask in subtasks:
                    subtask_id = subtask.get('id')
                    if subtask_id:
                        # Determinar status da subtarefa
                        status_icon = "‚úì" if subtask.get('completed') else "‚óã"
                        subtask_text = f"{status_icon} {subtask.get('text', '')}"
                        
                        # Tag para subtarefa
                        subtask_row_tag = "evenrow" if row_count % 2 == 0 else "oddrow"
                        
                        self.activities_tree.insert(
                            card_id, "end",
                            iid=f"subtask_{subtask_id}",
                            values=("Subtarefa", subtask_text, ""),
                            tags=(card_id, "subtask", subtask_row_tag)
                        )
                        row_count += 1

        # Adicionar subtarefas individuais do usu√°rio (n√£o apenas as dos cards)
        user_subtasks = self.get_user_subtasks()
        if user_subtasks:
            # Adicionar um separador visual
            self.activities_tree.insert(
                "", "end",
                iid="separator_subtasks",
                values=("", "--- Subtarefas Individuais ---", ""),
                tags=("separator",)
            )
            row_count += 1
            
            for subtask in user_subtasks:
                subtask_id = subtask.get('id')
                if subtask_id:
                    # Determinar status da subtarefa
                    status_icon = "‚úì" if subtask.get('completed') else "‚óã"
                    subtask_text = f"{status_icon} {subtask.get('text', '')}"
                    
                    # Tag para subtarefa individual
                    subtask_row_tag = "evenrow" if row_count % 2 == 0 else "oddrow"
                    
                    self.activities_tree.insert(
                        "", "end",
                        iid=f"subtask_{subtask_id}",
                        values=("Subtarefa", subtask_text, ""),
                        tags=("individual_subtask", "subtask", subtask_row_tag)
                    )
                    row_count += 1



    def on_activity_double_click(self, event):
        item_id = self.activities_tree.identify_row(event.y)
        if not item_id:
            return

        item_type = self.activities_tree.item(item_id, "values")[0]
        if item_type == "Subtarefa":
            # Extrair o ID da subtarefa do item_id (formato: "subtask_123")
            if item_id.startswith("subtask_"):
                subtask_id = int(item_id.split("_")[1])
                subtask = self.get_subtask_by_id(subtask_id)
                if subtask:
                    # Alternar status da subtarefa (marcar/desmarcar como conclu√≠da)
                    self.toggle_subtask_completion(subtask_id, subtask)
                    return
            else:
                # Fallback para o m√©todo antigo
                parent_id = self.activities_tree.parent(item_id)
    
    def toggle_subtask_completion(self, subtask_id, subtask):
        """Alterna o status de conclus√£o de uma subtarefa"""
        try:
            # Alternar o status
            new_status = not subtask.get('completed', False)
            
            # Atualizar no banco de dados
            conn = self.db.get_connection()
            if conn:
                cursor = conn.cursor()
                cursor.execute(
                    "UPDATE subtasks SET completed = %s, updated_at = NOW() WHERE id = %s",
                    (new_status, subtask_id)
                )
                conn.commit()
                cursor.close()
                
                # Atualizar a interface
                self.update_my_activities_tab()
                
                # Mostrar mensagem de confirma√ß√£o
                status_text = "conclu√≠da" if new_status else "desmarcada como conclu√≠da"
                messagebox.showinfo("Sucesso", f"Subtarefa '{subtask.get('title', '')}' foi {status_text}!")
            else:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel conectar ao banco de dados")
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao atualizar subtarefa: {e}")
            print(f"Erro ao alternar conclus√£o da subtarefa: {e}")
    
    def get_user_subtasks(self):
        """Busca subtarefas individuais do usu√°rio logado"""
        try:
            if not self.current_user:
                return []
            
            user_id = self.get_current_user_id()
            if not user_id:
                return []
            
            conn = self.db.get_connection()
            if not conn:
                return []
            
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id, title, completed, created_at, updated_at, card_id
                FROM subtasks 
                WHERE created_by = %s
                ORDER BY created_at DESC
            """, (user_id,))
            
            subtasks = []
            for row in cursor.fetchall():
                subtask = {
                    'id': row[0],
                    'text': row[1],
                    'completed': row[2],
                    'created_at': row[3],
                    'updated_at': row[4],
                    'card_id': row[5]
                }
                subtasks.append(subtask)
            
            cursor.close()
            return subtasks
            
        except Exception as e:
            print(f"Erro ao buscar subtarefas do usu√°rio: {e}")
            return []

    def go_to_board_from_activity(self):
        """Navega para o quadro da atividade selecionada"""
        selected_item_id = self.activities_tree.selection()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione uma atividade para navegar.", parent=self.root)
            return

        item_id = selected_item_id[0]
        
        # If it's a subtask, get the parent card's ID
        parent_id = self.activities_tree.parent(item_id)
        if parent_id:
            item_id = parent_id

        card_info = self.find_card_and_board_by_id(item_id)
        if card_info:
            board_name = card_info["board_name"]
            
            # Find the index of the 'Quadros' tab in the main notebook
            boards_tab_index = -1
            for i, tab in enumerate(self.main_notebook.tabs()):
                if self.main_notebook.tab(i, "text") == 'Quadros':
                    boards_tab_index = i
                    break
            
            if boards_tab_index != -1:
                self.main_notebook.select(boards_tab_index)
                
                # Now find and select the specific board's tab
                for i, tab in enumerate(self.board_notebook.tabs()):
                    if self.board_notebook.tab(i, "text") == board_name:
                        self.board_notebook.select(i)
                        break

    def open_card_from_activity(self, event=None):
        """Abre o card da atividade selecionada"""
        selected_item_id = self.activities_tree.selection()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione uma atividade para abrir.", parent=self.root)
            return

        item_id = selected_item_id[0]
        tags = self.activities_tree.item(item_id, "tags")

        if not tags:
            messagebox.showerror("Erro", "O item selecionado n√£o tem um ID de cart√£o associado.", parent=self.root)
            return

        card_id = tags[0]  # The card_id is the first tag
        card_info = self.find_card_and_board_by_id(card_id)

        if card_info:
            CardWindow(self.root, self, card_info["board_name"], card_info["list_name"], card_info["card"], self.current_user)
        else:
            messagebox.showerror("Erro", f"Cart√£o com ID '{card_id}' n√£o encontrado. Pode ter sido movido ou removido.", parent=self.root)

    def on_activity_select(self, event):
        selected_item = self.activities_tree.selection()
        if not selected_item:
            return

        item_id = selected_item[0]
        item_values = self.activities_tree.item(item_id, "values")
        item_type = item_values[0] if item_values else ""
        item_tags = self.activities_tree.item(item_id, "tags")
        
        # Verificar se √© uma subtarefa
        if item_type == "Subtarefa":
            # Extrair o ID da subtarefa do item_id (formato: "subtask_123")
            if item_id.startswith("subtask_"):
                subtask_id = int(item_id.split("_")[1])
                subtask = self.get_subtask_by_id(subtask_id)
                if subtask:
                    self.show_subtask_details_for_selection(subtask)
                    return
        
        # Verificar se √© um separador
        if "separator" in item_tags:
            return
        
        # Se n√£o √© subtarefa, tratar como card (comportamento original)
        card_id = item_tags[0]
        card_info = self.find_card_and_board_by_id(card_id)

        if not card_info:
            return

        card = card_info['card']
        self.show_card_details_in_activity_panel(card)

    def show_subtask_details_for_selection(self, subtask):
        """Mostra os detalhes de uma subtarefa no painel direito quando selecionada"""
        # --- Clear and prepare the details view ---
        self.activity_desc_text.config(state="normal")
        self.activity_desc_text.delete("1.0", tk.END)
        self.activity_subtasks_text.config(state="normal")
        self.activity_subtasks_text.delete("1.0", tk.END)

        # --- Configure fonts ---
        bold_font = ("Helvetica", 9, "bold")
        normal_font = ("Helvetica", 9)

        # --- Populate subtask details ---
        self.activity_due_date_label.config(text="-")  # Subtarefas n√£o t√™m prazo pr√≥prio
        self.activity_members_label.config(text="-")   # Subtarefas n√£o t√™m membros pr√≥prios
        self.activity_dependencies_label.config(text="-")  # Subtarefas n√£o t√™m depend√™ncias pr√≥prias

        # Mostrar descri√ß√£o da subtarefa
        self.activity_desc_text.insert("1.0", subtask.get("desc", "Sem descri√ß√£o."))

        # Mostrar informa√ß√µes da subtarefa
        self.activity_subtasks_text.tag_configure("bold", font=bold_font)
        
        # Status da subtarefa
        status = "‚úì Conclu√≠da" if subtask.get('completed') else "‚óã Pendente"
        self.activity_subtasks_text.insert(tk.END, f"Status: {status}\n\n", "bold")
        
        # T√≠tulo da subtarefa
        self.activity_subtasks_text.insert(tk.END, f"T√≠tulo: {subtask.get('text', '')}\n", "bold")
        
        # Data de cria√ß√£o se dispon√≠vel
        if subtask.get('created_at'):
            self.activity_subtasks_text.insert(tk.END, f"Criada em: {subtask.get('created_at')}\n")
        
        # Informa√ß√µes do card pai
        card = self.find_card_by_id(subtask.get('card_id'))
        if card:
            self.activity_subtasks_text.insert(tk.END, f"\nCard pai: {card.get('title', '')}\n", "bold")

        # --- Set text widgets to disabled ---
        self.activity_desc_text.config(state="disabled")
        self.activity_subtasks_text.config(state="disabled")
        
        # Armazenar a subtarefa selecionada para uso nos bot√µes
        self.selected_subtask = subtask
        
        # Sempre mostrar os bot√µes quando uma subtarefa √© selecionada
        self.subtask_details_button.pack(side=tk.LEFT, padx=5)
        self.complete_subtask_button.pack(side=tk.LEFT, padx=5)
        
        # Configurar o texto e √≠cone do bot√£o baseado no status da subtarefa
        if subtask.get('completed'):
            self.complete_subtask_button.config(
                text="‚úì J√° Conclu√≠da", 
                state="disabled",
                image=self.icons.get('check_completed_icon_32')
            )
        else:
            self.complete_subtask_button.config(
                text="Concluir Subtarefa", 
                state="normal",
                image=self.icons.get('check_white_icon_32')
            )

    def show_card_details_in_activity_panel(self, card):
        """Mostra os detalhes de um card no painel direito (comportamento original)"""
        # --- Clear and prepare the details view ---
        self.activity_desc_text.config(state="normal")
        self.activity_desc_text.delete("1.0", tk.END)
        self.activity_subtasks_text.config(state="normal")
        self.activity_subtasks_text.delete("1.0", tk.END)

        # --- Configure fonts ---
        bold_font = ("Helvetica", 9, "bold")
        normal_font = ("Helvetica", 9)

        # --- Populate details ---
        self.activity_due_date_label.config(text=card.get("due_date", "-"))
        self.activity_members_label.config(text=", ".join(card.get("members", [])) or "-")
        self.activity_dependencies_label.config(text=", ".join(card.get("dependencies", [])) or "-")

        self.activity_desc_text.insert("1.0", card.get("desc", "Sem descri√ß√£o."))

        # --- Populate Subtasks with formatting ---
        self.activity_subtasks_text.tag_configure("bold", font=bold_font)
        
        # Buscar subtarefas do banco de dados
        subtasks = self.get_subtasks_for_card(card.get('card_id'))
        if not subtasks:
            self.activity_subtasks_text.insert("1.0", "Nenhuma subtarefa.")
        else:
            # Contadores para estat√≠sticas
            completed_count = sum(1 for s in subtasks if s.get('completed'))
            total_count = len(subtasks)
            self.activity_subtasks_text.insert(tk.END, f"Progresso: {completed_count}/{total_count} subtarefas conclu√≠das\n\n", "bold")
            
            for subtask in subtasks:
                status = "‚úì" if subtask.get('completed') else "‚óã"
                self.activity_subtasks_text.insert(tk.END, f"{status} ")
                self.activity_subtasks_text.insert(tk.END, f"{subtask.get('text', '')}\n", "bold")
                if subtask.get('desc'):
                    self.activity_subtasks_text.insert(tk.END, f"  - {subtask.get('desc')}\n")
                # Adicionar data de cria√ß√£o se dispon√≠vel
                if subtask.get('created_at'):
                    self.activity_subtasks_text.insert(tk.END, f"  Criada em: {subtask.get('created_at')}\n")
                self.activity_subtasks_text.insert(tk.END, "\n")

        # --- Set text widgets to disabled ---
        self.activity_desc_text.config(state="disabled")
        self.activity_subtasks_text.config(state="disabled")
        
        # Limpar subtarefa selecionada e ocultar bot√µes de subtarefa
        self.selected_subtask = None
        self.subtask_details_button.pack_forget()
        self.complete_subtask_button.pack_forget()
    
    def show_subtask_details(self, item_id):
        """Mostra detalhes de uma subtarefa individual"""
        try:
            # Extrair o ID da subtarefa do item_id (formato: "subtask_123")
            if item_id.startswith("subtask_"):
                subtask_id = int(item_id.split("_")[1])
                subtask = self.get_subtask_by_id(subtask_id)
                
                if subtask:
                    # Limpar campos
                    self.activity_desc_text.config(state="normal")
                    self.activity_desc_text.delete("1.0", tk.END)
                    self.activity_subtasks_text.config(state="normal")
                    self.activity_subtasks_text.delete("1.0", tk.END)
                    
                    # Configurar fontes
                    bold_font = ("Helvetica", 9, "bold")
                    self.activity_subtasks_text.tag_configure("bold", font=bold_font)
                    
                    # Mostrar detalhes da subtarefa
                    self.activity_desc_text.insert("1.0", f"Subtarefa: {subtask.get('title', '')}")
                    
                    # Informa√ß√µes da subtarefa
                    status = "‚úì Conclu√≠da" if subtask.get('completed') else "‚óã Pendente"
                    self.activity_subtasks_text.insert(tk.END, f"Status: {status}\n", "bold")
                    
                    if subtask.get('created_at'):
                        self.activity_subtasks_text.insert(tk.END, f"Criada em: {subtask.get('created_at')}\n")
                    
                    if subtask.get('updated_at'):
                        self.activity_subtasks_text.insert(tk.END, f"Atualizada em: {subtask.get('updated_at')}\n")
                    
                    if subtask.get('card_id'):
                        # Buscar informa√ß√µes do card pai
                        card = self.find_card_by_id(subtask.get('card_id'))
                        if card:
                            self.activity_subtasks_text.insert(tk.END, f"\nCard pai: {card.get('title', '')}\n", "bold")
                    
                    # Desabilitar campos
                    self.activity_desc_text.config(state="disabled")
                    self.activity_subtasks_text.config(state="disabled")
                    
                    # Limpar outros campos
                    self.activity_due_date_label.config(text="-")
                    self.activity_members_label.config(text="-")
                    self.activity_dependencies_label.config(text="-")
                    
        except Exception as e:
            print(f"Erro ao mostrar detalhes da subtarefa: {e}")
            messagebox.showerror("Erro", f"Erro ao mostrar detalhes da subtarefa: {e}")

    def complete_selected_subtask(self):
        """Marca a subtarefa selecionada como conclu√≠da"""
        if not hasattr(self, 'selected_subtask') or not self.selected_subtask:
            messagebox.showwarning("Nenhuma Subtarefa Selecionada", "Por favor, selecione uma subtarefa para concluir.", parent=self.root)
            return
        
        subtask = self.selected_subtask
        
        # Verificar se a subtarefa j√° est√° conclu√≠da
        if subtask.get('completed'):
            messagebox.showinfo("Subtarefa J√° Conclu√≠da", "Esta subtarefa j√° est√° marcada como conclu√≠da.", parent=self.root)
            return
        
        try:
            # Marcar a subtarefa como conclu√≠da no banco de dados
            success = self.db.complete_subtask(subtask.get('id'))
            
            if success:
                # Atualizar a interface
                messagebox.showinfo("Sucesso", f"Subtarefa '{subtask.get('text', '')}' marcada como conclu√≠da!", parent=self.root)
                
                # Atualizar a lista de atividades
                self.update_my_activities_tab()
                
                # Atualizar os detalhes da subtarefa
                updated_subtask = self.get_subtask_by_id(subtask.get('id'))
                if updated_subtask:
                    self.selected_subtask = updated_subtask
                    self.show_subtask_details_for_selection(updated_subtask)
            else:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel marcar a subtarefa como conclu√≠da.", parent=self.root)
                
        except Exception as e:
            print(f"Erro ao concluir subtarefa: {e}")
            messagebox.showerror("Erro", f"Erro ao concluir subtarefa: {e}", parent=self.root)

    def show_subtask_detailed_info(self):
        """Abre a janela de detalhes da subtarefa (mesma tela do bot√£o 'Abrir Subtarefa')"""
        if not hasattr(self, 'selected_subtask') or not self.selected_subtask:
            messagebox.showwarning("Nenhuma Subtarefa Selecionada", "Por favor, selecione uma subtarefa para ver os detalhes.", parent=self.root)
            return
        
        subtask = self.selected_subtask
        
        try:
            # Buscar card pai
            card = self.find_card_by_id(subtask.get('card_id'))
            if card:
                # Abrir a mesma janela que o bot√£o "Abrir Subtarefa" usa
                SubTaskDetailWindow(self, card, subtask)
            else:
                messagebox.showerror("Erro", "Card pai n√£o encontrado.", parent=self.root)
                
        except Exception as e:
            print(f"Erro ao abrir detalhes da subtarefa: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir detalhes da subtarefa: {e}", parent=self.root)

    def find_card_by_id(self, card_id):
        for board_name, lists in self.boodesk_data["boards"].items():
            if board_name == "workflow": continue
            for list_name, cards in lists.items():
                for card in cards:
                    if card.get('card_id') == card_id:
                        return card
        return None

    def find_subtask_by_id(self, card, subtask_id):
        if card and "subtasks" in card:
            for subtask in card["subtasks"]:
                if subtask.get("id") == subtask_id:
                    return subtask
        return None

    def get_subtasks_for_card(self, card_id):
        """Busca subtarefas do banco de dados para um card espec√≠fico"""
        try:
            # Usar PostgreSQL atrav√©s do self.db
            subtasks = self.db.get_subtasks_for_card(card_id)
            
            # Converter para o formato esperado pela aplica√ß√£o
            formatted_subtasks = []
            for subtask in subtasks:
                try:
                    formatted_subtask = {
                        'id': subtask.get('id'),
                        'text': subtask.get('title', '') if subtask.get('title') else '',
                        'desc': subtask.get('description', '') if subtask.get('description') else '',
                        'completed': subtask.get('completed', False),
                        'position': subtask.get('position', 0),
                        'created_at': subtask.get('created_at', '') if subtask.get('created_at') else ''
                    }
                    formatted_subtasks.append(formatted_subtask)
                except Exception as e:
                    print(f"Erro ao processar subtarefa {subtask.get('id')}: {e}")
                    continue
            
            return formatted_subtasks
            
        except Exception as e:
            print(f"Erro ao buscar subtarefas para card {card_id}: {e}")
            return []

    def get_subtask_by_id(self, subtask_id):
        """Busca uma subtarefa espec√≠fica do banco de dados"""
        try:
            # Usar PostgreSQL atrav√©s do self.db
            subtask = self.db.get_subtask_by_id(subtask_id)
            
            if subtask:
                return {
                    'id': subtask.get('id'),
                    'card_id': subtask.get('card_id') or subtask.get('parent_card_id'),
                    'text': subtask.get('title', ''),
                    'desc': subtask.get('description', ''),
                    'completed': subtask.get('completed', False),
                    'position': subtask.get('position', 0),
                    'created_at': subtask.get('created_at', '')
                }
            return None
            
        except Exception as e:
            print(f"Erro ao buscar subtarefa {subtask_id}: {e}")
            return None

    def migrate_subtasks_to_database(self):
        """Migra subtarefas existentes do JSON para o banco de dados"""
        try:
            # Verificar se j√° existem subtarefas no banco
            existing_subtasks = self.db.get_subtasks_for_card("test")
            if existing_subtasks:
                print(f"J√° existem subtarefas no banco de dados PostgreSQL. Pulando migra√ß√£o.")
                return
            
            print("Iniciando migra√ß√£o de subtarefas do JSON para o banco de dados PostgreSQL...")
            
            migrated_count = 0
            
            # Percorrer todos os cards e suas subtarefas
            for board_name, lists in self.boodesk_data["boards"].items():
                if board_name == "workflow": 
                    continue
                    
                for list_name, cards in lists.items():
                    for card in cards:
                        card_id = card.get('card_id')
                        if not card_id:
                            continue
                            
                        subtasks = card.get('subtasks', [])
                        if subtasks:
                            for i, subtask in enumerate(subtasks):
                                try:
                                    # Usar PostgreSQL atrav√©s do self.db
                                    self.db.create_subtask(
                                        card_id=card_id,
                                        title=subtask.get('text', ''),
                                        description=subtask.get('desc', ''),
                                        completed=subtask.get('completed', False),
                                        user_id=None
                                    )
                                    migrated_count += 1
                                except Exception as e:
                                    print(f"Erro ao migrar subtarefa do card {card_id}: {e}")
            
            print(f"Migra√ß√£o conclu√≠da! {migrated_count} subtarefas migradas para o banco de dados PostgreSQL.")
            
        except Exception as e:
            print(f"Erro durante a migra√ß√£o de subtarefas: {e}")

    # M√©todos para funcionalidades avan√ßadas de subtarefas
    def get_subtask_files(self, subtask_id):
        """Busca arquivos de uma subtarefa"""
        try:
            return self.db.get_subtask_files(subtask_id)
        except Exception as e:
            print(f"Erro ao buscar arquivos da subtarefa: {e}")
            return []
    
    def add_subtask_file(self, subtask_id, file_path, user_id):
        """Adiciona arquivo a uma subtarefa"""
        try:
            return self.db.add_subtask_file(subtask_id, file_path, user_id)
        except Exception as e:
            print(f"Erro ao adicionar arquivo √† subtarefa: {e}")
            raise e
    
    def get_subtask_file_by_name(self, subtask_id, filename):
        """Busca arquivo espec√≠fico de uma subtarefa"""
        try:
            return self.db.get_subtask_file_by_name(subtask_id, filename)
        except Exception as e:
            print(f"Erro ao buscar arquivo da subtarefa: {e}")
            return None
    
    def remove_subtask_file(self, subtask_id, filename):
        """Remove arquivo de uma subtarefa"""
        try:
            return self.db.remove_subtask_file(subtask_id, filename)
        except Exception as e:
            print(f"Erro ao remover arquivo da subtarefa: {e}")
            raise e
    
    def get_subtask_comments(self, subtask_id):
        """Busca coment√°rios de uma subtarefa"""
        try:
            return self.db.get_subtask_comments(subtask_id)
        except Exception as e:
            print(f"Erro ao buscar coment√°rios da subtarefa: {e}")
            return []
    
    def add_subtask_comment(self, subtask_id, comment_text, user_id):
        """Adiciona coment√°rio a uma subtarefa"""
        try:
            return self.db.add_subtask_comment(subtask_id, comment_text, user_id)
        except Exception as e:
            print(f"Erro ao adicionar coment√°rio √† subtarefa: {e}")
            raise e
    
    def get_subtask_history(self, subtask_id):
        """Busca hist√≥rico de uma subtarefa"""
        try:
            return self.db.get_subtask_history(subtask_id)
        except Exception as e:
            print(f"Erro ao buscar hist√≥rico da subtarefa: {e}")
            return []
    
    def update_subtask_description(self, subtask_id, description):
        """Atualiza descri√ß√£o de uma subtarefa"""
        try:
            return self.db.update_subtask_description(subtask_id, description)
        except Exception as e:
            print(f"Erro ao atualizar descri√ß√£o da subtarefa: {e}")
            raise e
    
    def update_subtask_title(self, subtask_id, title):
        """Atualiza t√≠tulo de uma subtarefa"""
        try:
            return self.db.update_subtask_title(subtask_id, title)
        except Exception as e:
            print(f"Erro ao atualizar t√≠tulo da subtarefa: {e}")
            raise e
    
    def update_subtask_responsible(self, subtask_id, responsible):
        """Atualiza respons√°vel de uma subtarefa"""
        try:
            return self.db.update_subtask_responsible(subtask_id, responsible)
        except Exception as e:
            print(f"Erro ao atualizar respons√°vel da subtarefa: {e}")
            raise e
    
    def update_subtask_priority(self, subtask_id, priority):
        """Atualiza prioridade de uma subtarefa"""
        try:
            return self.db.update_subtask_priority(subtask_id, priority)
        except Exception as e:
            print(f"Erro ao atualizar prioridade da subtarefa: {e}")
            raise e
    
    # M√©todos para gerenciar subtarefas na aba de produtividade
    def load_my_subtasks(self):
        """Carrega subtarefas delegadas ao usu√°rio atual"""
        try:
            # Limpar treeview
            for item in self.my_subtasks_tree.get_children():
                self.my_subtasks_tree.delete(item)
            
            if not self.current_user:
                return
            
            # Obter membro do usu√°rio atual
            current_user_member = self._get_current_user_member()
            if not current_user_member:
                return
            
            # Buscar todas as subtarefas do banco
            all_subtasks = []
            all_cards = self.get_all_cards()
            
            for card_info in all_cards:
                card = card_info['card']
                card_id = card.get('card_id')
                if card_id:
                    subtasks = self.get_subtasks_for_card(card_id)
                    for subtask in subtasks:
                        # Verificar se a subtarefa foi delegada para o usu√°rio atual
                        assigned_member = subtask.get('assigned_member')
                        if assigned_member == current_user_member:
                            # Adicionar informa√ß√µes do card pai
                            subtask['card_title'] = card.get('title', '')
                            subtask['board_name'] = card_info.get('board_name', '')
                            subtask['list_name'] = card_info.get('list_name', '')
                            all_subtasks.append(subtask)
            
            # Inserir no treeview
            for subtask in all_subtasks:
                status = "Conclu√≠da" if subtask.get('completed') else "Pendente"
                priority = subtask.get('priority', 'Normal')
                created_at = subtask.get('created_at', '')
                if created_at:
                    # Formatar data se necess√°rio
                    if isinstance(created_at, str) and len(created_at) > 10:
                        created_at = created_at[:10]
                
                self.my_subtasks_tree.insert("", "end", values=(
                    subtask.get('id', ''),
                    subtask.get('text', ''),
                    subtask.get('card_title', ''),
                    status,
                    priority,
                    created_at,
                    subtask.get('assigned_member', '')
                ))
            
            # Atualizar estat√≠sticas
            self.update_subtask_statistics(all_subtasks)
            
        except Exception as e:
            print(f"Erro ao carregar subtarefas: {e}")
    
    def filter_my_subtasks(self):
        """Filtra subtarefas baseado nos filtros selecionados"""
        try:
            status_filter = self.subtask_status_filter.get()
            priority_filter = self.subtask_priority_filter.get()
            
            # Ocultar todas as linhas
            for item in self.my_subtasks_tree.get_children():
                self.my_subtasks_tree.detach(item)
            
            # Recarregar dados
            if not self.current_user:
                return
            
            current_user_member = self._get_current_user_member()
            if not current_user_member:
                return
            
            all_subtasks = []
            all_cards = self.get_all_cards()
            
            for card_info in all_cards:
                card = card_info['card']
                card_id = card.get('card_id')
                if card_id:
                    subtasks = self.get_subtasks_for_card(card_id)
                    for subtask in subtasks:
                        assigned_member = subtask.get('assigned_member')
                        if assigned_member == current_user_member:
                            # Aplicar filtros
                            status = "Conclu√≠da" if subtask.get('completed') else "Pendente"
                            priority = subtask.get('priority', 'Normal')
                            
                            # Verificar filtro de status
                            if status_filter != "Todas":
                                if status_filter == "Pendentes" and status != "Pendente":
                                    continue
                                elif status_filter == "Conclu√≠das" and status != "Conclu√≠da":
                                    continue
                                elif status_filter == "Em Progresso" and status != "Em Progresso":
                                    continue
                            
                            # Verificar filtro de prioridade
                            if priority_filter != "Todas" and priority != priority_filter:
                                continue
                            
                            subtask['card_title'] = card.get('title', '')
                            subtask['board_name'] = card_info.get('board_name', '')
                            subtask['list_name'] = card_info.get('list_name', '')
                            all_subtasks.append(subtask)
            
            # Inserir no treeview
            for subtask in all_subtasks:
                status = "Conclu√≠da" if subtask.get('completed') else "Pendente"
                priority = subtask.get('priority', 'Normal')
                created_at = subtask.get('created_at', '')
                if created_at and isinstance(created_at, str) and len(created_at) > 10:
                    created_at = created_at[:10]
                
                self.my_subtasks_tree.insert("", "end", values=(
                    subtask.get('id', ''),
                    subtask.get('text', ''),
                    subtask.get('card_title', ''),
                    status,
                    priority,
                    created_at,
                    subtask.get('assigned_member', '')
                ))
            
            # Atualizar estat√≠sticas
            self.update_subtask_statistics(all_subtasks)
            
        except Exception as e:
            print(f"Erro ao filtrar subtarefas: {e}")
    
    def update_subtask_statistics(self, subtasks):
        """Atualiza estat√≠sticas das subtarefas"""
        try:
            total = len(subtasks)
            pending = sum(1 for s in subtasks if not s.get('completed'))
            completed = sum(1 for s in subtasks if s.get('completed'))
            in_progress = sum(1 for s in subtasks if s.get('status') == 'Em Progresso')
            
            self.subtask_total_label.config(text=f"Total: {total}")
            self.subtask_pending_label.config(text=f"Pendentes: {pending}")
            self.subtask_completed_label.config(text=f"Conclu√≠das: {completed}")
            self.subtask_in_progress_label.config(text=f"Em Progresso: {in_progress}")
            
        except Exception as e:
            print(f"Erro ao atualizar estat√≠sticas: {e}")
    
    def refresh_my_subtasks(self):
        """Atualiza a lista de subtarefas"""
        self.load_my_subtasks()
        messagebox.showinfo("Atualizado", "Lista de subtarefas atualizada!")
    
    def open_subtask_from_tree(self, event):
        """Abre subtarefa selecionada no treeview"""
        selected_item = self.my_subtasks_tree.selection()
        if not selected_item:
            return
        
        try:
            # Obter dados da subtarefa
            item_data = self.my_subtasks_tree.item(selected_item[0])
            subtask_id = item_data['values'][0]
            
            # Buscar subtarefa no banco
            subtask = self.get_subtask_by_id(subtask_id)
            if subtask:
                # Buscar card pai
                card = self.find_card_by_id(subtask['card_id'])
                if card:
                    # Abrir janela de detalhes
                    SubTaskDetailWindow(self, card, subtask)
            
        except Exception as e:
            print(f"Erro ao abrir subtarefa: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir subtarefa: {e}")
    
    def delete_subtask_from_tree(self):
        """Remove subtarefa selecionada"""
        selected_item = self.my_subtasks_tree.selection()
        if not selected_item:
            messagebox.showwarning("Sele√ß√£o", "Por favor, selecione uma subtarefa para remover.")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja remover esta subtarefa?"):
            try:
                item_data = self.my_subtasks_tree.item(selected_item[0])
                subtask_id = item_data['values'][0]
                
                # Remover do banco
                self.db.delete_subtask(subtask_id)
                
                # Recarregar lista
                self.load_my_subtasks()
                
                messagebox.showinfo("Sucesso", "Subtarefa removida com sucesso!")
                
            except Exception as e:
                print(f"Erro ao remover subtarefa: {e}")
                messagebox.showerror("Erro", f"Erro ao remover subtarefa: {e}")
    
    def show_subtasks_report(self):
        """Mostra relat√≥rio de subtarefas"""
        try:
            if not self.current_user:
                messagebox.showwarning("Usu√°rio", "Usu√°rio n√£o logado.")
                return
            
            current_user_member = self._get_current_user_member()
            if not current_user_member:
                messagebox.showwarning("Membro", "Membro n√£o encontrado.")
                return
            
            # Buscar todas as subtarefas do usu√°rio
            all_subtasks = []
            all_cards = self.get_all_cards()
            
            for card_info in all_cards:
                card = card_info['card']
                card_id = card.get('card_id')
                if card_id:
                    subtasks = self.get_subtasks_for_card(card_id)
                    for subtask in subtasks:
                        assigned_member = subtask.get('assigned_member')
                        if assigned_member == current_user_member:
                            subtask['card_title'] = card.get('title', '')
                            all_subtasks.append(subtask)
            
            # Calcular estat√≠sticas
            total = len(all_subtasks)
            completed = sum(1 for s in all_subtasks if s.get('completed'))
            pending = total - completed
            completion_rate = (completed / total * 100) if total > 0 else 0
            
            # Criar janela de relat√≥rio
            report_window = tk.Toplevel(self.root)
            report_window.title(f"Relat√≥rio de Subtarefas - {current_user_member}")
            report_window.geometry("600x400")
            report_window.transient(self.root)
            report_window.grab_set()
            
            # Conte√∫do do relat√≥rio
            report_text = tk.Text(report_window, wrap=tk.WORD, padx=20, pady=20)
            report_text.pack(fill=tk.BOTH, expand=True)
            
            report_text.insert(tk.END, f"üìä RELAT√ìRIO DE SUBTAREFAS\n")
            report_text.insert(tk.END, f"Membro: {current_user_member}\n")
            report_text.insert(tk.END, f"Data: {datetime.now().strftime('%d/%m/%Y %H:%M')}\n\n")
            
            report_text.insert(tk.END, f"üìà ESTAT√çSTICAS GERAIS\n")
            report_text.insert(tk.END, f"Total de Subtarefas: {total}\n")
            report_text.insert(tk.END, f"Conclu√≠das: {completed}\n")
            report_text.insert(tk.END, f"Pendentes: {pending}\n")
            report_text.insert(tk.END, f"Taxa de Conclus√£o: {completion_rate:.1f}%\n\n")
            
            report_text.insert(tk.END, f"üìã LISTA DE SUBTAREFAS\n")
            for i, subtask in enumerate(all_subtasks, 1):
                status = "‚úì" if subtask.get('completed') else "‚óã"
                report_text.insert(tk.END, f"{i}. {status} {subtask.get('text', '')} - {subtask.get('card_title', '')}\n")
            
            report_text.config(state=tk.DISABLED)
            
            # Bot√£o para fechar
            ttk.Button(report_window, text="Fechar", 
                      command=report_window.destroy).pack(pady=10)
            
        except Exception as e:
            print(f"Erro ao gerar relat√≥rio: {e}")
            messagebox.showerror("Erro", f"Erro ao gerar relat√≥rio: {e}")

    def go_to_board_from_activity(self):
        selected_item_id = self.activities_tree.selection()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione uma atividade para navegar.", parent=self.root)
            return

        item_id = selected_item_id[0]
        
        # If it's a subtask, get the parent card's ID
        parent_id = self.activities_tree.parent(item_id)
        if parent_id:
            item_id = parent_id

        card_info = self.find_card_and_board_by_id(item_id)
        if card_info:
            board_name = card_info["board_name"]
            
            # Find the index of the 'Quadros' tab in the main notebook
            boards_tab_index = -1
            for i, tab in enumerate(self.main_notebook.tabs()):
                if self.main_notebook.tab(i, "text") == 'Quadros':
                    boards_tab_index = i
                    break
            
            if boards_tab_index != -1:
                self.main_notebook.select(boards_tab_index)
                
                # Now find and select the specific board's tab
                for i, tab in enumerate(self.board_notebook.tabs()):
                    if self.board_notebook.tab(i, "text") == board_name:
                        self.board_notebook.select(i)
                        break

    def open_card_from_activity(self, event=None):
        selected_item_id = self.activities_tree.selection()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione uma atividade para abrir.", parent=self.root)
            return

        item_id = selected_item_id[0]
        tags = self.activities_tree.item(item_id, "tags")

        if not tags:
            messagebox.showerror("Erro", "O item selecionado n√£o tem um ID de cart√£o associado.", parent=self.root)
            return

        card_id = tags[0]  # The card_id is the first tag
        card_info = self.find_card_and_board_by_id(card_id)

        if card_info:
            CardWindow(self.root, self, card_info["board_name"], card_info["list_name"], card_info["card"], self.current_user)
        else:
            messagebox.showerror("Erro", f"Cart√£o com ID '{card_id}' n√£o encontrado. Pode ter sido movido ou removido.", parent=self.root)

    def find_card_and_board_by_id(self, card_id):
        for board_name, board_content in self.boodesk_data.get("boards", {}).items():
            if isinstance(board_content, dict):
                for list_name, cards in board_content.items():
                    if isinstance(cards, list):
                        for card in cards:
                            if card.get("card_id") == card_id:
                                return {"board_name": board_name, "list_name": list_name, "card": card}
        return None

    def create_history_tab(self, parent):
        history_frame = ttk.LabelFrame(parent, text="Hist√≥rico de Estudos")
        history_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.log_list = ttk.Treeview(history_frame, columns=("Data e Hora", "Assunto", "Dura√ß√£o (min)"), show="headings")
        self.log_list.heading("Data e Hora", text="Data e Hora")
        self.log_list.heading("Assunto", text="Assunto")
        self.log_list.heading("Dura√ß√£o (min)", text="Dura√ß√£o (min)")
        self.log_list.column("Data e Hora", width=200, anchor="center")
        self.log_list.column("Assunto", width=200, anchor="w")
        self.log_list.column("Dura√ß√£o (min)", width=150, anchor="center")
        scrollbar = ttk.Scrollbar(history_frame, orient="vertical", command=self.log_list.yview)
        self.log_list.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        self.log_list.pack(fill=tk.BOTH, expand=True)

    def on_card_select_treeview(self, board_name, list_name, event):
        """Handler para sele√ß√£o de cart√£o no treeview"""
        treeview = event.widget
        selection = treeview.selection()
        
        if selection:
            item = treeview.item(selection[0])
            card_id = item['tags'][0] if item['tags'] else None
            
            if card_id:
                # Find the card data
                for card in self.boodesk_data["boards"][board_name][list_name]:
                    if card.get('card_id') == card_id:
                        self.show_card_details(card)
                        break

    def get_boards_for_member(self, member_name):
        """Retorna apenas os quadros onde o membro participa de cards"""
        boards = []
        for board_name, board_data in self.boodesk_data['boards'].items():
            for list_name, cards in board_data.items():
                if list_name == 'workflow':  # Ignorar metadados
                    continue
                for card in cards:
                    if member_name in card.get('members', []):
                        boards.append(board_name)
                        break  # Uma vez encontrado, n√£o precisa verificar mais cards
        return list(set(boards))  # Remove duplicatas

    def _should_show_board_for_user(self, board_name, current_user_member):
        """Vers√£o melhorada do filtro de quadros - mostra apenas quadros relevantes ao membro"""
        try:
            # Administradores veem todos os quadros
            if hasattr(self, 'current_user') and getattr(self.current_user, 'role', None) in ['admin', 'Administrador']:
                return True
            
            # Se n√£o h√° membro associado, mostrar apenas quadros principais
            if not current_user_member:
                return board_name in ["Quadro Principal", "Quadro Geral"]
            
            # Verificar se o membro participa de algum card no quadro
            board_data = self.boodesk_data.get("boards", {}).get(board_name, {})
            if isinstance(board_data, dict):
                for list_name, cards in board_data.items():
                    if list_name == 'workflow':
                        continue
                    for card in cards:
                        if current_user_member in card.get('members', []):
                            return True
            
            # Quadros especiais sempre vis√≠veis
            if board_name in ["Quadro Principal", "Quadro Geral"]:
                return True
            
            return False
        except Exception as e:
            print(f"DEBUG: _should_show_board_for_user - Erro: {e}")
            # Em caso de erro, manter comportamento permissivo para n√£o ocultar quadros indevidamente
            return True

    # --- UI Population and Updates ---
    def populate_boards(self):
        """Popula os quadros com otimiza√ß√£o de performance"""
        # Usar otimizador se dispon√≠vel
        if hasattr(self, 'kanban_optimizer') and self.kanban_optimizer:
            self.kanban_optimizer.optimize_populate_boards()
            return
        
        # Fallback para m√©todo original
        print(f"DEBUG: populate_boards iniciado (m√©todo original)")
        print(f"DEBUG: boodesk_data['boards'] = {self.boodesk_data['boards']}")
        print(f"DEBUG: N√∫mero de quadros: {len(self.boodesk_data['boards'])}")
        
        try:
            selected_tab_index = self.board_notebook.index(self.board_notebook.select())
        except tk.TclError:
            selected_tab_index = 0

        for i in self.board_notebook.tabs():
            self.board_notebook.forget(i)

        self.listbox_refs = {} # Clear existing references

        # Garantir que pelo menos o Quadro Principal existe
        if not self.boodesk_data["boards"] or "Quadro Principal" not in self.boodesk_data["boards"]:
            print("DEBUG: Criando Quadro Principal padr√£o")
            self.boodesk_data["boards"]["Quadro Principal"] = {
                "A Fazer": [],
                "Em Progresso": [],
                "Conclu√≠do": []
            }

        importance_colors = self.settings["importance_colors"]
        
        # Obter o membro do usu√°rio atual (se m√©todo estiver dispon√≠vel)
        current_user_member = None
        try:
            if hasattr(self, '_get_current_user_member'):
                current_user_member = self._get_current_user_member()
            else:
                # Se o m√©todo n√£o existe, definir como None
                current_user_member = None
        except Exception as e:
            print(f"DEBUG: populate_boards - erro ao obter membro do usu√°rio: {e}")
            current_user_member = None
        print(f"DEBUG: populate_boards - Usu√°rio atual: {current_user_member}")

        print("DEBUG: Criando quadros na interface...")
        for board_name, lists in self.boodesk_data["boards"].items():
            print(f"DEBUG: Processando quadro: {board_name}")
            print(f"DEBUG: Tipo de lists: {type(lists)}")
            print(f"DEBUG: Conte√∫do de lists: {lists}")
            
            # Verificar se o quadro deve ser exibido para o usu√°rio atual
            should_show_board = self._should_show_board_for_user(board_name, current_user_member)
            print(f"DEBUG: populate_boards - Quadro '{board_name}' deve ser exibido: {should_show_board}")
            
            if not should_show_board:
                print(f"DEBUG: Quadro '{board_name}' n√£o ser√° exibido")
                continue
                
            print(f"DEBUG: Criando frame para quadro: {board_name}")
            board_frame = ttk.Frame(self.board_notebook, padding=5)
            self.board_notebook.add(board_frame, text=board_name)
            
            # Verificar se o quadro foi adicionado corretamente
            print(f"DEBUG: N√∫mero de abas ap√≥s adicionar '{board_name}': {len(self.board_notebook.tabs())}")

            # Criar notebook interno para o quadro com abas "Cart√µes" e "Chat"
            board_internal_notebook = ttk.Notebook(board_frame)
            board_internal_notebook.pack(fill=tk.BOTH, expand=True)
            
            # Aba de Cart√µes
            cards_frame = ttk.Frame(board_internal_notebook, padding=5)
            board_internal_notebook.add(cards_frame, text="Cart√µes")
            
            # Aba de Chat
            chat_frame = ttk.Frame(board_internal_notebook, padding=5)
            board_internal_notebook.add(chat_frame, text="Chat")
            
            # Configurar √≠cones e texto nas abas (se dispon√≠veis)
            try:
                if self.icons.get('card_icon'):
                    board_internal_notebook.tab(0, text="Cards", image=self.icons.get('card_icon'), compound=tk.LEFT)
                else:
                    board_internal_notebook.tab(0, text="Cards")
                if self.icons.get('chat_icon'):
                    board_internal_notebook.tab(1, text="Chat", image=self.icons.get('chat_icon'), compound=tk.LEFT)
                else:
                    board_internal_notebook.tab(1, text="Chat")
            except Exception as e:
                print(f"Erro ao configurar √≠cones nas abas: {e}")
                # Fallback para texto simples
                try:
                    board_internal_notebook.tab(0, text="Cards")
                    board_internal_notebook.tab(1, text="Chat")
                except:
                    pass
            
            # Criar chat integrado para este quadro
            self.create_integrated_chat(chat_frame, board_name)

            # Frame de gerenciamento de listas (dentro da aba de cart√µes)
            list_management_frame = ttk.Frame(cards_frame)
            list_management_frame.pack(fill=tk.X, pady=5)
            ttk.Button(list_management_frame, text="Adicionar Nova Lista", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_list, board_name)).pack(side=tk.LEFT)
            ttk.Button(list_management_frame, text="Chat do Projeto", image=self.icons.get('chat_icon'), compound=tk.LEFT, command=lambda: self.open_chat_tab(board_name)).pack(side=tk.LEFT, padx=(10, 0))

            list_container = ttk.Frame(cards_frame)
            list_container.pack(fill=tk.BOTH, expand=True)

            # Verificar se lists √© um dicion√°rio ou lista
            if isinstance(lists, dict):
                print(f"DEBUG: Lists √© um dicion√°rio com {len(lists)} listas")
                for list_name, cards in lists.items():
                    print(f"DEBUG: Processando lista: {list_name} com {len(cards)} cards")
                    for card in cards:
                        print(f"DEBUG: Tipo de card: {type(card)}, Conte√∫do: {card}")
                    list_frame = ttk.LabelFrame(list_container, text=list_name, padding=5)
                    list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)

                    # Context menu for list management
                    list_context_menu = tk.Menu(self.root, tearoff=0)
                    list_context_menu.add_command(label="Renomear Lista", image=self.icons.get('pencil_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.rename_list(b, l))
                    list_context_menu.add_command(label="Excluir Lista", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.delete_list(b, l))
                    list_context_menu.add_separator()
                    list_context_menu.add_command(label="Mover para Esquerda", image=self.icons.get('left_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.move_list(b, l, -1))
                    list_context_menu.add_command(label="Mover para Direita", image=self.icons.get('right_icon'), compound=tk.LEFT, command=lambda b=board_name, l=list_name: self.move_list(b, l, 1))
                    
                    # Bind right-click to the LabelFrame (list header)
                    list_frame.bind("<Button-3>", lambda event, menu=list_context_menu: menu.post(event.x_root, event.y_root))

                    treeview = ttk.Treeview(list_frame, columns=("Title", "Subject", "Due Date", "Importance"), show="headings")
                    treeview.heading("Title", text="T√≠tulo")
                    treeview.heading("Subject", text="Assunto")
                    treeview.heading("Due Date", text="Prazo")
                    treeview.heading("Importance", text="Import√¢ncia")

                    treeview.column("Title", width=150, anchor="w")
                    treeview.column("Subject", width=100, anchor="w")
                    treeview.column("Due Date", width=100, anchor="center")
                    treeview.column("Importance", width=80, anchor="center")

                    treeview.pack(fill=tk.BOTH, expand=True, pady=5)
                    DraggableTreeview(treeview, self, board_name, list_name) # Enable drag-and-drop for Treeview
                    treeview.bind("<Double-1>", self.open_card_details) # Double-click to open card details
                    treeview.bind("<Button-3>", partial(self.show_card_context_menu, board_name, list_name)) # Right-click for card context menu
                    treeview.bind("<Key>", partial(self.handle_card_key_press, board_name, list_name)) # Keyboard shortcuts
                    treeview.bind("<<TreeviewSelect>>", partial(self.on_card_select_treeview, board_name, list_name)) # New binding for click-to-expand

                    # Store reference to treeview for target identification
                    self.listbox_refs[(board_name, list_name)] = treeview
        
        # Otimizar refer√™ncias para busca r√°pida
        if not hasattr(self, '_listbox_refs_optimized'):
            self._listbox_refs_optimized = {}
        
        self._listbox_refs_optimized[treeview] = (board_name, list_name)
        
        # Apply filters
        filtered_cards = []
        filter_subject = self.filter_subject_var.get()
        filter_goal = self.filter_goal_var.get()
        filter_member = self.filter_member_var.get()
        filter_due_date = self.filter_due_date_var.get()
        filter_importance = self.filter_importance_var.get()
        filter_recurrence = self.filter_recurrence_var.get()
        filter_keyword = self.filter_keyword_var.get().lower()

        # Get current user's member name for filtering
        try:
            if hasattr(self, '_get_current_user_member'):
                current_user_member = self._get_current_user_member()
            else:
                current_user_member = None
        except Exception as e:
            print(f"DEBUG: Erro ao obter membro do usu√°rio para filtro: {e}")
            current_user_member = None

        for card in cards:
            match = True

            # User-Member filter - show only cards where current user is a member
            # MODIFICA√á√ÉO: Tornar o filtro menos restritivo para evitar tela em branco
            if current_user_member and getattr(self.current_user, 'role', None) != 'admin':
                card_members = card.get('members', [])
                # Se o cart√£o n√£o tem membros, mostrar para todos
                if card_members and current_user_member not in card_members:
                    match = False

            # Keyword filter
            if match and filter_keyword:
                card_title_lower = card.get('title', '').lower()
                card_desc_lower = card.get('desc', '').lower()
                if filter_keyword not in card_title_lower and filter_keyword not in card_desc_lower:
                    match = False

            # Subject filter - only apply if filter is not empty
            if match and filter_subject and filter_subject != "Todos" and card.get('subject') != filter_subject:
                match = False
            
            # Goal filter - only apply if filter is not empty
            if match and filter_goal and filter_goal != "Todos" and card.get('goal') != filter_goal:
                match = False

            # Member filter - only apply if filter is not empty
            if match and filter_member and filter_member.lower() != "todos":
                card_members = [m.lower() for m in card.get('members', [])]
                if filter_member.lower() not in card_members:
                    match = False

            # Due Date filter - only apply if filter is not empty
            if match and filter_due_date and filter_due_date != "Todos":
                if not self._filter_due_date(card.get('due_date', ''), filter_due_date):
                    match = False

            # Importance filter - only apply if filter is not empty
            if match and filter_importance and filter_importance != "Todos" and card.get('importance') != filter_importance:
                match = False

            # Recurrence filter - only apply if filter is not empty
            if match and filter_recurrence and filter_recurrence != "Todos" and card.get('recurrence', 'Nenhuma') != filter_recurrence:
                match = False

            if match:
                filtered_cards.append(card)

        for card in filtered_cards: # Iterate directly over filtered_cards
            if card.get('is_archived', False): # Skip archived cards
                continue

            title = card['title']
            subject = card.get('subject', '-')
            due_date = card.get('due_date', '')
            importance = card.get('importance', 'Normal')
            card_id = card.get('card_id') # Get the unique card ID for tagging

            # Insert main card row
            item_id = treeview.insert("", "end", values=(title, subject, due_date, importance), tags=(card_id,))
            
            # Apply background color based on importance
            bg_color = importance_colors.get(importance, "white")
            dependencies = card.get('dependencies', [])
            if dependencies and not self.can_start_card(card):
                # Adjust color for cards with unfulfilled dependencies
                if bg_color == "white": bg_color = "#f0f0f0"
                elif bg_color == "#ffcccc": bg_color = "#ffb3b3"
                elif bg_color == "#ffffcc": bg_color = "#ffffb3"
                elif bg_color == "#ccffcc": bg_color = "#b3ffb3"
            
            treeview.tag_configure(card_id, background=bg_color)
            treeview.item(item_id, tags=(card_id,)) # Apply the tag to the item

        treeview.filtered_cards = filtered_cards

        card_management_frame = ttk.Frame(list_frame)
        card_management_frame.pack(fill=tk.X, pady=5)
        ttk.Button(card_management_frame, text="Adicionar Cart√£o", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_card_ui, board_name, list_name)).pack(side=tk.LEFT, expand=True, fill=tk.X, padx=2)
            elif isinstance(lists, list):
                print(f"DEBUG: Lists √© uma lista (workflow) com {len(lists)} itens: {lists}")
                # Pular quadros que s√£o listas (como workflow)
                continue
            else:
                print(f"DEBUG: Tipo inesperado para lists: {type(lists)}")
                continue

        # Verificar se h√° quadros vis√≠veis
        if not self.board_notebook.tabs():
            print("DEBUG: Nenhum quadro vis√≠vel - criando quadro padr√£o")
            # Criar um quadro padr√£o se nenhum estiver vis√≠vel
            default_board_frame = ttk.Frame(self.board_notebook, padding=5)
            self.board_notebook.add(default_board_frame, text="Quadro Principal")
            
            list_management_frame = ttk.Frame(default_board_frame)
            list_management_frame.pack(fill=tk.X, pady=5)
            ttk.Button(list_management_frame, text="Adicionar Nova Lista", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_list, "Quadro Principal")).pack(side=tk.LEFT)
            
            # Criar as listas padr√£o no quadro
            list_container = ttk.Frame(default_board_frame)
            list_container.pack(fill=tk.BOTH, expand=True)
            
            # Criar as tr√™s listas padr√£o
            for list_name in ["A Fazer", "Em Progresso", "Conclu√≠do"]:
                list_frame = ttk.LabelFrame(list_container, text=list_name, padding=5)
                list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
                
                treeview = ttk.Treeview(list_frame, columns=("Title", "Subject", "Due Date", "Importance"), show="headings")
                treeview.heading("Title", text="T√≠tulo")
                treeview.heading("Subject", text="Assunto")
                treeview.heading("Due Date", text="Prazo")
                treeview.heading("Importance", text="Import√¢ncia")
                
                treeview.column("Title", width=150, anchor="w")
                treeview.column("Subject", width=100, anchor="w")
                treeview.column("Due Date", width=100, anchor="center")
                treeview.column("Importance", width=80, anchor="center")
                
                treeview.pack(fill=tk.BOTH, expand=True, pady=5)
                self.listbox_refs[("Quadro Principal", list_name)] = treeview
                
                card_management_frame = ttk.Frame(list_frame)
                card_management_frame.pack(fill=tk.X, pady=5)
                ttk.Button(card_management_frame, text="Adicionar Cart√£o", image=self.icons.get('add_icon'), compound=tk.LEFT, command=partial(self.add_card_ui, "Quadro Principal", list_name)).pack(side=tk.LEFT, expand=True, fill=tk.X, padx=2)
            
            # Garantir que o Quadro Principal existe nos dados
            if "Quadro Principal" not in self.boodesk_data['boards']:
                self.boodesk_data['boards']["Quadro Principal"] = {
                    "A Fazer": [],
                    "Em Progresso": [],
                    "Conclu√≠do": []
                }
        
        if self.board_notebook.tabs():
            if selected_tab_index < len(self.board_notebook.tabs()):
                self.board_notebook.select(selected_tab_index)
            else:
                self.board_notebook.select(0)
        self.update_gantt_chart()

    def show_card_context_menu(self, board_name, list_name, event):
        treeview = event.widget
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return

        # Get the card_id from the tags of the selected item
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object and its index in the boodesk_data structure
        card_index = -1
        for i, card in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if card.get('card_id') == card_id:
                card_index = i
                break

        if card_index == -1:
            return

        card_context_menu = tk.Menu(self.root, tearoff=0)
        card_context_menu.add_command(label="Abrir Detalhes do Cart√£o", image=self.icons.get('info_icon'), compound=tk.LEFT, command=partial(self.open_card_details_from_context, board_name, list_name, card_index))
        card_context_menu.add_command(label="Arquivar Cart√£o", image=self.icons.get('folder_icon'), compound=tk.LEFT, command=partial(self.archive_card_from_context, board_name, list_name, treeview, card_index))
        card_context_menu.add_command(label="Excluir Cart√£o (Permanente)", image=self.icons.get('delete_icon'), compound=tk.LEFT, command=partial(self.delete_card_permanently_from_context, board_name, list_name, treeview, card_index))
        card_context_menu.post(event.x_root, event.y_root)

    def handle_card_key_press(self, board_name, list_name, event):
        """Handle keyboard shortcuts for cards"""
        treeview = event.widget
        selected_item_id = treeview.focus()
        
        if not selected_item_id:
            return

        card_id = treeview.item(selected_item_id, "tags")[0]
        card_index = -1
        for i, card in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if card.get('card_id') == card_id:
                card_index = i
                break

        if card_index == -1:
            return
            
        if event.keysym == 'Delete':
            # Delete key pressed - delete the selected card
            self.delete_card_permanently_from_context(board_name, list_name, treeview, card_index)
        elif event.keysym == 'Return':
            # Enter key pressed - open card details
            self.open_card_details_from_context(board_name, list_name, card_index)

    def open_card_details_from_context(self, board_name, list_name, card_index):
        # Get the card_id from the actual card object
        card_to_open = self.boodesk_data["boards"][board_name][list_name][card_index]
        card_id = card_to_open.get('card_id')
        if card_id:
            CardWindow(self.root, self, board_name, list_name, card_id, self.current_user)
        else:
            messagebox.showerror("Erro", "N√£o foi poss√≠vel abrir os detalhes do cart√£o: ID do cart√£o n√£o encontrado.")

    def open_archived_cards_window(self):
        ArchivedCardsWindow(self.root, self)

    def archive_card_from_context(self, board_name, list_name, treeview, card_index):
        # Get the card_id from the tags of the selected item
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object using its card_id
        card_to_archive = None
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card.get('card_id') == card_id:
                card_to_archive = card
                break
        
        if not card_to_archive:
            messagebox.showerror("Erro", "Cart√£o n√£o encontrado.")
            return

        card_title = card_to_archive['title']
        if messagebox.askyesno("Confirmar Arquivamento", f"Tem certeza que deseja arquivar o cart√£o '{card_title}'?", parent=self.root):
            card_to_archive['is_archived'] = True
            self.save_trello_data()
            self.populate_boards()
            messagebox.showinfo("Cart√£o Arquivado", f"O cart√£o '{card_title}' foi arquivado.")

    def delete_card_permanently_from_context(self, board_name, list_name, treeview, card_index):
        # Get the card_id from the tags of the selected item
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object using its card_id
        card_to_delete = None
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card.get('card_id') == card_id:
                card_to_delete = card
                break
        
        if not card_to_delete:
            messagebox.showerror("Erro", "Cart√£o n√£o encontrado.")
            return

        card_title = card_to_delete['title']
        if messagebox.askyesno("Confirmar Exclus√£o Permanente", f"Tem certeza que deseja EXCLUIR PERMANENTEMENTE o cart√£o '{card_title}'? Esta a√ß√£o n√£o pode ser desfeita.", parent=self.root):
            # Remove the card from the data structure by card_id
            self.boodesk_data["boards"][board_name][list_name] = [
                card for card in self.boodesk_data["boards"][board_name][list_name] if card.get('card_id') != card_id
            ]
            self.save_trello_data()
            self.populate_boards()

    def update_pomodoro_task_list(self):
        for i in self.pomodoro_task_list.get_children():
            self.pomodoro_task_list.delete(i)
        for index, row in self.pomodoro_tasks_df.iterrows():
            self.pomodoro_task_list.insert("", "end", values=(row["Tarefa"], row["Status"], row["Assunto"], row["Objetivo"]))
        self.update_pomodoro_stats()

    def update_pomodoro_stats(self):
        completed = len(self.pomodoro_tasks_df[self.pomodoro_tasks_df['Status'] == 'Conclu√≠do'])
        pending = len(self.pomodoro_tasks_df[self.pomodoro_tasks_df['Status'] == 'Pendente'])
        self.pomodoro_completed_label.config(text=f"Conclu√≠das: {completed}")
        self.pomodoro_pending_label.config(text=f"Pendentes: {pending}")

    def update_timer_display(self):
        display_seconds = self.time_left if self.time_left > 0 else self.get_current_time_setting() * 60
        # Garantir que display_seconds seja um n√∫mero
        if isinstance(display_seconds, str):
            try:
                display_seconds = int(display_seconds)
            except:
                display_seconds = 0
        minutes, secs = divmod(display_seconds, 60)
        text = f"{minutes:02d}:{secs:02d}"
        self.pomodoro_timer_label.config(text=text)
        self.pomodoro_cycle_label.config(text=f"Ciclo: {self.current_cycle}/{self.settings['cycles']}")

    def get_current_time_setting(self):
        if self.on_break:
            return self.settings['short_break'] if self.current_cycle % self.settings['cycles'] != 0 else self.settings['long_break']
        return self.settings['pomodoro']

    def on_pomodoro_task_select(self, event):
        selected_item = self.pomodoro_task_list.selection()
        if not selected_item:
            return
        
        task_name = self.pomodoro_task_list.item(selected_item, "values")[0]
        task_details = self.pomodoro_tasks_df[self.pomodoro_tasks_df['Tarefa'] == task_name].iloc[0].to_dict()
        self.active_pomodoro_task = {"source": "pomodoro_list", "details": task_details}

    def open_card_details(self, event):
        """Abre a janela de detalhes do cart√£o quando o usu√°rio faz duplo clique"""
        treeview = event.widget
        selected_item_id = treeview.focus()
        if not selected_item_id:
            return

        board_name = self.board_notebook.tab(self.board_notebook.select(), "text")
        list_name = treeview.master.cget("text")
        
        # Get the card_id from the tags of the selected item
        card_id = treeview.item(selected_item_id, "tags")[0]

        # Find the actual card object and its index in the boodesk_data structure
        card_index = -1
        for i, card in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if card.get('card_id') == card_id:
                card_index = i
                break

        if card_index != -1:
            CardWindow(self.root, self, board_name, list_name, card_id, self.current_user)

    def start_pomodoro_from_card(self, board_name, list_name, card_id):
        card = None
        for c in self.boodesk_data["boards"][board_name][list_name]:
            if c.get('card_id') == card_id:
                card = c
                break
        
        if not card:
            messagebox.showerror("Erro", "Cart√£o n√£o encontrado para iniciar Pomodoro.")
            return

        self.active_pomodoro_task = {"source": "boodesk", "details": card}
        messagebox.showinfo("Pomodoro Iniciado", f"Timer iniciado para a tarefa: {card['title']}")
        self.main_notebook.select(1) # Seleciona a aba Pomodoro
        self.pomodoro_notebook.select(0) # Seleciona a sub-aba Timer Pomodoro
        self.start_timer()

    def start_timer(self):
        if not self.active_pomodoro_task:
            messagebox.showwarning("Nenhuma Tarefa", "Selecione uma tarefa na lista de Pomodoro ou inicie a partir de um cart√£o Trello.")
            return
        if self.timer_running:
            return
        self.timer_running = True
        self.start_button.config(state=tk.DISABLED)
        self.pause_button.config(state=tk.NORMAL)
        self.reset_button.config(state=tk.NORMAL)
        self.skip_button.config(state=tk.NORMAL)
        if self.time_left == 0:
            self.time_left = self.get_current_time_setting() * 60
        self.countdown(self.time_left)

    def pause_timer(self):
        if not self.timer_running:
            return
        self.timer_running = False
        self.start_button.config(state=tk.NORMAL)
        self.pause_button.config(state=tk.DISABLED)
        if self.timer_id:
            self.root.after_cancel(self.timer_id)

    def reset_timer(self):
        if self.timer_id:
            self.root.after_cancel(self.timer_id)
        self.timer_running = False
        self.current_cycle = 0
        self.on_break = False
        self.time_left = 0
        self.update_timer_display()
        self.start_button.config(state=tk.NORMAL)
        self.pause_button.config(state=tk.DISABLED)
        self.reset_button.config(state=tk.DISABLED)
        self.skip_button.config(state=tk.DISABLED)

    def skip_cycle(self):
        if self.timer_id:
            self.root.after_cancel(self.timer_id)
        self.timer_running = False
        self.time_left = 0
        self.handle_cycle_completion()

    def countdown(self, seconds):
        if not self.timer_running:
            return
        self.time_left = seconds
        if seconds >= 0:
            minutes, secs = divmod(seconds, 60)
            self.pomodoro_timer_label.config(text=f"{minutes:02d}:{secs:02d}")
            self.timer_id = self.root.after(1000, self.countdown, seconds - 1)
        else:
            winsound.Beep(1000, 500)
            self.handle_cycle_completion()

    def handle_cycle_completion(self):
        if not self.on_break:
            self.current_cycle += 1
            self.log_pomodoro()
            if self.current_cycle % self.settings['cycles'] == 0:
                self.on_break = True
                messagebox.showinfo("Pausa Longa", "Pausa longa! Bom descanso.")
            else:
                self.on_break = True
                messagebox.showinfo("Pausa Curta", "Pausa curta! Respire fundo.")
        else:
            self.on_break = False
            messagebox.showinfo("Fim da Pausa", "Fim da pausa. Hora de voltar ao foco!")

        self.time_left = 0
        self.update_timer_display()
        self.start_timer()

    def log_pomodoro(self):
        if not self.active_pomodoro_task:
            return
        
        task_details = self.active_pomodoro_task['details']
        new_log = pd.DataFrame({
            'Data e Hora': [datetime.now().strftime('%Y-%m-%d %H:%M:%S')],
            'Assunto': [task_details.get('subject', task_details.get('Assunto', '-'))],
            'Dura√ß√£o (min)': [self.settings['pomodoro']]
        })
        self.log_df = pd.concat([self.log_df, new_log], ignore_index=True)
        self.save_log()
        self.update_log()

    def update_log(self):
        for i in self.log_list.get_children():
            self.log_list.delete(i)
        for index, row in self.log_df.iterrows():
            self.log_list.insert("", "end", values=(row["Data e Hora"], row["Assunto"], row["Dura√ß√£o (min)"]))

    # --- Board, List, and Card Management Logic ---
    def add_board(self):
        """Cria um novo quadro com op√ß√£o de templates"""
        try:
            # Importar o gerenciador de templates
            from board_template_manager import BoardTemplateWindow
            BoardTemplateWindow(self.root, self, self.on_board_created_from_template)
        except ImportError:
            # Fallback para cria√ß√£o simples se o m√≥dulo n√£o estiver dispon√≠vel
            new_board_name = simpledialog.askstring("Novo Quadro", "Digite o nome do novo quadro:", parent=self.root)
            if new_board_name:
                self.create_simple_board(new_board_name)
    
    def create_simple_board(self, new_board_name):
        """Cria um quadro simples sem template"""
        try:
            # Get current user ID
            user_id = self.get_current_user_id()
            if not user_id:
                messagebox.showerror("Erro", "Usu√°rio n√£o identificado. Fa√ßa login novamente.", parent=self.root)
                return
            
            # Check if board already exists for this user
            existing_boards = self.db.get_boards(user_id)
            board_names = [board['name'] for board in existing_boards]
            
            if new_board_name in board_names:
                messagebox.showwarning("Erro", "Um quadro com este nome j√° existe.", parent=self.root)
                return
            
            # Create board in database
            board_id = self.db.create_board(new_board_name, owner_id=user_id)
            
            if board_id:
                # Adicionar listas padr√£o
                self.boodesk_data['boards'][new_board_name] = {
                    "A Fazer": [],
                    "Em Progresso": [],
                    "Conclu√≠do": []
                }
                
                # Reload data and update display
                self.load_trello_data()
                self.populate_boards()
                
                # Select the new board
                try:
                    self.board_notebook.select(len(self.board_notebook.tabs()) - 1)
                except:
                    pass
                
                messagebox.showinfo("Sucesso", f"Quadro '{new_board_name}' criado com sucesso!", parent=self.root)
            else:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel criar o quadro.", parent=self.root)
                
        except Exception as e:
            print(f"Erro ao criar quadro: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel criar o quadro: {e}", parent=self.root)
    
    def on_board_created_from_template(self, board_name):
        """Callback chamado quando um quadro √© criado via template"""
        # Atualizar interface
        self.load_trello_data()
        self.populate_boards()
        
        # Select the new board
        try:
            self.board_notebook.select(len(self.board_notebook.tabs()) - 1)
        except:
            pass

    def rename_board(self, old_name):
        new_name = simpledialog.askstring("Renomear Quadro", f"Digite o novo nome para '{old_name}':", parent=self.root)
        
        if new_name and new_name != old_name:
            try:
                # Get current user ID
                user_id = self.get_current_user_id()
                if not user_id:
                    messagebox.showerror("Erro", "Usu√°rio n√£o identificado. Fa√ßa login novamente.", parent=self.root)
                    return
                
                # Check if new name already exists for this user
                existing_boards = self.db.get_boards(user_id)
                board_names = [board['name'] for board in existing_boards]
                
                if new_name in board_names:
                    messagebox.showwarning("Erro", "Um quadro com este nome j√° existe.", parent=self.root)
                    return
                
                # Get board ID
                board_id = self.get_board_id_by_name(old_name)
                if not board_id:
                    messagebox.showerror("Erro", f"Quadro '{old_name}' n√£o encontrado.", parent=self.root)
                    return
                
                # Update board name in database
                self.db.update_board(board_id, new_name, "", "")
                success = True
                
                if success:
                    # Reload data and update display
                    self.load_trello_data()
                    self.populate_boards()
                    messagebox.showinfo("Sucesso", f"Quadro renomeado para '{new_name}'!", parent=self.root)
                else:
                    messagebox.showerror("Erro", "N√£o foi poss√≠vel renomear o quadro.", parent=self.root)
                    
            except Exception as e:
                print(f"Erro ao renomear quadro: {e}")
                messagebox.showerror("Erro", f"N√£o foi poss√≠vel renomear o quadro: {e}", parent=self.root)
        elif new_name:
            messagebox.showwarning("Erro", "N√£o foi poss√≠vel renomear. Verifique se o nome j√° existe ou √© inv√°lido.", parent=self.root)

    def delete_board(self, board_name):
        print(f"DEBUG: Tentando excluir quadro: '{board_name}'")
        if messagebox.askyesno("Confirmar Exclus√£o", f"Tem certeza que deseja excluir o quadro '{board_name}' e todos os seus conte√∫dos?", parent=self.root):
            try:
                # Get board ID
                print(f"DEBUG: Buscando board_id para '{board_name}'")
                board_id = self.get_board_id_by_name(board_name)
                print(f"DEBUG: board_id encontrado: {board_id}")
                
                if not board_id:
                    messagebox.showerror("Erro", f"Quadro '{board_name}' n√£o encontrado.", parent=self.root)
                    return
                
                # Delete board from database (this will also delete all cards)
                print(f"DEBUG: Chamando delete_board no banco para board_id: {board_id}")
                self.db.delete_board(board_id)
                success = True
                print(f"DEBUG: delete_board executado com sucesso")
                
                if success:
                    # Reload data and update display
                    print(f"DEBUG: Recarregando dados ap√≥s exclus√£o")
                    self.load_trello_data()
                    self.populate_boards()
                    messagebox.showinfo("Sucesso", f"Quadro '{board_name}' exclu√≠do com sucesso!", parent=self.root)
                else:
                    messagebox.showerror("Erro", "N√£o foi poss√≠vel excluir o quadro.", parent=self.root)
                    
            except Exception as e:
                print(f"Erro ao excluir quadro: {e}")
                import traceback
                traceback.print_exc()
                messagebox.showerror("Erro", f"N√£o foi poss√≠vel excluir o quadro: {e}", parent=self.root)

    def add_list(self, board_name):
        new_list_name = simpledialog.askstring("Nova Lista", "Digite o nome da nova lista:", parent=self.root)
        if new_list_name and new_list_name not in self.boodesk_data["boards"][board_name]:
            self.boodesk_data["boards"][board_name][new_list_name] = []
            self.save_trello_data()
            self.populate_boards()
        elif new_list_name:
            messagebox.showwarning("Erro", "Uma lista com este nome j√° existe neste quadro.", parent=self.root)

    def rename_list(self, board_name, old_list_name):
        new_list_name = simpledialog.askstring("Renomear Lista", f"Digite o novo nome para '{old_list_name}':", parent=self.root)
        if new_list_name and new_list_name != old_list_name and new_list_name not in self.boodesk_data["boards"][board_name]:
            # Recreate the dictionary with the new key in the same position
            new_lists = {}
            for name, cards in self.boodesk_data["boards"][board_name].items():
                if name == old_list_name:
                    new_lists[new_list_name] = cards
                else:
                    new_lists[name] = cards
            self.boodesk_data["boards"][board_name] = new_lists
            self.save_trello_data()
            self.populate_boards()
        elif new_list_name:
            messagebox.showwarning("Erro", "N√£o foi poss√≠vel renomear. Verifique se o nome j√° existe ou √© inv√°lido.", parent=self.root)

    def delete_list(self, board_name, list_name):
        if messagebox.askyesno("Confirmar Exclus√£o", f"Tem certeza que deseja excluir a lista '{list_name}' e todos os seus cart√µes?", parent=self.root):
            del self.boodesk_data["boards"][board_name][list_name]
            self.save_trello_data()
            self.populate_boards()

    def move_list(self, board_name, list_name, direction):
        lists = list(self.boodesk_data["boards"][board_name].keys())
        try:
            current_index = lists.index(list_name)
        except ValueError:
            return

        new_index = current_index + direction
        if 0 <= new_index < len(lists):
            lists.insert(new_index, lists.pop(current_index))
            reordered_lists = {name: self.boodesk_data["boards"][board_name][name] for name in lists}
            self.boodesk_data["boards"][board_name] = reordered_lists
            self.save_trello_data()
            self.populate_boards()

    def add_card_ui(self, board_name, list_name):
        card_title = simpledialog.askstring("Novo Cart√£o", "Digite o t√≠tulo do novo cart√£o:", parent=self.root)
        if card_title and card_title.strip(): # Ensure title is not empty or just whitespace
            # Armazenar board e list name atuais para usar no callback
            self.current_board_name = board_name
            self.current_list_name = list_name
            
            # Abrir tela de sele√ß√£o de import√¢ncia
            CardImportanceWindow(self.root, self, board_name, list_name, card_title, 
                               self.create_card_with_data)
        else:
            print("‚ùå Cria√ß√£o de card cancelada - t√≠tulo vazio")
    
    def create_card_with_data(self, card_title, importance, description):
        """Callback para criar o card com os dados das telas de configura√ß√£o"""
        try:
            print(f"üîÑ Criando card: '{card_title}' com import√¢ncia '{importance}'")
            
            # Get current user ID
            user_id = self.get_current_user_id()
            if not user_id:
                print("‚ùå ERRO: Usu√°rio n√£o identificado")
                return
            
            # Get board ID
            board_id = self.get_board_id_by_name(self.current_board_name)
            if not board_id:
                print(f"‚ùå ERRO: Board '{self.current_board_name}' n√£o encontrado")
                return
            
            # Create card in database
            card_id = self.db.create_card(
                board_id=board_id,
                list_name=self.current_list_name,
                title=card_title,
                description=description,
                status='to_do',
                importance=importance,
                due_date="",
                subject="-",
                goal="-",
                members=[],
                git_branch="",
                git_commit="",
                recurrence="Nenhuma",
                dependencies=[],
                user_id=user_id
            )
            
            if card_id:
                print(f"‚úÖ Card criado com sucesso: {card_id}")
                
                # Reload data and update display
                self.load_trello_data()
                self.populate_boards()
                
                # Garantir que o cart√£o est√° na estrutura em mem√≥ria
                card_found_in_memory = False
                for card in self.boodesk_data["boards"][self.current_board_name][self.current_list_name]:
                    if card.get('card_id') == card_id:
                        card_found_in_memory = True
                        break
                
                if not card_found_in_memory:
                    print(f"DEBUG: Cart√£o {card_id} n√£o encontrado na mem√≥ria, adicionando...")
                    # Buscar dados do cart√£o no banco
                    card_data = self.db.get_card_by_id(card_id)
                    if card_data:
                        # Adicionar √† estrutura em mem√≥ria
                        self.boodesk_data["boards"][self.current_board_name][self.current_list_name].append(card_data)
                        print(f"DEBUG: Cart√£o adicionado √† mem√≥ria: {card_data.get('title', 'Sem t√≠tulo')}")
                
                # Email notification for card creation
                if hasattr(self, 'email_integration'):
                    card_data = {
                        "title": card_title,
                        "board": self.current_board_name,
                        "column": self.current_list_name,
                        "created_by": self.current_user.username,
                        "created_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                        "importance": importance,
                        "due_date": ""
                    }
                    self.email_integration.notify_card_created(card_data)
                
                # Open card window - the CardWindow will handle finding the card
                try:
                    print(f"DEBUG: Tentando abrir CardWindow para card_id: {card_id}")
                    CardWindow(self.root, self, self.current_board_name, self.current_list_name, card_id, self.current_user,
                               callback_on_close=partial(self.handle_card_window_closed, self.current_board_name, self.current_list_name, card_id))
                    print(f"DEBUG: CardWindow aberta com sucesso")
                except Exception as window_error:
                    print(f"DEBUG: Erro ao abrir CardWindow: {window_error}")
                    import traceback
                    traceback.print_exc()
                    raise window_error
            else:
                print("‚ùå ERRO: N√£o foi poss√≠vel criar o cart√£o no banco de dados")
                
        except Exception as e:
            print(f"‚ùå ERRO ao criar cart√£o: {e}")
            print(f"‚ùå ERRO: N√£o foi poss√≠vel criar o cart√£o: {e}")

    def delete_card(self, board_name, list_name, treeview):
        selected_item_id = treeview.focus()
        if not selected_item_id:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um cart√£o para excluir.", parent=self.root)
            return
        
        card_id = treeview.item(selected_item_id, "tags")[0]
        card_title = treeview.item(selected_item_id, "values")[0]

        if messagebox.askyesno("Confirmar Exclus√£o", f"Tem certeza que deseja excluir o cart√£o '{card_title}'?", parent=self.root):
            # Remove the card from the data structure by card_id
            self.boodesk_data["boards"][board_name][list_name] = [
                card for card in self.boodesk_data["boards"][board_name][list_name] if card.get('card_id') != card_id
            ]
            self.save_trello_data()
            self.populate_boards()

    def move_card_data(self, source_board_name, source_list_name, card_id, target_board_name, target_list_name):
        """Move card directly in SQL database with proper list_name update and logging"""
        # Usar otimizador se dispon√≠vel
        if hasattr(self, 'kanban_optimizer') and self.kanban_optimizer:
            return self.kanban_optimizer._optimized_move_card(
                card_id, source_board_name, source_list_name, target_board_name, target_list_name
            )
        
        # Fallback para m√©todo original
        try:
            print(f"SISTEMA: Iniciando movimenta√ß√£o de card")
            print(f"Card ID: {card_id}")
            print(f"Origem: '{source_board_name}' / '{source_list_name}'")
            print(f"Destino: '{target_board_name}' / '{target_list_name}'")
            
            # Obter board_id do quadro de destino
            target_board_id = self.get_board_id_by_name(target_board_name)
            if not target_board_id:
                print(f"ERRO: Board '{target_board_name}' n√£o encontrado no banco")
                print(f"‚ùå ERRO: Quadro '{target_board_name}' n√£o encontrado!")
                return False
            
            print(f"Board ID encontrado: {target_board_id}")
            
            # Verificar se o card existe antes de mover
            card_exists = self.db.get_card_by_id(card_id)
            if not card_exists:
                print(f"ERRO: Card {card_id} n√£o encontrado no banco")
                print(f"‚ùå ERRO: Cart√£o n√£o encontrado no banco de dados!")
                return False
            
            print(f"Card encontrado no banco: {card_exists.get('title', 'Sem t√≠tulo')}")
            
            # ATUALIZAR O CARD NO BANCO DE DADOS POSTGRESQL
            print(f"Atualizando card no PostgreSQL...")
            success = self.db.move_card(card_id, target_board_id, target_list_name)
            
            if success:
                print(f"SUCESSO: Card {card_id} movido para '{target_board_name}/{target_list_name}'")
                
                # REGISTRAR NO LOG DO SISTEMA
                try:
                    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    user_name = self.current_user.username if self.current_user else "Sistema"
                    
                    # Log detalhado da movimenta√ß√£o
                    log_entry = {
                        "timestamp": current_time,
                        "action": "MOVIMENTA√á√ÉO DE CARD",
                        "user": user_name,
                        "card_id": card_id,
                        "card_title": card_exists.get('title', 'Sem t√≠tulo'),
                        "source_board": source_board_name,
                        "source_list": source_list_name,
                        "target_board": target_board_name,
                        "target_list": target_list_name,
                        "target_board_id": target_board_id,
                        "status": "SUCESSO"
                    }
                    
                    print(f"LOG SISTEMA: {log_entry}")
                    
                    # Adicionar ao hist√≥rico do card
                    card_data = self.db.get_card_by_id(card_id)
                    if card_data:
                        history = card_data.get('history', [])
                        if isinstance(history, str):
                            try:
                                import json
                                history = json.loads(history)
                            except:
                                history = []
                        if not isinstance(history, list):
                            history = []
                        
                        # Adicionar entrada detalhada no hist√≥rico
                        history_entry = {
                            "timestamp": current_time,
                            "action": f"Card movido de '{source_list_name}' para '{target_list_name}'",
                            "user": user_name,
                            "source_board": source_board_name,
                            "source_list": source_list_name,
                            "target_board": target_board_name,
                            "target_list": target_list_name,
                            "list_name_updated": target_list_name,
                            "board_id_updated": target_board_id
                        }
                        
                        history.append(history_entry)
                        
                        # Atualizar hist√≥rico no banco
                        self.update_card_history(card_id, history)
                        print(f"Hist√≥rico atualizado no banco")
                
                except Exception as history_error:
                    print(f"Erro ao registrar hist√≥rico: {history_error}")
                
                # Notifica√ß√£o por email se habilitada
                try:
                    if hasattr(self, 'email_integration') and self.email_integration:
                        card_data = {
                            "title": card_exists.get("title", "Sem t√≠tulo"),
                            "board": target_board_name,
                            "column": target_list_name,
                            "modified_by": user_name,
                            "modified_date": current_time
                        }
                        changes = [f"Cart√£o movido de '{source_list_name}' para '{target_list_name}'"]
                        self.email_integration.notify_card_modified(card_data, changes)
                except Exception as email_error:
                    print(f"Erro ao enviar notifica√ß√£o por email: {email_error}")
                
                # RECARREGAR DADOS DO BANCO E ATUALIZAR INTERFACE
                print(f"Recarregando dados do banco...")
                self.load_trello_data()
                self.populate_boards()
                
                print(f"INTERFACE: Dados recarregados e interface atualizada")
                
                # Log de sucesso no terminal (sem popup)
                print(f"‚úÖ SUCESSO: Cart√£o movido com sucesso para '{target_list_name}'!")
                return True
            else:
                print(f"FALHA: N√£o foi poss√≠vel mover card {card_id} no banco")
                print(f"‚ùå ERRO: Falha ao mover o cart√£o no banco de dados!")
                return False
                
        except Exception as e:
            print(f"ERRO CR√çTICO ao mover cart√£o: {e}")
            print(f"‚ùå ERRO: N√£o foi poss√≠vel mover o cart√£o: {e}")
            return False

    def handle_card_window_closed(self, board_name, list_name, card_id, saved=False):
        if not saved:
            # If the card window was closed without saving, and it was a new card,
            # remove the card that was just added to the data model.
            # This prevents empty cards from appearing if the user cancels creation.
            current_list_cards = self.boodesk_data["boards"][board_name][list_name]
            card_to_remove_index = -1
            for i, card in enumerate(current_list_cards):
                if card.get('card_id') == card_id:
                    card_to_remove_index = i
                    break

            if card_to_remove_index != -1:
                # Only remove if it's a newly added card that wasn't saved
                # and still has the default/empty title.
                if current_list_cards[card_to_remove_index].get('title') == "" or \
                   current_list_cards[card_to_remove_index].get('title') == "Sua primeira tarefa Trello":
                    self.boodesk_data["boards"][board_name][list_name].pop(card_to_remove_index)
                    self.save_trello_data()
        else:
            # Se o card foi salvo, verificar se precisa sincronizar com Google Calendar
            if self.settings.get('google_calendar_enabled', False):
                # Encontrar o card salvo
                for card in self.boodesk_data["boards"][board_name][list_name]:
                    if card.get('card_id') == card_id:
                        # Verificar se tem data de vencimento
                        if card.get('due_date'):
                            # Sincronizar com Google Calendar
                            self._sync_new_card_to_calendar(card, board_name, list_name)
                        break
        
        self.populate_boards() # Always repopulate to reflect changes or removals

    def _sync_new_card_to_calendar(self, card, board_name, list_name):
        """Sincroniza um card rec√©m-criado com o Google Calendar"""
        try:
            # Verificar se o Google Calendar est√° configurado
            if not hasattr(self, 'google_calendar') or not self.google_calendar.is_authenticated:
                print("Google Calendar n√£o est√° autenticado")
                return
            
            # Verificar se h√° data de vencimento
            if not card.get('due_date'):
                print("Card n√£o possui data de vencimento")
                return
            
            # Usar fun√ß√£o auxiliar para processar data brasileira
            event_datetime = self.parse_brazilian_date(card['due_date'])
            
            if not event_datetime:
                print(f"Formato de data inv√°lido: {card['due_date']}")
                return
            
            # Criar evento no Google Calendar
            event_title = f"üìã {card['title']}"
            event_description = f"""
Card: {card['title']}
Descri√ß√£o: {card.get('desc', 'Sem descri√ß√£o')}
Import√¢ncia: {card.get('importance', 'Normal')}
Assunto: {card.get('subject', '-')}
Objetivo: {card.get('goal', '-')}
Membros: {', '.join(card.get('members', []))}
Board: {board_name}
Lista: {list_name}
Card ID: {card.get('card_id', '')}
            """.strip()
            
            # Definir dura√ß√£o do evento (1 hora por padr√£o)
            event_duration = timedelta(hours=1)
            
            # Coletar emails para o evento
            attendees = []
            
            # Adicionar emails padr√£o se habilitado
            calendar_settings = self.settings.get('calendar_integration', {})
            if calendar_settings.get('include_default_emails', True):
                default_emails = calendar_settings.get('default_emails', [])
                attendees.extend(default_emails)
            
            # Adicionar membros do card se habilitado
            if calendar_settings.get('include_card_members', True):
                card_members = card.get('members', [])
                for member in card_members:
                    # Buscar email do membro no arquivo de membros
                    member_email = self._get_member_email(member)
                    if member_email:
                        attendees.append(member_email)
            
            # Remover duplicatas
            attendees = list(set(attendees))
            
            # Criar evento
            success = self.google_calendar.create_event(
                title=event_title,
                description=event_description,
                start_datetime=event_datetime,
                duration=event_duration,
                card_id=card.get('card_id', ''),
                attendees=attendees if attendees else None
            )
            
            if success:
                print(f"‚úÖ Evento criado no Google Calendar para o card rec√©m-criado: {card['title']}")
                # Adicionar ao hist√≥rico do card
                # Garantir que history √© uma lista
                history = card.get('history', [])
                if isinstance(history, str):
                    try:
                        import json
                        history = json.loads(history)
                    except:
                        history = []
                if not isinstance(history, list):
                    history = []
                
                # Adicionar nova entrada ao hist√≥rico
                history.append({
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "action": f"Evento criado no Google Calendar",
                    "user": self.current_user.username if self.current_user else "Sistema"
                })
                card['history'] = history
                # Salvar dados atualizados
                self.save_trello_data()
            else:
                print(f"‚ùå Erro ao criar evento no Google Calendar para o card: {card['title']}")
                
        except Exception as e:
            print(f"‚ùå Erro na sincroniza√ß√£o com Google Calendar: {e}")
            import traceback
            traceback.print_exc()

    def _get_member_email(self, member_name):
        """Busca o email de um membro no arquivo de membros"""
        try:
            if hasattr(self, 'members') and self.members:
                print(f"DEBUG: Buscando email para membro '{member_name}'")
                print(f"DEBUG: Total de membros carregados: {len(self.members)}")
                for member in self.members:
                    print(f"DEBUG: Verificando membro: {member}")
                    if member.get('Membro') == member_name:
                        email = member.get('email', '')
                        print(f"DEBUG: Email encontrado para '{member_name}': {email}")
                        return email
                print(f"DEBUG: Membro '{member_name}' n√£o encontrado")
            else:
                print(f"DEBUG: Lista de membros n√£o dispon√≠vel ou vazia")
            return None
        except Exception as e:
            print(f"Erro ao buscar email do membro {member_name}: {e}")
            return None

    def _is_card_completed(self, card_full_title):
        # card_full_title format: "Board Name > List Name > Card Title"
        parts = card_full_title.split(' > ')
        if len(parts) != 3:
            return False # Invalid format
        
        board_name, list_name, card_title = parts

        if board_name not in self.boodesk_data["boards"]:
            return False
        if list_name not in self.boodesk_data["boards"][board_name]:
            return False
        
        for card in self.boodesk_data["boards"][board_name][list_name]:
            if card['title'] == card_title:
                # A card is considered completed if it's in the "Conclu√≠do" list
                return list_name == "Conclu√≠do"
        return False

    def _get_next_recurrence_date(self, current_date_str, recurrence_type):
        if not current_date_str:
            return ""
        
        try:
            current_date = datetime.strptime(current_date_str.split(' ')[0], "%Y-%m-%d")
        except ValueError:
            return "" # Invalid date format

        if recurrence_type == "Diariamente":
            next_date = current_date + timedelta(days=1)
        elif recurrence_type == "Semanalmente":
            next_date = current_date + timedelta(weeks=1)
        elif recurrence_type == "Mensalmente":
            # Advance by one month, handling end-of-month correctly
            year = current_date.year
            month = current_date.month + 1
            if month > 12:
                month = 1
                year += 1
            day = min(current_date.day, (datetime(year, month, 1) - timedelta(days=1)).day)
            next_date = datetime(year, month, day)
        elif recurrence_type == "Anualmente":
            next_date = current_date.replace(year=current_date.year + 1)
        else:
            return "" # No recurrence or invalid type

        return next_date.strftime("%Y-%m-%d")

    def complete_boodesk_card(self, board_name, list_name, card_id):
        card = None
        card_index = -1
        for i, c in enumerate(self.boodesk_data["boards"][board_name][list_name]):
            if c.get('card_id') == card_id:
                card = c
                card_index = i
                break
        
        if not card:
            messagebox.showerror("Erro", "Cart√£o n√£o encontrado para concluir.")
            return

        recurrence = card.get('recurrence', 'Nenhuma')

        # Verificar se todas as subtarefas est√£o conclu√≠das
        subtasks = card.get('subtasks', [])
        if subtasks:
            uncompleted_subtasks = [subtask for subtask in subtasks if not subtask['completed']]
            if uncompleted_subtasks:
                uncompleted_text = "\n".join([f"‚Ä¢ {subtask['text']}" for subtask in uncompleted_subtasks])
                messagebox.showwarning(
                    "Subtarefas Pendentes", 
                    f"N√£o √© poss√≠vel concluir o cart√£o '{card['title']}' porque ainda existem subtarefas pendentes:\n\n{uncompleted_text}\n\nConclua todas as subtarefas antes de marcar o cart√£o como conclu√≠do."
                )
                return

        # Handle dependencies first
        completed_card_full_title = f"{board_name} > {list_name} > {card['title']}"
        for b_name, lists in self.boodesk_data["boards"].items():
            for l_name, cards_in_list in lists.items():
                for c in cards_in_list:
                    if completed_card_full_title in c.get('dependencies', []):
                        messagebox.showinfo("Depend√™ncia Conclu√≠da", f"O cart√£o '{c['title']}' agora est√° desbloqueado, pois sua depend√™ncia '{card['title']}' foi conclu√≠da.")

        if recurrence == "Nenhuma":
            # Move to "Conclu√≠do" list if not recurring
            if list_name != "Conclu√≠do":
                if "Conclu√≠do" in self.boodesk_data["boards"][board_name]:
                    self.boodesk_data["boards"][board_name][list_name].pop(card_index)
                    self.boodesk_data["boards"][board_name]["Conclu√≠do"].append(card)
                    self.save_trello_data()
                else:
                    messagebox.showwarning("Lista N√£o Encontrada", "A lista 'Conclu√≠do' n√£o existe neste quadro.")
            else:
                messagebox.showinfo("Cart√£o J√° Conclu√≠do", "Este cart√£o j√° est√° na lista 'Conclu√≠do'.")
        else:
            # Handle recurrence: Create a new instance and move the original to "Conclu√≠do"
            original_card_id = card.get('card_id')
            
            # Move original card to "Conclu√≠do"
            if list_name != "Conclu√≠do":
                if "Conclu√≠do" in self.boodesk_data["boards"][board_name]:
                    self.boodesk_data["boards"][board_name][list_name].pop(card_index)
                    self.boodesk_data["boards"][board_name]["Conclu√≠do"].append(card)
                    messagebox.showinfo("Cart√£o Conclu√≠do", f"Cart√£o '{card['title']}' conclu√≠do e movido para 'Conclu√≠do'.")
                else:
                    messagebox.showwarning("Lista N√£o Encontrada", "A lista 'Conclu√≠do' n√£o existe neste quadro. O cart√£o original n√£o foi movido.")
            else:
                messagebox.showinfo("Cart√£o Conclu√≠do", "Este cart√£o j√° est√° na lista 'Conclu√≠do'.")

            # Create a new recurring instance
            new_card = card.copy()
            new_card['card_id'] = str(uuid.uuid4()) # New unique ID
            new_card['parent_card_id'] = original_card_id # Link to original
            new_card['creation_date'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S") # New creation date for the instance
            new_card['is_archived'] = False # Ensure new instance is not archived

            # Calculate next due date
            original_due_date = card.get('due_date', '')
            new_card['due_date'] = self._get_next_recurrence_date(original_due_date, recurrence)

            # Place the new instance in "A Fazer"
            if "A Fazer" in self.boodesk_data["boards"][board_name]:
                self.boodesk_data["boards"][board_name]["A Fazer"].append(new_card)
                messagebox.showinfo("Cart√£o Recorrente Criado", f"Nova inst√¢ncia de '{new_card['title']}' criada e adicionada a 'A Fazer'.")
            else:
                messagebox.showwarning("Lista N√£o Encontrada", "A lista 'A Fazer' n√£o existe neste quadro. A nova inst√¢ncia do cart√£o recorrente n√£o foi adicionada.")
            self.save_trello_data()
        self.populate_boards()

    def can_start_card(self, card):
        """Check if a card can be started based on its dependencies"""
        dependencies = card.get('dependencies', [])
        if not dependencies:
            return True
        
        return all(self._is_card_completed(dep) for dep in dependencies)

    def get_card_dependency_status(self, card):
        """Get detailed dependency status for a card"""
        dependencies = card.get('dependencies', [])
        if not dependencies:
            return {"can_start": True, "completed": 0, "total": 0, "pending": []}
        
        completed = [dep for dep in dependencies if self._is_card_completed(dep)]
        pending = [dep for dep in dependencies if not self._is_card_completed(dep)]
        
        return {
            "can_start": len(pending) == 0,
            "completed": len(completed),
            "total": len(dependencies),
            "pending": pending
        }

    def add_subject_dialog(self, subject_type):
        # This method now opens the management window instead of a simple dialog
        if self.settings['unify_subjects']:
            # If subjects are unified, always manage the pomodoro list which is the master list
            SubjectManagerWindow(self.root, self, 'pomodoro')
        else:
            SubjectManagerWindow(self.root, self, subject_type)

    def add_goal(self):
        new_goal = simpledialog.askstring("Novo Objetivo", "Digite o novo objetivo:").strip()
        if new_goal and new_goal not in self.goals:
            new_goal_df = pd.DataFrame({'Objetivo': [new_goal]})
            self.goals_df = pd.concat([self.goals_df, new_goal_df], ignore_index=True)
            self.goals = self.goals_df['Objetivo'].tolist()
            self.goals_df.to_excel(self.goals_file, index=False, engine='openpyxl')
            messagebox.showinfo("Sucesso", f"Objetivo '{new_goal}' adicionado.")

    def add_pomodoro_task(self):
        task = self.add_task_entry.get().strip()
        if not task:
            messagebox.showwarning("Entrada Inv√°lida", "Por favor, insira o nome da tarefa.")
            return

        subject = simpledialog.askstring("Assunto", "Digite o assunto da tarefa:")
        goal = simpledialog.askstring("Objetivo", "Digite o objetivo da tarefa:")

        new_task = pd.DataFrame({
            'Tarefa': [task],
            'Status': ['Pendente'],
            'Assunto': [subject if subject else '-'],
            'Objetivo': [goal if goal else '-']
        })
        self.pomodoro_tasks_df = pd.concat([self.pomodoro_tasks_df, new_task], ignore_index=True)
        self.save_pomodoro_tasks()
        self.update_pomodoro_task_list()
        self.add_task_entry.delete(0, tk.END)

    def remove_pomodoro_task(self):
        selected_item = self.pomodoro_task_list.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione uma tarefa para remover.")
            return

        task_name = self.pomodoro_task_list.item(selected_item, "values")[0]
        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover a tarefa '{task_name}'?"):
            self.pomodoro_tasks_df = self.pomodoro_tasks_df[self.pomodoro_tasks_df['Tarefa'] == task_name]
            self.save_pomodoro_tasks()
            self.update_pomodoro_task_list()

    def complete_pomodoro_task(self):
        selected_item = self.pomodoro_task_list.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione uma tarefa para concluir.")
            return

        task_name = self.pomodoro_task_list.item(selected_item, "values")[0]
        self.pomodoro_tasks_df.loc[self.pomodoro_tasks_df['Tarefa'] == task_name, 'Status'] = 'Conclu√≠do'
        self.save_pomodoro_tasks()
        self.update_pomodoro_task_list()

    def open_members_manager(self):
        MembersWindow(self.root, self)

    def open_categories_manager(self):
        """Abre o gerenciador de categorias"""
        CategoriesManagerWindow(self.root, self)

    def open_settings(self):
        SettingsWindow(self.root, self)
    
    def open_config_geral(self):
        """Abre configura√ß√µes gerais"""
        try:
            from configuracoes_separadas import ConfiguracaoGeralWindow
            ConfiguracaoGeralWindow(self.root, self)
        except ImportError as e:
            messagebox.showerror("Erro", f"Erro ao importar m√≥dulo de configura√ß√µes: {e}")
    
    def open_config_calendario(self):
        """Abre configura√ß√µes do calend√°rio"""
        try:
            from configuracoes_separadas import ConfiguracaoCalendarioWindow
            ConfiguracaoCalendarioWindow(self.root, self)
        except ImportError as e:
            messagebox.showerror("Erro", f"Erro ao importar m√≥dulo de configura√ß√µes: {e}")
    
    def open_config_email(self):
        """Abre configura√ß√µes de email"""
        try:
            from configuracoes_separadas import ConfiguracaoEmailWindow
            ConfiguracaoEmailWindow(self.root, self)
        except ImportError as e:
            messagebox.showerror("Erro", f"Erro ao importar m√≥dulo de configura√ß√µes: {e}")
    
    def open_config_templates_email(self):
        """Abre configura√ß√µes de templates de email"""
        try:
            from configuracoes_separadas import ConfiguracaoTemplatesEmailWindow
            ConfiguracaoTemplatesEmailWindow(self.root, self)
        except ImportError as e:
            messagebox.showerror("Erro", f"Erro ao importar m√≥dulo de configura√ß√µes: {e}")

    def open_notes_editor(self):
        """Abre o editor de anota√ß√µes para o card selecionado"""
        selected_item = self.activities_tree.selection()
        if not selected_item:
            messagebox.showwarning("Aviso", "Selecione uma atividade primeiro.")
            return
        
        # Obter dados do item selecionado
        item_id = selected_item[0]
        item_data = self.activities_tree.item(item_id)
        item_type = item_data.get('values', [None, None, None])[0]
        
        # Determinar o card_id baseado no tipo de item
        if item_type == "Subtarefa":
            # Para subtarefas, obter o card pai
            parent_id = self.activities_tree.parent(item_id)
            card_id = parent_id
        else:
            # Para tarefas, usar o pr√≥prio item_id
            card_id = item_id
        
        if not card_id:
            messagebox.showwarning("Aviso", "N√£o foi poss√≠vel identificar o card selecionado.")
            return
        
        # Abrir editor de anota√ß√µes
        NotesEditor(self.root, self.db, card_id, self.current_user)

    def apply_filters(self, status_filter, deadline_filter):
        """Aplica filtros aos cards"""
        # Implementar l√≥gica de filtros aqui
        print(f"Aplicando filtros: Status={status_filter}, Prazo={deadline_filter}")
        # Atualizar display dos cards com base nos filtros

    def open_personal_dashboard(self):
        """Abre dashboard personalizado do usu√°rio"""
        current_user_member = self._get_current_user_member()
        if not current_user_member:
            messagebox.showwarning("Aviso", "Voc√™ precisa estar logado para acessar o dashboard pessoal.")
            return
        
        dashboard_data = self.create_member_dashboard(current_user_member)
        self.show_personal_dashboard_window(dashboard_data)

    def create_tooltip(self, widget, text):
        """Cria um tooltip para um widget"""
        def show_tooltip(event):
            tooltip = tk.Toplevel()
            tooltip.wm_overrideredirect(True)
            tooltip.wm_geometry(f"+{event.x_root+10}+{event.y_root+10}")
            
            label = ttk.Label(tooltip, text=text, justify=tk.LEFT,
                             background="#ffffe0", relief=tk.SOLID, borderwidth=1,
                             font=("Arial", "8", "normal"))
            label.pack()
            
            def hide_tooltip(event):
                tooltip.destroy()
            
            widget.bind('<Leave>', hide_tooltip)
            tooltip.bind('<Leave>', hide_tooltip)
        
        widget.bind('<Enter>', show_tooltip)

    def show_kanban_performance(self):
        """Mostra janela de performance do Kanban"""
        if not hasattr(self, 'kanban_optimizer') or not self.kanban_optimizer:
            messagebox.showwarning("Aviso", "Otimizador de performance n√£o est√° dispon√≠vel")
            return
        
        # Criar janela de performance
        performance_window = tk.Toplevel(self.root)
        performance_window.title("Performance do Kanban")
        performance_window.geometry("400x300")
        performance_window.transient(self.root)
        performance_window.grab_set()
        
        # Frame principal
        main_frame = ttk.Frame(performance_window, padding=20)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        ttk.Label(main_frame, text="Estat√≠sticas de Performance", 
                 font=("Arial", 14, "bold")).pack(pady=(0, 20))
        
        # Obter estat√≠sticas
        stats = self.kanban_optimizer.get_performance_stats()
        
        # Frame para estat√≠sticas
        stats_frame = ttk.LabelFrame(main_frame, text="Cache e Performance", padding=10)
        stats_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Exibir estat√≠sticas
        ttk.Label(stats_frame, text=f"Widgets em cache: {stats.get('cached_widgets', 0)}").pack(anchor='w')
        ttk.Label(stats_frame, text=f"Cards em cache: {stats.get('cached_cards', 0)}").pack(anchor='w')
        ttk.Label(stats_frame, text=f"Fila de atualiza√ß√µes: {stats.get('update_queue_size', 0)}").pack(anchor='w')
        
        # Frame para a√ß√µes
        actions_frame = ttk.Frame(main_frame)
        actions_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(actions_frame, text="Limpar Cache", 
                  command=self.clear_kanban_cache).pack(side=tk.LEFT, padx=(0, 10))
        
        ttk.Button(actions_frame, text="Recarregar Otimizador", 
                  command=self.reload_kanban_optimizer).pack(side=tk.LEFT)
    
    def clear_kanban_cache(self):
        """Limpa cache do Kanban"""
        if hasattr(self, 'kanban_optimizer') and self.kanban_optimizer:
            self.kanban_optimizer.clear_cache()
            messagebox.showinfo("Sucesso", "Cache do Kanban limpo com sucesso!")
    
    def reload_kanban_optimizer(self):
        """Recarrega o otimizador do Kanban"""
        if KANBAN_OPTIMIZER_AVAILABLE:
            self.kanban_optimizer = KanbanPerformanceOptimizer(self)
            messagebox.showinfo("Sucesso", "Otimizador do Kanban recarregado!")
        else:
            messagebox.showerror("Erro", "Otimizador n√£o est√° dispon√≠vel")

    def show_personal_dashboard_window(self, dashboard_data):
        """Mostra janela do dashboard pessoal"""
        dashboard_window = tk.Toplevel(self.root)
        dashboard_window.title(f"Dashboard Pessoal - {dashboard_data['my_cards'][0]['members'][0] if dashboard_data['my_cards'] else 'Usu√°rio'}")
        dashboard_window.geometry("800x600")
        
        # Criar notebook para organizar as se√ß√µes
        notebook = ttk.Notebook(dashboard_window)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Aba de Cards
        cards_frame = ttk.Frame(notebook)
        notebook.add(cards_frame, text="Meus Cards")
        
        # Lista de cards
        cards_text = tk.Text(cards_frame, wrap=tk.WORD, height=20)
        cards_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        for card in dashboard_data['my_cards']:
            status_icon = "‚úÖ" if card.get('status') == 'done' else "üìã"
            card_text = f"{status_icon} {card['title']} - {card['board_name']} > {card['list_name']}\n"
            cards_text.insert(tk.END, card_text)
        
        # Aba de M√©tricas
        metrics_frame = ttk.Frame(notebook)
        notebook.add(metrics_frame, text="M√©tricas")
        
        metrics = self.get_member_metrics(dashboard_data['my_cards'][0]['members'][0] if dashboard_data['my_cards'] else 'Usu√°rio')
        
        metrics_text = tk.Text(metrics_frame, wrap=tk.WORD, height=20)
        metrics_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        metrics_text.insert(tk.END, f"üìä M√âTRICAS DE PRODUTIVIDADE\n\n")
        metrics_text.insert(tk.END, f"Cards Criados: {metrics['cards_created']}\n")
        metrics_text.insert(tk.END, f"Cards Completados: {metrics['cards_completed']}\n")
        metrics_text.insert(tk.END, f"Tempo M√©dio de Conclus√£o: {metrics['average_completion_time']:.1f} horas\n")
        metrics_text.insert(tk.END, f"Score de Produtividade: {metrics['productivity_score']:.1f}%\n")
        metrics_text.insert(tk.END, f"Taxa de Conclus√£o no Prazo: {metrics['on_time_completion_rate']*100:.1f}%\n")
        metrics_text.insert(tk.END, f"Quadros Ativos: {metrics['active_boards']}\n")
        
        # Aba de Atividades
        activities_frame = ttk.Frame(notebook)
        notebook.add(activities_frame, text="Atividades Recentes")
        
        activities_text = tk.Text(activities_frame, wrap=tk.WORD, height=20)
        activities_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        for activity in dashboard_data['recent_activities']:
            activity_text = f"üïí {activity['action']} - {activity['timestamp']}\n"
            activities_text.insert(tk.END, activity_text)

    def check_for_updates_manual(self):
        """Abre uma janela para verificar atualiza√ß√µes manualmente"""
        try:
            # Criar janela de atualiza√ß√µes
            update_window = tk.Toplevel(self.root)
            update_window.title("Verificar Atualiza√ß√µes - Boodesk")
            update_window.geometry("1000x900")
            update_window.resizable(True, True)
            update_window.transient(self.root)
            update_window.grab_set()
            
            # Centralizar a janela
            update_window.update_idletasks()
            x = (update_window.winfo_screenwidth() // 2) - (1000 // 2)
            y = (update_window.winfo_screenheight() // 2) - (900 // 2)
            update_window.geometry(f"1000x900+{x}+{y}")
            
            # Frame principal com scrollbar
            main_container = ttk.Frame(update_window)
            main_container.pack(fill='both', expand=True, padx=10, pady=10)
            
            # Canvas para scroll
            canvas = tk.Canvas(main_container)
            scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # Frame principal
            main_frame = ttk.Frame(scrollable_frame, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # T√≠tulo principal
            title_label = ttk.Label(main_frame, text="üîÑ SISTEMA DE ATUALIZA√á√ïES", 
                                   font=('Segoe UI', 18, 'bold'))
            title_label.pack(pady=(0, 10))
            
            # Subt√≠tulo
            subtitle_label = ttk.Label(main_frame, text="Gerencie as atualiza√ß√µes do Boodesk", 
                                     font=('Segoe UI', 12))
            subtitle_label.pack(pady=(0, 20))
            
            # Frame de status
            status_frame = ttk.LabelFrame(main_frame, text="Status da Verifica√ß√£o", padding=15)
            status_frame.pack(fill='x', pady=(0, 20))
            
            # Status inicial
            status_label = ttk.Label(status_frame, text="‚è≥ Verificando atualiza√ß√µes...", 
                                    font=('Segoe UI', 10))
            status_label.pack()
            
            # Frame de informa√ß√µes
            info_frame = ttk.LabelFrame(main_frame, text="Informa√ß√µes do Sistema", padding=15)
            info_frame.pack(fill='x', pady=(0, 20))
            
            # Informa√ß√µes do sistema
            system_info = f"""
Vers√£o Atual: 2.4.10
Data de Compila√ß√£o: {datetime.now().strftime('%d/%m/%Y')}
Sistema Operacional: {platform.system()} {platform.release()}
Python: {platform.python_version()}
Banco de Dados: PostgreSQL/Supabase
Status: Conectado ‚úÖ
            """
            
            info_text = tk.Text(info_frame, height=8, width=80, wrap=tk.WORD, 
                               font=('Consolas', 9), state='disabled')
            info_text.pack(fill='x')
            info_text.config(state='normal')
            info_text.insert('1.0', system_info.strip())
            info_text.config(state='disabled')
            
            # Frame para progresso de download
            progress_frame = ttk.LabelFrame(main_frame, text="Progresso de Download", padding=15)
            progress_frame.pack(fill='x', pady=(0, 20))
            
            # Barra de progresso
            progress_bar = ttk.Progressbar(progress_frame, mode='determinate', length=600)
            progress_bar.pack(pady=(0, 10))
            
            # Label de progresso
            progress_label = ttk.Label(progress_frame, text="Aguardando download...", 
                                     font=('Segoe UI', 9))
            progress_label.pack()
            
            # Separador visual
            separator = ttk.Separator(main_frame, orient='horizontal')
            separator.pack(fill='x', pady=(20, 20))
            
            # T√≠tulo dos bot√µes
            buttons_title = ttk.Label(main_frame, text="üéØ A√á√ïES DISPON√çVEIS", 
                                     font=('Segoe UI', 14, 'bold'))
            buttons_title.pack(pady=(0, 20))
            
            # Frame de bot√µes principais - Primeira linha
            button_frame1 = ttk.Frame(main_frame)
            button_frame1.pack(fill='x', pady=(0, 15))
            
            # Bot√£o de verificar novamente
            check_button = ttk.Button(button_frame1, text="üîÑ Verificar Novamente", 
                                     command=lambda: self.check_updates_again(status_label, progress_bar, progress_label),
                                     style='Accent.TButton', width=25)
            check_button.pack(side='left', padx=(0, 15))
            
            # Bot√£o de download
            download_button = ttk.Button(button_frame1, text="‚¨áÔ∏è Download Atualiza√ß√£o", 
                                       command=lambda: self.download_update(progress_bar, progress_label, update_window),
                                       style='Accent.TButton', width=25)
            download_button.pack(side='left', padx=(0, 15))
            
            # Bot√£o de instala√ß√£o
            install_button = ttk.Button(button_frame1, text="‚öôÔ∏è Instalar Atualiza√ß√£o", 
                                      command=lambda: self.install_update(progress_bar, progress_label),
                                      style='Accent.TButton', width=25)
            install_button.pack(side='left', padx=(0, 15))
            
            # Bot√£o para configurar diret√≥rio de download
            configure_dir_button = ttk.Button(button_frame1, text="‚öôÔ∏è Configurar Diret√≥rio", 
                                            command=lambda: self.configure_download_directory(),
                                            width=25)
            configure_dir_button.pack(side='left', padx=(0, 15))
            
            # Label para mostrar diret√≥rio atual
            download_dir_label = ttk.Label(button_frame1, text="üìÅ Diret√≥rio atual: Carregando...", 
                                         font=("Arial", 9))
            download_dir_label.pack(side='left', padx=(10, 0))
            
            # Bot√£o de abrir local do execut√°vel (inicialmente desabilitado)
            open_location_button = ttk.Button(button_frame1, text="üìÅ Abrir Local do Execut√°vel", 
                                            command=lambda: self.open_executable_location(),
                                            state='disabled', width=25)
            open_location_button.pack(side='left', padx=(0, 15))
            
            # Armazenar refer√™ncia do bot√£o para habilitar ap√≥s download
            update_window.open_location_button = open_location_button
            update_window.download_dir_label = download_dir_label
            
            # Frame de bot√µes secund√°rios - Segunda linha
            button_frame2 = ttk.Frame(main_frame)
            button_frame2.pack(fill='x', pady=(15, 15))
            
            # Bot√£o de configura√ß√µes avan√ßadas
            advanced_button = ttk.Button(button_frame2, text="üîß Configura√ß√µes Avan√ßadas", 
                                       command=lambda: self.show_advanced_update_settings(update_window),
                                       width=30)
            advanced_button.pack(side='left', padx=(0, 15))
            
            # Bot√£o de hist√≥rico de atualiza√ß√µes
            history_button = ttk.Button(button_frame2, text="üìã Hist√≥rico de Atualiza√ß√µes", 
                                      command=lambda: self.show_update_history(update_window),
                                      width=30)
            history_button.pack(side='left', padx=(0, 15))
            
            # Frame de bot√£o fechar - Terceira linha
            button_frame3 = ttk.Frame(main_frame)
            button_frame3.pack(fill='x', pady=(20, 0))
            
            # Bot√£o de fechar
            close_button = ttk.Button(button_frame3, text="‚ùå Fechar", 
                                     command=update_window.destroy,
                                     width=20)
            close_button.pack(side='right')
            
            # Configurar scrollbar
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # Simular verifica√ß√£o
            self.root.after(2000, lambda: self.simulate_update_check(status_label, progress_bar, progress_label))
            self.root.after(100, lambda: self.update_download_dir_label())
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir verifica√ß√£o de atualiza√ß√µes: {e}")
    
    def check_updates_again(self, status_label, progress_bar=None, progress_label=None):
        """Verifica atualiza√ß√µes novamente"""
        status_label.config(text="‚è≥ Verificando atualiza√ß√µes...")
        if progress_bar and progress_label:
            progress_bar['value'] = 0
            progress_label.config(text="Verificando...")
        self.root.after(2000, lambda: self.simulate_update_check(status_label, progress_bar, progress_label))
        self.root.after(100, lambda: self.update_download_dir_label())
    
    def simulate_update_check(self, status_label, progress_bar=None, progress_label=None):
        """Simula a verifica√ß√£o de atualiza√ß√µes"""
        try:
            # Simular verifica√ß√£o
            import random
            has_updates = random.choice([True, False])
            
            if has_updates:
                status_label.config(text="‚úÖ Atualiza√ß√µes dispon√≠veis! Vers√£o 2.3.2")
                if progress_bar and progress_label:
                    progress_bar['value'] = 0
                    progress_label.config(text="Atualiza√ß√£o dispon√≠vel para download")
                messagebox.showinfo("Atualiza√ß√µes", "Nova vers√£o dispon√≠vel: 2.3.2\n\nMelhorias:\n‚Ä¢ Corre√ß√µes de bugs\n‚Ä¢ Novas funcionalidades\n‚Ä¢ Melhor performance")
            else:
                status_label.config(text="‚úÖ Sistema atualizado! Voc√™ est√° usando a vers√£o mais recente.")
                if progress_bar and progress_label:
                    progress_bar['value'] = 100
                    progress_label.config(text="Sistema atualizado")
                
        except Exception as e:
            status_label.config(text=f"‚ùå Erro na verifica√ß√£o: {e}")
    
    def show_about_dialog(self):
        """Mostra a janela Sobre o Boodesk"""
        try:
            about_window = tk.Toplevel(self.root)
            about_window.title("Sobre o Boodesk")
            about_window.geometry("400x300")
            about_window.resizable(False, False)
            about_window.transient(self.root)
            about_window.grab_set()
            
            # Centralizar a janela
            about_window.update_idletasks()
            x = (about_window.winfo_screenwidth() // 2) - (400 // 2)
            y = (about_window.winfo_screenheight() // 2) - (300 // 2)
            about_window.geometry(f"400x300+{x}+{y}")
            
            # Frame principal
            main_frame = ttk.Frame(about_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # Logo/T√≠tulo
            title_label = ttk.Label(main_frame, text="üéØ BOODESK", 
                                   font=('Segoe UI', 20, 'bold'))
            title_label.pack(pady=(0, 10))
            
            subtitle_label = ttk.Label(main_frame, text="Sistema de Gerenciamento de Tarefas", 
                                      font=('Segoe UI', 12))
            subtitle_label.pack(pady=(0, 20))
            
            # Informa√ß√µes
            info_text = """
Vers√£o: 2.3.1
Desenvolvido por: Thalles Daniel
Data: Agosto 2025

Sistema completo de gerenciamento de tarefas
com integra√ß√£o PostgreSQL/Supabase e
interface moderna em Tkinter.

Funcionalidades:
‚Ä¢ Quadros Kanban
‚Ä¢ Sistema Pomodoro
‚Ä¢ Chat em tempo real
‚Ä¢ Dashboard executivo
‚Ä¢ Integra√ß√£o com calend√°rio
‚Ä¢ Upload de arquivos
‚Ä¢ Relat√≥rios avan√ßados
            """
            
            info_label = ttk.Label(main_frame, text=info_text, 
                                  font=('Segoe UI', 9), justify='left')
            info_label.pack(pady=(0, 20))
            
            # Bot√£o fechar
            close_button = ttk.Button(main_frame, text="Fechar", 
                                     command=about_window.destroy)
            close_button.pack()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir janela Sobre: {e}")

    def show_update_options(self, status_label):
        """Mostra op√ß√µes de download e instala√ß√£o"""
        try:
            # Criar janela de op√ß√µes
            options_window = tk.Toplevel(self.root)
            options_window.title("Nova Vers√£o Dispon√≠vel - Boodesk")
            options_window.geometry("600x500")
            options_window.resizable(False, False)
            options_window.transient(self.root)
            options_window.grab_set()
            
            # Centralizar a janela
            options_window.update_idletasks()
            x = (options_window.winfo_screenwidth() // 2) - (600 // 2)
            y = (options_window.winfo_screenheight() // 2) - (500 // 2)
            options_window.geometry(f"600x500+{x}+{y}")
            
            # Frame principal
            main_frame = ttk.Frame(options_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # T√≠tulo
            title_label = ttk.Label(main_frame, text="üÜï Nova Vers√£o Dispon√≠vel!", 
                                   font=('Segoe UI', 18, 'bold'))
            title_label.pack(pady=(0, 20))
            
            # Informa√ß√µes da vers√£o
            version_frame = ttk.LabelFrame(main_frame, text="Detalhes da Atualiza√ß√£o", padding=15)
            version_frame.pack(fill='x', pady=(0, 20))
            
            version_info = """
Vers√£o Atual: 2.4.10
Nova Vers√£o: 2.3.2
Tamanho: 15.2 MB
Data de Lan√ßamento: 25/08/2025

Melhorias Inclu√≠das:
‚Ä¢ Corre√ß√µes de bugs cr√≠ticos
‚Ä¢ Novas funcionalidades de produtividade
‚Ä¢ Melhor performance e estabilidade
‚Ä¢ Interface aprimorada
‚Ä¢ Novos temas visuais
‚Ä¢ Integra√ß√£o com Google Calendar melhorada
‚Ä¢ Sistema de backup autom√°tico
‚Ä¢ Relat√≥rios avan√ßados
            """
            
            info_text = tk.Text(version_frame, height=12, width=60, wrap=tk.WORD, 
                               font=('Consolas', 9), state='disabled')
            info_text.pack(fill='x')
            info_text.config(state='normal')
            info_text.insert('1.0', version_info.strip())
            info_text.config(state='disabled')
            
            # Frame de progresso (inicialmente oculto)
            progress_frame = ttk.LabelFrame(main_frame, text="Progresso do Download", padding=15)
            
            progress_label = ttk.Label(progress_frame, text="Preparando download...", 
                                      font=('Segoe UI', 10))
            progress_label.pack(pady=(0, 10))
            
            progress_bar = ttk.Progressbar(progress_frame, length=400, mode='determinate')
            progress_bar.pack(pady=(0, 10))
            
            progress_text = ttk.Label(progress_frame, text="0%", font=('Segoe UI', 9))
            progress_text.pack()
            
            # Frame de bot√µes
            button_frame = ttk.Frame(main_frame)
            button_frame.pack(fill='x', pady=(20, 0))
            
            # Bot√£o de download
            download_button = ttk.Button(button_frame, text="üì• Download e Instalar", 
                                        command=lambda: self.start_download_and_install(
                                            options_window, progress_frame, progress_label, 
                                            progress_bar, progress_text, status_label
                                        ))
            download_button.pack(side='left', padx=(0, 10))
            
            # Bot√£o de download manual
            manual_button = ttk.Button(button_frame, text="üåê Download Manual", 
                                      command=lambda: self.open_download_page())
            manual_button.pack(side='left', padx=(0, 10))
            
            # Bot√£o de lembrar depois
            later_button = ttk.Button(button_frame, text="‚è∞ Lembrar Depois", 
                                     command=options_window.destroy)
            later_button.pack(side='left', padx=(0, 10))
            
            # Bot√£o de fechar
            close_button = ttk.Button(button_frame, text="‚ùå Fechar", 
                                     command=options_window.destroy)
            close_button.pack(side='right')
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao mostrar op√ß√µes de atualiza√ß√£o: {e}")
    
    def start_download_and_install(self, options_window, progress_frame, progress_label, 
                                  progress_bar, progress_text, status_label):
        """Inicia o processo de download e instala√ß√£o"""
        try:
            # Mostrar frame de progresso
            progress_frame.pack(fill='x', pady=(0, 20))
            
            # Simular download
            self.simulate_download(progress_label, progress_bar, progress_text, 
                                  options_window, status_label)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao iniciar download: {e}")
    
    def simulate_download(self, progress_label, progress_bar, progress_text, 
                         options_window, status_label):
        """Simula o processo de download"""
        try:
            import time
            import threading
            
            def download_process():
                try:
                    # Simular etapas do download
                    steps = [
                        ("Conectando ao servidor...", 10),
                        ("Verificando integridade...", 20),
                        ("Baixando arquivos...", 50),
                        ("Validando arquivos...", 80),
                        ("Preparando instala√ß√£o...", 90),
                        ("Instalando atualiza√ß√£o...", 100)
                    ]
                    
                    for step_text, progress_value in steps:
                        # Atualizar interface na thread principal
                        self.root.after(0, lambda t=step_text, p=progress_value: 
                                      self.update_download_progress(progress_label, progress_bar, 
                                                                   progress_text, t, p))
                        time.sleep(1.5)  # Simular tempo de processamento
                    
                    # Download conclu√≠do
                    self.root.after(0, lambda: self.download_completed(options_window, status_label))
                    
                except Exception as e:
                    self.root.after(0, lambda: self.download_failed(e, options_window))
            
            # Executar download em thread separada
            download_thread = threading.Thread(target=download_process)
            download_thread.daemon = True
            download_thread.start()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro no download: {e}")
    
    def update_download_progress(self, progress_label, progress_bar, progress_text, 
                                step_text, progress_value):
        """Atualiza o progresso do download"""
        try:
            progress_label.config(text=step_text)
            progress_bar['value'] = progress_value
            progress_text.config(text=f"{progress_value}%")
            self.root.update_idletasks()
        except Exception as e:
            print(f"Erro ao atualizar progresso: {e}")
    
    def download_completed(self, options_window, status_label):
        """Chamado quando o download √© conclu√≠do"""
        try:
            # Mostrar mensagem de sucesso
            response = messagebox.askyesno(
                "‚úÖ Download Conclu√≠do!",
                "A atualiza√ß√£o foi baixada e instalada com sucesso!\n\n"
                "Para aplicar as mudan√ßas, √© necess√°rio reiniciar o Boodesk.\n\n"
                "Deseja reiniciar agora?"
            )
            
            if response:
                # Reiniciar aplica√ß√£o
                self.restart_application()
            else:
                # Fechar janela de op√ß√µes
                options_window.destroy()
                status_label.config(text="‚úÖ Atualiza√ß√£o instalada! Reinicie para aplicar.")
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao finalizar instala√ß√£o: {e}")
    
    def download_failed(self, error, options_window):
        """Chamado quando o download falha"""
        try:
            messagebox.showerror(
                "‚ùå Erro no Download",
                f"N√£o foi poss√≠vel baixar a atualiza√ß√£o:\n\n{error}\n\n"
                "Tente novamente ou use o download manual."
            )
            options_window.destroy()
        except Exception as e:
            print(f"Erro ao mostrar erro de download: {e}")
    
    def open_download_page(self):
        """Abre a p√°gina de download manual"""
        try:
            import webbrowser
            
            # URL fict√≠cia para download manual
            download_url = "https://boodesk.com/downloads"
            
            # Tentar abrir no navegador
            webbrowser.open(download_url)
            
            messagebox.showinfo(
                "üåê Download Manual",
                f"A p√°gina de download foi aberta no seu navegador:\n\n{download_url}\n\n"
                "Baixe a vers√£o mais recente e execute o instalador."
            )
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir p√°gina de download: {e}")
    
    def restart_application(self):
        """Reinicia a aplica√ß√£o"""
        try:
            # Salvar configura√ß√µes antes de reiniciar
            self.save_settings()
            
            # Mostrar mensagem de reinicializa√ß√£o
            messagebox.showinfo(
                "üîÑ Reiniciando",
                "O Boodesk ser√° reiniciado para aplicar as atualiza√ß√µes.\n\n"
                "Aguarde alguns segundos..."
            )
            
            # Fechar aplica√ß√£o atual
            self.root.quit()
            
            # Em um ambiente real, aqui voc√™ executaria o novo instalador
            # Por enquanto, apenas simulamos o rein√≠cio
            import subprocess
            import sys
            
            # Reiniciar a aplica√ß√£o
            subprocess.Popen([os.path.abspath(sys.argv[0]), sys.argv[0]])
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao reiniciar aplica√ß√£o: {e}")

    def download_update(self, progress_bar, progress_label, update_window=None):
        """Simula o download de uma atualiza√ß√£o"""
        try:
            progress_label.config(text="Iniciando download...")
            progress_bar['value'] = 0
            
            def update_progress():
                current = progress_bar['value']
                if current < 100:
                    progress_bar['value'] += 10
                    if current < 30:
                        progress_label.config(text="Baixando arquivos...")
                    elif current < 60:
                        progress_label.config(text="Verificando integridade...")
                    elif current < 90:
                        progress_label.config(text="Finalizando download...")
                    else:
                        progress_label.config(text="Download conclu√≠do!")
                    
                    if current < 100:
                        self.root.after(500, update_progress)
                    else:
                        messagebox.showinfo("Download Conclu√≠do", "Atualiza√ß√£o baixada com sucesso!\nClique em 'Instalar Atualiza√ß√£o' para aplicar.")
            
            update_progress()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro no download: {e}")
            progress_label.config(text="Erro no download")
    
    
    def get_current_version(self):
        """Retorna a vers√£o atual do aplicativo"""
        try:
            # Tentar obter do banco de dados
            if hasattr(self, 'db') and self.db:
                conn = self.db.get_connection()
                if conn:
                    cursor = conn.cursor()
                    cursor.execute("""
                        SELECT versao FROM versoes_sistema 
                        WHERE ativo = true 
                        ORDER BY data_lancamento DESC 
                        LIMIT 1
                    """)
                    result = cursor.fetchone()
                    if result:
                        return result[0]
        except:
            pass
        
        # Fallback para vers√£o hardcoded
        return "2.4.9"
    def install_update(self, progress_bar, progress_label):
        """Instala a atualiza√ß√£o baixada usando script de instala√ß√£o"""
        try:
            # Verificar se o download foi conclu√≠do com sucesso
            download_dir = self.get_download_directory()
            new_exe_path = os.path.join(download_dir, "boodesk_latest.exe")
            installer_script = "install_update.bat"
            
            print(f"üîç Verificando arquivo de atualiza√ß√£o: {new_exe_path}")
            print(f"üîç Verificando script de instala√ß√£o: {installer_script}")
            
            # Verificar se o arquivo novo existe e √© v√°lido
            if not os.path.exists(new_exe_path):
                print("‚ùå Arquivo de atualiza√ß√£o n√£o encontrado")
                messagebox.showwarning("Aviso", "Arquivo de atualiza√ß√£o n√£o encontrado.\n\nClique em '‚¨áÔ∏è Download Atualiza√ß√£o' primeiro!")
                return
            
            # Verificar se o arquivo √© v√°lido (m√≠nimo 50MB)
            file_size = os.path.getsize(new_exe_path)
            print(f"üì¶ Tamanho do arquivo: {file_size} bytes ({file_size//1024//1024}MB)")
            
            if file_size < 50*1024*1024:  # Menos de 50MB
                print("‚ùå Arquivo de atualiza√ß√£o muito pequeno (possivelmente corrompido)")
                messagebox.showerror("Erro", f"Arquivo de atualiza√ß√£o inv√°lido ou corrompido!\n\nTamanho: {file_size//1024//1024}MB (m√≠nimo: 50MB)\n\nTente fazer o download novamente.")
                return
            
            # Gerar script de instala√ß√£o dinamicamente
            install_script_path = os.path.join(download_dir, installer_script)
            
            # Definir vari√°veis necess√°rias
            new_exe_name = "boodesk_latest.exe"
            current_exe = os.path.abspath(sys.argv[0])
            
            # Conte√∫do do script de instala√ß√£o robusto
            install_script_content = f"""@echo off
echo ========================================
echo    INSTALADOR DE ATUALIZACAO BOODESK
echo ========================================
echo.

echo [1/6] Verificando arquivos...
if not exist "{download_dir}\\{new_exe_name}" (
    echo ERRO: Arquivo de atualizacao nao encontrado!
    echo Caminho: {download_dir}\\{new_exe_name}
    pause
    exit /b 1
)

echo [2/6] Verificando se o arquivo e valido...
"{download_dir}\\{new_exe_name}" --help >nul 2>&1
if errorlevel 1 (
    echo AVISO: Arquivo pode nao ser um executavel valido
    echo Continuando mesmo assim...
)

echo [3/6] Criando backup do executavel atual...
if exist "{os.path.dirname(os.path.abspath(sys.argv[0]))}\\app23a.py" (
    copy "{os.path.dirname(os.path.abspath(sys.argv[0]))}\\app23a.py" "{os.path.dirname(os.path.abspath(sys.argv[0]))}\\app23a.py.backup" >nul
    echo Backup criado: app23a.py.backup
) else (
    echo Aviso: Arquivo atual nao encontrado
)

echo [4/6] Aguardando fechamento do aplicativo...
echo Aguardando 5 segundos para garantir que o aplicativo foi fechado...
timeout /t 5 /nobreak >nul

echo [5/6] Copiando nova versao...
echo Copiando {new_exe_name} para BoodeskApp.exe...
copy "{download_dir}\\{new_exe_name}" "{os.path.dirname(os.path.abspath(sys.argv[0]))}\\BoodeskApp.exe" >nul
if errorlevel 1 (
    echo ERRO: Falha ao copiar nova versao!
    echo Tentando novamente...
    copy "{download_dir}\\{new_exe_name}" "{os.path.dirname(os.path.abspath(sys.argv[0]))}\\BoodeskApp.exe" >nul
    if errorlevel 1 (
        echo ERRO: Falha ao copiar nova versao na segunda tentativa!
        pause
        exit /b 1
    )
)

echo [6/6] Limpando arquivos temporarios...
del "{download_dir}\\{new_exe_name}" >nul 2>&1
del "{download_dir}\\{installer_script}" >nul 2>&1

echo.
echo ========================================
echo    ATUALIZACAO CONCLUIDA COM SUCESSO!
echo ========================================
echo.
echo O Boodesk foi atualizado e sera iniciado.
echo Pressione qualquer tecla para continuar...
pause >nul

echo Iniciando Boodesk atualizado...
cd /d "{os.path.dirname(os.path.abspath(sys.argv[0]))}"
echo Diretorio atual: %CD%
echo Executando: BoodeskApp.exe
start "" "BoodeskApp.exe"
if errorlevel 1 (
    echo ERRO: Falha ao iniciar BoodeskApp.exe
    echo Tentando executar diretamente...
    "BoodeskApp.exe"
)
echo.
echo Se o Boodesk nao iniciou automaticamente, execute manualmente:
echo cd "{os.path.dirname(os.path.abspath(sys.argv[0]))}"
echo BoodeskApp.exe
pause
exit
"""
            
            # Salvar o script de instala√ß√£o
            try:
                with open(install_script_path, 'w', encoding='utf-8') as f:
                    f.write(install_script_content)
                print(f"‚úÖ Script de instala√ß√£o criado: {install_script_path}")
            except Exception as e:
                print(f"‚ùå Erro ao criar script de instala√ß√£o: {e}")
                messagebox.showerror("Erro", f"Erro ao criar script de instala√ß√£o: {e}")
                return
            
            print("‚úÖ Todos os arquivos necess√°rios encontrados")
            
            progress_label.config(text="üöÄ Preparando instala√ß√£o...")
            progress_bar['value'] = 0
            self.root.update_idletasks()
            
            # Confirmar instala√ß√£o
            result = messagebox.askyesno("Confirmar Instala√ß√£o", 
                "A instala√ß√£o ir√°:\n\n"
                "1. Fazer backup do execut√°vel atual\n"
                "2. Substituir pelo novo execut√°vel\n"
                "3. Fechar o aplicativo atual\n"
                "4. Abrir a nova vers√£o\n\n"
                "Deseja continuar?")
            
            if not result:
                return
            
            progress_label.config(text="üìù Salvando configura√ß√µes...")
            progress_bar['value'] = 20
            self.root.update_idletasks()
            
            # Salvar informa√ß√µes da instala√ß√£o
            try:
                if hasattr(self, 'db') and self.db:
                    user_id = self.get_current_user_id() or 1
                    install_info = {
                        "install_date": datetime.now().isoformat(),
                        "version": "2.4.9",  # Vers√£o atual
                        "source": "cloudflare_r2",
                        "installer_script": installer_script,
                        "new_exe_path": new_exe_path
                    }
                    self.db.save_setting('last_update_install', json.dumps(install_info), user_id)
                    print("‚úÖ Informa√ß√µes da instala√ß√£o salvas no banco")
            except Exception as save_error:
                print(f"‚ö†Ô∏è Erro ao salvar informa√ß√µes: {save_error}")
            
            progress_label.config(text="üîÑ Iniciando processo de instala√ß√£o...")
            progress_bar['value'] = 50
            self.root.update_idletasks()
            
            # Executar script de instala√ß√£o
            try:
                import subprocess
                import platform
                
                if platform.system() == "Windows":
                    # Executar script batch
                    subprocess.Popen([installer_script], shell=True)
                    print(f"‚úÖ Script de instala√ß√£o iniciado: {installer_script}")
                else:
                    # Para outros sistemas, usar comando equivalente
                    subprocess.Popen(["bash", installer_script])
                    print(f"‚úÖ Script de instala√ß√£o iniciado: {installer_script}")
                
                progress_label.config(text="‚úÖ Instala√ß√£o iniciada!")
                progress_bar['value'] = 100
                self.root.update_idletasks()
                
                # Mostrar mensagem final
                messagebox.showinfo("Instala√ß√£o Iniciada", 
                    "O processo de instala√ß√£o foi iniciado!\n\n"
                    "O aplicativo ser√° fechado automaticamente e a nova vers√£o ser√° aberta.\n\n"
                    "Se algo der errado, o backup ser√° restaurado automaticamente.")
                
                # Aguardar um pouco e fechar o app
                self.root.after(3000, self.root.quit)
                
            except Exception as script_error:
                print(f"‚ùå Erro ao executar script: {script_error}")
                messagebox.showerror("Erro na Instala√ß√£o", 
                    f"Erro ao executar script de instala√ß√£o:\n{script_error}")
                progress_label.config(text="‚ùå Erro na instala√ß√£o")
                progress_bar['value'] = 0
            
        except Exception as e:
            error_msg = f"Erro na instala√ß√£o: {e}"
            print(f"‚ùå {error_msg}")
            messagebox.showerror("Erro na Instala√ß√£o", error_msg)
            progress_label.config(text="‚ùå Erro na instala√ß√£o")
            progress_bar['value'] = 0
    def show_advanced_update_settings(self, parent_window):
        """Mostra configura√ß√µes avan√ßadas de atualiza√ß√£o"""
        try:
            settings_window = tk.Toplevel(parent_window)
            settings_window.title("Configura√ß√µes Avan√ßadas - Atualiza√ß√µes")
            settings_window.geometry("500x400")
            settings_window.transient(parent_window)
            settings_window.grab_set()
            
            # Frame principal
            main_frame = ttk.Frame(settings_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # T√≠tulo
            ttk.Label(main_frame, text="üîß Configura√ß√µes Avan√ßadas", 
                     font=('Segoe UI', 14, 'bold')).pack(pady=(0, 20))
            
            # Op√ß√µes de atualiza√ß√£o
            options_frame = ttk.LabelFrame(main_frame, text="Op√ß√µes de Atualiza√ß√£o", padding=15)
            options_frame.pack(fill='x', pady=(0, 20))
            
            # Checkboxes
            auto_check_var = tk.BooleanVar(value=True)
            ttk.Checkbutton(options_frame, text="Verificar atualiza√ß√µes automaticamente", 
                           variable=auto_check_var).pack(anchor='w', pady=2)
            
            backup_var = tk.BooleanVar(value=True)
            ttk.Checkbutton(options_frame, text="Fazer backup antes de atualizar", 
                           variable=backup_var).pack(anchor='w', pady=2)
            
            notifications_var = tk.BooleanVar(value=True)
            ttk.Checkbutton(options_frame, text="Mostrar notifica√ß√µes de atualiza√ß√£o", 
                           variable=notifications_var).pack(anchor='w', pady=2)
            
            # Configura√ß√µes de proxy
            proxy_frame = ttk.LabelFrame(main_frame, text="Configura√ß√µes de Proxy", padding=15)
            proxy_frame.pack(fill='x', pady=(0, 20))
            
            ttk.Label(proxy_frame, text="Servidor Proxy:").pack(anchor='w')
            proxy_entry = ttk.Entry(proxy_frame, width=40)
            proxy_entry.pack(fill='x', pady=(0, 10))
            
            ttk.Label(proxy_frame, text="Porta:").pack(anchor='w')
            port_entry = ttk.Entry(proxy_frame, width=10)
            port_entry.pack(anchor='w', pady=(0, 10))
            
            # Bot√µes
            button_frame = ttk.Frame(main_frame)
            button_frame.pack(fill='x', pady=(20, 0))
            
            ttk.Button(button_frame, text="Salvar", 
                      command=lambda: self.save_update_settings(settings_window, auto_check_var, 
                                                               backup_var, notifications_var, 
                                                               proxy_entry, port_entry)).pack(side='right', padx=(10, 0))
            ttk.Button(button_frame, text="Cancelar", 
                      command=settings_window.destroy).pack(side='right')
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir configura√ß√µes: {e}")
    
    def save_update_settings(self, window, auto_check_var, backup_var, notifications_var, proxy_entry, port_entry):
        """Salva as configura√ß√µes de atualiza√ß√£o"""
        try:
            # Aqui voc√™ salvaria as configura√ß√µes no banco de dados
            settings = {
                'auto_check': auto_check_var.get(),
                'backup_before_update': backup_var.get(),
                'show_notifications': notifications_var.get(),
                'proxy_server': proxy_entry.get(),
                'proxy_port': port_entry.get()
            }
            
            # Salvar no banco de dados
            # self.db.save_update_settings(settings)
            
            messagebox.showinfo("Sucesso", "Configura√ß√µes salvas com sucesso!")
            window.destroy()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar configura√ß√µes: {e}")
    
    def show_update_history(self, parent_window):
        """Mostra o hist√≥rico de atualiza√ß√µes"""
        try:
            history_window = tk.Toplevel(parent_window)
            history_window.title("Hist√≥rico de Atualiza√ß√µes")
            history_window.geometry("600x400")
            history_window.transient(parent_window)
            history_window.grab_set()
            
            # Frame principal
            main_frame = ttk.Frame(history_window, padding=20)
            main_frame.pack(fill='both', expand=True)
            
            # T√≠tulo
            ttk.Label(main_frame, text="üìã Hist√≥rico de Atualiza√ß√µes", 
                     font=('Segoe UI', 14, 'bold')).pack(pady=(0, 20))
            
            # Treeview para o hist√≥rico
            columns = ('Vers√£o', 'Data', 'Status', 'Tamanho')
            tree = ttk.Treeview(main_frame, columns=columns, show='headings', height=15)
            
            # Configurar colunas
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=120)
            
            # Adicionar dados de exemplo
            tree.insert('', 'end', values=('2.3.1', '26/08/2025', 'Instalada', '15.2 MB'))
            tree.insert('', 'end', values=('2.3.0', '20/08/2025', 'Instalada', '14.8 MB'))
            tree.insert('', 'end', values=('2.2.9', '15/08/2025', 'Instalada', '14.5 MB'))
            tree.insert('', 'end', values=('2.2.8', '10/08/2025', 'Instalada', '14.2 MB'))
            
            tree.pack(fill='both', expand=True, pady=(0, 20))
            
            # Bot√£o fechar
            ttk.Button(main_frame, text="Fechar", command=history_window.destroy).pack()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir hist√≥rico: {e}")


class NotesEditor:
    """Editor de anota√ß√µes para cards"""
    
    def __init__(self, parent, db, card_id, current_user):
        self.parent = parent
        self.db = db
        self.card_id = card_id
        self.current_user = current_user
        self.current_note_id = None
        self.is_fullscreen = False
        self.original_geometry = None
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title(f"Editor de Anota√ß√µes - Card {card_id}")
        self.window.geometry("900x700")
        self.window.resizable(True, True)
        
        # Configurar grid
        self.window.grid_rowconfigure(1, weight=1)
        self.window.grid_columnconfigure(0, weight=1)
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        self.load_notes()
        
        # Centralizar janela
        self.window.transient(parent)
        self.window.grab_set()
        self.center_window()
        
        # Configurar atalhos de teclado
        self.setup_shortcuts()
    
    def create_widgets(self):
        """Cria os widgets da interface"""
        # Frame superior para controles
        top_frame = ttk.Frame(self.window)
        top_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=5)
        
        # T√≠tulo
        ttk.Label(top_frame, text="Editor de Anota√ß√µes", font=("Arial", 14, "bold")).pack(side=tk.LEFT)
        
        # Bot√µes de a√ß√£o
        button_frame = ttk.Frame(top_frame)
        button_frame.pack(side=tk.RIGHT)
        
        ttk.Button(button_frame, text="Nova Anota√ß√£o", command=self.new_note).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="Salvar", command=self.save_note).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="Excluir", command=self.delete_note).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="Exportar PDF", command=self.export_pdf).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="üñ•Ô∏è Tela Cheia", command=self.toggle_fullscreen).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="‚ùå Sair", command=self.close_editor).pack(side=tk.LEFT, padx=2)
        
        # Frame principal
        main_frame = ttk.Frame(self.window)
        main_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=5)
        main_frame.grid_rowconfigure(0, weight=1)
        main_frame.grid_columnconfigure(1, weight=1)
        
        # Lista de anota√ß√µes (esquerda)
        notes_frame = ttk.LabelFrame(main_frame, text="Anota√ß√µes", padding="5")
        notes_frame.grid(row=0, column=0, sticky="ns", padx=(0, 5))
        
        self.notes_listbox = tk.Listbox(notes_frame, width=30, height=20)
        self.notes_listbox.pack(fill=tk.BOTH, expand=True)
        self.notes_listbox.bind("<<ListboxSelect>>", self.on_note_select)
        
        # Frame do editor (direita)
        editor_frame = ttk.LabelFrame(main_frame, text="Editor", padding="5")
        editor_frame.grid(row=0, column=1, sticky="nsew")
        editor_frame.grid_rowconfigure(2, weight=1)
        editor_frame.grid_columnconfigure(1, weight=1)
        
        # T√≠tulo da anota√ß√£o
        ttk.Label(editor_frame, text="T√≠tulo:").grid(row=0, column=0, sticky="w", pady=(0, 5))
        self.title_entry = ttk.Entry(editor_frame)
        self.title_entry.grid(row=0, column=1, sticky="ew", pady=(0, 5))
        
        # Editor avan√ßado de texto
        try:
            from advanced_text_editor import AdvancedTextEditor
            
            # Criar editor avan√ßado
            self.advanced_editor = AdvancedTextEditor(editor_frame, height=15, width=50)
            self.advanced_editor.grid(row=2, column=0, columnspan=2, sticky="nsew")
            self.text_widget = self.advanced_editor.text_widget
            
            # Configurar tags adicionais espec√≠ficas para anota√ß√µes
            self.text_widget.tag_configure("bullet", lmargin1=20, lmargin2=20)
            self.text_widget.tag_configure("number", lmargin1=20, lmargin2=20)
            self.text_widget.tag_configure("checkbox", lmargin1=20, lmargin2=20)
            
            # Configurar eventos para atualiza√ß√£o autom√°tica
            self.text_widget.bind("<KeyRelease>", self.on_text_change)
            self.text_widget.bind("<ButtonRelease-1>", self.on_text_change)
            
            # Atualizar recursos periodicamente
            self.schedule_update()
            
        except ImportError:
            # Fallback para editor b√°sico se o avan√ßado n√£o estiver dispon√≠vel
            # Barra de formata√ß√£o
            format_frame = ttk.Frame(editor_frame)
            format_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(0, 5))
            
            # Bot√µes de formata√ß√£o (usando tk.Button em vez de ttk.Button para suportar font)
            tk.Button(format_frame, text="B", font=("Arial", 10, "bold"), width=3, 
                      command=lambda: self.apply_format("bold")).pack(side=tk.LEFT, padx=2)
            tk.Button(format_frame, text="I", font=("Arial", 10, "italic"), width=3,
                      command=lambda: self.apply_format("italic")).pack(side=tk.LEFT, padx=2)
            tk.Button(format_frame, text="U", font=("Arial", 10, "underline"), width=3,
                      command=lambda: self.apply_format("underline")).pack(side=tk.LEFT, padx=2)
            tk.Button(format_frame, text="‚Ä¢", width=3,
                      command=self.insert_bullet).pack(side=tk.LEFT, padx=2)
            tk.Button(format_frame, text="1.", width=3,
                      command=self.insert_number).pack(side=tk.LEFT, padx=2)
            tk.Button(format_frame, text="‚òê", width=3,
                      command=self.insert_checkbox).pack(side=tk.LEFT, padx=2)
            
            # √Årea de texto
            text_frame = ttk.Frame(editor_frame)
            text_frame.grid(row=2, column=0, columnspan=2, sticky="nsew")
            text_frame.grid_rowconfigure(0, weight=1)
            text_frame.grid_columnconfigure(0, weight=1)
            
            self.text_widget = tk.Text(text_frame, wrap=tk.WORD, undo=True)
            self.text_widget.grid(row=0, column=0, sticky="nsew")
            
            # Scrollbar
            scrollbar = ttk.Scrollbar(text_frame, orient="vertical", command=self.text_widget.yview)
            scrollbar.grid(row=0, column=1, sticky="ns")
            self.text_widget.configure(yscrollcommand=scrollbar.set)
            
            # Configurar tags para formata√ß√£o
            self.text_widget.tag_configure("bold", font=("Arial", 10, "bold"))
            self.text_widget.tag_configure("italic", font=("Arial", 10, "italic"))
            self.text_widget.tag_configure("underline", underline=True)
            self.text_widget.tag_configure("bullet", lmargin1=20, lmargin2=20)
            self.text_widget.tag_configure("number", lmargin1=20, lmargin2=20)
            self.text_widget.tag_configure("checkbox", lmargin1=20, lmargin2=20)
        
        # Status bar
        status_frame = ttk.Frame(self.window)
        status_frame.grid(row=2, column=0, sticky="ew", padx=10, pady=5)
        
        self.status_label = ttk.Label(status_frame, text="Pronto")
        self.status_label.pack(side=tk.LEFT)
        
        # Contador de caracteres
        self.char_count_label = ttk.Label(status_frame, text="0 caracteres")
        self.char_count_label.pack(side=tk.RIGHT)
        
        # Bind para contador de caracteres
        self.text_widget.bind("<KeyRelease>", self.update_char_count)
    
    def center_window(self):
        """Centraliza a janela na tela"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")
    
    def load_notes(self):
        """Carrega as anota√ß√µes do card"""
        self.notes_listbox.delete(0, tk.END)
        self.notes = []
        
        if self.current_user:
            user_id = getattr(self.current_user, 'id', None) or getattr(self.current_user, 'user_id', None)
            notes = self.db.get_card_notes(self.card_id, user_id)
        else:
            notes = self.db.get_card_notes(self.card_id)
        
        for note in notes:
            self.notes.append(note)
            self.notes_listbox.insert(tk.END, note['title'])
        
        if notes:
            self.notes_listbox.selection_set(0)
            self.on_note_select(None)
    
    def on_note_select(self, event):
        """Chamado quando uma anota√ß√£o √© selecionada"""
        selection = self.notes_listbox.curselection()
        if not selection:
            return
        
        note_index = selection[0]
        note = self.notes[note_index]
        
        self.current_note_id = note['id']
        self.title_entry.delete(0, tk.END)
        self.title_entry.insert(0, note['title'])
        
        self.text_widget.delete(1.0, tk.END)
        self.text_widget.insert(1.0, note['content'])
        
        self.update_char_count()
        self.status_label.config(text=f"Carregado: {note['title']}")
        
        # Atualizar recursos de formata√ß√£o
        self.update_formatting_resources()
    
    def new_note(self):
        """Cria uma nova anota√ß√£o"""
        self.current_note_id = None
        self.title_entry.delete(0, tk.END)
        self.title_entry.insert(0, "Nova Anota√ß√£o")
        self.text_widget.delete(1.0, tk.END)
        self.notes_listbox.selection_clear(0, tk.END)
        self.status_label.config(text="Nova anota√ß√£o")
        self.update_char_count()
    
    def save_note(self):
        """Salva a anota√ß√£o atual"""
        title = self.title_entry.get().strip()
        content = self.text_widget.get(1.0, tk.END).strip()
        
        if not title:
            messagebox.showwarning("Aviso", "Digite um t√≠tulo para a anota√ß√£o.")
            return
        
        if not self.current_user:
            messagebox.showerror("Erro", "Usu√°rio n√£o identificado.")
            return
        
        user_id = getattr(self.current_user, 'id', None) or getattr(self.current_user, 'user_id', None)
        
        if self.current_note_id:
            # Atualizar anota√ß√£o existente
            success = self.db.update_card_note(self.current_note_id, title, content)
            if success:
                self.status_label.config(text=f"Anota√ß√£o atualizada: {title}")
                self.load_notes()
            else:
                messagebox.showerror("Erro", "Erro ao atualizar anota√ß√£o.")
        else:
            # Criar nova anota√ß√£o
            note_id = self.db.create_card_note(self.card_id, user_id, title, content)
            if note_id:
                self.status_label.config(text=f"Anota√ß√£o criada: {title}")
                self.load_notes()
            else:
                messagebox.showerror("Erro", "Erro ao criar anota√ß√£o.")
    
    def delete_note(self):
        """Exclui a anota√ß√£o atual"""
        if not self.current_note_id:
            messagebox.showwarning("Aviso", "Selecione uma anota√ß√£o para excluir.")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir esta anota√ß√£o?"):
            success = self.db.delete_card_note(self.current_note_id)
            if success:
                self.status_label.config(text="Anota√ß√£o exclu√≠da")
                self.load_notes()
                self.new_note()
            else:
                messagebox.showerror("Erro", "Erro ao excluir anota√ß√£o.")
    
    def apply_format(self, format_type):
        """Aplica formata√ß√£o ao texto selecionado"""
        try:
            selection = self.text_widget.tag_ranges(tk.SEL)
            if not selection:
                return
            
            start, end = selection
            
            if format_type == "bold":
                self.text_widget.tag_add("bold", start, end)
            elif format_type == "italic":
                self.text_widget.tag_add("italic", start, end)
            elif format_type == "underline":
                self.text_widget.tag_add("underline", start, end)
        except tk.TclError:
            pass  # Nenhuma sele√ß√£o
    
    def insert_bullet(self):
        """Insere um ponto de t√≥pico"""
        current_pos = self.text_widget.index(tk.INSERT)
        self.text_widget.insert(current_pos, "‚Ä¢ ")
        self.text_widget.tag_add("bullet", current_pos, f"{current_pos}+2c")
    
    def insert_number(self):
        """Insere numera√ß√£o"""
        current_pos = self.text_widget.index(tk.INSERT)
        self.text_widget.insert(current_pos, "1. ")
        self.text_widget.tag_add("number", current_pos, f"{current_pos}+3c")
    
    def insert_checkbox(self):
        """Insere checkbox"""
        current_pos = self.text_widget.index(tk.INSERT)
        self.text_widget.insert(current_pos, "‚òê ")
        self.text_widget.tag_add("checkbox", current_pos, f"{current_pos}+2c")
    
    def update_char_count(self, event=None):
        """Atualiza o contador de caracteres"""
        content = self.text_widget.get(1.0, tk.END)
        char_count = len(content) - 1  # -1 para remover o caractere de nova linha final
        self.char_count_label.config(text=f"{char_count} caracteres")
    
    def export_pdf(self):
        """Exporta a anota√ß√£o atual para PDF"""
        if not self.current_note_id:
            messagebox.showwarning("Aviso", "Selecione uma anota√ß√£o para exportar.")
            return
        
        try:
            from reportlab.lib.pagesizes import letter
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            from reportlab.lib.enums import TA_LEFT, TA_CENTER
            import os
            
            # Obter dados da anota√ß√£o
            note = self.db.get_note_by_id(self.current_note_id)
            if not note:
                messagebox.showerror("Erro", "Anota√ß√£o n√£o encontrada.")
                return
            
            # Solicitar local para salvar
            import tkinter.filedialog as filedialog
            filename = filedialog.asksaveasfilename(
                defaultextension=".pdf",
                filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")],
                title="Salvar anota√ß√£o como PDF"
            )
            
            if not filename:
                return
            
            # Criar documento PDF
            doc = SimpleDocTemplate(filename, pagesize=letter)
            story = []
            
            # Estilos
            styles = getSampleStyleSheet()
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=16,
                spaceAfter=30,
                alignment=TA_CENTER
            )
            
            content_style = ParagraphStyle(
                'CustomContent',
                parent=styles['Normal'],
                fontSize=12,
                spaceAfter=12,
                alignment=TA_LEFT
            )
            
            # T√≠tulo
            story.append(Paragraph(note['title'], title_style))
            story.append(Spacer(1, 20))
            
            # Conte√∫do (processar formata√ß√£o b√°sica)
            content_lines = note['content'].split('\n')
            for line in content_lines:
                if line.strip():
                    # Processar formata√ß√£o b√°sica
                    processed_line = line.replace('‚Ä¢', '‚Ä¢').replace('‚òê', '‚òê')
                    story.append(Paragraph(processed_line, content_style))
                else:
                    story.append(Spacer(1, 6))
            
            # Gerar PDF
            doc.build(story)
            
            self.status_label.config(text=f"PDF exportado: {os.path.basename(filename)}")
            messagebox.showinfo("Sucesso", f"PDF exportado com sucesso!\n{filename}")
            
        except ImportError:
            messagebox.showerror("Erro", "Biblioteca reportlab n√£o encontrada. Instale com: pip install reportlab")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar PDF: {str(e)}")
    
    def toggle_fullscreen(self):
        """Alterna entre tela cheia e normal"""
        if not self.is_fullscreen:
            # Salvar geometria atual
            self.original_geometry = self.window.geometry()
            # Ir para tela cheia
            self.window.state('zoomed')  # Windows
            self.is_fullscreen = True
        else:
            # Restaurar geometria original
            if self.original_geometry:
                self.window.geometry(self.original_geometry)
            else:
                self.window.geometry("900x700")
            self.window.state('normal')
            self.is_fullscreen = False
    
    def close_editor(self):
        """Fecha o editor de anota√ß√µes"""
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja sair? As altera√ß√µes n√£o salvas ser√£o perdidas."):
            self.window.destroy()
    
    def update_formatting_resources(self):
        """Atualiza os recursos de formata√ß√£o do editor avan√ßado"""
        if hasattr(self, 'advanced_editor'):
            # Atualizar fontes e tamanhos no editor avan√ßado
            self.advanced_editor.update_status()
            
            # For√ßar atualiza√ß√£o da interface
            self.advanced_editor.text_widget.update_idletasks()
            
            # Atualizar contador de caracteres
            self.update_char_count()
    
    def on_text_change(self, event=None):
        """Chamado quando o texto √© alterado"""
        # Atualizar contador de caracteres
        self.update_char_count()
        
        # Atualizar recursos de formata√ß√£o se necess√°rio
        if hasattr(self, 'advanced_editor'):
            self.advanced_editor.update_status()
    
    def schedule_update(self):
        """Agenda atualiza√ß√µes peri√≥dicas dos recursos"""
        try:
            if hasattr(self, 'advanced_editor'):
                self.advanced_editor.update_status()
            self.update_char_count()
            
            # Agendar pr√≥xima atualiza√ß√£o em 1 segundo
            self.window.after(1000, self.schedule_update)
        except:
            pass  # Janela pode ter sido fechada
    
    def setup_shortcuts(self):
        """Configura atalhos de teclado"""
        self.window.bind("<F11>", lambda e: self.toggle_fullscreen())
        self.window.bind("<Escape>", lambda e: self.close_editor())
        self.window.bind("<Control-s>", lambda e: self.save_note())
        self.window.bind("<Control-n>", lambda e: self.new_note())
        self.window.bind("<Control-d>", lambda e: self.delete_note())
        self.window.bind("<Control-e>", lambda e: self.export_pdf())

class SubjectManagerWindow(tk.Toplevel):
    def __init__(self, parent, app, subject_type):
        super().__init__(parent)
        self.app = app
        self.subject_type = subject_type
        
        if self.subject_type == 'pomodoro':
            self.title("Gerenciar Assuntos do Pomodoro")
            self.subjects_df = self.app.pomodoro_subjects_df
            self.subjects_list = self.app.pomodoro_subjects
            self.file_path = self.app.pomodoro_subjects_file
        else: # boodesk
            self.title("Gerenciar Assuntos do Boodesk")
            self.subjects_df = self.app.boodesk_subjects_df
            self.subjects_list = self.app.boodesk_subjects
            self.file_path = self.app.boodesk_subjects_file

        self.geometry("450x350")
        self.transient(parent)
        self.grab_set()

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        self._populate_subjects_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Listbox Frame
        list_frame = ttk.LabelFrame(main_frame, text="Assuntos Cadastrados")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        self.subjects_listbox = tk.Listbox(list_frame, selectmode=tk.SINGLE)
        self.subjects_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.subjects_listbox.bind("<<ListboxSelect>>", self._on_subject_select)
        
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.subjects_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.subjects_listbox.config(yscrollcommand=scrollbar.set)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Assunto")
        entry_frame.pack(fill=tk.X, pady=5)
        entry_frame.columnconfigure(0, weight=1)

        self.subject_entry = ttk.Entry(entry_frame)
        self.subject_entry.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        
        self.add_edit_button = ttk.Button(entry_frame, text="Adicionar", command=self._add_subject)
        self.add_edit_button.grid(row=0, column=1, padx=5, pady=5)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Remover Selecionado", command=self._remove_subject).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", command=self.destroy).pack(side=tk.RIGHT, padx=5)

    def _populate_subjects_list(self):
        self.subjects_listbox.delete(0, tk.END)
        # Sort the list for better UX
        for subject in sorted(self.subjects_list):
            if subject != '-': # Don't show the default '-'
                self.subjects_listbox.insert(tk.END, subject)

    def _on_subject_select(self, event):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            self.subject_entry.delete(0, tk.END)
            self.add_edit_button.config(text="Adicionar", command=self._add_subject)
            return
        
        selected_subject = self.subjects_listbox.get(selected_indices[0])
        self.subject_entry.delete(0, tk.END)
        self.subject_entry.insert(0, selected_subject)
        self.add_edit_button.config(text="Salvar Edi√ß√£o", command=self._edit_subject)

    def _clear_selection(self):
        self.subjects_listbox.selection_clear(0, tk.END)
        self.subject_entry.delete(0, tk.END)
        self.add_edit_button.config(text="Adicionar", command=self._add_subject)
        # Manually trigger the event handler to reset the button state
        self._on_subject_select(None)


    def _add_subject(self):
        new_subject = self.subject_entry.get().strip()
        if not new_subject:
            messagebox.showwarning("Entrada Inv√°lida", "O nome do assunto n√£o pode estar vazio.", parent=self)
            return
        
        if new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' j√° existe.", parent=self)
            return

        # Update DataFrame and list
        new_subject_df = pd.DataFrame({'Assunto': [new_subject]})
        self.subjects_df = pd.concat([self.subjects_df, new_subject_df], ignore_index=True)
        self.subjects_list.append(new_subject)
        
        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{new_subject}' adicionado.", parent=self)

    def _edit_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um assunto para editar.", parent=self)
            return
            
        old_subject = self.subjects_listbox.get(selected_indices[0])
        new_subject = self.subject_entry.get().strip()

        if not new_subject:
            messagebox.showwarning("Entrada Inv√°lida", "O nome do assunto n√£o pode estar vazio.", parent=self)
            return

        if new_subject != old_subject and new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' j√° existe.", parent=self)
            return

        # Update DataFrame and list
        self.subjects_df.loc[self.subjects_df['Assunto'] == old_subject, 'Assunto'] = new_subject
        self.subjects_list[self.subjects_list.index(old_subject)] = new_subject

        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{old_subject}' atualizado para '{new_subject}'.", parent=self)

    def _remove_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um assunto para remover.", parent=self)
            return

        subject_to_remove = self.subjects_listbox.get(selected_indices[0])
        
        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover o assunto '{subject_to_remove}'?\nIsso n√£o pode ser desfeito e n√£o alterar√° os cart√µes existentes.", parent=self):
            # Update DataFrame and list
            self.subjects_df = self.subjects_df[self.subjects_df['Assunto'] != subject_to_remove]
            self.subjects_list.remove(subject_to_remove)
            
            # Save and refresh
            self._save_and_refresh()
            self._clear_selection()
            messagebox.showinfo("Sucesso", f"Assunto '{subject_to_remove}' removido.", parent=self)

    def _save_and_refresh(self):
        # Save the DataFrame to the Excel file
        self.subjects_df.to_excel(self.file_path, index=False)
        
        # Update the main app's data
        if self.subject_type == 'pomodoro':
            self.app.pomodoro_subjects_df = self.subjects_df
            self.app.pomodoro_subjects = self.subjects_list
        else: # boodesk
            self.app.boodesk_subjects_df = self.subjects_df
            self.app.boodesk_subjects = self.subjects_list
            
        # Reload all auxiliary data in the main app to update all UI components
        self.app.load_aux_data()
        self.app.update_all_displays() # A comprehensive update
        
        # Refresh the listbox in this window
        self._populate_subjects_list()

    def destroy(self):
        # Ensure the main app window gets focus back
        self.app.root.focus_set()
        super().destroy()

class ArchivedCardsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Cart√µes Arquivados")
        self.geometry("600x400")
        self.transient(parent)
        self.grab_set()

        if self.app.settings.get('open_on_current_screen', False):
            self.update_idletasks()
            parent_x = parent.winfo_x()
            parent_y = parent.winfo_y()
            parent_width = parent.winfo_width()
            parent_height = parent.winfo_height()

            x = parent_x + (parent_width // 2) - (self.winfo_width() // 2)
            y = parent_y + (parent_height // 2) - (self.winfo_height() // 2)
            self.geometry(f"+{x}+{y}")

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        self._populate_archived_cards_listbox()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Cart√µes Arquivados:").pack(anchor="w", pady=5)

        self.archived_listbox = tk.Listbox(main_frame, selectmode=tk.SINGLE)
        self.archived_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        self.archived_listbox.bind("<Double-1>", self._restore_card_from_double_click)

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=5)

        ttk.Button(button_frame, text="Restaurar Cart√£o", command=self._restore_card).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Excluir Permanentemente", command=self._delete_card_permanently).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", command=self.destroy).pack(side=tk.LEFT, padx=5)

    def _populate_archived_cards_listbox(self):
        self.archived_listbox.delete(0, tk.END)
        self.archived_cards_data = [] # Store references to actual card objects

        for board_name, lists in self.app.trello_data["boards"].items():
            for list_name, cards in lists.items():
                for card in cards:
                    if card.get("is_archived", False):
                        display_text = f"{board_name} > {list_name} > {card['title']}"
                        self.archived_listbox.insert(tk.END, display_text)
                        self.archived_cards_data.append({"board": board_name, "list": list_name, "card": card})

    def _restore_card_from_double_click(self, event):
        self._restore_card()

    def _restore_card(self):
        selected_index = self.archived_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um cart√£o para restaurar.")
            return

        card_info = self.archived_cards_data[selected_index[0]]
        card = card_info["card"]
        board_name = card_info["board"]
        list_name = card_info["list"] # This is the original list name

        if messagebox.askyesno("Confirmar Restaura√ß√£o", f"Tem certeza que deseja restaurar o cart√£o '{card['title']}' para o quadro '{board_name}' na lista '{list_name}'?"):
            card["is_archived"] = False

            # Remove the card from its current list (where it was archived)
            # We need to find the card by its card_id and remove it from the list it's currently in.
            # This assumes the card is still in the list it was in when it was archived.
            found_and_removed = False
            if board_name in self.app.trello_data["boards"] and list_name in self.app.trello_data["boards"][board_name]:
                original_list = self.app.trello_data["boards"][board_name][list_name]
                for i, c in enumerate(original_list):
                    if c.get("card_id") == card.get("card_id"):
                        original_list.pop(i)
                        found_and_removed = True
                        break
            
            if not found_and_removed:
                messagebox.showerror("Erro de Restaura√ß√£o", "N√£o foi poss√≠vel encontrar o cart√£o em sua lista original para remo√ß√£o.")
                return

            # Add the card to the target list
            target_list_name = list_name # Default to original list
            if list_name not in self.app.trello_data["boards"][board_name]:
                # Fallback to "A Fazer" if original list was deleted
                if "A Fazer" in self.app.trello_data["boards"][board_name]:
                    target_list_name = "A Fazer"
                    messagebox.showinfo("Restaura√ß√£o", f"Lista original '{list_name}' n√£o encontrada. Cart√£o restaurado para 'A Fazer'.")
                else:
                    messagebox.showerror("Erro de Restaura√ß√£o", "N√£o foi poss√≠vel restaurar o cart√£o. A lista original e 'A Fazer' n√£o existem.")
                    return
            
            self.app.trello_data["boards"][board_name][target_list_name].append(card)
            
            self.app.save_trello_data()
            self.app.populate_boards() # Refresh main board view
            self._populate_archived_cards_listbox() # Refresh archived list
            messagebox.showinfo("Sucesso", f"Cart√£o '{card['title']}' restaurado com sucesso!")

    def _delete_card_permanently(self):
        selected_index = self.archived_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um cart√£o para excluir permanentemente.")
            return

        card_info = self.archived_cards_data[selected_index[0]]
        card = card_info["card"]
        board_name = card_info["board"]
        list_name = card_info["list"]

        if messagebox.askyesno("Confirmar Exclus√£o Permanente", f"Tem certeza que deseja EXCLUIR PERMANENTEMENTE o cart√£o '{card['title']}'? Esta a√ß√£o n√£o pode ser desfeita."):
            # Find the card in the actual data structure and remove it
            if board_name in self.app.trello_data["boards"] and list_name in self.app.trello_data["boards"][board_name]:
                # Filter out the card by its unique card_id
                self.app.trello_data["boards"][board_name][list_name] = [
                    c for c in self.app.trello_data["boards"][board_name][list_name] if c.get("card_id") != card.get("card_id")
                ]
                self.app.save_trello_data()
                self.app.populate_boards() # Refresh main board view
                self._populate_archived_cards_listbox() # Refresh archived list
                messagebox.showinfo("Sucesso", f"Cart√£o '{card['title']}' exclu√≠do permanentemente.")
            else:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel encontrar o cart√£o na estrutura de dados para exclus√£o.")


class CardImportanceWindow:
    def __init__(self, parent, app, board_name, list_name, card_title, callback):
        self.parent = parent
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self.card_title = card_title
        self.callback = callback
        self.selected_importance = "Normal"
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title("Selecionar Import√¢ncia")
        self.window.geometry("500x400")
        self.window.resizable(False, False)
        self.window.transient(parent)
        self.window.grab_set()
        
        # Centralizar na tela
        self.window.update_idletasks()
        x = (self.window.winfo_screenwidth() // 2) - (500 // 2)
        y = (self.window.winfo_screenheight() // 2) - (400 // 2)
        self.window.geometry(f"500x400+{x}+{y}")
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        
    def create_widgets(self):
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_label = ttk.Label(main_frame, text="Selecionar Import√¢ncia do Card", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Card title
        card_title_label = ttk.Label(main_frame, text=f"T√≠tulo: {self.card_title}", 
                                    font=("Arial", 10))
        card_title_label.pack(pady=(0, 20))
        
        # Frame para os bot√µes de import√¢ncia
        importance_frame = ttk.Frame(main_frame)
        importance_frame.pack(pady=20)
        
        # Obter configura√ß√µes de import√¢ncia das configura√ß√µes do app
        importance_colors = self.app.settings.get("importance_colors", {
            "Cr√≠tica": "#FFCCCC",
            "Alta": "#FFE5CC", 
            "Normal": "#FFFFCC",
            "Baixa": "#CCFFCC"
        })
        
        # Debug: imprimir as import√¢ncias dispon√≠veis
        print(f"DEBUG: Import√¢ncias dispon√≠veis: {list(importance_colors.keys())}")
        
        self.importance_var = tk.StringVar(value="Normal")
        self.importance_buttons = {}  # Para armazenar refer√™ncias dos bot√µes
        
        # Criar bot√µes coloridos para cada n√≠vel de import√¢ncia
        # Organizar em uma coluna vertical com ordem espec√≠fica
        importance_order = ["Cr√≠tica", "Alta", "Normal", "Baixa"]
        
        for importance in importance_order:
            if importance in importance_colors:
                color = importance_colors[importance]
                print(f"DEBUG: Criando bot√£o para {importance} com cor {color}")
                # Bot√£o colorido (mais fino)
                importance_btn = tk.Button(importance_frame, 
                                         text=importance,
                                         font=("Arial", 14, "bold"),
                                         bg=color,
                                         fg="black",
                                         relief=tk.RAISED,
                                         borderwidth=1,
                                         width=25,
                                         height=1,
                                         command=lambda imp=importance: self.on_importance_selected(imp))
                importance_btn.pack(fill=tk.X, padx=30, pady=3)
                
                # Armazenar refer√™ncia do bot√£o
                self.importance_buttons[importance] = importance_btn
            else:
                print(f"DEBUG: Import√¢ncia {importance} n√£o encontrada nas configura√ß√µes")
        
        # Frame para bot√£o Cancelar (opcional)
        action_frame = ttk.Frame(main_frame)
        action_frame.pack(pady=20)
        
        # Bot√£o Cancelar (opcional, caso o usu√°rio queira cancelar)
        cancel_btn = ttk.Button(action_frame, text="Cancelar", 
                               command=self.cancel)
        cancel_btn.pack(side=tk.RIGHT)
        
    def on_importance_selected(self, importance):
        self.selected_importance = importance
        self.importance_var.set(importance)
        
        # Atualizar apar√™ncia dos bot√µes (destacar o selecionado)
        for imp, btn in self.importance_buttons.items():
            if imp == importance:
                # Bot√£o selecionado - borda mais grossa
                btn.config(relief=tk.SUNKEN, borderwidth=3)
            else:
                # Bot√£o n√£o selecionado - borda normal
                btn.config(relief=tk.RAISED, borderwidth=2)
        
        # Aguardar um momento para mostrar a sele√ß√£o e depois avan√ßar
        self.window.after(500, self.continue_to_description)
        
    def continue_to_description(self):
        self.window.destroy()
        # Abrir tela de descri√ß√£o
        CardDescriptionWindow(self.parent, self.app, self.board_name, 
                            self.list_name, self.card_title, 
                            self.selected_importance, self.callback)
        
    def cancel(self):
        self.window.destroy()


class CardDescriptionWindow:
    def __init__(self, parent, app, board_name, list_name, card_title, 
                 importance, callback, initial_description=""):
        self.parent = parent
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self.card_title = card_title
        self.importance = importance
        self.callback = callback
        self.description = initial_description
        
        # Criar janela
        self.window = tk.Toplevel(parent)
        self.window.title("Descri√ß√£o do Card")
        self.window.geometry("500x400")
        self.window.resizable(False, False)
        self.window.transient(parent)
        self.window.grab_set()
        
        # Centralizar na tela
        self.window.update_idletasks()
        x = (self.window.winfo_screenwidth() // 2) - (500 // 2)
        y = (self.window.winfo_screenheight() // 2) - (400 // 2)
        self.window.geometry(f"500x400+{x}+{y}")
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        
    def create_widgets(self):
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_label = ttk.Label(main_frame, text="Descri√ß√£o do Card", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 10))
        
        # Informa√ß√µes do card
        info_frame = ttk.Frame(main_frame)
        info_frame.pack(fill=tk.X, pady=(0, 20))
        
        # T√≠tulo do card
        card_title_label = ttk.Label(info_frame, text=f"T√≠tulo: {self.card_title}", 
                                    font=("Arial", 10))
        card_title_label.pack(anchor=tk.W)
        
        # Import√¢ncia
        importance_colors = self.app.settings.get("importance_colors", {
            "Cr√≠tica": "#FFCCCC",
            "Alta": "#FFE5CC", 
            "Normal": "#FFFFCC",
            "Baixa": "#CCFFCC"
        })
        
        importance_frame = ttk.Frame(info_frame)
        importance_frame.pack(anchor=tk.W, pady=(5, 0))
        
        importance_label = ttk.Label(importance_frame, text="Import√¢ncia: ")
        importance_label.pack(side=tk.LEFT)
        
        color_label = tk.Label(importance_frame, text=f" {self.importance} ", 
                              bg=importance_colors.get(self.importance, "#FFFFCC"),
                              relief=tk.SOLID, borderwidth=1,
                              font=("Arial", 10, "bold"))
        color_label.pack(side=tk.LEFT)
        
        # Frame para descri√ß√£o
        desc_frame = ttk.LabelFrame(main_frame, text="Descri√ß√£o (opcional)", padding="10")
        desc_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Frame interno para text e scrollbar
        text_frame = ttk.Frame(desc_frame)
        text_frame.pack(fill=tk.BOTH, expand=True)
        
        # Text area para descri√ß√£o
        self.desc_text = tk.Text(text_frame, height=8, wrap=tk.WORD, 
                                font=("Arial", 10))
        self.desc_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Carregar descri√ß√£o inicial se existir
        if self.description:
            self.desc_text.insert("1.0", self.description)
        
        # Scrollbar para o text area
        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, 
                                 command=self.desc_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.desc_text.configure(yscrollcommand=scrollbar.set)
        
        # === BOTTOM ACTION BUTTONS (FIXED AT BOTTOM) ===
        button_frame = ttk.LabelFrame(main_frame, text="A√ß√µes", padding="10")
        button_frame.pack(fill=tk.X, side=tk.BOTTOM, pady=(10, 0))
        
        # Create buttons using pack layout
        send_btn = ttk.Button(button_frame, text="Enviar", 
                            command=self.save_card)
        send_btn.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
        
        cancel_btn = ttk.Button(button_frame, text="Cancelar", 
                              command=self.cancel)
        cancel_btn.pack(side=tk.RIGHT, fill=tk.X, expand=True)
        
    def save_card(self):
        # Obter descri√ß√£o
        self.description = self.desc_text.get("1.0", tk.END).strip()
        
        # Fechar janela
        self.window.destroy()
        
        # Chamar callback com os dados do card
        self.callback(self.card_title, self.importance, self.description)
        
    def cancel(self):
        self.window.destroy()


class SubTaskDetailWindow:
    """Janela para gerenciar detalhes de uma subtarefa espec√≠fica"""
    
    def __init__(self, app, card, subtask, parent=None):
        self.app = app
        self.card = card
        self.subtask = subtask
        self.parent = parent
        self.current_user = app.current_user
        
        # Criar janela
        self.window = tk.Toplevel(app.root)
        self.window.title(f"Detalhes da Subtarefa: {subtask.get('title', '')}")
        self.window.geometry("800x700")
        self.window.resizable(True, True)
        self.window.transient(app.root)
        self.window.grab_set()
        
        # Centralizar janela
        self.window.update_idletasks()
        x = (self.window.winfo_screenwidth() // 2) - (800 // 2)
        y = (self.window.winfo_screenheight() // 2) - (700 // 2)
        self.window.geometry(f"800x700+{x}+{y}")
        
        # Criar interface
        self._create_widgets()
        self._load_subtask_data()
    
    def _create_widgets(self):
        """Cria os widgets da interface"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(title_frame, text="üìã Detalhes da Subtarefa", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        # Status da subtarefa
        self.status_var = tk.StringVar()
        status_combo = ttk.Combobox(title_frame, textvariable=self.status_var,
                                   values=["Pendente", "Em Progresso", "Conclu√≠da", "Cancelada"],
                                   state="readonly", width=15)
        status_combo.pack(side=tk.RIGHT, padx=10)
        status_combo.bind("<<ComboboxSelected>>", self._update_subtask_status)
        
        # Notebook para organizar as se√ß√µes
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Aba de Informa√ß√µes Gerais
        self._create_general_tab()
        
        # Aba de Descri√ß√£o
        self._create_description_tab()
        
        # Aba de Arquivos
        self._create_files_tab()
        
        # Aba de Coment√°rios
        self._create_comments_tab()
        
        # Aba de Hist√≥rico
        self._create_history_tab()
        
        # Bot√µes de a√ß√£o
        self._create_action_buttons(main_frame)
    
    def _create_general_tab(self):
        """Cria aba de informa√ß√µes gerais"""
        general_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(general_frame, text="Informa√ß√µes Gerais")
        
        # Informa√ß√µes da subtarefa
        info_frame = ttk.LabelFrame(general_frame, text="Informa√ß√µes da Subtarefa", padding="10")
        info_frame.pack(fill=tk.X, pady=(0, 10))
        
        # T√≠tulo
        ttk.Label(info_frame, text="T√≠tulo:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        self.title_entry = ttk.Entry(info_frame, width=50)
        self.title_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        
        # Card pai
        ttk.Label(info_frame, text="Card Pai:").grid(row=1, column=0, sticky="w", padx=5, pady=5)
        card_label = ttk.Label(info_frame, text=self.card.get('title', ''), font=("Arial", 10, "bold"))
        card_label.grid(row=1, column=1, sticky="w", padx=5, pady=5)
        
        # Respons√°vel
        ttk.Label(info_frame, text="Respons√°vel:").grid(row=2, column=0, sticky="w", padx=5, pady=5)
        
        # Buscar membros do banco de dados
        try:
            members = self.app.db.get_members()
            member_options = [member['Membro'] for member in members] if members else []
        except:
            member_options = []
        
        self.responsible_combo = ttk.Combobox(info_frame, values=member_options, state="readonly", width=30)
        self.responsible_combo.grid(row=2, column=1, sticky="w", padx=5, pady=5)
        self.responsible_combo.bind("<<ComboboxSelected>>", self._update_responsible)
        
        # Prioridade
        ttk.Label(info_frame, text="Prioridade:").grid(row=3, column=0, sticky="w", padx=5, pady=5)
        self.priority_var = tk.StringVar()
        priority_combo = ttk.Combobox(info_frame, textvariable=self.priority_var,
                                    values=["Baixa", "Normal", "Alta", "Cr√≠tica"], state="readonly", width=15)
        priority_combo.grid(row=3, column=1, sticky="w", padx=5, pady=5)
        priority_combo.bind("<<ComboboxSelected>>", self._update_priority)
        
        # Data de cria√ß√£o
        ttk.Label(info_frame, text="Criada em:").grid(row=4, column=0, sticky="w", padx=5, pady=5)
        created_label = ttk.Label(info_frame, text=self.subtask.get('created_at', ''))
        created_label.grid(row=4, column=1, sticky="w", padx=5, pady=5)
        
        # Data de conclus√£o
        ttk.Label(info_frame, text="Conclu√≠da em:").grid(row=5, column=0, sticky="w", padx=5, pady=5)
        completed_label = ttk.Label(info_frame, text=self.subtask.get('completed_at', 'N√£o conclu√≠da'))
        completed_label.grid(row=5, column=1, sticky="w", padx=5, pady=5)
        
        # Configurar grid
        info_frame.columnconfigure(1, weight=1)
    
    def _create_description_tab(self):
        """Cria aba de descri√ß√£o"""
        desc_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(desc_frame, text="Descri√ß√£o")
        
        # Descri√ß√£o da subtarefa
        desc_label_frame = ttk.LabelFrame(desc_frame, text="Descri√ß√£o Detalhada", padding="10")
        desc_label_frame.pack(fill=tk.BOTH, expand=True)
        
        # Text widget para descri√ß√£o
        self.description_text = tk.Text(desc_label_frame, height=15, wrap=tk.WORD)
        self.description_text.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Scrollbar para o text widget
        desc_scrollbar = ttk.Scrollbar(desc_label_frame, orient="vertical", command=self.description_text.yview)
        desc_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.description_text.config(yscrollcommand=desc_scrollbar.set)
        
        # Bot√£o para salvar descri√ß√£o
        save_desc_btn = ttk.Button(desc_label_frame, text="Salvar Descri√ß√£o", 
                                  command=self._save_description)
        save_desc_btn.pack(pady=10)
    
    def _create_files_tab(self):
        """Cria aba de arquivos"""
        files_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(files_frame, text="Arquivos")
        
        # Frame para upload de arquivos
        upload_frame = ttk.LabelFrame(files_frame, text="Upload de Arquivos", padding="10")
        upload_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Bot√µes de upload
        btn_frame = ttk.Frame(upload_frame)
        btn_frame.pack(fill=tk.X)
        
        ttk.Button(btn_frame, text="üìÅ Selecionar Arquivo", 
                  command=self._upload_file).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(btn_frame, text="üñºÔ∏è Selecionar Imagem", 
                  command=self._upload_image).pack(side=tk.LEFT, padx=5)
        
        # Lista de arquivos
        files_list_frame = ttk.LabelFrame(files_frame, text="Arquivos Anexados", padding="10")
        files_list_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview para arquivos
        columns = ("Nome", "Tipo", "Tamanho", "Data")
        self.files_treeview = ttk.Treeview(files_list_frame, columns=columns, show="headings", height=8)
        
        self.files_treeview.heading("Nome", text="Nome do Arquivo")
        self.files_treeview.heading("Tipo", text="Tipo")
        self.files_treeview.heading("Tamanho", text="Tamanho")
        self.files_treeview.heading("Data", text="Data de Upload")
        
        self.files_treeview.column("Nome", width=200, anchor="w")
        self.files_treeview.column("Tipo", width=100, anchor="w")
        self.files_treeview.column("Tamanho", width=100, anchor="w")
        self.files_treeview.column("Data", width=150, anchor="w")
        
        self.files_treeview.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Scrollbar para treeview
        files_scrollbar = ttk.Scrollbar(files_list_frame, orient="vertical", command=self.files_treeview.yview)
        files_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.files_treeview.config(yscrollcommand=files_scrollbar.set)
        
        # Bot√µes de a√ß√£o para arquivos
        files_btn_frame = ttk.Frame(files_list_frame)
        files_btn_frame.pack(fill=tk.X, pady=5)
        
        ttk.Button(files_btn_frame, text="üì• Baixar", 
                  command=self._download_file).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(files_btn_frame, text="üóëÔ∏è Remover", 
                  command=self._remove_file).pack(side=tk.LEFT, padx=5)
        
        # Bind duplo clique para abrir arquivo
        self.files_treeview.bind("<Double-1>", self._open_file)
    
    def _create_comments_tab(self):
        """Cria aba de coment√°rios"""
        comments_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(comments_frame, text="Coment√°rios")
        
        # Frame para adicionar coment√°rio
        add_comment_frame = ttk.LabelFrame(comments_frame, text="Adicionar Coment√°rio", padding="10")
        add_comment_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Text widget para novo coment√°rio
        self.new_comment_text = tk.Text(add_comment_frame, height=4, wrap=tk.WORD)
        self.new_comment_text.pack(fill=tk.X, pady=5)
        
        # Bot√£o para adicionar coment√°rio
        add_comment_btn = ttk.Button(add_comment_frame, text="Adicionar Coment√°rio", 
                                   command=self._add_comment)
        add_comment_btn.pack(pady=5)
        
        # Lista de coment√°rios
        comments_list_frame = ttk.LabelFrame(comments_frame, text="Coment√°rios", padding="10")
        comments_list_frame.pack(fill=tk.BOTH, expand=True)
        
        # Text widget para exibir coment√°rios
        self.comments_text = tk.Text(comments_list_frame, wrap=tk.WORD, state=tk.DISABLED)
        self.comments_text.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Scrollbar para coment√°rios
        comments_scrollbar = ttk.Scrollbar(comments_list_frame, orient="vertical", command=self.comments_text.yview)
        comments_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.comments_text.config(yscrollcommand=comments_scrollbar.set)
    
    def _create_history_tab(self):
        """Cria aba de hist√≥rico"""
        history_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(history_frame, text="Hist√≥rico")
        
        # Treeview para hist√≥rico
        columns = ("Data/Hora", "Usu√°rio", "A√ß√£o", "Detalhes")
        self.history_treeview = ttk.Treeview(history_frame, columns=columns, show="headings", height=10)
        
        self.history_treeview.heading("Data/Hora", text="Data/Hora")
        self.history_treeview.heading("Usu√°rio", text="Usu√°rio")
        self.history_treeview.heading("A√ß√£o", text="A√ß√£o")
        self.history_treeview.heading("Detalhes", text="Detalhes")
        
        self.history_treeview.column("Data/Hora", width=150, anchor="w")
        self.history_treeview.column("Usu√°rio", width=100, anchor="w")
        self.history_treeview.column("A√ß√£o", width=120, anchor="w")
        self.history_treeview.column("Detalhes", width=300, anchor="w")
        
        self.history_treeview.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Scrollbar para hist√≥rico
        history_scrollbar = ttk.Scrollbar(history_frame, orient="vertical", command=self.history_treeview.yview)
        history_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.history_treeview.config(yscrollcommand=history_scrollbar.set)
    
    def _get_user_id_safe(self):
        """Obt√©m o user_id de forma segura"""
        if hasattr(self.current_user, 'id'):
            return self.current_user.id
        elif hasattr(self.current_user, 'user_id'):
            return self.current_user.user_id
        elif isinstance(self.current_user, dict):
            return self.current_user.get('id') or self.current_user.get('user_id')
        else:
            # Tentar obter do banco de dados
            try:
                if hasattr(self.current_user, 'username'):
                    user_data = self.app.db.get_user_by_username(self.current_user.username)
                    return user_data.get('id') if user_data else 1
                else:
                    return 1  # Usu√°rio padr√£o
            except:
                return 1  # Usu√°rio padr√£o

    def _create_action_buttons(self, parent):
        """Cria bot√µes de a√ß√£o"""
        button_frame = ttk.Frame(parent)
        button_frame.pack(fill=tk.X, pady=(20, 0))
        
        ttk.Button(button_frame, text="Salvar Altera√ß√µes", 
                  command=self._save_changes).pack(side=tk.RIGHT, padx=5)
        
        ttk.Button(button_frame, text="Fechar", 
                  command=self.window.destroy).pack(side=tk.RIGHT, padx=5)
    
    def _load_subtask_data(self):
        """Carrega os dados da subtarefa"""
        try:
            # Carregar dados b√°sicos
            self.title_entry.insert(0, self.subtask.get('title', ''))
            self.description_text.insert("1.0", self.subtask.get('description', ''))
            
            # Carregar respons√°vel
            responsible = self.subtask.get('assigned_member', '')
            if responsible:
                self.responsible_combo.set(responsible)
            
            # Carregar prioridade
            priority = self.subtask.get('priority', 'Normal')
            self.priority_var.set(priority)
            
            # Carregar status
            status = "Conclu√≠da" if self.subtask.get('completed', False) else "Pendente"
            self.status_var.set(status)
            
            # Carregar arquivos
            self._load_files()
            
            # Carregar coment√°rios
            self._load_comments()
            
            # Carregar hist√≥rico
            self._load_history()
            
        except Exception as e:
            print(f"Erro ao carregar dados da subtarefa: {e}")
    
    def _load_files(self):
        """Carrega lista de arquivos"""
        try:
            # Limpar treeview
            for item in self.files_treeview.get_children():
                self.files_treeview.delete(item)
            
            # Buscar arquivos da subtarefa no banco
            files = self.app.db.get_subtask_files(self.subtask.get('id'))
            
            for file_data in files:
                self.files_treeview.insert("", "end", values=(
                    file_data.get('filename', ''),
                    file_data.get('file_type', ''),
                    file_data.get('file_size', ''),
                    file_data.get('upload_date', '')
                ))
        except Exception as e:
            print(f"Erro ao carregar arquivos: {e}")
    
    def _load_comments(self):
        """Carrega coment√°rios"""
        try:
            self.comments_text.config(state=tk.NORMAL)
            self.comments_text.delete("1.0", tk.END)
            
            # Buscar coment√°rios da subtarefa no banco
            comments = self.app.db.get_subtask_comments(self.subtask.get('id'))
            
            for comment in comments:
                timestamp = comment.get('created_at', '')
                user = comment.get('user_name', '')
                text = comment.get('comment_text', '')
                
                self.comments_text.insert(tk.END, f"[{timestamp}] {user}:\n{text}\n\n")
            
            self.comments_text.config(state=tk.DISABLED)
        except Exception as e:
            print(f"Erro ao carregar coment√°rios: {e}")
    
    def _load_history(self):
        """Carrega hist√≥rico"""
        try:
            # Limpar treeview
            for item in self.history_treeview.get_children():
                self.history_treeview.delete(item)
            
            # Buscar hist√≥rico da subtarefa no banco
            history = self.app.db.get_subtask_history(self.subtask.get('id'))
            
            for entry in history:
                self.history_treeview.insert("", "end", values=(
                    entry.get('timestamp', ''),
                    entry.get('user_name', ''),
                    entry.get('action', ''),
                    entry.get('details', '')
                ))
        except Exception as e:
            print(f"Erro ao carregar hist√≥rico: {e}")
    
    def _upload_file(self):
        """Upload de arquivo"""
        file_path = filedialog.askopenfilename(
            title="Selecionar Arquivo",
            filetypes=[
                ("Todos os arquivos", "*.*"),
                ("Documentos", "*.pdf *.doc *.docx *.txt"),
                ("Imagens", "*.jpg *.jpeg *.png *.gif"),
                ("V√≠deos", "*.mp4 *.avi *.mov")
            ]
        )
        
        if file_path:
            try:
                # Obter user_id de forma segura
                user_id = self._get_user_id_safe()
                
                # Tentar usar sistema de upload completo (Supabase + Cloudflare R2)
                if SISTEMA_UPLOAD_DISPONIVEL and hasattr(self.app, 'sistema_upload'):
                    # Upload para nuvem
                    result = self.app.sistema_upload.upload_arquivo(
                        file_path=file_path,
                        categoria="subtasks"
                    )
                    
                    if result["success"]:
                        # Salvar metadados no banco com URL da nuvem
                        self.app.db.add_subtask_file(
                            subtask_id=self.subtask.get('id'),
                            file_path=result["url"],  # URL da nuvem
                            user_id=user_id
                        )
                        
                        # Recarregar lista de arquivos
                        self._load_files()
                        
                        messagebox.showinfo("Sucesso", f"Arquivo enviado para nuvem com sucesso!\nURL: {result['url']}")
                    else:
                        # Fallback para upload local
                        self._upload_file_local(file_path, user_id)
                else:
                    # Upload local (fallback)
                    self._upload_file_local(file_path, user_id)
                
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao enviar arquivo: {e}")
    
    def _upload_file_local(self, file_path, user_id):
        """Upload local (fallback)"""
        try:
            # Salvar arquivo no banco (caminho local)
            self.app.db.add_subtask_file(
                subtask_id=self.subtask.get('id'),
                file_path=file_path,
                user_id=user_id
            )
            
            # Recarregar lista de arquivos
            self._load_files()
            
            messagebox.showinfo("Sucesso", "Arquivo enviado localmente com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao enviar arquivo local: {e}")
    
    def _upload_image(self):
        """Upload de imagem"""
        file_path = filedialog.askopenfilename(
            title="Selecionar Imagem",
            filetypes=[
                ("Imagens", "*.jpg *.jpeg *.png *.gif *.bmp"),
                ("Todos os arquivos", "*.*")
            ]
        )
        
        if file_path:
            try:
                # Obter user_id de forma segura
                user_id = self._get_user_id_safe()
                
                # Tentar usar sistema de upload completo (Supabase + Cloudflare R2)
                if SISTEMA_UPLOAD_DISPONIVEL and hasattr(self.app, 'sistema_upload'):
                    # Upload para nuvem
                    result = self.app.sistema_upload.upload_arquivo(
                        file_path=file_path,
                        categoria="subtasks_images"
                    )
                    
                    if result["success"]:
                        # Salvar metadados no banco com URL da nuvem
                        self.app.db.add_subtask_file(
                            subtask_id=self.subtask.get('id'),
                            file_path=result["url"],  # URL da nuvem
                            user_id=user_id
                        )
                        
                        # Recarregar lista de arquivos
                        self._load_files()
                        
                        messagebox.showinfo("Sucesso", f"Imagem enviada para nuvem com sucesso!\nURL: {result['url']}")
                    else:
                        # Fallback para upload local
                        self._upload_image_local(file_path, user_id)
                else:
                    # Upload local (fallback)
                    self._upload_image_local(file_path, user_id)
                
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao enviar imagem: {e}")
    
    def _upload_image_local(self, file_path, user_id):
        """Upload local de imagem (fallback)"""
        try:
            # Salvar imagem no banco (caminho local)
            self.app.db.add_subtask_file(
                subtask_id=self.subtask.get('id'),
                file_path=file_path,
                user_id=user_id
            )
            
            # Recarregar lista de arquivos
            self._load_files()
            
            messagebox.showinfo("Sucesso", "Imagem enviada localmente com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao enviar imagem local: {e}")
    
    def _download_file(self):
        """Download de arquivo"""
        selected_item = self.files_treeview.selection()
        if not selected_item:
            messagebox.showwarning("Sele√ß√£o", "Por favor, selecione um arquivo para baixar.")
            return
        
        try:
            # Obter dados do arquivo
            file_data = self.files_treeview.item(selected_item[0])
            filename = file_data['values'][0]
            
            # Buscar arquivo no banco
            file_info = self.app.db.get_subtask_file_by_name(self.subtask.get('id'), filename)
            
            if file_info:
                file_path = file_info['file_path']
                
                # Salvar arquivo localmente
                save_path = filedialog.asksaveasfilename(
                    title="Salvar Arquivo Como",
                    defaultextension=os.path.splitext(filename)[1],
                    initialname=filename
                )
                
                if save_path:
                    # Verificar se √© URL da nuvem ou arquivo local
                    if file_path.startswith(('http://', 'https://')):
                        # Download da nuvem
                        self._download_from_cloud(file_path, save_path)
                    else:
                        # Arquivo local
                        shutil.copy2(file_path, save_path)
                        messagebox.showinfo("Sucesso", f"Arquivo salvo em: {save_path}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao baixar arquivo: {e}")
    
    def _download_from_cloud(self, url, save_path):
        """Download de arquivo da nuvem"""
        try:
            import requests
            
            # Download do arquivo
            response = requests.get(url, stream=True)
            response.raise_for_status()
            
            with open(save_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            messagebox.showinfo("Sucesso", f"Arquivo baixado da nuvem e salvo em: {save_path}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao baixar arquivo da nuvem: {e}")
    
    def _remove_file(self):
        """Remove arquivo"""
        selected_item = self.files_treeview.selection()
        if not selected_item:
            messagebox.showwarning("Sele√ß√£o", "Por favor, selecione um arquivo para remover.")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja remover este arquivo?"):
            try:
                # Obter dados do arquivo
                file_data = self.files_treeview.item(selected_item[0])
                filename = file_data['values'][0]
                
                # Remover arquivo do banco
                self.app.db.remove_subtask_file(self.subtask.get('id'), filename)
                
                # Recarregar lista de arquivos
                self._load_files()
                
                messagebox.showinfo("Sucesso", "Arquivo removido com sucesso!")
                
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao remover arquivo: {e}")
    
    def _open_file(self, event):
        """Abre arquivo"""
        selected_item = self.files_treeview.selection()
        if selected_item:
            self._download_file()
    
    def _add_comment(self):
        """Adiciona coment√°rio"""
        comment_text = self.new_comment_text.get("1.0", tk.END).strip()
        if not comment_text:
            messagebox.showwarning("Coment√°rio", "Por favor, digite um coment√°rio.")
            return
        
        try:
            # Obter user_id de forma segura
            user_id = self._get_user_id_safe()
            
            # Salvar coment√°rio no banco
            self.app.db.add_subtask_comment(
                subtask_id=self.subtask.get('id'),
                comment_text=comment_text,
                user_id=user_id
            )
            
            # Limpar campo
            self.new_comment_text.delete("1.0", tk.END)
            
            # Recarregar coment√°rios
            self._load_comments()
            
            messagebox.showinfo("Sucesso", "Coment√°rio adicionado com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar coment√°rio: {e}")
    
    def _save_description(self):
        """Salva descri√ß√£o"""
        try:
            description = self.description_text.get("1.0", tk.END).strip()
            
            # Atualizar descri√ß√£o no banco
            self.app.db.update_subtask_description(
                subtask_id=self.subtask.get('id'),
                description=description
            )
            
            messagebox.showinfo("Sucesso", "Descri√ß√£o salva com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar descri√ß√£o: {e}")
    
    def _update_subtask_status(self, event=None):
        """Atualiza status da subtarefa"""
        try:
            new_status = self.status_var.get()
            completed = new_status == "Conclu√≠da"
            
            # Atualizar status no banco
            self.app.db.update_subtask_status(
                subtask_id=self.subtask.get('id'),
                completed=completed
            )
            
            # Atualizar dados locais
            self.subtask['completed'] = completed
            
            # Recarregar hist√≥rico
            self._load_history()
            
            # Notificar parent se necess√°rio
            if self.parent:
                self.parent._populate_subtasks_listbox()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao atualizar status: {e}")
    
    def _update_responsible(self, event=None):
        """Atualiza respons√°vel da subtarefa"""
        try:
            new_responsible = self.responsible_combo.get()
            
            # Atualizar respons√°vel no banco
            self.app.db.update_subtask_responsible(
                subtask_id=self.subtask.get('id'),
                responsible=new_responsible
            )
            
            # Atualizar dados locais
            self.subtask['assigned_member'] = new_responsible
            
            # Recarregar hist√≥rico
            self._load_history()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao atualizar respons√°vel: {e}")
    
    def _update_priority(self, event=None):
        """Atualiza prioridade da subtarefa"""
        try:
            new_priority = self.priority_var.get()
            
            # Atualizar prioridade no banco
            self.app.db.update_subtask_priority(
                subtask_id=self.subtask.get('id'),
                priority=new_priority
            )
            
            # Atualizar dados locais
            self.subtask['priority'] = new_priority
            
            # Recarregar hist√≥rico
            self._load_history()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao atualizar prioridade: {e}")
    
    def _save_changes(self):
        """Salva todas as altera√ß√µes"""
        try:
            # Salvar t√≠tulo
            new_title = self.title_entry.get().strip()
            if new_title:
                self.app.db.update_subtask_title(
                    subtask_id=self.subtask.get('id'),
                    title=new_title
                )
                self.subtask['title'] = new_title
            
            # Salvar descri√ß√£o
            self._save_description()
            
            # Recarregar hist√≥rico
            self._load_history()
            
            messagebox.showinfo("Sucesso", "Altera√ß√µes salvas com sucesso!")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar altera√ß√µes: {e}")


class CardWindow(tk.Toplevel):
    def __init__(self, parent, app, board_name, list_name, card_id, current_user, callback_on_close=None):
        super().__init__(parent)
        self.app = app
        self.board_name = board_name
        self.list_name = list_name
        self.card_id = card_id # Now using card_id instead of card_index
        self.current_user = current_user # Store the current user
        self.callback_on_close = callback_on_close
        
        # Find the card using its card_id - try both in-memory data and database
        self.card = None
        
        # First, try to find in the in-memory data structure
        if (self.board_name in self.app.boodesk_data["boards"] and 
            self.list_name in self.app.boodesk_data["boards"][self.board_name]):
            for card_data in self.app.boodesk_data["boards"][self.board_name][self.list_name]:
                if card_data.get('card_id') == self.card_id:
                    self.card = card_data
                    break
        
        # If not found in memory, try to get from database
        if not self.card and hasattr(self.app, 'db') and self.app.db:
            try:
                card_data = self.app.db.get_card_by_id(self.card_id)
                if card_data:
                    # Convert to dictionary if needed
                    if not isinstance(card_data, dict):
                        card_data = dict(card_data)
                    
                    # Add board and list information
                    card_data['board_name'] = self.board_name
                    card_data['list_name'] = self.list_name
                    print(f"DEBUG: Type of card_data before assignment: {type(card_data)}, Content: {card_data}")
                    self.card = card_data
                    
                    # Verificar se self.card √© um dicion√°rio antes de usar .get()
                    if isinstance(self.card, dict):
                        print(f"DEBUG: Card encontrado no banco de dados: {self.card.get('title', 'Sem t√≠tulo')}")
                    else:
                        print(f"DEBUG: Erro - self.card n√£o √© um dicion√°rio: {type(self.card)} - {self.card}")
                        # Tentar converter para dicion√°rio se poss√≠vel
                        if hasattr(self.card, '__dict__'):
                            self.card = self.card.__dict__
                        else:
                            print(f"DEBUG: N√£o foi poss√≠vel converter self.card para dicion√°rio")
                            return
            except Exception as e:
                print(f"Erro ao buscar card no banco: {e}")

        if not self.card:
            messagebox.showerror("Erro", "Cart√£o n√£o encontrado. Pode ter sido exclu√≠do ou movido.")
            self.destroy()
            return

        # Verificar se self.card √© um dicion√°rio antes de acessar
        if isinstance(self.card, dict):
            title = self.card.get('title', 'Sem t√≠tulo')
        else:
            title = 'Sem t√≠tulo'
        self.title(f"Editar Tarefa: {title}")
        self.geometry("1000x700")  # Tamanho fixo que funciona bem
        self.resizable(False, False)  # Impedir redimensionamento para evitar deforma√ß√£o
        
        # Centralizar a janela na tela
        self.center_window()
        
        # Tornar esta janela modal (usu√°rio deve interagir com ela antes de voltar √† janela principal)
        self.transient(parent)
        self.grab_set()

        # Initialize StringVars for Git integration
        if isinstance(self.card, dict):
            self.git_branch_var = tk.StringVar(value=self.card.get('git_branch', ''))
            self.git_commit_var = tk.StringVar(value=self.card.get('git_commit', ''))
            self.git_pr_var = tk.StringVar(value=self.card.get('git_pr', ''))
        else:
            self.git_branch_var = tk.StringVar(value='')
            self.git_commit_var = tk.StringVar(value='')
            self.git_pr_var = tk.StringVar(value='')

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")

    def center_window(self):
        """Centraliza a janela na tela"""
        self.update_idletasks()
        
        # Obter dimens√µes da tela
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Obter dimens√µes da janela
        window_width = self.winfo_width()
        window_height = self.winfo_height()
        
        # Calcular posi√ß√£o central
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        
        # Aplicar posi√ß√£o
        self.geometry(f"+{x}+{y}")

    def create_widgets(self):
        # Main container with proper layout
        main_container = ttk.Frame(self)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Configure main container for proper layout
        main_container.columnconfigure(0, weight=1)
        main_container.rowconfigure(0, weight=1)
        
        # Create a frame for the scrollable content
        content_frame = ttk.Frame(main_container)
        content_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 10))
        content_frame.columnconfigure(0, weight=1)
        content_frame.rowconfigure(0, weight=1)
        
        # Create canvas and scrollbar
        canvas = tk.Canvas(content_frame)
        scrollbar = ttk.Scrollbar(content_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # Main frame inside scrollable area
        main_frame = ttk.Frame(scrollable_frame, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure grid for 2 columns with proper weights
        main_frame.columnconfigure(0, weight=1)  # Left column
        main_frame.columnconfigure(1, weight=1)  # Right column
        main_frame.rowconfigure(0, weight=1)  # Allow vertical expansion

        # === LEFT COLUMN ===
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
        left_frame.columnconfigure(1, weight=1)
        left_frame.rowconfigure(0, weight=1)  # Allow expansion

        # --- Card Details Section ---
        details_frame = ttk.LabelFrame(left_frame, text="Detalhes do Cart√£o", padding="10")
        details_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        details_frame.columnconfigure(1, weight=1)

        ttk.Label(details_frame, text="T√≠tulo:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
        self.title_entry = ttk.Entry(details_frame)
        self.title_entry.grid(row=0, column=1, sticky="ew", pady=3, padx=5)
        # Verificar se self.card √© um dicion√°rio antes de acessar
        if isinstance(self.card, dict):
            self.title_entry.insert(0, self.card.get('title', ''))
        else:
            self.title_entry.insert(0, '')

        ttk.Label(details_frame, text="Descri√ß√£o:", font=("Arial", 9, "bold")).grid(row=1, column=0, sticky="nw", pady=3, padx=5)
        self.desc_text = tk.Text(details_frame, height=4, width=35, wrap=tk.WORD)
        self.desc_text.grid(row=1, column=1, sticky="ew", pady=3, padx=5)
        if isinstance(self.card, dict):
            # Tentar carregar descri√ß√£o de diferentes campos poss√≠veis
            description = self.card.get('description', '') or self.card.get('desc', '')
            self.desc_text.insert("1.0", description)
        else:
            self.desc_text.insert("1.0", '')

        # --- Dates and Recurrence Section ---
        dates_frame = ttk.LabelFrame(left_frame, text="Datas e Recorr√™ncia", padding="10")
        dates_frame.pack(fill=tk.X, pady=(0, 10))
        dates_frame.columnconfigure(1, weight=1)

        ttk.Label(dates_frame, text="Prazo:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
        date_frame = ttk.Frame(dates_frame)
        date_frame.grid(row=0, column=1, sticky="ew", pady=3, padx=5)
        self.due_date_entry = ttk.Entry(date_frame, width=15, state="readonly")
        self.due_date_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(date_frame, image=self.app.icons.get('time_icon'), width=3, command=self.open_date_picker).pack(side=tk.LEFT, padx=2)

        self.include_time_var = tk.BooleanVar()
        self.include_time_var.set(False)
        self.include_time_check = ttk.Checkbutton(dates_frame, text="Incluir Hor√°rio", 
                                                variable=self.include_time_var, 
                                                command=self.toggle_time_fields)
        self.include_time_check.grid(row=1, column=0, sticky="w", pady=3, padx=5)

        time_frame = ttk.Frame(dates_frame)
        time_frame.grid(row=1, column=1, sticky="ew", pady=3, padx=5)
        self.hour_entry = tk.Spinbox(time_frame, from_=0, to=23, width=3, state="disabled", wrap=True)
        self.hour_entry.pack(side=tk.LEFT)
        ttk.Label(time_frame, text=":").pack(side=tk.LEFT)
        self.minute_entry = tk.Spinbox(time_frame, from_=0, to=59, width=3, state="disabled", wrap=True)
        self.minute_entry.pack(side=tk.LEFT)

        ttk.Label(dates_frame, text="Recorr√™ncia:", font=("Arial", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3, padx=5)
        self.recurrence_options = ["Nenhuma", "Diariamente", "Semanalmente", "Mensalmente", "Anualmente"]
        self.recurrence_combo = ttk.Combobox(dates_frame, values=self.recurrence_options, state="readonly")
        self.recurrence_combo.grid(row=2, column=1, sticky="ew", pady=3, padx=5)
        recurrence = self.card.get('recurrence', 'Nenhuma') if isinstance(self.card, dict) else 'Nenhuma'
        self.recurrence_combo.set(recurrence)

        # Git Integration Section (visible only in dev mode)
        if self.app.settings.get('dev_mode', False):
            git_frame = ttk.LabelFrame(left_frame, text="Integra√ß√£o Git", padding="10")
            git_frame.pack(fill=tk.X, pady=(0, 10))
            git_frame.columnconfigure(1, weight=1)

            # Git Status and Actions
            git_status_frame = ttk.Frame(git_frame)
            git_status_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 10))
            git_status_frame.columnconfigure(1, weight=1)

            ttk.Label(git_status_frame, text="Status Git:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
            self.git_status_label = ttk.Label(git_status_frame, text="N√£o configurado", foreground="gray")
            self.git_status_label.grid(row=0, column=1, sticky="w", pady=3, padx=5)

            # Git Actions Buttons
            git_actions_frame = ttk.Frame(git_frame)
            git_actions_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(0, 10))

            ttk.Button(git_actions_frame, text="Inicializar Repo", 
                      image=self.app.icons.get('add_icon'), compound=tk.LEFT,
                      command=self.init_git_repo).pack(side=tk.LEFT, padx=2)
            
            ttk.Button(git_actions_frame, text="Criar Branch", 
                      image=self.app.icons.get('add_folder_icon'), compound=tk.LEFT,
                      command=self.create_git_branch).pack(side=tk.LEFT, padx=2)
            
            ttk.Button(git_actions_frame, text="Commit", 
                      image=self.app.icons.get('save_icon'), compound=tk.LEFT,
                      command=self.make_git_commit).pack(side=tk.LEFT, padx=2)

            # Git Information Fields
            ttk.Label(git_frame, text="Branch Atual:", font=("Arial", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3, padx=5)
            self.git_branch_entry = ttk.Entry(git_frame, textvariable=self.git_branch_var)
            self.git_branch_entry.grid(row=2, column=1, sticky="ew", pady=3, padx=5)

            ttk.Label(git_frame, text="√öltimo Commit:", font=("Arial", 9, "bold")).grid(row=3, column=0, sticky="w", pady=3, padx=5)
            self.git_commit_entry = ttk.Entry(git_frame, textvariable=self.git_commit_var)
            self.git_commit_entry.grid(row=3, column=1, sticky="ew", pady=3, padx=5)

            ttk.Label(git_frame, text="Pull Request:", font=("Arial", 9, "bold")).grid(row=4, column=0, sticky="w", pady=3, padx=5)
            self.git_pr_entry = ttk.Entry(git_frame, textvariable=self.git_pr_var)
            self.git_pr_entry.grid(row=4, column=1, sticky="ew", pady=3, padx=5)

            # Git History Section
            git_history_frame = ttk.LabelFrame(git_frame, text="Hist√≥rico Git", padding="5")
            git_history_frame.grid(row=5, column=0, columnspan=2, sticky="ew", pady=(10, 0))
            git_history_frame.columnconfigure(0, weight=1)

            self.git_history_text = tk.Text(git_history_frame, height=4, width=40, wrap=tk.WORD, state="disabled")
            self.git_history_text.pack(fill=tk.BOTH, expand=True, pady=5)
            
            # Update Git status
            self.update_git_status()

        # Populate due date and time if available
        if self.card.get('due_date'):
            try:
                # Tentar diferentes formatos de data
                due_date_str = self.card.get('due_date', '')
                dt_obj = None
                
                # Formato com data e hora: "2025-08-12 14:30"
                if ' ' in due_date_str:
                    try:
                        dt_obj = datetime.strptime(due_date_str, "%Y-%m-%d %H:%M")
                        self.include_time_var.set(True)
                        self.toggle_time_fields()
                    except ValueError:
                        try:
                            dt_obj = datetime.strptime(due_date_str, "%Y-%m-%d %H:%M:%S")
                            self.include_time_var.set(True)
                            self.toggle_time_fields()
                        except ValueError:
                            pass
                
                # Formato apenas data: "2025-08-12"
                if not dt_obj:
                    try:
                        dt_obj = datetime.strptime(due_date_str, "%Y-%m-%d")
                        self.include_time_var.set(False)
                        self.toggle_time_fields()
                    except ValueError:
                        # Formato brasileiro: "12/08/2025"
                        try:
                            dt_obj = datetime.strptime(due_date_str, "%d/%m/%Y")
                            self.include_time_var.set(False)
                            self.toggle_time_fields()
                        except ValueError:
                            pass
                
                if dt_obj:
                    self.due_date_entry.config(state="normal")
                    self.due_date_entry.delete(0, tk.END)
                    self.due_date_entry.insert(0, dt_obj.strftime("%Y-%m-%d"))
                    self.due_date_entry.config(state="readonly")
                    
                    if self.include_time_var.get():
                        self.hour_entry.config(state="normal")
                        self.minute_entry.config(state="normal")
                        self.hour_entry.delete(0, tk.END)
                        self.minute_entry.delete(0, tk.END)
                        self.hour_entry.insert(0, dt_obj.strftime("%H"))
                        self.minute_entry.insert(0, dt_obj.strftime("%M"))
                        
            except Exception as e:
                print(f"Erro ao processar data do card: {e}")
                # Se n√£o conseguir processar, limpar os campos
                self.due_date_entry.config(state="normal")
                self.due_date_entry.delete(0, tk.END)
                self.due_date_entry.config(state="readonly")
                self.include_time_var.set(True)
            except ValueError:  # Only date available
                self.due_date_entry.config(state="normal")
                self.due_date_entry.delete(0, tk.END)
                self.due_date_entry.insert(0, self.card.get('due_date', ''))
                self.due_date_entry.config(state="readonly")
                self.include_time_var.set(False)
        self.toggle_time_fields()

        # --- Attributes Section ---
        attributes_frame = ttk.LabelFrame(left_frame, text="Atributos", padding="10")
        attributes_frame.pack(fill=tk.X, pady=(0, 10))
        attributes_frame.columnconfigure(1, weight=1)

        ttk.Label(attributes_frame, text="Import√¢ncia:", font=("Arial", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3, padx=5)
        self.importance_options = list(self.app.settings["importance_colors"].keys())
        self.importance_combo = ttk.Combobox(attributes_frame, values=self.importance_options, state="readonly")
        self.importance_combo.grid(row=0, column=1, sticky="ew", pady=3, padx=5)
        importance = self.card.get('importance', 'Normal') if isinstance(self.card, dict) else 'Normal'
        self.importance_combo.set(importance)

        ttk.Label(attributes_frame, text="Categoria:", font=("Arial", 9, "bold")).grid(row=1, column=0, sticky="w", pady=3, padx=5)
        category_options = [cat['name'] for cat in self.app.categories]
        self.category_combo = ttk.Combobox(attributes_frame, values=category_options, state="readonly")
        self.category_combo.grid(row=1, column=1, sticky="ew", pady=3, padx=5)
        category = self.card.get('category', '-') if isinstance(self.card, dict) else '-'
        self.category_combo.set(category)

        ttk.Label(attributes_frame, text="Objetivo:", font=("Arial", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3, padx=5)
        self.goal_combo = ttk.Combobox(attributes_frame, values=self.app.goals, state="readonly")
        self.goal_combo.grid(row=2, column=1, sticky="ew", pady=3, padx=5)
        goal = self.card.get('goal', '-') if isinstance(self.card, dict) else '-'
        self.goal_combo.set(goal)

        # --- Members Section ---
        members_frame = ttk.LabelFrame(left_frame, text="Membros Respons√°veis", padding="10")
        members_frame.pack(fill=tk.X, pady=(0, 10))
        members_frame.columnconfigure(0, weight=1)

        # Frame for the combobox and add button
        add_member_frame = ttk.Frame(members_frame)
        add_member_frame.pack(fill=tk.X, pady=2)
        add_member_frame.columnconfigure(0, weight=1)

        self.member_suggestions_combo = ttk.Combobox(add_member_frame, values=[member['Membro'] for member in self.app.members], state="readonly")
        self.member_suggestions_combo.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        self.member_suggestions_combo.set("Selecionar Membro para Adicionar")
        
        add_member_btn = ttk.Button(add_member_frame, text="Adicionar", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_member_from_combo)
        add_member_btn.grid(row=0, column=1)

        # Listbox for assigned members
        self.assigned_members_listbox = tk.Listbox(members_frame, selectmode=tk.SINGLE, height=3)
        self.assigned_members_listbox.pack(fill=tk.BOTH, expand=True, pady=2)
        # Populate with existing members (if any)
        if isinstance(self.card, dict):
            members = self.card.get('members', [])
            if isinstance(members, list):
                for member in members:
                    self.assigned_members_listbox.insert(tk.END, member)

        # Remove button
        remove_member_btn = ttk.Button(members_frame, text="Remover Selecionado", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_assigned_member)
        remove_member_btn.pack(pady=2)

        # --- Creation Date Section ---
        creation_frame = ttk.LabelFrame(left_frame, text="Informa√ß√µes do Sistema", padding="10")
        creation_frame.pack(fill=tk.X)
        
        ttk.Label(creation_frame, text="Data de Cria√ß√£o:", font=("Arial", 9, "bold")).pack(anchor="w", padx=5, pady=2)
        creation_date = self.card.get('creation_date', 'N/A') if isinstance(self.card, dict) else 'N/A'
        self.creation_date_label = ttk.Label(creation_frame, text=creation_date)
        self.creation_date_label.pack(anchor="w", padx=5, pady=2)

        # === RIGHT COLUMN ===
        right_frame = ttk.Frame(main_frame)
        right_frame.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
        right_frame.columnconfigure(0, weight=1)
        right_frame.rowconfigure(0, weight=1)  # Allow expansion

        # --- Dependencies Section ---
        dependencies_frame = ttk.LabelFrame(right_frame, text="Depend√™ncias", padding="10")
        dependencies_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        dependencies_frame.columnconfigure(0, weight=1)
        
        # Configure the frame to expand properly
        dependencies_frame.pack_configure(fill=tk.BOTH, expand=True)

        # Dependency input area
        dependency_input_frame = ttk.Frame(dependencies_frame)
        dependency_input_frame.pack(fill=tk.X, pady=(0, 5))
        dependency_input_frame.columnconfigure(0, weight=1)
        
        self.dependency_combo = ttk.Combobox(dependency_input_frame, state="readonly")
        self.dependency_combo.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        add_dep_btn = ttk.Button(dependency_input_frame, text="Adicionar", 
                               image=self.app.icons.get('add_icon'), compound=tk.LEFT,
                               command=self._add_dependency)
        add_dep_btn.grid(row=0, column=1)

        # Dependencies list
        self.dependencies_listbox = tk.Listbox(dependencies_frame, selectmode=tk.SINGLE, height=6)
        self.dependencies_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        
        dep_scrollbar = ttk.Scrollbar(dependencies_frame, orient="vertical", command=self.dependencies_listbox.yview)
        dep_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.dependencies_listbox.config(yscrollcommand=dep_scrollbar.set)

        # Populate with existing dependencies (if any)
        if isinstance(self.card, dict):
            dependencies = self.card.get('dependencies', [])
            if isinstance(dependencies, list):
                for dependency in dependencies:
                    self.dependencies_listbox.insert(tk.END, dependency)

        # Remove dependency button
        remove_dep_btn = ttk.Button(dependencies_frame, text="Remover Depend√™ncia", 
                                  image=self.app.icons.get('delete_icon'), compound=tk.LEFT,
                                  command=self._remove_dependency)
        remove_dep_btn.pack(pady=5)

        # --- Subtasks Section ---
        subtasks_frame = ttk.LabelFrame(right_frame, text="Subtarefas/Checklist", padding="10")
        subtasks_frame.pack(fill=tk.BOTH, expand=True)
        subtasks_frame.columnconfigure(0, weight=1)
        
        # Configure the frame to expand properly
        subtasks_frame.pack_configure(fill=tk.BOTH, expand=True)

        # Subtask input area
        subtask_input_frame = ttk.Frame(subtasks_frame)
        subtask_input_frame.pack(fill=tk.X, pady=(0, 5))
        subtask_input_frame.columnconfigure(0, weight=1)
        subtask_input_frame.columnconfigure(1, weight=1)
        
        # Subtask entry
        self.subtask_entry = ttk.Entry(subtask_input_frame)
        self.subtask_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        self.subtask_entry.bind('<Return>', lambda e: self._add_subtask())
        
        # Member assignment for subtask
        member_options = [member['Membro'] for member in self.app.members]
        self.subtask_member_combo = ttk.Combobox(subtask_input_frame, values=member_options, state="readonly")
        self.subtask_member_combo.grid(row=0, column=1, sticky="ew", padx=(0, 5))
        self.subtask_member_combo.set("Delegar para...")
        
        add_subtask_btn = ttk.Button(subtask_input_frame, text="Adicionar", 
                                   image=self.app.icons.get('add_icon'), compound=tk.LEFT,
                                   command=self._add_subtask)
        add_subtask_btn.grid(row=0, column=2)

        # Subtasks list
        self.subtasks_listbox = tk.Listbox(subtasks_frame, selectmode=tk.SINGLE, height=8)
        self.subtasks_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        self.subtasks_listbox.bind("<Double-1>", self._toggle_subtask_completion)

        # Populate with existing subtasks
        if isinstance(self.card, dict):
            self.subtasks = self.app.db.get_subtasks(self.card['card_id'])
            for subtask in self.subtasks:
                status = "‚úì" if subtask['completed'] else "‚óã"
                self.subtasks_listbox.insert(tk.END, f"{status} {subtask['text']}")
        
        subtask_scrollbar = ttk.Scrollbar(subtasks_frame, orient="vertical", command=self.subtasks_listbox.yview)
        subtask_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.subtasks_listbox.config(yscrollcommand=subtask_scrollbar.set)

        # Remove subtask button
        remove_subtask_btn = ttk.Button(subtasks_frame, text="Remover Subtarefa", 
                                      image=self.app.icons.get('delete_icon'), compound=tk.LEFT,
                                      command=self._remove_subtask)
        remove_subtask_btn.pack(pady=5)
        
        # Bot√£o para abrir janela detalhada da subtarefa
        open_subtask_btn = ttk.Button(subtasks_frame, text="Abrir Subtarefa", 
                                     image=self.app.icons.get('edit_icon'), compound=tk.LEFT,
                                     command=self._open_subtask_details)
        open_subtask_btn.pack(pady=5)

        # --- Activity History Section ---
        history_frame = ttk.LabelFrame(right_frame, text="Hist√≥rico de Atividade", padding="10")
        history_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        history_frame.columnconfigure(0, weight=1)
        history_frame.rowconfigure(0, weight=1) # Allow treeview to expand

        self.history_treeview = ttk.Treeview(history_frame, columns=("Timestamp", "User", "Details"), show="headings")
        self.history_treeview.heading("Timestamp", text="Data/Hora")
        self.history_treeview.heading("User", text="Usu√°rio")
        self.history_treeview.heading("Details", text="Detalhes")

        self.history_treeview.column("Timestamp", width=150, anchor="w")
        self.history_treeview.column("User", width=80, anchor="w")
        self.history_treeview.column("Details", width=300, anchor="w")

        self.history_treeview.grid(row=0, column=0, sticky="nsew", pady=5)

        history_scrollbar = ttk.Scrollbar(history_frame, orient="vertical", command=self.history_treeview.yview)
        history_scrollbar.grid(row=0, column=1, sticky="ns")
        self.history_treeview.config(yscrollcommand=history_scrollbar.set)

        # Pack canvas and scrollbar
        canvas.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")
        
        # Configure canvas to expand properly
        content_frame.columnconfigure(0, weight=1)
        content_frame.rowconfigure(0, weight=1)
        
        # === BOTTOM ACTION BUTTONS (FIXED AT BOTTOM) ===
        button_frame = ttk.LabelFrame(main_container, text="A√ß√µes", padding="10")
        button_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(10, 0))
        
        # Configure button frame for proper layout
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)
        button_frame.columnconfigure(4, weight=1)
        
        # Create buttons with better spacing
        save_btn = ttk.Button(button_frame, text="Salvar", 
                            image=self.app.icons.get('save_icon'), compound=tk.LEFT,
                            command=self.save_card)
        save_btn.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        cancel_btn = ttk.Button(button_frame, text="Cancelar", 
                              image=self.app.icons.get('cancel_icon'), compound=tk.LEFT,
                              command=self.destroy)
        cancel_btn.grid(row=0, column=1, sticky="ew", padx=(0, 5))
        
        pomodoro_btn = ttk.Button(button_frame, text="Iniciar Pomodoro", 
                                image=self.app.icons.get('coffee_icon'), compound=tk.LEFT,
                                command=self.start_pomodoro_action)
        pomodoro_btn.grid(row=0, column=2, sticky="ew", padx=(0, 5))
        
        complete_btn = ttk.Button(button_frame, text="Concluir Cart√£o", 
                                image=self.app.icons.get('ok_icon'), compound=tk.LEFT,
                                command=self.complete_card_action)
        complete_btn.grid(row=0, column=3, sticky="ew", padx=(0, 5))
        
        manage_btn = ttk.Button(button_frame, text="Gerenciar Card", 
                              image=self.app.icons.get('settings_icon'), compound=tk.LEFT,
                              command=self.open_advanced_card_manager)
        manage_btn.grid(row=0, column=4, sticky="ew")
        
        # Add keyboard shortcuts
        self.bind('<Control-s>', lambda e: self.save_card())
        self.bind('<Escape>', lambda e: self.destroy())
        self.bind('<Return>', lambda e: self.save_card())
        
        # Initialize data
        self._populate_dependency_combobox()
        self._populate_dependencies_listbox()
        self._populate_subtasks_listbox()
        self._populate_history_treeview()
        
        # Focus on title entry
        self.title_entry.focus_set()

    def _populate_history_treeview(self):
        self.history_treeview.delete(*self.history_treeview.get_children())
        history = self.card.get('history', [])
        
        # Se history √© uma string JSON, converter para lista
        if isinstance(history, str):
            try:
                import json
                history = json.loads(history)
            except:
                history = []
        
        # Garantir que history √© uma lista
        if not isinstance(history, list):
            history = []
        
        for entry in history:
            # Verificar se entry √© um dicion√°rio
            if isinstance(entry, dict):
                timestamp = entry.get('timestamp', 'N/A')
                user = entry.get('user', 'Sistema')
                action = entry.get('action', 'A√ß√£o desconhecida')
            else:
                # Se entry n√£o √© um dicion√°rio, usar valores padr√£o
                timestamp = 'N/A'
                user = 'Sistema'
                action = 'A√ß√£o desconhecida'
            
            self.history_treeview.insert("", "end", values=(timestamp, user, action))

    def _add_member_from_combo(self):
        selected_member = self.member_suggestions_combo.get()
        if selected_member and selected_member != "Selecionar Membro para Adicionar":
            current_members = self.assigned_members_listbox.get(0, tk.END)
            if selected_member not in current_members:
                self.assigned_members_listbox.insert(tk.END, selected_member)
            self.member_suggestions_combo.set("Selecionar Membro para Adicionar")

    def _remove_assigned_member(self):
        selected_index = self.assigned_members_listbox.curselection()
        if selected_index:
            self.assigned_members_listbox.delete(selected_index)

    def _add_suggested_member(self, event):
        selected_member = self.member_suggestions_combo.get()
        current_members = [m.strip() for m in self.members_entry.get().split(',') if m.strip()]
        if selected_member and selected_member != "Selecionar Membro" and selected_member not in current_members:
            current_members.append(selected_member)
            self.members_entry.delete(0, tk.END)
            self.members_entry.insert(0, ", ".join(current_members))
        self.member_suggestions_combo.set("Selecionar Membro")

    def open_date_picker(self):
        current_date_str = self.due_date_entry.get()
        dialog = DatePickerDialog(self, current_date=current_date_str, icons=self.app.icons)
        self.wait_window(dialog)
        if dialog.result_date:
            self.due_date_entry.config(state="normal")
            self.due_date_entry.delete(0, tk.END)
            self.due_date_entry.insert(0, dialog.result_date.strftime("%Y-%m-%d"))
            self.due_date_entry.config(state="readonly")

    def toggle_time_fields(self):
        state = "normal" if self.include_time_var.get() else "disabled"
        self.hour_entry.config(state=state)
        self.minute_entry.config(state=state)

    def _open_subtask_details(self):
        """Abre janela detalhada da subtarefa selecionada"""
        selected_index = self.subtasks_listbox.curselection()
        if not selected_index:
            messagebox.showwarning("Sele√ß√£o", "Por favor, selecione uma subtarefa para abrir.")
            return
        
        # Obter card_id para buscar subtarefas no banco
        card_id = self.card.get('card_id')
        if not card_id:
            messagebox.showerror("Erro", "N√£o foi poss√≠vel identificar o cart√£o")
            return
        
        try:
            # Buscar subtarefas do banco
            subtasks = self.app.get_subtasks_for_card(card_id)
            
            # Filtrar subtarefas baseado no usu√°rio logado
            filtered_subtasks = []
            current_user_member = self.app._get_current_user_member()
            
            for subtask in subtasks:
                # Administradores veem todas as subtarefas
                if hasattr(self.current_user, 'role') and self.current_user.role in ['admin', 'Administrador']:
                    filtered_subtasks.append(subtask)
                else:
                    # Usu√°rios normais veem apenas subtarefas delegadas para eles
                    assigned_member = subtask.get('assigned_member')
                    if assigned_member == current_user_member or not assigned_member:
                        filtered_subtasks.append(subtask)
            
            # Ajustar √≠ndice para considerar cabe√ßalho e separador
            actual_index = selected_index[0] - 2
            if actual_index < 0 or actual_index >= len(filtered_subtasks):
                messagebox.showerror("Erro", "√çndice de subtarefa inv√°lido")
                return
            
            subtask = filtered_subtasks[actual_index]
            
            # Abrir janela detalhada da subtarefa
            SubTaskDetailWindow(self.app, self.card, subtask, self)
            
        except Exception as e:
            print(f"DEBUG: Erro ao abrir detalhes da subtarefa: {e}")
            messagebox.showerror("Erro", f"Erro ao abrir detalhes da subtarefa: {e}")

    def _add_subtask(self):
        """Adiciona subtarefa ao banco de dados"""
        subtask_text = self.subtask_entry.get().strip()
        if subtask_text:
            # Obter membro delegado
            assigned_member = self.subtask_member_combo.get()
            if assigned_member == "Delegar para...":
                assigned_member = None
            
            # Obter card_id para salvar no banco
            card_id = self.card.get('card_id')
            if not card_id:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel identificar o cart√£o")
                return
            
            print(f"DEBUG: Adicionando subtarefa ao card: {card_id}")
            print(f"DEBUG: Texto: {subtask_text}, Membro: {assigned_member}")
            
            try:
                # Salvar subtarefa no banco de dados PostgreSQL
                # Buscar user_id se houver membro atribu√≠do
                user_id = None
                if assigned_member:
                    # Buscar o user_id do membro atribu√≠do
                    users = self.app.db.get_all_users()
                    for user in users:
                        if hasattr(user, 'cargo') and user.get('cargo') == assigned_member:
                            user_id = user.get('id')
                            break
                
                # Inserir nova subtarefa usando PostgreSQL
                subtask_id = self.app.db.create_subtask(
                    card_id=card_id,
                    title=subtask_text.upper(),
                    description='',
                    completed=False,
                    user_id=user_id
                )
                
                if not subtask_id:
                    print(f"DEBUG: Erro ao criar subtarefa no PostgreSQL")
                    messagebox.showerror("Erro", "Erro ao salvar subtarefa no banco de dados")
                    return
                
                print(f"DEBUG: Subtarefa salva com sucesso no banco")
                
                # Limpar campos
                self.subtask_entry.delete(0, tk.END)
                self.subtask_member_combo.set("Delegar para...")
                
                # Recarregar lista de subtarefas
                self._populate_subtasks_listbox()
                
            except Exception as e:
                print(f"DEBUG: Erro ao salvar subtarefa: {e}")
                messagebox.showerror("Erro", f"Erro ao salvar subtarefa: {e}")

    def _remove_subtask(self):
        """Remove subtarefa do banco de dados"""
        selected_index = self.subtasks_listbox.curselection()
        if selected_index:
            # Adjust index to account for header and separator
            actual_index = selected_index[0] - 2
            if actual_index < 0:
                return
            
            # Obter card_id para buscar subtarefas no banco
            card_id = self.card.get('card_id')
            if not card_id:
                messagebox.showerror("Erro", "N√£o foi poss√≠vel identificar o cart√£o")
                return
            
            try:
                # Buscar subtarefas do banco
                subtasks = self.app.get_subtasks_for_card(card_id)
                
                # Filtrar subtarefas baseado no usu√°rio logado
                filtered_subtasks = []
                current_user_member = self.app._get_current_user_member()
                
                for subtask in subtasks:
                    # Administradores veem todas as subtarefas
                    if hasattr(self.current_user, 'role') and self.current_user.role in ['admin', 'Administrador']:
                        filtered_subtasks.append(subtask)
                    else:
                        # Usu√°rios normais veem apenas subtarefas delegadas para eles
                        assigned_member = subtask.get('assigned_member')
                        if assigned_member == current_user_member or not assigned_member:
                            filtered_subtasks.append(subtask)
                
                if actual_index < len(filtered_subtasks):
                    subtask_to_remove = filtered_subtasks[actual_index]
                    subtask_id = subtask_to_remove.get('id')
                    
                    if subtask_id:
                        # Remover do banco de dados PostgreSQL
                        success = self.app.db.delete_subtask(subtask_id)
                        
                        if not success:
                            print(f"DEBUG: Erro ao remover subtarefa do PostgreSQL")
                            messagebox.showerror("Erro", "Erro ao remover subtarefa do banco de dados")
                            return
                        
                        print(f"DEBUG: Subtarefa removida do banco: {subtask_to_remove.get('text', '')}")
                        
                        # Recarregar lista
                        self._populate_subtasks_listbox()
                    else:
                        print(f"DEBUG: Erro - subtarefa sem ID")
                        
            except Exception as e:
                print(f"DEBUG: Erro ao remover subtarefa: {e}")
                messagebox.showerror("Erro", f"Erro ao remover subtarefa: {e}")

    def _toggle_subtask_completion(self, event):
        """Vers√£o corrigida para alternar status de conclus√£o da subtarefa"""
        selected_index = self.subtasks_listbox.nearest(event.y)
        if selected_index != -1:
            # Adjust index to account for header and separator
            actual_index = selected_index - 2
            if actual_index < 0:
                return
            
            # Obter card_id para buscar subtarefas no banco
            card_id = self.card.get('card_id')
            if not card_id:
                return
            
            try:
                # Buscar subtarefas do banco
                subtasks = self.app.get_subtasks_for_card(card_id)
                
                # Filtrar subtarefas baseado no usu√°rio logado
                filtered_subtasks = []
                current_user_member = self.app._get_current_user_member()
                
                for subtask in subtasks:
                    # Administradores veem todas as subtarefas
                    if hasattr(self.current_user, 'role') and self.current_user.role in ['admin', 'Administrador']:
                        filtered_subtasks.append(subtask)
                    else:
                        # Usu√°rios normais veem apenas subtarefas delegadas para eles
                        assigned_member = subtask.get('assigned_member')
                        if assigned_member == current_user_member or not assigned_member:
                            filtered_subtasks.append(subtask)
                
                if actual_index < len(filtered_subtasks):
                    subtask_to_toggle = filtered_subtasks[actual_index]
                    subtask_id = subtask_to_toggle.get('id')
                    
                    if subtask_id:
                        # Alternar status no banco de dados PostgreSQL
                        current_status = subtask_to_toggle.get('completed', False)
                        new_status = not current_status
                        
                        # Atualizar no banco com data de conclus√£o
                        success = self.app.db.update_subtask_completion(
                            subtask_id=subtask_id,
                            completed=new_status,
                            completed_at=datetime.now() if new_status else None
                        )
                        
                        if not success:
                            print(f"DEBUG: Erro ao atualizar status da subtarefa no PostgreSQL")
                            messagebox.showerror("Erro", "Erro ao atualizar status da subtarefa no banco de dados")
                            return
                        
                        # Atualizar dados locais
                        subtask_to_toggle['completed'] = new_status
                        if new_status:
                            subtask_to_toggle['completed_at'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        else:
                            subtask_to_toggle['completed_at'] = None
                        
                        print(f"DEBUG: Status da subtarefa alterado: {subtask_to_toggle.get('text', '')} -> {'Conclu√≠da' if new_status else 'Pendente'}")
                        
                        # Recarregar lista
                        self._populate_subtasks_listbox()
                        
                        # Notificar janelas de detalhes abertas
                        self._notify_subtask_details_windows(subtask_id, new_status)
                        
                    else:
                        print(f"DEBUG: Erro - subtarefa sem ID")
                        
            except Exception as e:
                print(f"DEBUG: Erro ao alternar status da subtarefa: {e}")
                messagebox.showerror("Erro", f"Erro ao alternar status da subtarefa: {e}")

    def _notify_subtask_details_windows(self, subtask_id, new_status):
        """Notifica janelas de detalhes abertas sobre mudan√ßa de status"""
        try:
            # Buscar janelas de detalhes abertas para esta subtarefa
            for window in self.winfo_children():
                if hasattr(window, 'subtask') and window.subtask.get('id') == subtask_id:
                    # Atualizar dados da subtarefa na janela
                    window.subtask['completed'] = new_status
                    if new_status:
                        window.subtask['completed_at'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    else:
                        window.subtask['completed_at'] = None
                    
                    # Recarregar dados na janela
                    if hasattr(window, '_load_subtask_data'):
                        window._load_subtask_data()
                    
                    print(f"DEBUG: Janela de detalhes atualizada para subtarefa {subtask_id}")
                    
        except Exception as e:
            print(f"DEBUG: Erro ao notificar janelas de detalhes: {e}")

    def _populate_subtasks_listbox(self):
        """Carrega subtarefas do banco de dados com filtragem por usu√°rio"""
        self.subtasks_listbox.delete(0, tk.END)
        
        # Obter o card_id para buscar subtarefas no banco
        card_id = self.card.get('card_id')
        if not card_id:
            self.subtasks_listbox.insert(tk.END, "Nenhuma subtarefa adicionada")
            return
        
        print(f"DEBUG: Carregando subtarefas para card: {card_id}")
        
        # Buscar subtarefas do banco de dados
        subtasks = self.app.get_subtasks_for_card(card_id)
        print(f"DEBUG: Encontradas {len(subtasks)} subtarefas no banco")
        
        # Filtrar subtarefas baseado no usu√°rio logado
        filtered_subtasks = []
        current_user_member = self.app._get_current_user_member()
        
        print(f"DEBUG: Usu√°rio atual: {self.current_user.username}, Membro: {current_user_member}")
        
        for subtask in subtasks:
            # Administradores veem todas as subtarefas
            if hasattr(self.current_user, 'role') and self.current_user.role in ['admin', 'Administrador']:
                filtered_subtasks.append(subtask)
                print(f"DEBUG: Administrador - incluindo subtarefa: {subtask.get('text', '')}")
            else:
                # Usu√°rios normais veem apenas subtarefas delegadas para eles
                assigned_member = subtask.get('assigned_member')
                if assigned_member == current_user_member or not assigned_member:
                    filtered_subtasks.append(subtask)
                    print(f"DEBUG: Usu√°rio normal - incluindo subtarefa: {subtask.get('text', '')} (delegada para: {assigned_member})")
                else:
                    print(f"DEBUG: Usu√°rio normal - filtrando subtarefa: {subtask.get('text', '')} (delegada para: {assigned_member})")
        
        print(f"DEBUG: Ap√≥s filtragem: {len(filtered_subtasks)} subtarefas")
        
        if not filtered_subtasks:
            self.subtasks_listbox.insert(tk.END, "Nenhuma subtarefa adicionada")
            return
            
        completed_count = sum(1 for subtask in filtered_subtasks if subtask.get('completed', False))
        total_count = len(filtered_subtasks)
        
        # Add progress header
        progress_text = f"Progresso: {completed_count}/{total_count} ({completed_count/total_count*100:.0f}%)"
        self.subtasks_listbox.insert(tk.END, progress_text)
        self.subtasks_listbox.itemconfig(0, foreground='blue')
        
        # Add separator
        self.subtasks_listbox.insert(tk.END, "‚îÄ" * 50)
        self.subtasks_listbox.itemconfig(1, foreground='gray')
        
        # Add subtasks
        for i, subtask in enumerate(filtered_subtasks):
            status_icon = "‚úì" if subtask.get('completed', False) else "‚óã"
            display_text = f"{status_icon} {subtask.get('text', '')}"
            
            # Adicionar informa√ß√£o do membro delegado
            assigned_member = subtask.get('assigned_member')
            if assigned_member:
                display_text += f" ‚Üí {assigned_member}"
            
            self.subtasks_listbox.insert(tk.END, display_text)
            listbox_index = i + 2  # +2 because of progress header and separator
            if subtask.get('completed', False):
                self.subtasks_listbox.itemconfig(listbox_index, foreground='gray', selectforeground='gray')
            else:
                self.subtasks_listbox.itemconfig(listbox_index, foreground='black', selectforeground='black')

    def _populate_dependency_combobox(self):
        all_cards = []
        for board_name, lists in self.app.boodesk_data["boards"].items():
            for list_name, cards in lists.items():
                for i, card_data in enumerate(cards):
                    # Don't allow a card to be a dependency of itself or an archived card
                    if card_data.get("card_id") != self.card.get("card_id") and not card_data.get("is_archived", False):
                        all_cards.append(f"{board_name} > {list_name} > {card_data['title']}")
        self.dependency_combo['values'] = sorted(list(set(all_cards)))

    def _add_dependency(self):
        selected_dependency_str = self.dependency_combo.get()
        if selected_dependency_str and selected_dependency_str not in self.card.get('dependencies', []):
            # Garantir que dependencies √© uma lista
            dependencies = self.card.get('dependencies', [])
            if isinstance(dependencies, str):
                try:
                    import json
                    dependencies = json.loads(dependencies)
                except:
                    dependencies = []
            if not isinstance(dependencies, list):
                dependencies = []
            
            # Adicionar nova depend√™ncia
            dependencies.append(selected_dependency_str)
            self.card['dependencies'] = dependencies
            self._populate_dependencies_listbox()
            self.dependency_combo.set("")

    def _remove_dependency(self):
        selected_index = self.dependencies_listbox.curselection()
        if selected_index:
            # Adjust index to account for header and separator
            actual_index = selected_index[0] - 2
            if actual_index >= 0 and actual_index < len(self.card.get('dependencies', [])):
                del self.card['dependencies'][actual_index]
                self._populate_dependencies_listbox()

    def _populate_dependencies_listbox(self):
        self.dependencies_listbox.delete(0, tk.END)
        dependencies = self.card.get('dependencies', [])
        
        # Se dependencies √© uma string JSON, converter para lista
        if isinstance(dependencies, str):
            try:
                import json
                dependencies = json.loads(dependencies)
            except:
                dependencies = []
        
        # Garantir que dependencies √© uma lista
        if not isinstance(dependencies, list):
            dependencies = []
        
        if not dependencies:
            self.dependencies_listbox.insert(tk.END, "Nenhuma depend√™ncia adicionada")
            return
            
        # Add header with dependency status
        completed_deps = sum(1 for dep in dependencies if self.app._is_card_completed(dep))
        total_deps = len(dependencies)
        status_text = f"Depend√™ncias: {completed_deps}/{total_deps} Conclu√≠das"
        self.dependencies_listbox.insert(tk.END, status_text)
        self.dependencies_listbox.itemconfig(0, foreground='blue')
        
        # Add separator
        self.dependencies_listbox.insert(tk.END, "‚îÄ" * 50)
        self.dependencies_listbox.itemconfig(1, foreground='gray')
        
        # Add dependencies with detailed status
        for i, dep in enumerate(dependencies):
            is_completed = self.app._is_card_completed(dep)
            status = "Conclu√≠da" if is_completed else "Pendente"
            
            # Get card details for better display
            dep_parts = dep.split(" > ")
            if len(dep_parts) >= 3:
                board_name, list_name, card_title = dep_parts[0], dep_parts[1], dep_parts[2]
                # Check if card is in "Conclu√≠do" list
                if list_name == "Conclu√≠do":
                    status = "Conclu√≠da"
                else:
                    status = "Pendente"
                    
                display_text = f"{status} | {card_title} ({list_name})"
            else:
                display_text = f"{status} | {dep}"
                
            self.dependencies_listbox.insert(tk.END, display_text)
            listbox_index = i + 2  # +2 because of header and separator
            
            if is_completed:
                self.dependencies_listbox.itemconfig(listbox_index, foreground='green')
            else:
                self.dependencies_listbox.itemconfig(listbox_index, foreground='orange')
                
        # Add footer with card status
        if dependencies:
            can_start = all(self.app._is_card_completed(dep) for dep in dependencies)
            if can_start:
                self.dependencies_listbox.insert(tk.END, "Status: Card pode ser iniciado!")
                self.dependencies_listbox.itemconfig(len(dependencies) + 2, foreground='green')
            else:
                pending_count = total_deps - completed_deps
                self.dependencies_listbox.insert(tk.END, f"Status: Aguardando {pending_count} depend√™ncia(s)")
                self.dependencies_listbox.itemconfig(len(dependencies) + 2, foreground='orange')

    def save_card(self):
        # Capture original card state for history logging
        original_card = self.card.copy()
        
        # Tratar subtasks - converter string JSON para lista se necess√°rio
        subtasks = self.card.get('subtasks', [])
        if isinstance(subtasks, str):
            try:
                import json
                subtasks = json.loads(subtasks)
            except:
                subtasks = []
        if not isinstance(subtasks, list):
            subtasks = []
        original_card['subtasks'] = [st.copy() for st in subtasks]
        
        # Tratar dependencies - converter string JSON para lista se necess√°rio
        dependencies = self.card.get('dependencies', [])
        if isinstance(dependencies, str):
            try:
                import json
                dependencies = json.loads(dependencies)
            except:
                dependencies = []
        if not isinstance(dependencies, list):
            dependencies = []
        original_card['dependencies'] = dependencies.copy()
        
        # Tratar members - converter string JSON para lista se necess√°rio
        members = self.card.get('members', [])
        if isinstance(members, str):
            try:
                import json
                members = json.loads(members)
            except:
                members = []
        if not isinstance(members, list):
            members = []
        original_card['members'] = members.copy()

        title = self.title_entry.get()
        desc = self.desc_text.get("1.0", tk.END).strip()
        due_date_str = self.due_date_entry.get()
        importance = self.importance_combo.get()
        category = self.category_combo.get()
        goal = self.goal_combo.get()
        members = list(self.assigned_members_listbox.get(0, tk.END)) # Convert tuple to list

        if not title:
            messagebox.showwarning("Campo Obrigat√≥rio", "O t√≠tulo da tarefa √© obrigat√≥rio.")
            return

        full_due_date = due_date_str
        if self.include_time_var.get():
            hour = self.hour_entry.get().strip()
            minute = self.minute_entry.get().strip()
            if hour and minute:
                try:
                    h = int(hour)
                    m = int(minute)
                    if 0 <= h <= 23 and 0 <= m <= 59:
                        full_due_date = f"{due_date_str} {h:02d}:{m:02d}"
                    else:
                        messagebox.showwarning("Entrada Inv√°lida", "Hora ou minuto inv√°lidos.")
                        return
                except ValueError:
                    messagebox.showwarning("Entrada Inv√°lida", "Hora e minuto devem ser n√∫meros.")
                    return
            else:
                messagebox.showwarning("Entrada Inv√°lida", "Preencha a hora e o minuto ou desmarque 'Incluir Hor√°rio'.")
                return
        
        # Update card data
        self.card['title'] = title.upper()
        self.card['desc'] = desc
        self.card['due_date'] = full_due_date
        self.card['importance'] = importance
        self.card['category'] = category
        self.card['goal'] = goal
        self.card['members'] = members
        if self.app.settings.get('dev_mode', False):
            self.card['git_branch'] = self.git_branch_var.get()
            self.card['git_commit'] = self.git_commit_var.get()
            self.card['git_pr'] = self.git_pr_var.get()
        # Subtasks and dependencies are already updated directly in self.card by their respective methods

        # Log changes to history
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        user_name = self.current_user.username

        def add_history_entry(action_desc):
            # Garantir que history √© uma lista
            history = self.card.get('history', [])
            if isinstance(history, str):
                try:
                    import json
                    history = json.loads(history)
                except:
                    history = []
            if not isinstance(history, list):
                history = []
            
            # Adicionar nova entrada ao hist√≥rico
            history.append({"timestamp": current_time, "action": action_desc, "user": user_name})
            self.card['history'] = history

        # Title
        if self.card.get('title', '') != original_card.get('title', ''):
            add_history_entry(f"T√≠tulo alterado de '{original_card.get('title', '')}' para '{self.card.get('title', '')}'.")

        # Description
        if self.card.get('desc', '') != original_card.get('desc', ''):
            add_history_entry(f"Descri√ß√£o alterada.")

        # Due Date
        if self.card.get('due_date', '') != original_card.get('due_date', ''):
            add_history_entry(f"Prazo alterado de '{original_card.get('due_date', '')}' para '{self.card.get('due_date', '')}'.")

        # Importance
        if self.card.get('importance', '') != original_card.get('importance', ''):
            add_history_entry(f"Import√¢ncia alterada de '{original_card.get('importance', '')}' para '{self.card.get('importance', '')}'.")

        # Category
        if self.card.get('category', '-') != original_card.get('category', '-'):
            add_history_entry(f"Categoria alterada de '{original_card.get('category', '-')}' para '{self.card.get('category', '-')}'.")

        # Goal
        if self.card.get('goal', '') != original_card.get('goal', ''):
            add_history_entry(f"Objetivo alterado de '{original_card.get('goal', '')}' para '{self.card.get('goal', '')}'.")

        # Members
        current_members = self.card.get('members', [])
        original_members = original_card.get('members', [])
        added_members = [m for m in current_members if m not in original_members]
        removed_members = [m for m in original_members if m not in current_members]
        for member in added_members:
            add_history_entry(f"Membro '{member}' adicionado.")
        for member in removed_members:
            add_history_entry(f"Membro '{member}' removido.")

        # Subtasks (more complex, check for additions, removals, and completion changes)
        # Garantir que subtasks s√£o listas
        original_subtasks = original_card.get('subtasks', [])
        if isinstance(original_subtasks, str):
            try:
                import json
                original_subtasks = json.loads(original_subtasks)
            except:
                original_subtasks = []
        if not isinstance(original_subtasks, list):
            original_subtasks = []
            
        current_subtasks = self.card.get('subtasks', [])
        if isinstance(current_subtasks, str):
            try:
                import json
                current_subtasks = json.loads(current_subtasks)
            except:
                current_subtasks = []
        if not isinstance(current_subtasks, list):
            current_subtasks = []
            
        original_subtasks_map = {st['text']: st['completed'] for st in original_subtasks}
        current_subtasks_map = {st['text']: st['completed'] for st in current_subtasks}

        for subtask_text, completed_status in current_subtasks_map.items():
            if subtask_text not in original_subtasks_map:
                add_history_entry(f"Subtarefa '{subtask_text}' adicionada.")
            elif original_subtasks_map[subtask_text] != completed_status:
                status_change = "conclu√≠da" if completed_status else "reaberta"
                add_history_entry(f"Subtarefa '{subtask_text}' marcada como {status_change}.")
        
        for subtask_text in original_subtasks_map:
            if subtask_text not in current_subtasks_map:
                add_history_entry(f"Subtarefa '{subtask_text}' removida.")

        # Dependencies (check for additions and removals)
        # Garantir que dependencies s√£o listas
        current_dependencies = self.card.get('dependencies', [])
        if isinstance(current_dependencies, str):
            try:
                import json
                current_dependencies = json.loads(current_dependencies)
            except:
                current_dependencies = []
        if not isinstance(current_dependencies, list):
            current_dependencies = []
            
        original_dependencies = original_card.get('dependencies', [])
        if isinstance(original_dependencies, str):
            try:
                import json
                original_dependencies = json.loads(original_dependencies)
            except:
                original_dependencies = []
        if not isinstance(original_dependencies, list):
            original_dependencies = []
            
        added_dependencies = [d for d in current_dependencies if d not in original_dependencies]
        removed_dependencies = [d for d in original_dependencies if d not in current_dependencies]
        for dep in added_dependencies:
            add_history_entry(f"Depend√™ncia '{dep}' adicionada.")
        for dep in removed_dependencies:
            add_history_entry(f"Depend√™ncia '{dep}' removida.")

        # Find the card in the main data structure and update it
        found_card = False
        
        for i, card_data in enumerate(self.app.boodesk_data["boards"][self.board_name][self.list_name]):
            if card_data.get('card_id') == self.card_id:
                self.app.boodesk_data["boards"][self.board_name][self.list_name][i] = self.card
                found_card = True
                break
        
        if not found_card:
            messagebox.showerror("Erro", "N√£o foi poss√≠vel encontrar o cart√£o para salvar as altera√ß√µes.")
            return

        self.app.save_trello_data()
        
        # Sincronizar com Google Calendar se habilitado
        if self.app.settings.get('google_calendar_enabled', False):
            self._sync_card_to_calendar()
        
        if self.callback_on_close:
            self.callback_on_close(saved=True)
        self.destroy()

    def start_pomodoro_action(self):
        # Find the card index using card_id
        card_index = -1
        for i, card_data in enumerate(self.app.boodesk_data["boards"][self.board_name][self.list_name]):
            if card_data.get('card_id') == self.card_id:
                card_index = i
                break
        
        if card_index != -1:
            self.app.start_pomodoro_from_card(self.board_name, self.list_name, card_index)
        self.destroy()

    def complete_card_action(self):
        # Find the card index using card_id
        card_index = -1
        for i, card_data in enumerate(self.app.boodesk_data["boards"][self.board_name][self.list_name]):
            if card_data.get('card_id') == self.card_id:
                card_index = i
                break
        
        if card_index != -1:
            self.app.complete_trello_card(self.board_name, self.list_name, card_index)
        self.destroy()

    def _sync_card_to_calendar(self):
        """Sincroniza o card com o Google Calendar"""
        try:
            # Verificar se o Google Calendar est√° configurado
            if not hasattr(self.app, 'google_calendar') or not self.app.google_calendar.is_authenticated:
                print("Google Calendar n√£o est√° autenticado")
                return
            
            # Verificar se h√° data de vencimento
            if not self.card.get('due_date'):
                print("Card n√£o possui data de vencimento")
                return
            
            # Usar fun√ß√£o auxiliar para processar data brasileira
            event_datetime = self.app.parse_brazilian_date(self.card['due_date'])
            
            if not event_datetime:
                print(f"Formato de data inv√°lido: {self.card['due_date']}")
                return
            
            # Criar evento no Google Calendar
            event_title = f"üìã {self.card['title']}"
            event_description = f"""
Card: {self.card['title']}
Descri√ß√£o: {self.card.get('desc', 'Sem descri√ß√£o')}
Import√¢ncia: {self.card.get('importance', 'Normal')}
Assunto: {self.card.get('subject', '-')}
Objetivo: {self.card.get('goal', '-')}
Membros: {', '.join(self.card.get('members', []))}
Board: {self.board_name}
Lista: {self.list_name}
Card ID: {self.card_id}
            """.strip()
            
            # Definir dura√ß√£o do evento (1 hora por padr√£o)
            event_duration = timedelta(hours=1)
            
            # Coletar emails para o evento
            attendees = []
            
            # Adicionar emails padr√£o se habilitado
            calendar_settings = self.app.settings.get('calendar_integration', {})
            if calendar_settings.get('include_default_emails', True):
                default_emails = calendar_settings.get('default_emails', [])
                attendees.extend(default_emails)
            
            # Adicionar membros do card se habilitado
            if calendar_settings.get('include_card_members', True):
                card_members = self.card.get('members', [])
                for member in card_members:
                    # Buscar email do membro no arquivo de membros
                    member_email = self._get_member_email(member)
                    if member_email:
                        attendees.append(member_email)
            
            # Remover duplicatas
            attendees = list(set(attendees))
            
            # Criar evento
            success = self.app.google_calendar.create_event(
                title=event_title,
                description=event_description,
                start_datetime=event_datetime,
                duration=event_duration,
                card_id=self.card_id,
                attendees=attendees if attendees else None
            )
            
            if success:
                print(f"‚úÖ Evento criado no Google Calendar para o card: {self.card['title']}")
                # Adicionar ao hist√≥rico do card
                # Garantir que history √© uma lista
                history = self.card.get('history', [])
                if isinstance(history, str):
                    try:
                        import json
                        history = json.loads(history)
                    except:
                        history = []
                if not isinstance(history, list):
                    history = []
                
                # Adicionar nova entrada ao hist√≥rico
                history.append({
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "action": f"Evento criado no Google Calendar",
                    "user": self.current_user.username
                })
                self.card['history'] = history
            else:
                print(f"‚ùå Erro ao criar evento no Google Calendar para o card: {self.card['title']}")
                
        except Exception as e:
            print(f"‚ùå Erro na sincroniza√ß√£o com Google Calendar: {e}")
            import traceback
            traceback.print_exc()

    def _get_member_email(self, member_name):
        """Busca o email de um membro no arquivo de membros"""
        try:
            if hasattr(self.app, 'members') and self.app.members:
                print(f"DEBUG: Buscando email para membro '{member_name}' (CardWindow)")
                print(f"DEBUG: Total de membros carregados: {len(self.app.members)}")
                for member in self.app.members:
                    print(f"DEBUG: Verificando membro: {member}")
                    if member.get('Membro') == member_name:
                        email = member.get('email', '')
                        print(f"DEBUG: Email encontrado para '{member_name}': {email}")
                        return email
                print(f"DEBUG: Membro '{member_name}' n√£o encontrado")
            else:
                print(f"DEBUG: Lista de membros n√£o dispon√≠vel ou vazia")
            return None
        except Exception as e:
            print(f"Erro ao buscar email do membro {member_name}: {e}")
            return None

    # Git Integration Methods
    def update_git_status(self):
        """Update the Git status display"""
        if hasattr(self, 'git_status_label'):
            if self.git_branch_var.get():
                self.git_status_label.config(text="Configurado", foreground="green")
            else:
                self.git_status_label.config(text="N√£o configurado", foreground="gray")
            
            # Update Git history
            if hasattr(self, 'git_history_text'):
                self.update_git_history()

    def update_git_history(self):
        """Update the Git history display"""
        if hasattr(self, 'git_history_text'):
            self.git_history_text.config(state="normal")
            self.git_history_text.delete("1.0", tk.END)
            
            history_text = "Hist√≥rico Git:\n"
            if self.git_branch_var.get():
                history_text += f"Branch: {self.git_branch_var.get()}\n"
            if self.git_commit_var.get():
                history_text += f"Commit: {self.git_commit_var.get()}\n"
            if self.git_pr_var.get():
                history_text += f"PR: {self.git_pr_var.get()}\n"
            
            if not any([self.git_branch_var.get(), self.git_commit_var.get(), self.git_pr_var.get()]):
                history_text += "Nenhuma informa√ß√£o Git dispon√≠vel"
            
            self.git_history_text.insert("1.0", history_text)
            self.git_history_text.config(state="disabled")

    def init_git_repo(self):
        """Initialize Git repository for this card"""
        try:
            import subprocess
            import os
            
            # Create a directory for this card's Git repo
            repo_dir = os.path.join(self.app.base_dir, f"git_repos/{self.card_id}")
            os.makedirs(repo_dir, exist_ok=True)
            
            # Initialize Git repository
            result = subprocess.run(['git', 'init'], cwd=repo_dir, capture_output=True, text=True)
            
            if result.returncode == 0:
                messagebox.showinfo("Git", "Reposit√≥rio Git inicializado com sucesso!")
                self.git_branch_var.set("main")
                self.update_git_status()
            else:
                messagebox.showerror("Erro Git", f"Erro ao inicializar reposit√≥rio: {result.stderr}")
                
        except Exception as e:
            messagebox.showerror("Erro Git", f"Erro ao inicializar reposit√≥rio Git: {e}")

    def create_git_branch(self):
        """Create a new Git branch for this card"""
        branch_name = simpledialog.askstring("Criar Branch", "Nome da nova branch:", parent=self)
        if branch_name:
            try:
                import subprocess
                import os
                
                repo_dir = os.path.join(self.app.base_dir, f"git_repos/{self.card_id}")
                
                if not os.path.exists(os.path.join(repo_dir, '.git')):
                    messagebox.showerror("Erro Git", "Reposit√≥rio Git n√£o inicializado. Use 'Inicializar Repo' primeiro.")
                    return
                
                # Create and checkout new branch
                result = subprocess.run(['git', 'checkout', '-b', branch_name], cwd=repo_dir, capture_output=True, text=True)
                
                if result.returncode == 0:
                    self.git_branch_var.set(branch_name)
                    self.update_git_status()
                    messagebox.showinfo("Git", f"Branch '{branch_name}' criada e ativada!")
                else:
                    messagebox.showerror("Erro Git", f"Erro ao criar branch: {result.stderr}")
                    
            except Exception as e:
                messagebox.showerror("Erro Git", f"Erro ao criar branch Git: {e}")

    def make_git_commit(self):
        """Make a Git commit for this card"""
        commit_message = simpledialog.askstring("Commit", "Mensagem do commit:", parent=self)
        if commit_message:
            try:
                import subprocess
                import os
                
                repo_dir = os.path.join(self.app.base_dir, f"git_repos/{self.card_id}")
                
                if not os.path.exists(os.path.join(repo_dir, '.git')):
                    messagebox.showerror("Erro Git", "Reposit√≥rio Git n√£o inicializado. Use 'Inicializar Repo' primeiro.")
                    return
                
                # Add all files and commit
                subprocess.run(['git', 'add', '.'], cwd=repo_dir, capture_output=True)
                result = subprocess.run(['git', 'commit', '-m', commit_message], cwd=repo_dir, capture_output=True, text=True)
                
                if result.returncode == 0:
                    # Get the commit hash
                    commit_result = subprocess.run(['git', 'rev-parse', 'HEAD'], cwd=repo_dir, capture_output=True, text=True)
                    if commit_result.returncode == 0:
                        commit_hash = commit_result.stdout.strip()[:8]  # First 8 characters
                        self.git_commit_var.set(commit_hash)
                        self.update_git_status()
                        messagebox.showinfo("Git", f"Commit realizado com sucesso!\nHash: {commit_hash}")
                    else:
                        messagebox.showinfo("Git", "Commit realizado com sucesso!")
                else:
                    messagebox.showerror("Erro Git", f"Erro ao fazer commit: {result.stderr}")
                    
            except Exception as e:
                messagebox.showerror("Erro Git", f"Erro ao fazer commit Git: {e}")

    def destroy(self):
        if self.callback_on_close:
            self.callback_on_close(saved=False)
        super().destroy()

    def _get_current_user_member(self):
        """Retorna o nome do membro associado ao usu√°rio logado"""
        try:
            if not self.current_user:
                return None
            
            username = self.current_user.username
            
            # Buscar o usu√°rio no PostgreSQL
            user_data = self.db.get_user_by_username(username)
            
            if user_data and user_data.get('member_id'):
                member_id = user_data['member_id']
                # Buscar o nome do membro usando o member_id
                members = self.db.get_all_members()
                for member in members:
                    if member['id'] == member_id:
                        member_name = member['name']
                        print(f"DEBUG: Usu√°rio {username} associado ao membro {member_name}")
                        return member_name
            
            print(f"DEBUG: Usu√°rio {username} n√£o tem membro associado")
            return None
            
        except Exception as e:
            print(f"DEBUG: Erro ao buscar membro do usu√°rio: {e}")
            return None

    # Chamar update_all_displays ap√≥s todos os m√©todos serem definidos
    def initialize_displays(self):
        """Inicializa todos os displays ap√≥s a classe estar completamente definida"""
        print("DEBUG: Chamando update_all_displays")
        self.update_all_displays()
        print("DEBUG: update_all_displays conclu√≠do")

    def open_advanced_card_manager(self):
        """Abre o gerenciador avan√ßado de cards"""
        try:
            # Criar janela do gerenciador avan√ßado
            manager_window = tk.Toplevel(self)
            manager_window.title(f"Gerenciador Avan√ßado - {self.card.get('title', 'Card')}")
            manager_window.geometry("1000x700")
            manager_window.transient(self)
            manager_window.grab_set()
            
            # Centralizar janela
            manager_window.update_idletasks()
            screen_width = manager_window.winfo_screenwidth()
            screen_height = manager_window.winfo_screenheight()
            window_width = 1000
            window_height = 700
            x = (screen_width - window_width) // 2
            y = (screen_height - window_height) // 2
            manager_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            # Criar notebook para organizar as se√ß√µes
            notebook = ttk.Notebook(manager_window)
            notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Aba de Tags
            tags_frame = ttk.Frame(notebook)
            notebook.add(tags_frame, text="Tags")
            self._create_tags_tab(tags_frame)
            
            # Aba de Checklist
            checklist_frame = ttk.Frame(notebook)
            notebook.add(checklist_frame, text="Checklist")
            self._create_checklist_tab(checklist_frame)
            
            # Aba de Coment√°rios
            comments_frame = ttk.Frame(notebook)
            notebook.add(comments_frame, text="Coment√°rios")
            self._create_comments_tab(comments_frame)
            
            # Aba de Depend√™ncias
            dependencies_frame = ttk.Frame(notebook)
            notebook.add(dependencies_frame, text="Depend√™ncias")
            self._create_dependencies_tab(dependencies_frame)
            
            # Aba de Tempo
            time_frame = ttk.Frame(notebook)
            notebook.add(time_frame, text="Tempo")
            self._create_time_tab(time_frame)
            
            # Aba de Configura√ß√µes
            config_frame = ttk.Frame(notebook)
            notebook.add(config_frame, text="Configura√ß√µes")
            self._create_config_tab(config_frame)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir gerenciador avan√ßado: {e}")

    def _create_tags_tab(self, parent):
        """Cria a aba de tags"""
        # Frame principal
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Tags dispon√≠veis
        available_frame = ttk.LabelFrame(main_frame, text="Tags Dispon√≠veis", padding="5")
        available_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Lista de tags dispon√≠veis
        self.tags_listbox = tk.Listbox(available_frame, height=6)
        self.tags_listbox.pack(fill=tk.X, pady=5)
        
        # Bot√µes para tags
        tags_buttons_frame = ttk.Frame(available_frame)
        tags_buttons_frame.pack(fill=tk.X)
        
        ttk.Button(tags_buttons_frame, text="Adicionar Tag", 
                  command=self._add_tag_to_card).pack(side=tk.LEFT, padx=5)
        ttk.Button(tags_buttons_frame, text="Remover Tag", 
                  command=self._remove_tag_from_card).pack(side=tk.LEFT, padx=5)
        
        # Tags do card
        card_tags_frame = ttk.LabelFrame(main_frame, text="Tags do Card", padding="5")
        card_tags_frame.pack(fill=tk.BOTH, expand=True)
        
        self.card_tags_listbox = tk.Listbox(card_tags_frame)
        self.card_tags_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Carregar tags
        self._load_tags()

    def _create_checklist_tab(self, parent):
        """Cria a aba de checklist"""
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Adicionar item
        add_frame = ttk.Frame(main_frame)
        add_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(add_frame, text="Novo item:").pack(side=tk.LEFT)
        self.checklist_entry = ttk.Entry(add_frame)
        self.checklist_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        ttk.Button(add_frame, text="Adicionar", 
                  command=self._add_checklist_item).pack(side=tk.LEFT, padx=5)
        
        # Lista de itens
        checklist_frame = ttk.LabelFrame(main_frame, text="Itens do Checklist", padding="5")
        checklist_frame.pack(fill=tk.BOTH, expand=True)
        
        self.checklist_tree = ttk.Treeview(checklist_frame, columns=("Item", "Status"), show="headings")
        self.checklist_tree.heading("Item", text="Item")
        self.checklist_tree.heading("Status", text="Status")
        self.checklist_tree.column("Item", width=300)
        self.checklist_tree.column("Status", width=100)
        self.checklist_tree.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Carregar checklist
        self._load_checklist()

    def _create_comments_tab(self, parent):
        """Cria a aba de coment√°rios"""
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Adicionar coment√°rio
        add_frame = ttk.Frame(main_frame)
        add_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(add_frame, text="Novo coment√°rio:").pack(anchor=tk.W)
        self.comment_text = tk.Text(add_frame, height=4)
        self.comment_text.pack(fill=tk.X, pady=5)
        
        ttk.Button(add_frame, text="Adicionar Coment√°rio", 
                  command=self._add_comment).pack(pady=5)
        
        # Lista de coment√°rios
        comments_frame = ttk.LabelFrame(main_frame, text="Coment√°rios", padding="5")
        comments_frame.pack(fill=tk.BOTH, expand=True)
        
        self.comments_tree = ttk.Treeview(comments_frame, columns=("Data", "Autor", "Coment√°rio"), show="headings")
        self.comments_tree.heading("Data", text="Data")
        self.comments_tree.heading("Autor", text="Autor")
        self.comments_tree.heading("Coment√°rio", text="Coment√°rio")
        self.comments_tree.column("Data", width=150)
        self.comments_tree.column("Autor", width=100)
        self.comments_tree.column("Coment√°rio", width=300)
        self.comments_tree.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Carregar coment√°rios
        self._load_comments()

    def _create_dependencies_tab(self, parent):
        """Cria a aba de depend√™ncias"""
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Adicionar depend√™ncia
        add_frame = ttk.Frame(main_frame)
        add_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(add_frame, text="Card dependente:").pack(side=tk.LEFT)
        self.dependency_combo = ttk.Combobox(add_frame, state="readonly")
        self.dependency_combo.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        ttk.Button(add_frame, text="Adicionar", 
                  command=self._add_dependency).pack(side=tk.LEFT, padx=5)
        
        # Lista de depend√™ncias
        deps_frame = ttk.LabelFrame(main_frame, text="Depend√™ncias", padding="5")
        deps_frame.pack(fill=tk.BOTH, expand=True)
        
        self.dependencies_tree = ttk.Treeview(deps_frame, columns=("Card", "Status"), show="headings")
        self.dependencies_tree.heading("Card", text="Card Dependente")
        self.dependencies_tree.heading("Status", text="Status")
        self.dependencies_tree.column("Card", width=300)
        self.dependencies_tree.column("Status", width=100)
        self.dependencies_tree.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Carregar depend√™ncias
        self._load_dependencies()

    def _create_time_tab(self, parent):
        """Cria a aba de tempo"""
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Log de tempo
        time_frame = ttk.LabelFrame(main_frame, text="Log de Tempo", padding="5")
        time_frame.pack(fill=tk.BOTH, expand=True)
        
        self.time_tree = ttk.Treeview(time_frame, columns=("Data", "Tempo", "Descri√ß√£o"), show="headings")
        self.time_tree.heading("Data", text="Data")
        self.time_tree.heading("Tempo", text="Tempo (min)")
        self.time_tree.heading("Descri√ß√£o", text="Descri√ß√£o")
        self.time_tree.column("Data", width=150)
        self.time_tree.column("Tempo", width=100)
        self.time_tree.column("Descri√ß√£o", width=300)
        self.time_tree.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Carregar log de tempo
        self._load_time_log()

    def _create_config_tab(self, parent):
        """Cria a aba de configura√ß√µes"""
        main_frame = ttk.Frame(parent, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configura√ß√µes do card
        config_frame = ttk.LabelFrame(main_frame, text="Configura√ß√µes do Card", padding="5")
        config_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Prioridade
        ttk.Label(config_frame, text="Prioridade:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)
        self.priority_combo = ttk.Combobox(config_frame, values=["Baixa", "M√©dia", "Alta", "Urgente"], state="readonly")
        self.priority_combo.grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)
        
        # Complexidade
        ttk.Label(config_frame, text="Complexidade:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)
        self.complexity_combo = ttk.Combobox(config_frame, values=["Simples", "M√©dia", "Complexa"], state="readonly")
        self.complexity_combo.grid(row=1, column=1, sticky=tk.W, padx=5, pady=2)
        
        # Progresso
        ttk.Label(config_frame, text="Progresso (%):").grid(row=2, column=0, sticky=tk.W, padx=5, pady=2)
        self.progress_scale = ttk.Scale(config_frame, from_=0, to=100, orient=tk.HORIZONTAL)
        self.progress_scale.grid(row=2, column=1, sticky=tk.EW, padx=5, pady=2)
        
        # Bot√£o salvar
        ttk.Button(config_frame, text="Salvar Configura√ß√µes", 
                  command=self._save_card_config).grid(row=3, column=0, columnspan=2, pady=10)
        
        # Carregar configura√ß√µes atuais
        self._load_card_config()

    def _load_tags(self):
        """Carrega tags dispon√≠veis e do card"""
        try:
            # Carregar tags dispon√≠veis
            available_tags = self.app.db.get_card_tags()
            self.tags_listbox.delete(0, tk.END)
            for tag in available_tags:
                self.tags_listbox.insert(tk.END, tag['name'])
            
            # Carregar tags do card
            card_tags = self.app.db.get_card_tags_by_card(self.card['id'])
            self.card_tags_listbox.delete(0, tk.END)
            for tag in card_tags:
                self.card_tags_listbox.insert(tk.END, tag['name'])
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar tags: {e}")

    def _add_tag_to_card(self):
        """Adiciona tag ao card"""
        try:
            selection = self.tags_listbox.curselection()
            if not selection:
                messagebox.showwarning("Aviso", "Selecione uma tag para adicionar")
                return
            
            tag_name = self.tags_listbox.get(selection[0])
            self.app.db.add_card_tag(self.card['id'], tag_name)
            self._load_tags()
            messagebox.showinfo("Sucesso", f"Tag '{tag_name}' adicionada ao card")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar tag: {e}")

    def _remove_tag_from_card(self):
        """Remove tag do card"""
        try:
            selection = self.card_tags_listbox.curselection()
            if not selection:
                messagebox.showwarning("Aviso", "Selecione uma tag para remover")
                return
            
            tag_name = self.card_tags_listbox.get(selection[0])
            self.app.db.remove_card_tag(self.card['id'], tag_name)
            self._load_tags()
            messagebox.showinfo("Sucesso", f"Tag '{tag_name}' removida do card")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao remover tag: {e}")

    def _load_checklist(self):
        """Carrega checklist do card"""
        try:
            checklists = self.app.db.get_card_checklists(self.card['id'])
            self.checklist_tree.delete(*self.checklist_tree.get_children())
            
            for checklist in checklists:
                items = self.app.db.get_checklist_items(checklist['id'])
                for item in items:
                    status = "‚úì" if item['completed'] else "‚òê"
                    self.checklist_tree.insert("", "end", values=(item['description'], status))
                    
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar checklist: {e}")

    def _add_checklist_item(self):
        """Adiciona item ao checklist"""
        try:
            description = self.checklist_entry.get().strip()
            if not description:
                messagebox.showwarning("Aviso", "Digite uma descri√ß√£o para o item")
                return
            
            # Criar checklist se n√£o existir
            checklists = self.app.db.get_card_checklists(self.card['id'])
            if not checklists:
                checklist_id = self.app.db.create_card_checklist(self.card['id'], "Checklist Principal")
            else:
                checklist_id = checklists[0]['id']
            
            # Adicionar item
            self.app.db.add_checklist_item(checklist_id, description)
            self.checklist_entry.delete(0, tk.END)
            self._load_checklist()
            messagebox.showinfo("Sucesso", "Item adicionado ao checklist")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar item: {e}")

    def _load_comments(self):
        """Carrega coment√°rios do card"""
        try:
            comments = self.app.db.get_card_comments(self.card['id'])
            self.comments_tree.delete(*self.comments_tree.get_children())
            
            for comment in comments:
                self.comments_tree.insert("", "end", values=(
                    comment['created_at'][:10],
                    comment['author'],
                    comment['content']
                ))
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar coment√°rios: {e}")

    def _add_comment(self):
        """Adiciona coment√°rio ao card"""
        try:
            content = self.comment_text.get("1.0", tk.END).strip()
            if not content:
                messagebox.showwarning("Aviso", "Digite um coment√°rio")
                return
            
            author = "Usu√°rio"  # TODO: Pegar usu√°rio atual
            self.app.db.add_card_comment(self.card['id'], author, content)
            self.comment_text.delete("1.0", tk.END)
            self._load_comments()
            messagebox.showinfo("Sucesso", "Coment√°rio adicionado")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar coment√°rio: {e}")

    def _load_dependencies(self):
        """Carrega depend√™ncias do card"""
        try:
            dependencies = self.app.db.get_card_dependencies(self.card['id'])
            self.dependencies_tree.delete(*self.dependencies_tree.get_children())
            
            for dep in dependencies:
                # Buscar informa√ß√µes do card dependente
                dependent_card = self.app.get_card_by_id(dep['dependent_card_id'])
                status = dependent_card.get('status', 'unknown') if dependent_card else 'unknown'
                title = dependent_card.get('title', 'Card n√£o encontrado') if dependent_card else 'Card n√£o encontrado'
                
                self.dependencies_tree.insert("", "end", values=(title, status))
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar depend√™ncias: {e}")

    def _add_dependency(self):
        """Adiciona depend√™ncia ao card"""
        try:
            # TODO: Implementar sele√ß√£o de card dependente
            messagebox.showinfo("Info", "Funcionalidade de depend√™ncias ser√° implementada em breve")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao adicionar depend√™ncia: {e}")

    def _load_time_log(self):
        """Carrega log de tempo do card"""
        try:
            time_logs = self.app.db.get_card_time_logs(self.card['id'])
            self.time_tree.delete(*self.time_tree.get_children())
            
            for log in time_logs:
                self.time_tree.insert("", "end", values=(
                    log['logged_at'][:10],
                    log['time_spent'],
                    log['description']
                ))
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar log de tempo: {e}")

    def _load_card_config(self):
        """Carrega configura√ß√µes atuais do card"""
        try:
            # Carregar valores atuais do card
            priority = self.card.get('priority', 'M√©dia')
            complexity = self.card.get('complexity', 'M√©dia')
            progress = self.card.get('progress', 0)
            
            self.priority_combo.set(priority)
            self.complexity_combo.set(complexity)
            self.progress_scale.set(progress)
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar configura√ß√µes: {e}")

    def _save_card_config(self):
        """Salva configura√ß√µes do card"""
        try:
            priority = self.priority_combo.get()
            complexity = self.complexity_combo.get()
            progress = int(self.progress_scale.get())
            
            # Atualizar card no banco
            self.app.db.update_card_progress(self.card['id'], progress, priority, complexity)
            
            # Atualizar card local
            self.card['priority'] = priority
            self.card['complexity'] = complexity
            self.card['progress'] = progress
            
            messagebox.showinfo("Sucesso", "Configura√ß√µes salvas com sucesso")
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar configura√ß√µes: {e}")

class MembersWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Gerenciar Membros")
        self.geometry("1000x700") # Increased size for photo and additional fields
        self.resizable(True, True)  # Allow resizing
        self.minsize(900, 650)  # Minimum size
        self.transient(parent)
        self.grab_set()
        
        # Variables for edit mode
        self.edit_mode = False
        self.selected_member = None
        
        # Initialize image upload manager
        self.image_manager = ImageUploadManager()
        self.current_photo_path = None
        self.photo_preview = None

        # Center the window on screen
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 800
        window_height = 600
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        self._populate_members_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure main frame for better layout
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)  # List frame should expand
        
        # Title
        title_label = ttk.Label(main_frame, text="Gerenciamento de Membros", font=("Arial", 12, "bold"))
        title_label.grid(row=0, column=0, pady=(0, 10), sticky="w")

        # Member List Frame
        list_frame = ttk.LabelFrame(main_frame, text="Lista de Membros", padding="5")
        list_frame.grid(row=1, column=0, sticky="nsew", pady=(0, 10))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        self.members_tree = ttk.Treeview(list_frame, columns=("Membro", "Cargo", "Email"), show="headings")
        self.members_tree.heading("Membro", text="Membro")
        self.members_tree.heading("Cargo", text="Cargo")
        self.members_tree.heading("Email", text="Email")
        self.members_tree.column("Membro", width=150, anchor="w")
        self.members_tree.column("Cargo", width=100, anchor="w")
        self.members_tree.column("Email", width=200, anchor="w")
        self.members_tree.grid(row=0, column=0, sticky="nsew", pady=5)
        self.members_tree.bind("<<TreeviewSelect>>", self._on_member_select)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Membro", padding="10")
        entry_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        entry_frame.columnconfigure(1, weight=1) # Make entry expandable
        entry_frame.columnconfigure(2, weight=0) # Photo column

        # Photo upload section
        photo_frame = ttk.Frame(entry_frame)
        photo_frame.grid(row=0, column=2, rowspan=6, padx=(10, 0), sticky="n")
        
        ttk.Label(photo_frame, text="Foto de Perfil", font=("Arial", 10, "bold")).pack(pady=(0, 5))
        
        # Photo preview
        self.photo_label = ttk.Label(photo_frame, text="üì∑\nSem foto", 
                                   font=("Arial", 24), 
                                   relief="solid", 
                                   borderwidth=1,
                                   width=12)
        self.photo_label.pack(pady=(0, 5))
        
        # Photo buttons
        photo_buttons_frame = ttk.Frame(photo_frame)
        photo_buttons_frame.pack(fill=tk.X)
        
        ttk.Button(photo_buttons_frame, text="üìÅ Selecionar", 
                  command=self._select_photo).pack(side=tk.LEFT, padx=(0, 2))
        ttk.Button(photo_buttons_frame, text="üóëÔ∏è Remover", 
                  command=self._remove_photo).pack(side=tk.LEFT, padx=(2, 0))

        # Member information fields
        ttk.Label(entry_frame, text="Nome do Membro:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.member_name_entry = ttk.Entry(entry_frame)
        self.member_name_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(entry_frame, text="Cargo:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.role_combo = ttk.Combobox(entry_frame, values=list(self.app.settings["roles"].keys()), state="readonly")
        self.role_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        self.role_combo.set("Usu√°rio") # Default role

        ttk.Label(entry_frame, text="Email:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        self.email_entry = ttk.Entry(entry_frame)
        self.email_entry.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        
        # Adicionar instru√ß√£o sobre o email
        email_info = ttk.Label(entry_frame, text="(Opcional - usado para convites do Google Calendar)", 
                              font=("Arial", 8), foreground="gray")
        email_info.grid(row=3, column=0, columnspan=2, sticky="w", padx=5, pady=(0, 5))
        
        # Additional fields
        ttk.Label(entry_frame, text="Telefone:").grid(row=4, column=0, sticky="w", padx=5, pady=2)
        self.phone_entry = ttk.Entry(entry_frame)
        self.phone_entry.grid(row=4, column=1, sticky="ew", padx=5, pady=2)
        
        ttk.Label(entry_frame, text="Departamento:").grid(row=5, column=0, sticky="w", padx=5, pady=2)
        self.department_entry = ttk.Entry(entry_frame)
        self.department_entry.grid(row=5, column=1, sticky="ew", padx=5, pady=2)

        button_row = ttk.Frame(entry_frame)
        button_row.grid(row=6, column=0, columnspan=2, pady=5)
        button_row.columnconfigure(0, weight=1)
        button_row.columnconfigure(1, weight=1)
        
        ttk.Button(button_row, text="Adicionar Membro", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_member).grid(row=0, column=0, padx=2)
        ttk.Button(button_row, text="Limpar", image=self.app.icons.get('clear_icon'), compound=tk.LEFT, command=self._clear_form).grid(row=0, column=1, padx=2)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=3, column=0, pady=5, sticky="ew")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)
        
        ttk.Button(button_frame, text="Editar Membro", image=self.app.icons.get('edit_icon'), compound=tk.LEFT, command=self._edit_member).grid(row=0, column=0, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Remover Membro", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_member).grid(row=0, column=1, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Cadastrar Cargo", image=self.app.icons.get('settings_icon'), compound=tk.LEFT, command=self._open_roles_settings).grid(row=0, column=2, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Cadastrar Usu√°rio", image=self.app.icons.get('registration_icon'), compound=tk.LEFT, command=self._open_user_registration_for_member).grid(row=0, column=3, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Fechar", image=self.app.icons.get('cancel_icon'), compound=tk.LEFT, command=self.destroy).grid(row=0, column=4, padx=5, sticky="ew")

    def _open_roles_settings(self):
        """Open SettingsWindow and navigate to the Roles tab"""
        settings_window = SettingsWindow(self.master, self.app)
        settings_window.notebook.select(settings_window.roles_tab) # Select the roles tab
        self.master.wait_window(settings_window)
        
        # Refresh the roles combo after settings window is closed
        self.role_combo['values'] = list(self.app.settings["roles"].keys())
        if self.role_combo.get() not in self.app.settings["roles"]:
            self.role_combo.set("Usu√°rio")  # Reset to default if current role was removed
        # Tamb√©m atualizar combo de cargo na janela de usu√°rios
        try:
            if hasattr(self, 'cargo_combo') and self.cargo_combo:
                self.cargo_combo['values'] = list(self.app.settings["roles"].keys())
                if self.cargo_combo.get() not in self.cargo_combo['values'] and self.cargo_combo['values']:
                    self.cargo_combo.set(self.cargo_combo['values'][0])
        except Exception:
            pass

    def _open_user_registration_for_member(self):
        """Abre a tela de usu√°rios j√° com o membro selecionado"""
        try:
            selected_item = self.members_tree.selection()
            pre_member_id = None
            if selected_item:
                values = self.members_tree.item(selected_item, "values")
                member_name = values[0]
                # Buscar ID do membro por nome
                import sqlite3
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                cursor.execute("SELECT id FROM members WHERE membro = %s", (member_name,))
                row = cursor.fetchone()
                conn.close()
                if row:
                    pre_member_id = row[0]
            # Abrir a janela de usu√°rios passando app e o member_id
            UserRegistrationWindow(self.master, self.app.user_management if hasattr(self.app, 'user_management') else None, self.app.icons, app=self.app, preselected_member_id=pre_member_id)
        except Exception as e:
            print(f"DEBUG: Erro ao abrir cadastro de usu√°rio a partir de membros: {e}")

    def _populate_members_list(self):
        self.members_tree.delete(*self.members_tree.get_children())
        for index, row in self.app.members_df.iterrows():
            # Verificar se a coluna email existe, sen√£o usar string vazia
            email = row.get('email', '') if 'email' in row else ''
            self.members_tree.insert("", "end", values=(row['Membro'], row['Cargo'], email))

    def _select_photo(self):
        """Seleciona foto de perfil"""
        result = self.image_manager.select_image(self)
        if result:
            self.current_photo_path = result['processed_path']
            self._update_photo_preview()
            messagebox.showinfo("Sucesso", "Foto selecionada com sucesso!")
    
    def _remove_photo(self):
        """Remove foto de perfil"""
        if self.current_photo_path:
            # Deletar arquivo se existir
            if os.path.exists(self.current_photo_path):
                self.image_manager.delete_image(os.path.basename(self.current_photo_path))
            
            self.current_photo_path = None
            self._update_photo_preview()
            messagebox.showinfo("Sucesso", "Foto removida!")
        else:
            messagebox.showinfo("Info", "Nenhuma foto para remover.")
    
    def _update_photo_preview(self):
        """Atualiza preview da foto"""
        if self.current_photo_path and os.path.exists(self.current_photo_path):
            # Criar preview da imagem
            self.photo_preview = self.image_manager.get_image_preview(self.current_photo_path, (120, 120))
            if self.photo_preview:
                self.photo_label.configure(image=self.photo_preview, text="")
            else:
                self.photo_label.configure(image="", text="üì∑\nErro ao carregar")
        else:
            self.photo_label.configure(image="", text="üì∑\nSem foto")
    
    def _clear_form(self):
        """Limpa formul√°rio e foto"""
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usu√°rio")
        self.email_entry.delete(0, tk.END)
        self.phone_entry.delete(0, tk.END)
        self.department_entry.delete(0, tk.END)
        
        # Limpar foto
        if self.current_photo_path:
            self._remove_photo()
        
        self.edit_mode = False
        self.selected_member = None

    def _add_member(self):
        new_member_name = self.member_name_entry.get().strip()
        new_member_role = self.role_combo.get()
        new_member_email = self.email_entry.get().strip()
        new_member_phone = self.phone_entry.get().strip()
        new_member_department = self.department_entry.get().strip()

        if not new_member_name:
            messagebox.showwarning("Entrada Inv√°lida", "O nome do membro n√£o pode estar vazio.")
            return

        # Verificar se o membro j√° existe no banco SQLite
        try:
            import sqlite3
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM members WHERE membro = %s", (new_member_name,))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este membro j√° existe.")
                conn.close()
                return
            conn.close()
        except Exception as e:
            print(f"Erro ao verificar membro existente: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel verificar se o membro existe: {e}")
            return

        # Validar email se fornecido
        if new_member_email:
            import re
            email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
            if not email_pattern.match(new_member_email):
                messagebox.showwarning("Email Inv√°lido", "Por favor, insira um email v√°lido ou deixe em branco.")
                return

        # Adicionar membro diretamente no banco SQLite
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Verificar se o membro j√° existe
            cursor.execute("SELECT id FROM members WHERE membro = %s", (new_member_name,))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este nome de membro j√° existe.")
                conn.close()
                return
            
            # Inserir novo membro
            cursor.execute("""
                INSERT INTO members (membro, email, cargo, phone, department, photo_path, created_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """, (new_member_name, new_member_email, new_member_role, new_member_phone, 
                  new_member_department, self.current_photo_path, datetime.now()))
            
            conn.commit()
            conn.close()
            
            # Recarregar membros na aplica√ß√£o principal
            self.app.load_members()
            self._populate_members_list()
            
            # Atualizar dropdown de membros na tela de usu√°rios
            if hasattr(self, 'populate_members_combo'):
                self.populate_members_combo()
            
        except Exception as e:
            print(f"Erro ao adicionar membro: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel adicionar o membro: {e}")
            return
        
        # Clear form
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usu√°rio") # Reset to default
        self.email_entry.delete(0, tk.END)
        self.phone_entry.delete(0, tk.END)
        self.department_entry.delete(0, tk.END)
        
        # Limpar foto
        if self.current_photo_path:
            self._remove_photo()
        
        self.edit_mode = False
        self.selected_member = None
        
        messagebox.showinfo("Sucesso", f"Membro '{new_member_name}' adicionado com sucesso!")
        self.app.populate_boards() # Refresh boards to update member filter options

    def _on_member_select(self, event):
        """Handle member selection in treeview"""
        selected_item = self.members_tree.selection()
        if selected_item:
            values = self.members_tree.item(selected_item, "values")
            self.selected_member = values[0]  # Member name
            
            # Buscar dados completos do membro no banco
            try:
                import sqlite3
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM members WHERE membro = %s", (values[0],))
                member_data = cursor.fetchone()
                conn.close()
                
                if member_data:
                    # Populate entry fields for editing
                    self.member_name_entry.delete(0, tk.END)
                    self.member_name_entry.insert(0, member_data[1])  # name
                    
                    self.role_combo.set(member_data[3])  # role
                    
                    self.email_entry.delete(0, tk.END)
                    self.email_entry.insert(0, member_data[2] or "")  # email
                    
                    self.phone_entry.delete(0, tk.END)
                    self.phone_entry.insert(0, member_data[4] or "")  # phone
                    
                    self.department_entry.delete(0, tk.END)
                    self.department_entry.insert(0, member_data[5] or "")  # department
                    
                    # Carregar foto se existir
                    if member_data[6]:  # photo_path
                        self.current_photo_path = member_data[6]
                        self._update_photo_preview()
                    else:
                        self.current_photo_path = None
                        self._update_photo_preview()
                
            except Exception as e:
                print(f"Erro ao carregar dados do membro: {e}")
                # Fallback para dados b√°sicos
                self.member_name_entry.delete(0, tk.END)
                self.member_name_entry.insert(0, values[0])
                self.role_combo.set(values[1])
                if len(values) > 2:
                    self.email_entry.delete(0, tk.END)
                    self.email_entry.insert(0, values[2])
                else:
                    self.email_entry.delete(0, tk.END)
            
            self.edit_mode = True
        else:
            self.edit_mode = False
            self.selected_member = None

    def _edit_member(self):
        """Edit selected member"""
        if not self.selected_member:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um membro para editar.")
            return

        new_member_name = self.member_name_entry.get().strip()
        new_member_role = self.role_combo.get()
        new_member_email = self.email_entry.get().strip()
        new_member_phone = self.phone_entry.get().strip()
        new_member_department = self.department_entry.get().strip()

        if not new_member_name:
            messagebox.showwarning("Entrada Inv√°lida", "O nome do membro n√£o pode estar vazio.")
            return

        # Check if new name conflicts with existing members (excluding current member)
        try:
            import sqlite3
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM members WHERE membro = %s AND membro != %s", (new_member_name, self.selected_member))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este nome de membro j√° existe.")
                conn.close()
                return
            conn.close()
        except Exception as e:
            print(f"Erro ao verificar membro existente: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel verificar se o membro existe: {e}")
            return

        # Validar email se fornecido
        if new_member_email:
            import re
            email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
            if not email_pattern.match(new_member_email):
                messagebox.showwarning("Email Inv√°lido", "Por favor, insira um email v√°lido ou deixe em branco.")
                return

        # Atualizar membro no banco SQLite
        try:
            import sqlite3
            from datetime import datetime
            
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Verificar se o novo nome j√° existe (excluindo o membro atual)
            cursor.execute("SELECT id FROM members WHERE membro = %s AND membro != %s", (new_member_name, self.selected_member))
            if cursor.fetchone():
                messagebox.showwarning("Membro Existente", "Este nome de membro j√° existe.")
                conn.close()
                return
            
            # Atualizar membro
            cursor.execute("""
                UPDATE members 
                SET membro = %s, email = %s, cargo = %s, phone = %s, department = %s, photo_path = %s, updated_at = %s
                WHERE membro = %s
            """, (new_member_name, new_member_email, new_member_role, new_member_phone, 
                  new_member_department, self.current_photo_path, datetime.now(), self.selected_member))
            
            conn.commit()
            conn.close()
            
            # Recarregar membros na aplica√ß√£o principal
            self.app.load_members()
            self._populate_members_list()
            
            # Atualizar dropdown de membros na tela de usu√°rios
            if hasattr(self, 'populate_members_combo'):
                self.populate_members_combo()
            
        except Exception as e:
            print(f"Erro ao atualizar membro: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel atualizar o membro: {e}")
            return
        
        # Clear form
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usu√°rio")
        self.email_entry.delete(0, tk.END)
        self.phone_entry.delete(0, tk.END)
        self.department_entry.delete(0, tk.END)
        
        # Limpar foto
        if self.current_photo_path:
            self._remove_photo()
        
        self.edit_mode = False
        self.selected_member = None
        
        messagebox.showinfo("Sucesso", f"Membro '{new_member_name}' atualizado com sucesso!")
        self.app.populate_boards()

    def _remove_member(self):
        selected_item = self.members_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um membro para remover.")
            return

        member_name_to_remove = self.members_tree.item(selected_item, "values")[0]
        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover '{member_name_to_remove}'?"):
            try:
                import sqlite3
                
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                
                # Remover membro do banco
                cursor.execute("DELETE FROM members WHERE membro = %s", (member_name_to_remove,))
                
                conn.commit()
                conn.close()
                
                # Recarregar membros na aplica√ß√£o principal
                self.app.load_members()
                
            except Exception as e:
                print(f"Erro ao remover membro: {e}")
                messagebox.showerror("Erro", f"N√£o foi poss√≠vel remover o membro: {e}")
                return
            self._populate_members_list()
            
            # Clear form if the removed member was selected
            if self.selected_member == member_name_to_remove:
                self.member_name_entry.delete(0, tk.END)
                self.role_combo.set("Usu√°rio")
                self.edit_mode = False
                self.selected_member = None
            
            messagebox.showinfo("Sucesso", f"Membro '{member_name_to_remove}' removido com sucesso!")
            self.app.populate_boards() # Refresh boards to update member filter options

    def _clear_form(self):
        """Clear the form and reset to add mode"""
        self.member_name_entry.delete(0, tk.END)
        self.role_combo.set("Usu√°rio")
        self.email_entry.delete(0, tk.END)
        self.edit_mode = False
        self.selected_member = None
        self.members_tree.selection_remove(*self.members_tree.selection())

    def toggle_always_on_top(self):
        self.app.root.attributes("-topmost", self.always_on_top_var.get())

class SubjectManagerWindow(tk.Toplevel):
    def __init__(self, parent, app, subject_type):
        super().__init__(parent)
        self.app = app
        self.subject_type = subject_type
        
        if self.subject_type == 'pomodoro':
            self.title("Gerenciar Assuntos do Pomodoro")
            self.subjects_df = self.app.pomodoro_subjects_df
            self.subjects_list = self.app.pomodoro_subjects
            self.file_path = self.app.pomodoro_subjects_file
        else: # boodesk
            self.title("Gerenciar Assuntos do Boodesk")
            self.subjects_df = self.app.boodesk_subjects_df
            self.subjects_list = self.app.boodesk_subjects
            self.file_path = self.app.boodesk_subjects_file

        self.geometry("450x350")
        self.transient(parent)
        self.grab_set()

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        self._populate_subjects_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Listbox Frame
        list_frame = ttk.LabelFrame(main_frame, text="Assuntos Cadastrados")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        self.subjects_listbox = tk.Listbox(list_frame, selectmode=tk.SINGLE)
        self.subjects_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.subjects_listbox.bind("<<ListboxSelect>>", self._on_subject_select)
        
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.subjects_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.subjects_listbox.config(yscrollcommand=scrollbar.set)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Assunto")
        entry_frame.pack(fill=tk.X, pady=5)
        entry_frame.columnconfigure(0, weight=1)

        self.subject_entry = ttk.Entry(entry_frame)
        self.subject_entry.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        
        self.add_edit_button = ttk.Button(entry_frame, text="Adicionar", command=self._add_subject)
        self.add_edit_button.grid(row=0, column=1, padx=5, pady=5)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        ttk.Button(button_frame, text="Remover Selecionado", command=self._remove_subject).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Fechar", command=self.destroy).pack(side=tk.RIGHT, padx=5)

    def _populate_subjects_list(self):
        self.subjects_listbox.delete(0, tk.END)
        # Sort the list for better UX
        for subject in sorted(self.subjects_list):
            if subject != '-': # Don't show the default '-'
                self.subjects_listbox.insert(tk.END, subject)

    def _on_subject_select(self, event):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            self.subject_entry.delete(0, tk.END)
            self.add_edit_button.config(text="Adicionar", command=self._add_subject)
            return
        
        selected_subject = self.subjects_listbox.get(selected_indices[0])
        self.subject_entry.delete(0, tk.END)
        self.subject_entry.insert(0, selected_subject)
        self.add_edit_button.config(text="Salvar Edi√ß√£o", command=self._edit_subject)

    def _clear_selection(self):
        self.subjects_listbox.selection_clear(0, tk.END)
        self.subject_entry.delete(0, tk.END)
        self.add_edit_button.config(text="Adicionar", command=self._add_subject)
        # Manually trigger the event handler to reset the button state
        self._on_subject_select(None)


    def _add_subject(self):
        new_subject = self.subject_entry.get().strip()
        if not new_subject:
            messagebox.showwarning("Entrada Inv√°lida", "O nome do assunto n√£o pode estar vazio.", parent=self)
            return
        
        if new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' j√° existe.", parent=self)
            return

        # Update DataFrame and list
        new_subject_df = pd.DataFrame({'Assunto': [new_subject]})
        self.subjects_df = pd.concat([self.subjects_df, new_subject_df], ignore_index=True)
        self.subjects_list.append(new_subject)
        
        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{new_subject}' adicionado.", parent=self)

    def _edit_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um assunto para editar.", parent=self)
            return
            
        old_subject = self.subjects_listbox.get(selected_indices[0])
        new_subject = self.subject_entry.get().strip()

        if not new_subject:
            messagebox.showwarning("Entrada Inv√°lida", "O nome do assunto n√£o pode estar vazio.", parent=self)
            return

        if new_subject != old_subject and new_subject in self.subjects_list:
            messagebox.showwarning("Assunto Existente", f"O assunto '{new_subject}' j√° existe.", parent=self)
            return

        # Update DataFrame and list
        self.subjects_df.loc[self.subjects_df['Assunto'] == old_subject, 'Assunto'] = new_subject
        self.subjects_list[self.subjects_list.index(old_subject)] = new_subject

        # Save and refresh
        self._save_and_refresh()
        self._clear_selection()
        messagebox.showinfo("Sucesso", f"Assunto '{old_subject}' atualizado para '{new_subject}'.", parent=self)

    def _remove_subject(self):
        selected_indices = self.subjects_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um assunto para remover.", parent=self)
            return

        subject_to_remove = self.subjects_listbox.get(selected_indices[0])
        
        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover o assunto '{subject_to_remove}'?\nIsso n√£o pode ser desfeito e n√£o alterar√° os cart√µes existentes.", parent=self):
            # Update DataFrame and list
            self.subjects_df = self.subjects_df[self.subjects_df['Assunto'] != subject_to_remove]
            self.subjects_list.remove(subject_to_remove)
            
            # Save and refresh
            self._save_and_refresh()
            self._clear_selection()
            messagebox.showinfo("Sucesso", f"Assunto '{subject_to_remove}' removido.", parent=self)

    def _save_and_refresh(self):
        # Save the DataFrame to the Excel file
        self.subjects_df.to_excel(self.file_path, index=False)
        
        # Update the main app's data
        if self.subject_type == 'pomodoro':
            self.app.pomodoro_subjects_df = self.subjects_df
            self.app.pomodoro_subjects = self.subjects_list
        else: # boodesk
            self.app.boodesk_subjects_df = self.subjects_df
            self.app.boodesk_subjects = self.subjects_list
            
        # Reload all auxiliary data in the main app to update all UI components
        self.app.load_aux_data()
        self.app.update_all_displays() # A comprehensive update
        
        # Refresh the listbox in this window
        self._populate_subjects_list()

    def destroy(self):
        # Ensure the main app window gets focus back
        self.app.root.focus_set()
        super().destroy()


class EmailManagementWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Gerenciamento de Emails")
        self.geometry("800x600")
        self.resizable(True, True)
        self.minsize(700, 500)
        self.transient(parent)
        self.grab_set()
        
        # Variables for edit mode
        self.edit_mode = False
        self.selected_email_id = None
        
        # Center the window on screen
        self.update_idletasks()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 800
        window_height = 600
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
        self._populate_emails_list()

    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Configure main frame for better layout
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)  # List frame should expand
        
        # Title
        title_label = ttk.Label(main_frame, text="Gerenciamento de Emails", font=("Arial", 12, "bold"))
        title_label.grid(row=0, column=0, pady=(0, 10), sticky="w")

        # Email List Frame
        list_frame = ttk.LabelFrame(main_frame, text="Lista de Emails", padding="5")
        list_frame.grid(row=1, column=0, sticky="nsew", pady=(0, 10))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        self.emails_tree = ttk.Treeview(list_frame, columns=("ID", "Email", "Nome", "Categoria", "Ativo"), show="headings")
        self.emails_tree.heading("ID", text="ID")
        self.emails_tree.heading("Email", text="Email")
        self.emails_tree.heading("Nome", text="Nome")
        self.emails_tree.heading("Categoria", text="Categoria")
        self.emails_tree.heading("Ativo", text="Ativo")
        self.emails_tree.column("ID", width=50, anchor="center")
        self.emails_tree.column("Email", width=200, anchor="w")
        self.emails_tree.column("Nome", width=150, anchor="w")
        self.emails_tree.column("Categoria", width=100, anchor="w")
        self.emails_tree.column("Ativo", width=80, anchor="center")
        self.emails_tree.grid(row=0, column=0, sticky="nsew", pady=5)
        self.emails_tree.bind("<<TreeviewSelect>>", self._on_email_select)

        # Entry and Add/Edit Frame
        entry_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Email", padding="10")
        entry_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        entry_frame.columnconfigure(1, weight=1)

        # Email information fields
        ttk.Label(entry_frame, text="Email:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.email_entry = ttk.Entry(entry_frame)
        self.email_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(entry_frame, text="Nome:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.name_entry = ttk.Entry(entry_frame)
        self.name_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(entry_frame, text="Categoria:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        self.category_combo = ttk.Combobox(entry_frame, values=["Padr√£o", "Notifica√ß√µes", "Relat√≥rios", "Administra√ß√£o", "Suporte"], state="readonly")
        self.category_combo.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        self.category_combo.set("Padr√£o")

        ttk.Label(entry_frame, text="Ativo:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        self.active_var = tk.BooleanVar(value=True)
        self.active_check = ttk.Checkbutton(entry_frame, text="Sim", variable=self.active_var)
        self.active_check.grid(row=3, column=1, sticky="w", padx=5, pady=2)

        button_row = ttk.Frame(entry_frame)
        button_row.grid(row=4, column=0, columnspan=2, pady=5)
        button_row.columnconfigure(0, weight=1)
        button_row.columnconfigure(1, weight=1)
        
        ttk.Button(button_row, text="Adicionar Email", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_email).grid(row=0, column=0, padx=2)
        ttk.Button(button_row, text="Limpar", image=self.app.icons.get('clear_icon'), compound=tk.LEFT, command=self._clear_form).grid(row=0, column=1, padx=2)

        # Action Buttons Frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=3, column=0, pady=5, sticky="ew")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)
        
        ttk.Button(button_frame, text="Editar Email", image=self.app.icons.get('edit_icon'), compound=tk.LEFT, command=self._edit_email).grid(row=0, column=0, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Remover Email", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_email).grid(row=0, column=1, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Importar CSV", image=self.app.icons.get('import_icon'), compound=tk.LEFT, command=self._import_csv).grid(row=0, column=2, padx=5, sticky="ew")
        ttk.Button(button_frame, text="Fechar", image=self.app.icons.get('cancel_icon'), compound=tk.LEFT, command=self.destroy).grid(row=0, column=3, padx=5, sticky="ew")

    def _populate_emails_list(self):
        """Popula a lista de emails do banco de dados"""
        self.emails_tree.delete(*self.emails_tree.get_children())
        try:
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Verificar se a tabela existe, se n√£o, criar
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS system_emails (
                    id SERIAL PRIMARY KEY,
                    email VARCHAR(255) NOT NULL UNIQUE,
                    name VARCHAR(255),
                    category VARCHAR(100) DEFAULT 'Padr√£o',
                    is_active BOOLEAN DEFAULT TRUE,
                    created_at TIMESTAMP DEFAULT NOW(),
                    updated_at TIMESTAMP DEFAULT NOW()
                )
            """)
            conn.commit()
            
            # Buscar emails
            cursor.execute("SELECT id, email, name, category, is_active FROM system_emails ORDER BY email")
            emails = cursor.fetchall()
            conn.close()
            
            for email_data in emails:
                email_id, email, name, category, is_active = email_data
                active_text = "Sim" if is_active else "N√£o"
                self.emails_tree.insert("", "end", values=(email_id, email, name or "", category, active_text))
                
        except Exception as e:
            print(f"Erro ao carregar emails: {e}")
            messagebox.showerror("Erro", f"Erro ao carregar lista de emails: {e}")

    def _add_email(self):
        """Adiciona um novo email ao sistema"""
        email = self.email_entry.get().strip()
        name = self.name_entry.get().strip()
        category = self.category_combo.get()
        is_active = self.active_var.get()

        if not email:
            messagebox.showwarning("Entrada Inv√°lida", "O email n√£o pode estar vazio.")
            return

        # Validar formato do email
        import re
        email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
        if not email_pattern.match(email):
            messagebox.showwarning("Email Inv√°lido", "Por favor, insira um email v√°lido.")
            return

        try:
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Verificar se o email j√° existe
            cursor.execute("SELECT id FROM system_emails WHERE email = %s", (email,))
            if cursor.fetchone():
                messagebox.showwarning("Email Existente", "Este email j√° est√° cadastrado.")
                conn.close()
                return
            
            # Inserir novo email
            cursor.execute("""
                INSERT INTO system_emails (email, name, category, is_active)
                VALUES (%s, %s, %s, %s)
            """, (email, name, category, is_active))
            
            conn.commit()
            conn.close()
            
            self._populate_emails_list()
            self._clear_form()
            
            messagebox.showinfo("Sucesso", f"Email '{email}' adicionado com sucesso!")
            
        except Exception as e:
            print(f"Erro ao adicionar email: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel adicionar o email: {e}")

    def _on_email_select(self, event):
        """Handle email selection in treeview"""
        selected_item = self.emails_tree.selection()
        if selected_item:
            values = self.emails_tree.item(selected_item, "values")
            self.selected_email_id = values[0]
            
            # Buscar dados completos do email no banco
            try:
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                cursor.execute("SELECT email, name, category, is_active FROM system_emails WHERE id = %s", (values[0],))
                email_data = cursor.fetchone()
                conn.close()
                
                if email_data:
                    # Populate entry fields for editing
                    self.email_entry.delete(0, tk.END)
                    self.email_entry.insert(0, email_data[0])
                    
                    self.name_entry.delete(0, tk.END)
                    self.name_entry.insert(0, email_data[1] or "")
                    
                    self.category_combo.set(email_data[2])
                    self.active_var.set(email_data[3])
                
            except Exception as e:
                print(f"Erro ao carregar dados do email: {e}")
            
            self.edit_mode = True
        else:
            self.edit_mode = False
            self.selected_email_id = None

    def _edit_email(self):
        """Edita o email selecionado"""
        if not self.selected_email_id:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um email para editar.")
            return

        email = self.email_entry.get().strip()
        name = self.name_entry.get().strip()
        category = self.category_combo.get()
        is_active = self.active_var.get()

        if not email:
            messagebox.showwarning("Entrada Inv√°lida", "O email n√£o pode estar vazio.")
            return

        # Validar formato do email
        import re
        email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
        if not email_pattern.match(email):
            messagebox.showwarning("Email Inv√°lido", "Por favor, insira um email v√°lido.")
            return

        try:
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            # Verificar se o novo email j√° existe (excluindo o atual)
            cursor.execute("SELECT id FROM system_emails WHERE email = %s AND id != %s", (email, self.selected_email_id))
            if cursor.fetchone():
                messagebox.showwarning("Email Existente", "Este email j√° est√° cadastrado.")
                conn.close()
                return
            
            # Atualizar email
            cursor.execute("""
                UPDATE system_emails 
                SET email = %s, name = %s, category = %s, is_active = %s, updated_at = NOW()
                WHERE id = %s
            """, (email, name, category, is_active, self.selected_email_id))
            
            conn.commit()
            conn.close()
            
            self._populate_emails_list()
            self._clear_form()
            
            messagebox.showinfo("Sucesso", f"Email '{email}' atualizado com sucesso!")
            
        except Exception as e:
            print(f"Erro ao atualizar email: {e}")
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel atualizar o email: {e}")

    def _remove_email(self):
        """Remove o email selecionado"""
        selected_item = self.emails_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Por favor, selecione um email para remover.")
            return

        email_to_remove = self.emails_tree.item(selected_item, "values")[1]  # Email est√° na coluna 1
        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover '{email_to_remove}'?"):
            try:
                conn = supabase_config.get_connection()
                cursor = conn.cursor()
                
                # Remover email do banco
                cursor.execute("DELETE FROM system_emails WHERE id = %s", (self.selected_email_id,))
                
                conn.commit()
                conn.close()
                
                self._populate_emails_list()
                self._clear_form()
                
                messagebox.showinfo("Sucesso", f"Email '{email_to_remove}' removido com sucesso!")
                
            except Exception as e:
                print(f"Erro ao remover email: {e}")
                messagebox.showerror("Erro", f"N√£o foi poss√≠vel remover o email: {e}")

    def _import_csv(self):
        """Importa emails de um arquivo CSV"""
        file_path = filedialog.askopenfilename(
            title="Selecionar arquivo CSV",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        
        if not file_path:
            return
            
        try:
            import pandas as pd
            df = pd.read_csv(file_path)
            
            # Verificar colunas necess√°rias
            required_columns = ['email']
            if not all(col in df.columns for col in required_columns):
                messagebox.showerror("Erro", "O arquivo CSV deve ter pelo menos uma coluna 'email'")
                return
            
            # Processar emails
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            imported_count = 0
            skipped_count = 0
            
            for index, row in df.iterrows():
                email = str(row['email']).strip()
                
                # Validar email
                import re
                email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
                if not email_pattern.match(email):
                    skipped_count += 1
                    continue
                
                # Verificar se j√° existe
                cursor.execute("SELECT id FROM system_emails WHERE email = %s", (email,))
                if cursor.fetchone():
                    skipped_count += 1
                    continue
                
                # Inserir email
                name = str(row.get('name', '')).strip() if 'name' in row else ''
                category = str(row.get('category', 'Padr√£o')).strip() if 'category' in row else 'Padr√£o'
                is_active = bool(row.get('is_active', True)) if 'is_active' in row else True
                
                cursor.execute("""
                    INSERT INTO system_emails (email, name, category, is_active)
                    VALUES (%s, %s, %s, %s)
                """, (email, name, category, is_active))
                
                imported_count += 1
            
            conn.commit()
            conn.close()
            
            self._populate_emails_list()
            
            messagebox.showinfo("Importa√ß√£o Conclu√≠da", 
                              f"Importa√ß√£o conclu√≠da!\n"
                              f"Emails importados: {imported_count}\n"
                              f"Emails ignorados: {skipped_count}")
            
        except Exception as e:
            print(f"Erro ao importar CSV: {e}")
            messagebox.showerror("Erro", f"Erro ao importar arquivo CSV: {e}")

    def _clear_form(self):
        """Limpa o formul√°rio"""
        self.email_entry.delete(0, tk.END)
        self.name_entry.delete(0, tk.END)
        self.category_combo.set("Padr√£o")
        self.active_var.set(True)
        
        self.edit_mode = False
        self.selected_email_id = None
        self.emails_tree.selection_remove(*self.emails_tree.selection())

    def get_active_emails(self, category=None):
        """Retorna lista de emails ativos, opcionalmente filtrados por categoria"""
        try:
            conn = supabase_config.get_connection()
            cursor = conn.cursor()
            
            if category:
                cursor.execute("SELECT email FROM system_emails WHERE is_active = TRUE AND category = %s ORDER BY email", (category,))
            else:
                cursor.execute("SELECT email FROM system_emails WHERE is_active = TRUE ORDER BY email")
            
            emails = [row[0] for row in cursor.fetchall()]
            conn.close()
            return emails
            
        except Exception as e:
            print(f"Erro ao buscar emails ativos: {e}")
            return []


class SettingsWindow(tk.Toplevel):
    def __init__(self, parent, app):
        super().__init__(parent)
        self.app = app
        self.title("Configura√ß√µes")
        self.geometry("1200x800")  # Tamanho maior para acomodar scrollbars
        self.resizable(True, True)  # Permitir redimensionamento
        self.transient(parent)
        self.grab_set()
        
        # Centralizar a janela na tela
        self.center_window()
        
        # Criar estilo vermelho para destacar a se√ß√£o de a√ß√µes
        style = ttk.Style()
        style.configure('Red.TFrame', background='#ffcccc')

        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")

    def center_window(self):
        """Centraliza a janela na tela - igual ao CardWindow"""
        self.update_idletasks()
        
        # Obter dimens√µes da tela
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Obter dimens√µes da janela
        window_width = self.winfo_width()
        window_height = self.winfo_height()
        
        # Calcular posi√ß√£o central
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        
        # Aplicar posi√ß√£o
        self.geometry(f"+{x}+{y}")

    def create_widgets(self):
        # Main container with proper layout - igual √† tela de cards
        main_container = ttk.Frame(self)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Configure main container for proper layout
        main_container.columnconfigure(0, weight=1)
        main_container.rowconfigure(0, weight=1)
        
        # === CONTENT FRAME (TOP) ===
        content_frame = ttk.Frame(main_container)
        content_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 10))
        content_frame.columnconfigure(0, weight=1)
        content_frame.rowconfigure(0, weight=1)
        
        # Configure grid for 2 columns
        content_frame.columnconfigure(0, weight=1)  # Left column
        content_frame.columnconfigure(1, weight=1)  # Right column
        content_frame.rowconfigure(0, weight=1)

        # === LEFT COLUMN ===
        left_frame = ttk.Frame(content_frame)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
        
        # Notebook principal
        self.notebook = ttk.Notebook(left_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)

        # Create tabs with scrollbars and icons
        self.geral_tab = self.create_scrollable_tab("Geral", "settings_icon")
        self.quadros_tab = self.create_scrollable_tab("Quadros", "folder_icon")
        self.pomodoro_tab = self.create_scrollable_tab("Pomodoro", "time_icon")
        self.roles_tab = self.create_scrollable_tab("Cargos", "key_icon")
        self.dashboard_tab = self.create_scrollable_tab("Dashboard", "dashboard_icon")
        self.calendar_tab = self.create_scrollable_tab("Calend√°rio", "calendar_icon")
        self.email_tab = self.create_scrollable_tab("Email", "info_icon")
        self.email_templates_tab = self.create_scrollable_tab("Templates de Email", "registration_icon")

        # Create tab contents
        self.create_geral_tab()
        self.create_quadros_tab()
        self.create_pomodoro_tab()
        self.create_roles_tab()
        self.create_dashboard_settings_tab()
        self.create_calendar_tab()
        self.create_email_tab()
        self.create_email_templates_tab()

        # === RIGHT COLUMN ===
        right_frame = ttk.Frame(content_frame)
        right_frame.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
        
        # Adicionar informa√ß√µes extras na coluna direita
        info_frame = ttk.LabelFrame(right_frame, text="Informa√ß√µes do Sistema", padding="10")
        info_frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(info_frame, text="Vers√£o do Sistema: 2.0", font=("Arial", 10, "bold")).pack(anchor="w", pady=5)
        ttk.Label(info_frame, text="Status: Ativo", font=("Arial", 9)).pack(anchor="w", pady=2)
        ttk.Label(info_frame, text="√öltima Atualiza√ß√£o: Hoje", font=("Arial", 9)).pack(anchor="w", pady=2)
        ttk.Label(info_frame, text="Configura√ß√µes Salvas: Sim", font=("Arial", 9)).pack(anchor="w", pady=2)
        
        # === BOTTOM ACTION BUTTONS (FIXED AT BOTTOM) ===
        # Bot√µes fixos na parte inferior - igual √† tela de cards
        button_frame = ttk.LabelFrame(main_container, text="A√ß√µes", padding="10")
        button_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(10, 0))
        
        # Configure button frame for proper layout
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        
        # Create buttons with better spacing and icons like in CardWindow
        restore_btn = ttk.Button(button_frame, text="Restaurar Padr√µes", 
                                image=self.app.icons.get('refresh_icon'), compound=tk.LEFT,
                                command=self.restore_defaults)
        restore_btn.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        cancel_btn = ttk.Button(button_frame, text="Cancelar", 
                              image=self.app.icons.get('cancel_icon'), compound=tk.LEFT,
                              command=self.destroy)
        cancel_btn.grid(row=0, column=1, sticky="ew", padx=(0, 5))
        
        save_btn = ttk.Button(button_frame, text="Salvar", 
                            image=self.app.icons.get('save_icon'), compound=tk.LEFT,
                            command=self.save_settings)
        save_btn.grid(row=0, column=2, sticky="ew")
        
        # Add keyboard shortcuts
        self.bind('<Control-s>', lambda e: self.save_settings())
        self.bind('<Escape>', lambda e: self.destroy())
        self.bind('<Return>', lambda e: self.save_settings())
        
        # Focus on save button
        save_btn.focus_set()
        
        # For√ßar atualiza√ß√£o da interface
        self.update_idletasks()
        
        # Debug: verificar se os bot√µes foram criados
        print(f"DEBUG: Bot√µes criados - Restaurar: {restore_btn.winfo_exists()}, Cancelar: {cancel_btn.winfo_exists()}, Salvar: {save_btn.winfo_exists()}")
        print(f"DEBUG: Layout igual √† tela de cards - Bot√µes fixos na parte inferior")

    def create_scrollable_tab(self, tab_name, icon_name=None):
        """Cria uma aba com scrollbar vertical e horizontal e √≠cone opcional"""
        # Frame principal da aba
        tab_frame = ttk.Frame(self.notebook)
        
        # Canvas para scroll
        canvas = tk.Canvas(tab_frame, bg='white')
        scrollbar_y = ttk.Scrollbar(tab_frame, orient="vertical", command=canvas.yview)
        scrollbar_x = ttk.Scrollbar(tab_frame, orient="horizontal", command=canvas.xview)
        
        # Frame interno para o conte√∫do
        content_frame = ttk.Frame(canvas)
        
        # Configurar scroll
        canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        # Layout dos widgets
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar_y.pack(side="right", fill="y")
        scrollbar_x.pack(side="bottom", fill="x")
        
        # Criar janela no canvas
        canvas_window = canvas.create_window((0, 0), window=content_frame, anchor="nw")
        
        # Configurar redimensionamento
        def configure_scroll_region(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
        
        def configure_canvas_window(event):
            canvas.itemconfig(canvas_window, width=event.width)
        
        content_frame.bind("<Configure>", configure_scroll_region)
        canvas.bind("<Configure>", configure_canvas_window)
        
        # Adicionar aba ao notebook
        self.notebook.add(tab_frame, text=tab_name)
        
        # Configurar √≠cone na aba se fornecido
        if icon_name and hasattr(self.app, 'icons') and self.app.icons.get(icon_name):
            try:
                # Obter o √≠ndice da aba rec√©m-adicionada
                tab_index = len(self.notebook.tabs()) - 1
                self.notebook.tab(tab_index, image=self.app.icons.get(icon_name), compound=tk.LEFT)
            except Exception as e:
                print(f"Erro ao configurar √≠cone {icon_name} na aba {tab_name}: {e}")
        
        # Retornar o frame de conte√∫do para ser usado pelas fun√ß√µes de cria√ß√£o
        return content_frame

    def create_geral_tab(self):
        frame = self.geral_tab
        frame.grid_columnconfigure(0, weight=1)

        ttk.Label(frame, text="Tema do Aplicativo:").pack(anchor="w", padx=10, pady=(10, 0))
        self.theme_combo = ttk.Combobox(frame, values=self.app.root.get_themes(), state="readonly")
        self.theme_combo.pack(fill="x", padx=10, pady=5)
        self.theme_combo.set(self.app.settings.get('theme', 'aquativo'))
        # Aplicar tema imediatamente quando o usu√°rio seleciona um tema
        self.theme_combo.bind('<<ComboboxSelected>>', self._on_theme_selected)

        self.always_on_top_var = tk.BooleanVar()
        self.always_on_top_var.set(self.app.root.attributes("-topmost"))
        ttk.Checkbutton(frame, text="Sempre no topo", variable=self.always_on_top_var, command=self.toggle_always_on_top).pack(anchor="w", padx=10, pady=5)

        self.dev_mode_var = tk.BooleanVar()
        self.dev_mode_var.set(self.app.settings.get('dev_mode', False))
        ttk.Checkbutton(frame, text="Modo Desenvolvedor (Recursos √Ågeis)", variable=self.dev_mode_var).pack(anchor="w", padx=10, pady=5)

        self.git_integration_enabled_var = tk.BooleanVar()
        self.git_integration_enabled_var.set(self.app.settings.get('git_integration_enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integra√ß√£o Git (Modo Dev)", variable=self.git_integration_enabled_var).pack(anchor="w", padx=10, pady=5)


    def _on_theme_selected(self, event=None):
        """Aplica o tema imediatamente quando selecionado no combobox"""
        try:
            selected_theme = self.theme_combo.get()
            if selected_theme:
                print(f"üé® Aplicando tema imediatamente: {selected_theme}")
                self.app.change_theme(selected_theme)
        except Exception as e:
            print(f"‚ùå Erro ao aplicar tema: {e}")
    def create_quadros_tab(self):
        frame = self.quadros_tab
        frame.grid_columnconfigure(1, weight=1)
        frame.grid_rowconfigure(2, weight=1)

        self.unify_subjects_var = tk.BooleanVar()
        self.unify_subjects_var.set(self.app.settings.get('unify_subjects', False))
        ttk.Checkbutton(frame, text="Unificar Assuntos (Boodesk e Pomodoro)", variable=self.unify_subjects_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)

        self.show_card_details_on_board_var = tk.BooleanVar()
        self.show_card_details_on_board_var.set(self.app.settings.get('show_card_details_on_board', False))
        ttk.Checkbutton(frame, text="Mostrar Detalhes do Cart√£o no Quadro (Respons√°vel, Cria√ß√£o)", variable=self.show_card_details_on_board_var).grid(row=1, column=0, columnspan=2, sticky="w", padx=10, pady=5)

        # Importance Levels Management
        importance_frame = ttk.LabelFrame(frame, text="Gerenciar N√≠veis de Import√¢ncia", padding=10)
        importance_frame.grid(row=2, column=0, columnspan=3, sticky="nsew", padx=10, pady=(15, 5))
        importance_frame.grid_columnconfigure(0, weight=1)

        # Verificar se o usu√°rio √© administrador
        is_admin = self._check_admin_permissions()
        
        if not is_admin:
            # Mostrar aviso para usu√°rios n√£o-admin
            warning_label = ttk.Label(importance_frame, 
                text="‚ö†Ô∏è Apenas administradores podem modificar as cores de import√¢ncia", 
                foreground="red", font=("Arial", 9, "bold"))
            warning_label.pack(pady=10)

        self.importance_tree = ttk.Treeview(importance_frame, columns=("Nome", "Cor"), show="headings")
        self.importance_tree.heading("Nome", text="Nome")
        self.importance_tree.heading("Cor", text="Cor")
        self.importance_tree.column("Nome", width=150, anchor="w")
        self.importance_tree.column("Cor", width=100, anchor="center")
        self.importance_tree.pack(fill="both", expand=True, pady=5)
        
        # Apenas administradores podem editar cores
        if is_admin:
            self.importance_tree.bind("<Double-1>", self._edit_importance_color)

        importance_buttons_frame = ttk.Frame(importance_frame)
        importance_buttons_frame.pack(fill="x", pady=5)

        # Bot√µes apenas para administradores
        if is_admin:
            ttk.Button(importance_buttons_frame, text="Adicionar N√≠vel", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_importance_level).pack(side="left", padx=5)
            ttk.Button(importance_buttons_frame, text="‚ûñ Remover N√≠vel", command=self._remove_importance_level).pack(side="left", padx=5)
        else:
            # Bot√µes desabilitados para usu√°rios n√£o-admin
            add_button = ttk.Button(importance_buttons_frame, text="Adicionar N√≠vel", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_importance_level, state="disabled")
            add_button.pack(side="left", padx=5)
            remove_button = ttk.Button(importance_buttons_frame, text="‚ûñ Remover N√≠vel", command=self._remove_importance_level, state="disabled")
            remove_button.pack(side="left", padx=5)

        self._populate_importance_treeview()

    def create_dashboard_settings_tab(self):
        """Cria a aba de configura√ß√µes do dashboard"""
        frame = self.dashboard_tab
        frame.grid_columnconfigure(0, weight=1)
        
        # Widget settings
        widget_frame = ttk.LabelFrame(frame, text="Widgets do Dashboard", padding=10)
        widget_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Dashboard widget checkboxes
        self.dashboard_widget_vars = {}
        widget_settings = self.app.settings.get('dashboard_widgets', {})
        
        widgets = [
            ('overview', 'Vis√£o Geral'),
            ('urgent_tasks', 'Tarefas Urgentes'),
            ('upcoming_deadlines', 'Pr√≥ximos Prazos'),
            ('recent_activities', 'Atividades Recentes'),
            ('quick_links', 'Links Frequentes'),
            ('quick_actions', 'A√ß√µes R√°pidas'),
            ('meeting_widget', 'Widget de Reuni√µes')
        ]
        
        for i, (widget_key, widget_name) in enumerate(widgets):
            if widget_key == 'meeting_widget':
                var = tk.BooleanVar(value=self.app.notification_manager.notification_settings['show_widget'])
            else:
                var = tk.BooleanVar(value=widget_settings.get(widget_key, True))
            self.dashboard_widget_vars[widget_key] = var
            ttk.Checkbutton(widget_frame, text=widget_name, variable=var).pack(anchor=tk.W, pady=2)
        
        # Preview button
        ttk.Button(frame, text="Visualizar Dashboard", 
                  command=self.preview_dashboard_settings).pack(pady=10)

    def create_calendar_tab(self):
        """Cria a aba de configura√ß√µes de calend√°rio"""
        frame = self.calendar_tab
        frame.grid_columnconfigure(1, weight=1)
        
        calendar_settings = self.app.settings.get('calendar_integration', {})
        
        # Enable calendar integration
        self.calendar_enabled_var = tk.BooleanVar(value=calendar_settings.get('enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integra√ß√£o com Google Calendar", 
                       variable=self.calendar_enabled_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)
        
        # Tipo de autentica√ß√£o
        ttk.Label(frame, text="Tipo de Autentica√ß√£o:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        auth_frame = ttk.Frame(frame)
        auth_frame.grid(row=1, column=1, sticky="w", padx=10, pady=5)
        
        self.auth_type_var = tk.StringVar(value=calendar_settings.get('auth_type', 'json'))
        print(f"DEBUG: auth_type_var inicializado com: {self.auth_type_var.get()}")
        
        json_radio = ttk.Radiobutton(auth_frame, text="Arquivo JSON", 
                       variable=self.auth_type_var, value="json", 
                       command=self.toggle_auth_methods)
        json_radio.pack(side=tk.LEFT, padx=5)
        print("DEBUG: Radio button JSON criado")
        
        key_radio = ttk.Radiobutton(auth_frame, text="ID e Chave Privada", 
                       variable=self.auth_type_var, value="key", 
                       command=self.toggle_auth_methods)
        key_radio.pack(side=tk.LEFT, padx=5)
        print("DEBUG: Radio button ID/Chave criado")
        
        # Frame para arquivo JSON
        self.json_frame = ttk.LabelFrame(frame, text="Arquivo JSON de Credenciais", padding=10)
        self.json_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        self.json_frame.columnconfigure(1, weight=1)
        
        ttk.Label(self.json_frame, text="Arquivo:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        json_credentials_frame = ttk.Frame(self.json_frame)
        json_credentials_frame.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        json_credentials_frame.columnconfigure(0, weight=1)
        
        self.credentials_file_var = tk.StringVar(value=calendar_settings.get('credentials_file', ''))
        self.credentials_entry = ttk.Entry(json_credentials_frame, textvariable=self.credentials_file_var, width=50)
        self.credentials_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        ttk.Button(json_credentials_frame, text="Procurar", 
                  command=self.browse_credentials_file).grid(row=0, column=1)
        
        # Frame para ID e chave privada
        self.key_frame = ttk.LabelFrame(frame, text="ID e Chave Privada", padding=10)
        self.key_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        self.key_frame.columnconfigure(1, weight=1)
        
        ttk.Label(self.key_frame, text="Client ID:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.client_id_var = tk.StringVar(value=calendar_settings.get('client_id', ''))
        self.client_id_entry = ttk.Entry(self.key_frame, textvariable=self.client_id_var, width=50)
        self.client_id_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.key_frame, text="Client Secret:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.client_secret_var = tk.StringVar(value=calendar_settings.get('client_secret', ''))
        self.client_secret_entry = ttk.Entry(self.key_frame, textvariable=self.client_secret_var, width=50, show="*")
        self.client_secret_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        
        # Bot√£o para mostrar/ocultar senha
        self.show_secret_var = tk.BooleanVar()
        ttk.Checkbutton(self.key_frame, text="Mostrar chave", 
                       variable=self.show_secret_var, 
                       command=self.toggle_secret_visibility).grid(row=1, column=2, padx=5, pady=2)
        
        # Instru√ß√µes
        instructions_frame = ttk.LabelFrame(frame, text="Instru√ß√µes Para configurar o Google Calendar:", padding=10)
        instructions_frame.grid(row=4, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        instructions = [
            "1. Acesse https://console.developers.google.com/",
            "2. Crie um novo projeto ou selecione um existente",
            "3. Ative a Google Calendar API",
            "4. Crie credenciais OAuth 2.0",
            "5. Baixe o arquivo JSON OU copie o Client ID e Secret",
            "6. Configure acima usando JSON ou ID/Chave"
        ]
        
        for instruction in instructions:
            ttk.Label(instructions_frame, text=instruction).pack(anchor="w", pady=1)
        
        # Sincroniza√ß√£o autom√°tica
        sync_frame = ttk.LabelFrame(frame, text="Sincroniza√ß√£o Autom√°tica", padding=10)
        sync_frame.grid(row=5, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        self.sync_auto_var = tk.BooleanVar(value=calendar_settings.get('sync_auto', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar automaticamente", 
                       variable=self.sync_auto_var).pack(anchor=tk.W, pady=2)
        
        self.sync_cards_deadline_var = tk.BooleanVar(value=calendar_settings.get('sync_cards_deadline', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar cart√µes com prazo", 
                       variable=self.sync_cards_deadline_var).pack(anchor=tk.W, pady=2)
        
        self.sync_calendar_events_var = tk.BooleanVar(value=calendar_settings.get('sync_calendar_events', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar eventos do calend√°rio", 
                       variable=self.sync_calendar_events_var).pack(anchor=tk.W, pady=2)
        
        # Bot√µes de valida√ß√£o e teste
        test_frame = ttk.LabelFrame(frame, text="Valida√ß√£o e Teste", padding=10)
        test_frame.grid(row=6, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        test_buttons_frame = ttk.Frame(test_frame)
        test_buttons_frame.pack(fill=tk.X)
        
        ttk.Button(test_buttons_frame, text="üîç Validar Credenciais", 
                  command=self.validate_credentials).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(test_buttons_frame, text="üîÑ Testar Conex√£o", 
                  command=self.test_calendar_connection).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(test_buttons_frame, text="üìÇ Configurar Credenciais", 
                  command=self.open_credentials_config).pack(side=tk.LEFT, padx=5)
        
        # Status da valida√ß√£o
        self.validation_status_var = tk.StringVar(value="Status: N√£o verificado")
        ttk.Label(test_frame, textvariable=self.validation_status_var, 
                 font=("Arial", 9)).pack(anchor="w", pady=(10, 0))
        
        # Configurar navega√ß√£o com Enter
        self.setup_enter_navigation()
        
        # Inicializar visibilidade dos m√©todos de autentica√ß√£o
        print("DEBUG: Inicializando visibilidade dos m√©todos de autentica√ß√£o")
        self.toggle_auth_methods()
        print("DEBUG: Aba de calend√°rio criada com sucesso")
        print("üéØ OP√á√ÉO 'ID E CHAVE PRIVADA' DEVE APARECER NA ABA CALEND√ÅRIO!")
    
    def setup_enter_navigation(self):
        """Configura navega√ß√£o com Enter entre campos"""
        # Configurar Enter para navegar entre campos
        self.credentials_entry.bind('<Return>', lambda e: self.client_id_entry.focus())
        self.client_id_entry.bind('<Return>', lambda e: self.client_secret_entry.focus())
        self.client_secret_entry.bind('<Return>', lambda e: self.credentials_entry.focus())
    
    def toggle_auth_methods(self):
        """Alterna entre m√©todos de autentica√ß√£o"""
        print(f"DEBUG: toggle_auth_methods chamado - auth_type: {self.auth_type_var.get()}")
        if self.auth_type_var.get() == 'json':
            print("DEBUG: Mostrando frame JSON, ocultando frame Key")
            self.json_frame.grid()
            self.key_frame.grid_remove()
        else:
            print("DEBUG: Mostrando frame Key, ocultando frame JSON")
            self.json_frame.grid_remove()
            self.key_frame.grid()
    
    def toggle_secret_visibility(self):
        """Alterna visibilidade da chave privada"""
        if self.show_secret_var.get():
            self.client_secret_entry.config(show="")
        else:
            self.client_secret_entry.config(show="*")
    
    def browse_credentials_file(self):
        """Abre di√°logo para selecionar arquivo de credenciais"""
        from tkinter import filedialog
        file_path = filedialog.askopenfilename(
            title="Selecionar arquivo de credenciais do Google Calendar",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if file_path:
            self.credentials_file_var.set(file_path)
    
    def validate_credentials(self):
        """Valida as credenciais (JSON ou ID/Chave)"""
        auth_type = self.auth_type_var.get()
        
        if auth_type == 'json':
            self.validate_json_credentials()
        else:
            self.validate_key_credentials()
    
    def validate_json_credentials(self):
        """Valida o arquivo de credenciais JSON"""
        import json
        import os
        
        file_path = self.credentials_file_var.get()
        
        if not file_path:
            self.validation_status_var.set("Status: ‚ùå Nenhum arquivo selecionado")
            return
        
        if not os.path.exists(file_path):
            self.validation_status_var.set("Status: ‚ùå Arquivo n√£o encontrado")
            return
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            if 'installed' in data:
                client_info = data['installed']
                project_id = client_info.get('project_id', 'N/A')
                client_id = client_info.get('client_id', 'N/A')
                
                self.validation_status_var.set(f"Status: ‚úÖ JSON V√°lido - Projeto: {project_id}")
                messagebox.showinfo("Valida√ß√£o", 
                                  f"‚úÖ Arquivo de credenciais v√°lido!\n\n"
                                  f"üìù Projeto: {project_id}\n"
                                  f"üÜî Client ID: {client_id[:30]}...\n"
                                  f"üìè Tamanho: {os.path.getsize(file_path)} bytes")
                
            elif 'web' in data:
                client_info = data['web']
                project_id = client_info.get('project_id', 'N/A')
                client_id = client_info.get('client_id', 'N/A')
                
                self.validation_status_var.set(f"Status: ‚úÖ JSON V√°lido (Web) - Projeto: {project_id}")
                messagebox.showinfo("Valida√ß√£o", 
                                  f"‚úÖ Arquivo de credenciais v√°lido!\n\n"
                                  f"üìù Projeto: {project_id}\n"
                                  f"üÜî Client ID: {client_id[:30]}...\n"
                                  f"üìè Tamanho: {os.path.getsize(file_path)} bytes")
                
            else:
                self.validation_status_var.set("Status: ‚ùå Formato inv√°lido")
                messagebox.showerror("Erro", "‚ùå Arquivo n√£o cont√©m credenciais v√°lidas!\n\nO arquivo deve conter 'installed' ou 'web'")
                
        except json.JSONDecodeError:
            self.validation_status_var.set("Status: ‚ùå JSON inv√°lido")
            messagebox.showerror("Erro", "‚ùå Arquivo JSON inv√°lido!")
        except Exception as e:
            self.validation_status_var.set("Status: ‚ùå Erro ao ler arquivo")
            messagebox.showerror("Erro", f"‚ùå Erro ao ler arquivo: {e}")
    
    def validate_key_credentials(self):
        """Valida o ID e chave privada"""
        client_id = self.client_id_var.get().strip()
        client_secret = self.client_secret_var.get().strip()
        
        if not client_id:
            self.validation_status_var.set("Status: ‚ùå Client ID n√£o informado")
            messagebox.showerror("Erro", "‚ùå Client ID √© obrigat√≥rio!")
            return
        
        if not client_secret:
            self.validation_status_var.set("Status: ‚ùå Client Secret n√£o informado")
            messagebox.showerror("Erro", "‚ùå Client Secret √© obrigat√≥rio!")
            return
        
        # Validar formato do Client ID
        if not client_id.endswith('.apps.googleusercontent.com'):
            self.validation_status_var.set("Status: ‚ö†Ô∏è Client ID pode estar incorreto")
            messagebox.showwarning("Aviso", "‚ö†Ô∏è Client ID deve terminar com '.apps.googleusercontent.com'")
            return
        
        # Validar formato do Client Secret
        if len(client_secret) < 10:
            self.validation_status_var.set("Status: ‚ö†Ô∏è Client Secret pode estar incorreto")
            messagebox.showwarning("Aviso", "‚ö†Ô∏è Client Secret parece muito curto")
            return
        
        self.validation_status_var.set("Status: ‚úÖ ID e Chave v√°lidos")
        messagebox.showinfo("Valida√ß√£o", 
                          f"‚úÖ Credenciais v√°lidas!\n\n"
                          f"üÜî Client ID: {client_id[:30]}...\n"
                          f"üîê Client Secret: {client_secret[:10]}...\n"
                          f"üìù Tipo: ID e Chave Privada")
    
    def test_calendar_connection(self):
        """Testa a conex√£o com Google Calendar"""
        auth_type = self.auth_type_var.get()
        
        if auth_type == 'json':
            self.test_json_connection()
        else:
            self.test_key_connection()
    
    def test_json_connection(self):
        """Testa conex√£o usando arquivo JSON"""
        try:
            # Verificar se as bibliotecas est√£o instaladas
            try:
                from google.oauth2.credentials import Credentials
                from google_auth_oauthlib.flow import InstalledAppFlow
                from google.auth.transport.requests import Request
                from googleapiclient.discovery import build
                from googleapiclient.errors import HttpError
                import pickle
            except ImportError as e:
                messagebox.showerror("Erro", 
                                   f"‚ùå Bibliotecas n√£o instaladas: {e}\n\n"
                                   f"üí° Execute:\n"
                                   f"pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
                return
            
            # Verificar arquivo de credenciais
            file_path = self.credentials_file_var.get()
            if not file_path or not os.path.exists(file_path):
                messagebox.showerror("Erro", "‚ùå Arquivo de credenciais n√£o encontrado!\n\nSelecione um arquivo v√°lido primeiro.")
                return
            
            # Validar formato do arquivo JSON
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    json_data = json.load(f)
                
                if 'installed' not in json_data:
                    messagebox.showerror("Erro", "‚ùå Formato de arquivo inv√°lido!\n\nO arquivo deve conter credenciais OAuth 2.0 para aplica√ß√£o instalada.")
                    return
                    
            except json.JSONDecodeError:
                messagebox.showerror("Erro", "‚ùå Arquivo JSON inv√°lido!")
                return
            
            # Tentar autentica√ß√£o
            SCOPES = ['https://www.googleapis.com/auth/calendar']
            
            creds = None
            token_file = os.path.join(self.app.base_dir, 'test_token.pickle')
            
            if os.path.exists(token_file):
                try:
                    with open(token_file, 'rb') as token:
                        creds = pickle.load(token)
                except Exception as e:
                    print(f"Erro ao carregar token de teste: {e}")
                    creds = None
            
            if not creds or not creds.valid:
                if creds and creds.expired and creds.refresh_token:
                    try:
                        creds.refresh(Request())
                    except Exception as e:
                        print(f"Erro ao renovar token: {e}")
                        creds = None
                
                if not creds:
                    try:
                        flow = InstalledAppFlow.from_client_secrets_file(file_path, SCOPES)
                        creds = flow.run_local_server(port=0)
                        
                        # Salvar token de teste
                        with open(token_file, 'wb') as token:
                            pickle.dump(creds, token)
                    except Exception as e:
                        messagebox.showerror("Erro", f"‚ùå Erro na autentica√ß√£o OAuth:\n\n{e}")
                        return
            
            # Testar API
            service = build('calendar', 'v3', credentials=creds)
            
            try:
                calendar_list = service.calendarList().list().execute()
                calendars = calendar_list.get('items', [])
                
                if calendars:
                    self.validation_status_var.set("Status: ‚úÖ Conectado (JSON) - Calend√°rios dispon√≠veis")
                    messagebox.showinfo("Sucesso", 
                                      f"üéâ Conex√£o bem-sucedida!\n\n"
                                      f"üìÖ Calend√°rios encontrados: {len(calendars)}\n"
                                      f"üìù Primeiro calend√°rio: {calendars[0]['summary']}\n"
                                      f"üîó Tipo: Arquivo JSON")
                else:
                    self.validation_status_var.set("Status: ‚ö†Ô∏è Conectado (JSON) - Nenhum calend√°rio")
                    messagebox.showwarning("Aviso", "‚ö†Ô∏è Conex√£o bem-sucedida, mas nenhum calend√°rio encontrado!")
                    
            except HttpError as e:
                error_details = f"Erro {e.resp.status}: {e.content.decode()}"
                self.validation_status_var.set("Status: ‚ùå Erro de API (JSON)")
                messagebox.showerror("Erro de API", f"‚ùå Erro na API do Google Calendar:\n\n{error_details}")
                
        except Exception as e:
            self.validation_status_var.set("Status: ‚ùå Erro de conex√£o (JSON)")
            messagebox.showerror("Erro de Conex√£o", f"‚ùå Erro ao conectar com Google Calendar:\n\n{e}")
    
    def test_key_connection(self):
        """Testa conex√£o usando ID e chave privada"""
        try:
            # Verificar se as bibliotecas est√£o instaladas
            try:
                from google.oauth2.credentials import Credentials
                from google_auth_oauthlib.flow import InstalledAppFlow
                from google.auth.transport.requests import Request
                from googleapiclient.discovery import build
                from googleapiclient.errors import HttpError
                import pickle
            except ImportError as e:
                messagebox.showerror("Erro", 
                                   f"‚ùå Bibliotecas n√£o instaladas: {e}\n\n"
                                   f"üí° Execute:\n"
                                   f"pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
                return
            
            # Verificar credenciais
            client_id = self.client_id_var.get().strip()
            client_secret = self.client_secret_var.get().strip()
            
            if not client_id or not client_secret:
                messagebox.showerror("Erro", "‚ùå Client ID e Client Secret s√£o obrigat√≥rios!")
                return
            
            # Validar formato do Client ID
            if not client_id.endswith('.apps.googleusercontent.com'):
                messagebox.showwarning("Aviso", "‚ö†Ô∏è Client ID deve terminar com '.apps.googleusercontent.com'")
            
            # Validar formato do Client Secret
            if len(client_secret) < 10:
                messagebox.showwarning("Aviso", "‚ö†Ô∏è Client Secret parece muito curto")
            
            # Criar arquivo tempor√°rio de credenciais
            import tempfile
            import json
            
            temp_creds = {
                "installed": {
                    "client_id": client_id,
                    "client_secret": client_secret,
                    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                    "token_uri": "https://oauth2.googleapis.com/token",
                    "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                    "redirect_uris": ["http://localhost"]
                }
            }
            
            # Criar arquivo tempor√°rio
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                json.dump(temp_creds, f)
                temp_file = f.name
            
            try:
                # Tentar autentica√ß√£o
                SCOPES = ['https://www.googleapis.com/auth/calendar']
                
                creds = None
                token_file = os.path.join(self.app.base_dir, 'test_token.pickle')
                
                if os.path.exists(token_file):
                    try:
                        with open(token_file, 'rb') as token:
                            creds = pickle.load(token)
                    except Exception as e:
                        print(f"Erro ao carregar token de teste: {e}")
                        creds = None
                
                if not creds or not creds.valid:
                    if creds and creds.expired and creds.refresh_token:
                        try:
                            creds.refresh(Request())
                        except Exception as e:
                            print(f"Erro ao renovar token: {e}")
                            creds = None
                    
                    if not creds:
                        try:
                            flow = InstalledAppFlow.from_client_secrets_file(temp_file, SCOPES)
                            creds = flow.run_local_server(port=0)
                            
                            # Salvar token de teste
                            with open(token_file, 'wb') as token:
                                pickle.dump(creds, token)
                        except Exception as e:
                            messagebox.showerror("Erro", f"‚ùå Erro na autentica√ß√£o OAuth:\n\n{e}")
                            return
                
                # Testar API
                service = build('calendar', 'v3', credentials=creds)
                
                try:
                    calendar_list = service.calendarList().list().execute()
                    calendars = calendar_list.get('items', [])
                    
                    if calendars:
                        self.validation_status_var.set("Status: ‚úÖ Conectado (ID/Chave) - Calend√°rios dispon√≠veis")
                        messagebox.showinfo("Sucesso", 
                                          f"üéâ Conex√£o bem-sucedida!\n\n"
                                          f"üìÖ Calend√°rios encontrados: {len(calendars)}\n"
                                          f"üìù Primeiro calend√°rio: {calendars[0]['summary']}\n"
                                          f"üîó Tipo: ID e Chave Privada")
                    else:
                        self.validation_status_var.set("Status: ‚ö†Ô∏è Conectado (ID/Chave) - Nenhum calend√°rio")
                        messagebox.showwarning("Aviso", "‚ö†Ô∏è Conex√£o bem-sucedida, mas nenhum calend√°rio encontrado!")
                        
                except HttpError as e:
                    error_details = f"Erro {e.resp.status}: {e.content.decode()}"
                    self.validation_status_var.set("Status: ‚ùå Erro de API (ID/Chave)")
                    messagebox.showerror("Erro de API", f"‚ùå Erro na API do Google Calendar:\n\n{error_details}")
                    
            finally:
                # Limpar arquivo tempor√°rio
                try:
                    os.unlink(temp_file)
                except:
                    pass
                    
        except Exception as e:
            self.validation_status_var.set("Status: ‚ùå Erro de conex√£o (ID/Chave)")
            messagebox.showerror("Erro de Conex√£o", f"‚ùå Erro ao conectar com Google Calendar:\n\n{e}")
    
    def open_credentials_config(self):
        """Abre o configurador de credenciais"""
        try:
            import subprocess
            import sys
            
            # Tentar executar o configurador
            subprocess.Popen([os.path.abspath(sys.argv[0]), "config_google_calendar.py"])
            
        except Exception as e:
            messagebox.showerror("Erro", 
                               f"‚ùå Erro ao abrir configurador: {e}\n\n"
                               f"üí° Execute manualmente:\n"
                               f"python config_google_calendar.py")

    def create_email_tab(self):
        """Cria a aba de configura√ß√µes de email"""
        frame = self.email_tab
        frame.grid_columnconfigure(1, weight=1)
        
        email_settings = self.app.settings.get('email_integration', {})
        
        # Enable email integration
        self.email_enabled_var = tk.BooleanVar(value=email_settings.get('enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integra√ß√£o de Email", 
                       variable=self.email_enabled_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)
        
        # Provider selection
        ttk.Label(frame, text="Provedor:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        self.email_provider_var = tk.StringVar(value=email_settings.get('provider', 'gmail'))
        provider_frame = ttk.Frame(frame)
        provider_frame.grid(row=1, column=1, sticky="w", padx=10, pady=5)
        
        ttk.Radiobutton(provider_frame, text="Gmail", 
                       variable=self.email_provider_var, value="gmail").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(provider_frame, text="Outlook", 
                       variable=self.email_provider_var, value="outlook").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(provider_frame, text="SMTP Personalizado", 
                       variable=self.email_provider_var, value="smtp").pack(side=tk.LEFT, padx=5)
        
        # Email credentials
        ttk.Label(frame, text="Email:").grid(row=2, column=0, sticky="w", padx=10, pady=5)
        self.email_address_entry = ttk.Entry(frame, width=50)
        self.email_address_entry.grid(row=2, column=1, sticky="ew", padx=10, pady=5)
        self.email_address_entry.insert(0, email_settings.get('email_address', ''))
        
        ttk.Label(frame, text="Senha:").grid(row=3, column=0, sticky="w", padx=10, pady=5)
        self.email_password_entry = ttk.Entry(frame, width=50, show="*")
        self.email_password_entry.grid(row=3, column=1, sticky="ew", padx=10, pady=5)
        self.email_password_entry.insert(0, email_settings.get('email_password', ''))
        
        ttk.Label(frame, text="Senha do App (Gmail):").grid(row=4, column=0, sticky="w", padx=10, pady=5)
        self.app_password_entry = ttk.Entry(frame, width=50, show="*")
        self.app_password_entry.grid(row=4, column=1, sticky="ew", padx=10, pady=5)
        self.app_password_entry.insert(0, email_settings.get('app_password', ''))
        
        # SMTP settings
        ttk.Label(frame, text="Servidor SMTP:").grid(row=5, column=0, sticky="w", padx=10, pady=5)
        self.smtp_server_entry = ttk.Entry(frame, width=50)
        self.smtp_server_entry.grid(row=5, column=1, sticky="ew", padx=10, pady=5)
        self.smtp_server_entry.insert(0, email_settings.get('smtp_server', 'smtp.gmail.com'))
        
        ttk.Label(frame, text="Porta SMTP:").grid(row=6, column=0, sticky="w", padx=10, pady=5)
        self.smtp_port_entry = ttk.Entry(frame, width=50)
        self.smtp_port_entry.grid(row=6, column=1, sticky="ew", padx=10, pady=5)
        self.smtp_port_entry.insert(0, str(email_settings.get('smtp_port', 587)))
        
        # Auto notifications
        notif_frame = ttk.LabelFrame(frame, text="Notifica√ß√µes Autom√°ticas", padding=10)
        notif_frame.grid(row=7, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        auto_notifications = email_settings.get('auto_notifications', {})
        
        self.notify_card_created_var = tk.BooleanVar(value=auto_notifications.get('card_created', True))
        ttk.Checkbutton(notif_frame, text="Cart√£o Criado", 
                       variable=self.notify_card_created_var).pack(anchor=tk.W, pady=2)
        
        self.notify_card_modified_var = tk.BooleanVar(value=auto_notifications.get('card_modified', True))
        ttk.Checkbutton(notif_frame, text="Cart√£o Modificado", 
                       variable=self.notify_card_modified_var).pack(anchor=tk.W, pady=2)
        
        self.notify_card_moved_var = tk.BooleanVar(value=auto_notifications.get('card_moved', True))
        ttk.Checkbutton(notif_frame, text="Cart√£o Movido", 
                       variable=self.notify_card_moved_var).pack(anchor=tk.W, pady=2)
        
        self.notify_deadline_reminder_var = tk.BooleanVar(value=auto_notifications.get('deadline_reminder', True))
        ttk.Checkbutton(notif_frame, text="Lembrete de Prazo", 
                       variable=self.notify_deadline_reminder_var).pack(anchor=tk.W, pady=2)
        
        self.notify_weekly_report_var = tk.BooleanVar(value=auto_notifications.get('weekly_report', True))
        ttk.Checkbutton(notif_frame, text="Relat√≥rio Semanal", 
                       variable=self.notify_weekly_report_var).pack(anchor=tk.W, pady=2)
        
        # Recipients
        ttk.Label(frame, text="Destinat√°rios (separados por v√≠rgula):").grid(row=8, column=0, sticky="w", padx=10, pady=5)
        self.recipients_entry = ttk.Entry(frame, width=50)
        self.recipients_entry.grid(row=8, column=1, sticky="ew", padx=10, pady=5)
        recipients = email_settings.get('notification_recipients', [])
        self.recipients_entry.insert(0, ', '.join(recipients))
        
        # Reminder settings
        reminder_frame = ttk.LabelFrame(frame, text="Configura√ß√µes de Lembrete", padding=10)
        reminder_frame.grid(row=9, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        ttk.Label(reminder_frame, text="Horas antes do prazo:").pack(anchor=tk.W, pady=2)
        self.reminder_hours_var = tk.StringVar(value=str(email_settings.get('deadline_reminder_hours', 24)))
        reminder_hours_spinbox = ttk.Spinbox(reminder_frame, from_=1, to=168, textvariable=self.reminder_hours_var, width=10)
        reminder_hours_spinbox.pack(anchor=tk.W, pady=2)
        
        # Weekly report settings
        report_frame = ttk.LabelFrame(frame, text="Relat√≥rio Semanal", padding=10)
        report_frame.grid(row=10, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        ttk.Label(report_frame, text="Dia da semana:").pack(anchor=tk.W, pady=2)

    def create_calendar_tab(self):
        """Cria a aba de configura√ß√µes do Google Calendar"""
        frame = self.calendar_tab
        frame.grid_columnconfigure(1, weight=1)
        
        calendar_settings = self.app.settings.get('google_calendar', {})
        
        # Enable Google Calendar integration
        self.calendar_enabled_var = tk.BooleanVar(value=calendar_settings.get('enabled', False))
        ttk.Checkbutton(frame, text="Habilitar Integra√ß√£o com Google Calendar", 
                       variable=self.calendar_enabled_var).grid(row=0, column=0, columnspan=2, sticky="w", padx=10, pady=10)
        
        # Credentials file
        ttk.Label(frame, text="Arquivo de Credenciais:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        self.credentials_file_var = tk.StringVar(value=calendar_settings.get('credentials_file', ''))
        credentials_frame = ttk.Frame(frame)
        credentials_frame.grid(row=1, column=1, sticky="ew", padx=10, pady=5)
        
        self.credentials_entry = ttk.Entry(credentials_frame, textvariable=self.credentials_file_var, width=40)
        self.credentials_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(credentials_frame, text="Procurar", command=self.browse_credentials_file).pack(side=tk.RIGHT, padx=(5, 0))
        
        # Instructions
        instructions_frame = ttk.LabelFrame(frame, text="Instru√ß√µes", padding=10)
        instructions_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        instructions_text = """
Para configurar o Google Calendar:

1. Acesse https://console.developers.google.com/
2. Crie um novo projeto ou selecione um existente
3. Ative a Google Calendar API
4. Crie credenciais OAuth 2.0
5. Baixe o arquivo JSON de credenciais
6. Selecione o arquivo acima
        """.strip()
        
        ttk.Label(instructions_frame, text=instructions_text, justify=tk.LEFT).pack(anchor=tk.W)
        
        # Auto sync settings
        sync_frame = ttk.LabelFrame(frame, text="Sincroniza√ß√£o Autom√°tica", padding=10)
        sync_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        self.auto_sync_var = tk.BooleanVar(value=calendar_settings.get('auto_sync', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar automaticamente", 
                       variable=self.auto_sync_var).pack(anchor=tk.W, pady=2)
        
        self.sync_cards_var = tk.BooleanVar(value=calendar_settings.get('sync_cards', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar cart√µes com prazo", 
                       variable=self.sync_cards_var).pack(anchor=tk.W, pady=2)
        
        self.sync_events_var = tk.BooleanVar(value=calendar_settings.get('sync_events', True))
        ttk.Checkbutton(sync_frame, text="Sincronizar eventos do calend√°rio", 
                       variable=self.sync_events_var).pack(anchor=tk.W, pady=2)
        
        # Email management settings
        email_frame = ttk.LabelFrame(frame, text="Gerenciamento de Emails", padding=10)
        email_frame.grid(row=4, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        # Add default emails
        ttk.Label(email_frame, text="Emails Padr√£o (um por linha):").pack(anchor=tk.W, pady=(0, 5))
        
        email_text_frame = ttk.Frame(email_frame)
        email_text_frame.pack(fill=tk.X, pady=(0, 5))
        
        self.default_emails_text = tk.Text(email_text_frame, height=4, width=50)
        email_scrollbar = ttk.Scrollbar(email_text_frame, orient="vertical", command=self.default_emails_text.yview)
        self.default_emails_text.configure(yscrollcommand=email_scrollbar.set)
        
        self.default_emails_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        email_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Load existing emails
        default_emails = calendar_settings.get('default_emails', [])
        self.default_emails_text.insert("1.0", "\n".join(default_emails))
        
        # Email options
        email_options_frame = ttk.Frame(email_frame)
        email_options_frame.pack(fill=tk.X, pady=(5, 0))
        
        self.include_default_emails_var = tk.BooleanVar(value=calendar_settings.get('include_default_emails', True))
        ttk.Checkbutton(email_options_frame, text="Incluir emails padr√£o em todos os eventos", 
                       variable=self.include_default_emails_var).pack(side=tk.LEFT, padx=(0, 10))
        
        self.include_card_members_var = tk.BooleanVar(value=calendar_settings.get('include_card_members', True))
        ttk.Checkbutton(email_options_frame, text="Incluir membros do card automaticamente", 
                       variable=self.include_card_members_var).pack(side=tk.LEFT)
        
        # Instructions for emails
        email_instructions = ttk.LabelFrame(email_frame, text="Instru√ß√µes para Emails", padding=5)
        email_instructions.pack(fill=tk.X, pady=(10, 0))
        
        instructions_text = """
* Emails padr√£o: Ser√£o inclu√≠dos em todos os eventos criados
* Membros do card: Ser√£o adicionados automaticamente se tiverem email configurado
* Formato: um email por linha (exemplo@email.com)
* Os emails receber√£o convites autom√°ticos do Google Calendar
        """.strip()
        
        ttk.Label(email_instructions, text=instructions_text, justify=tk.LEFT, font=("TkDefaultFont", 8)).pack(anchor=tk.W)

    def create_email_templates_tab(self):
        """Cria a aba de gerenciamento de templates de email"""
        frame = self.email_templates_tab
        frame.grid_columnconfigure(1, weight=1)
        frame.grid_rowconfigure(2, weight=1)
        
        # Template selection
        ttk.Label(frame, text="Template:").grid(row=0, column=0, sticky="w", padx=10, pady=5)
        self.template_var = tk.StringVar()
        self.template_combo = ttk.Combobox(frame, textvariable=self.template_var, state="readonly", width=30)
        self.template_combo.grid(row=0, column=1, sticky="w", padx=10, pady=5)
        self.template_combo['values'] = self.app.email_template_manager.get_available_templates()
        self.template_combo.bind("<<ComboboxSelected>>", self.on_template_selected)
        
        # Template actions
        template_actions = ttk.Frame(frame)
        template_actions.grid(row=1, column=0, columnspan=2, sticky="w", padx=10, pady=5)
        
        ttk.Button(template_actions, text="Novo Template", command=self.create_new_template).pack(side=tk.LEFT, padx=2)
        ttk.Button(template_actions, text="Duplicar", command=self.duplicate_template).pack(side=tk.LEFT, padx=2)
        ttk.Button(template_actions, text="Excluir", command=self.delete_template).pack(side=tk.LEFT, padx=2)
        
        # Template editor
        editor_frame = ttk.LabelFrame(frame, text="Editor de Template", padding=10)
        editor_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", padx=10, pady=10)
        editor_frame.grid_columnconfigure(0, weight=1)
        editor_frame.grid_rowconfigure(1, weight=1)
        
        # Subject
        ttk.Label(editor_frame, text="Assunto:").grid(row=0, column=0, sticky="w", pady=(0, 5))
        self.subject_var = tk.StringVar()
        self.subject_entry = ttk.Entry(editor_frame, textvariable=self.subject_var, width=60)
        self.subject_entry.grid(row=0, column=1, sticky="ew", pady=(0, 5), padx=(10, 0))
        
        # Body
        ttk.Label(editor_frame, text="Corpo do Email:").grid(row=1, column=0, sticky="nw", pady=(0, 5))
        body_frame = ttk.Frame(editor_frame)
        body_frame.grid(row=1, column=1, sticky="nsew", padx=(10, 0))
        body_frame.grid_columnconfigure(0, weight=1)
        body_frame.grid_rowconfigure(0, weight=1)
        
        # Advanced text editor for email body
        try:
            from advanced_text_editor import AdvancedTextEditor
            self.body_editor = AdvancedTextEditor(body_frame, height=15, width=60)
            self.body_editor.grid(row=0, column=0, sticky="nsew")
            self.body_text = self.body_editor.text_widget
        except ImportError:
            # Fallback to simple text widget if advanced editor is not available
            self.body_text = tk.Text(body_frame, height=15, width=60)
            body_scrollbar = ttk.Scrollbar(body_frame, orient="vertical", command=self.body_text.yview)
            self.body_text.configure(yscrollcommand=body_scrollbar.set)
            
            self.body_text.grid(row=0, column=0, sticky="nsew")
            body_scrollbar.grid(row=0, column=1, sticky="ns")
        
        # Variables help
        variables_frame = ttk.LabelFrame(frame, text="Vari√°veis Dispon√≠veis", padding=10)
        variables_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        variables_text = """
Vari√°veis que podem ser usadas nos templates:
{card_title} - T√≠tulo do cart√£o
{board_name} - Nome do quadro
{list_name} - Nome da lista
{card_description} - Descri√ß√£o do cart√£o
{due_date} - Data de vencimento
{importance} - N√≠vel de import√¢ncia
{member_name} - Nome do membro
{changes} - Lista de altera√ß√µes
{week_period} - Per√≠odo do relat√≥rio
{completed_tasks} - Tarefas conclu√≠das
{pending_tasks} - Tarefas pendentes
{total_pomodoro_time} - Tempo total de pomodoro
{productivity_score} - Score de produtividade
{important_completed_tasks} - Tarefas importantes conclu√≠das
{upcoming_deadlines} - Pr√≥ximos prazos
        """.strip()
        
        ttk.Label(variables_frame, text=variables_text, justify=tk.LEFT, font=("TkDefaultFont", 9)).pack(anchor=tk.W)
        
        # Save button
        save_frame = ttk.Frame(frame)
        save_frame.grid(row=4, column=0, columnspan=2, pady=10)
        
        ttk.Button(save_frame, text="Salvar Template", command=self.save_template).pack(side=tk.LEFT, padx=5)
        ttk.Button(save_frame, text="Testar Template", command=self.test_template).pack(side=tk.LEFT, padx=5)
        ttk.Button(save_frame, text="Restaurar Padr√£o", command=self.restore_default_template).pack(side=tk.LEFT, padx=5)

    def browse_credentials_file(self):
        """Abre di√°logo para selecionar arquivo de credenciais"""
        from tkinter import filedialog
        filename = filedialog.askopenfilename(
            title="Selecionar arquivo de credenciais",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if filename:
            self.credentials_file_var.set(filename)

    def on_template_selected(self, event=None):
        """Chamado quando um template √© selecionado"""
        template_name = self.template_var.get()
        if template_name:
            template = self.app.email_template_manager.get_template(template_name)
            if template:
                self.subject_var.set(template.get('subject', ''))
                self.body_text.delete("1.0", tk.END)
                self.body_text.insert("1.0", template.get('body', ''))

    def create_new_template(self):
        """Cria um novo template"""
        template_name = simpledialog.askstring("Novo Template", "Nome do template:")
        if template_name:
            if template_name in self.app.email_template_manager.get_available_templates():
                messagebox.showwarning("Aviso", "Template com este nome j√° existe!")
                return
            
            # Adicionar ao combo
            current_values = list(self.template_combo['values'])
            current_values.append(template_name)
            self.template_combo['values'] = current_values
            self.template_combo.set(template_name)
            
            # Limpar campos
            self.subject_var.set("")
            self.body_text.delete("1.0", tk.END)
            
            # Focar no campo de assunto
            self.subject_entry.focus()

    def duplicate_template(self):
        """Duplica o template selecionado"""
        current_template = self.template_var.get()
        if not current_template:
            messagebox.showwarning("Aviso", "Selecione um template para duplicar!")
            return
        
        new_name = simpledialog.askstring("Duplicar Template", f"Nome do novo template (baseado em {current_template}):")
        if new_name:
            if new_name in self.app.email_template_manager.get_available_templates():
                messagebox.showwarning("Aviso", "Template com este nome j√° existe!")
                return
            
            # Copiar template
            original_template = self.app.email_template_manager.get_template(current_template)
            self.app.email_template_manager.update_template(
                new_name, 
                original_template.get('subject', ''),
                original_template.get('body', '')
            )
            
            # Atualizar combo
            current_values = list(self.template_combo['values'])
            current_values.append(new_name)
            self.template_combo['values'] = current_values
            self.template_combo.set(new_name)

    def delete_template(self):
        """Exclui o template selecionado"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para excluir!")
            return
        
        if messagebox.askyesno("Confirmar", f"Tem certeza que deseja excluir o template '{template_name}'?"):
            # Remover template
            templates = self.app.email_template_manager.templates
            if template_name in templates:
                del templates[template_name]
                self.app.email_template_manager.save_templates()
            
            # Atualizar combo
            current_values = list(self.template_combo['values'])
            current_values.remove(template_name)
            self.template_combo['values'] = current_values
            self.template_combo.set("")
            
            # Limpar campos
            self.subject_var.set("")
            self.body_text.delete("1.0", tk.END)

    def save_template(self):
        """Salva o template atual"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para salvar!")
            return
        
        subject = self.subject_var.get().strip()
        body = self.body_text.get("1.0", tk.END).strip()
        
        if not subject:
            messagebox.showwarning("Aviso", "O assunto √© obrigat√≥rio!")
            return
        
        # Salvar template
        self.app.email_template_manager.update_template(template_name, subject, body)
        messagebox.showinfo("Sucesso", "Template salvo com sucesso!")

    def test_template(self):
        """Testa o template atual com dados de exemplo"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para testar!")
            return
        
        # Dados de exemplo
        test_variables = {
            'card_title': 'Tarefa de Exemplo',
            'board_name': 'Quadro de Teste',
            'list_name': 'Em Progresso',
            'card_description': 'Esta √© uma descri√ß√£o de exemplo',
            'due_date': '2024-01-15',
            'importance': 'Alta',
            'member_name': 'Jo√£o Silva',
            'changes': '- T√≠tulo alterado\n- Prazo atualizado',
            'week_period': '01/01/2024 - 07/01/2024',
            'completed_tasks': '5',
            'pending_tasks': '3',
            'total_pomodoro_time': '12h 30m',
            'productivity_score': '85',
            'important_completed_tasks': '- Tarefa importante 1\n- Tarefa importante 2',
            'upcoming_deadlines': '- Reuni√£o de equipe (15/01)\n- Relat√≥rio mensal (20/01)'
        }
        
        # Formatar template
        subject, body = self.app.email_template_manager.format_template(template_name, test_variables)
        
        # Mostrar preview
        preview_window = tk.Toplevel(self)
        preview_window.title("Preview do Template")
        preview_window.geometry("600x500")
        preview_window.transient(self)
        preview_window.grab_set()
        
        # Assunto
        ttk.Label(preview_window, text="Assunto:", font=("TkDefaultFont", 10, "bold")).pack(anchor="w", padx=10, pady=(10, 5))
        subject_text = tk.Text(preview_window, height=2, width=70)
        subject_text.pack(fill=tk.X, padx=10, pady=(0, 10))
        subject_text.insert("1.0", subject)
        subject_text.config(state="disabled")
        
        # Corpo
        ttk.Label(preview_window, text="Corpo:", font=("TkDefaultFont", 10, "bold")).pack(anchor="w", padx=10, pady=(10, 5))
        body_text = tk.Text(preview_window, height=20, width=70)
        body_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
        body_text.insert("1.0", body)
        body_text.config(state="disabled")
        
        # Bot√£o fechar
        ttk.Button(preview_window, text="Fechar", command=preview_window.destroy).pack(pady=10)

    def restore_default_template(self):
        """Restaura o template padr√£o"""
        template_name = self.template_var.get()
        if not template_name:
            messagebox.showwarning("Aviso", "Selecione um template para restaurar!")
            return
        
        if messagebox.askyesno("Confirmar", f"Tem certeza que deseja restaurar o template '{template_name}' para o padr√£o?"):
            # Recarregar templates padr√£o
            self.app.email_template_manager.load_templates()
            
            # Atualizar campos
            self.on_template_selected()
            
            messagebox.showinfo("Sucesso", "Template restaurado para o padr√£o!")

    def toggle_config_frames(self):
        self.report_day_var = tk.StringVar(value=email_settings.get('weekly_report_day', 'monday'))
        report_day_combo = ttk.Combobox(report_frame, textvariable=self.report_day_var, 
                                       values=['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
                                       state="readonly")
        report_day_combo.pack(anchor=tk.W, pady=2)
        
        ttk.Label(report_frame, text="Hor√°rio (HH:MM):").pack(anchor=tk.W, pady=2)
        self.report_time_var = tk.StringVar(value=email_settings.get('weekly_report_time', '09:00'))
        report_time_entry = ttk.Entry(report_frame, textvariable=self.report_time_var, width=10)
        report_time_entry.pack(anchor=tk.W, pady=2)
        
        # Test connection button
        ttk.Button(frame, text="Testar Conex√£o", 
                  command=self.test_email_connection).grid(row=11, column=0, columnspan=2, pady=10)

    def toggle_config_frames(self):
        """Alterna a visibilidade dos frames de configura√ß√£o"""
        if self.config_type_var.get() == "individual":
            self.individual_frame.grid()
            self.centralized_frame.grid_remove()
        else:
            self.individual_frame.grid_remove()
            self.centralized_frame.grid()

    def preview_dashboard_settings(self):
        """Mostra preview das configura√ß√µes do dashboard"""
        enabled_widgets = [name for key, var in self.dashboard_widget_vars.items() if var.get()]
        messagebox.showinfo("Preview Dashboard", 
                          f"Widgets habilitados:\n" + "\n".join([f"‚Ä¢ {name}" for name in enabled_widgets]))

    # Fun√ß√µes de teste e reautentica√ß√£o do Google Calendar removidas - integra√ß√£o desabilitada

    def test_email_connection(self):
        """Testa a conex√£o de email"""
        try:
            # Create temporary email integration for testing
            temp_email = EmailIntegration(self.app)
            temp_email.settings = {
                'enabled': True,
                'provider': self.email_provider_var.get(),
                'email_address': self.email_address_entry.get(),
                'email_password': self.email_password_entry.get(),
                'app_password': self.app_password_entry.get(),
                'smtp_server': self.smtp_server_entry.get(),
                'smtp_port': int(self.smtp_port_entry.get()),
                'demo_mode': True  # Use demo mode for testing
            }
            
            # Test with demo mode
            if temp_email.send_email("test@example.com", "Teste de Conex√£o", "Este √© um teste de conex√£o."):
                messagebox.showinfo("Teste de Conex√£o", "Conex√£o de email testada com sucesso (modo demo)!")
            else:
                messagebox.showerror("Erro de Conex√£o", "Falha ao testar conex√£o de email.")
                
        except Exception as e:
            messagebox.showerror("Erro de Conex√£o", f"Erro ao testar conex√£o: {e}")

    def create_pomodoro_tab(self):
        frame = self.pomodoro_tab
        frame.grid_columnconfigure(1, weight=1)

        ttk.Label(frame, text="Tempo do Pomodoro (minutos):").grid(row=0, column=0, sticky="w", padx=10, pady=(10, 2))
        self.pomodoro_entry = ttk.Spinbox(frame, from_=1, to=120, increment=1)
        self.pomodoro_entry.grid(row=0, column=1, sticky="ew", padx=10, pady=(10, 2))
        self.pomodoro_entry.set(self.app.settings['pomodoro'])

        ttk.Label(frame, text="Pausa Curta (minutos):").grid(row=1, column=0, sticky="w", padx=10, pady=2)
        self.short_break_entry = ttk.Spinbox(frame, from_=1, to=60, increment=1)
        self.short_break_entry.grid(row=1, column=1, sticky="ew", padx=10, pady=2)
        self.short_break_entry.set(self.app.settings['short_break'])

        ttk.Label(frame, text="Pausa Longa (minutos):").grid(row=2, column=0, sticky="w", padx=10, pady=2)
        self.long_break_entry = ttk.Spinbox(frame, from_=1, to=120, increment=1)
        self.long_break_entry.grid(row=2, column=1, sticky="ew", padx=10, pady=2)
        self.long_break_entry.set(self.app.settings['long_break'])

        ttk.Label(frame, text="Ciclos at√© a Pausa Longa:").grid(row=3, column=0, sticky="w", padx=10, pady=2)
        self.cycles_entry = ttk.Spinbox(frame, from_=1, to=10, increment=1)
        self.cycles_entry.grid(row=3, column=1, sticky="ew", padx=10, pady=2)
        self.cycles_entry.set(self.app.settings['cycles'])

    def _check_admin_permissions(self):
        """Verifica se o usu√°rio atual tem permiss√µes de administrador"""
        try:
            if not hasattr(self.app, 'current_user') or not self.app.current_user:
                return False
            
            # Verificar role do usu√°rio
            user_role = getattr(self.app.current_user, 'role', '').lower()
            user_cargo = getattr(self.app.current_user, 'cargo', '').lower()
            
            # Administradores podem ser identificados por role ou cargo
            admin_roles = ['admin', 'administrador', 'administrator']
            admin_cargos = ['admin', 'administrador', 'administrator', 'gerente', 'manager']
            
            return (user_role in admin_roles or user_cargo in admin_cargos)
            
        except Exception as e:
            print(f"Erro ao verificar permiss√µes de administrador: {e}")
            return False

    def _populate_importance_treeview(self):
        for i in self.importance_tree.get_children():
            self.importance_tree.delete(i)
        for name, color in self.app.settings["importance_colors"].items():
            self.importance_tree.insert("", "end", values=(name, color), tags=(name,))
            self.importance_tree.tag_configure(name, background=color)

    def _add_importance_level(self):
        # Verificar permiss√µes de administrador
        if not self._check_admin_permissions():
            messagebox.showerror("Acesso Negado", "Apenas administradores podem adicionar n√≠veis de import√¢ncia.", parent=self)
            return
            
        new_name = simpledialog.askstring("Novo N√≠vel de Import√¢ncia", "Digite o nome para o novo n√≠vel de import√¢ncia:", parent=self)
        if new_name:
            new_name = new_name.strip()
            if new_name in self.app.settings["importance_colors"]:
                messagebox.showwarning("Nome Duplicado", f"O n√≠vel de import√¢ncia '{new_name}' j√° existe.", parent=self)
                return
            color_code = colorchooser.askcolor(title=f"Escolha a cor para {new_name}")
            if color_code[1]:
                self.app.settings["importance_colors"][new_name] = color_code[1]
                self._populate_importance_treeview()
            else:
                messagebox.showwarning("Cor N√£o Selecionada", "Nenhuma cor foi selecionada para o novo n√≠vel.", parent=self)

    def _remove_importance_level(self):
        # Verificar permiss√µes de administrador
        if not self._check_admin_permissions():
            messagebox.showerror("Acesso Negado", "Apenas administradores podem remover n√≠veis de import√¢ncia.", parent=self)
            return
            
        selected_item = self.importance_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um n√≠vel de import√¢ncia para remover.", parent=self)
            return
        
        importance_name = self.importance_tree.item(selected_item, "values")[0]
        
        # Prevent removal of default importance levels
        default_importance_levels = self.app.get_default_settings()["importance_colors"].keys()
        if importance_name in default_importance_levels:
            messagebox.showwarning("N√≠vel Padr√£o", f"O n√≠vel de import√¢ncia '{importance_name}' √© padr√£o e n√£o pode ser removido.", parent=self)
            return

        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover o n√≠vel de import√¢ncia '{importance_name}'? Isso pode afetar cart√µes existentes.", parent=self):
            del self.app.settings["importance_colors"][importance_name]
            self._populate_importance_treeview()

    def _edit_importance_color(self, event):
        # Verificar permiss√µes de administrador
        if not self._check_admin_permissions():
            messagebox.showerror("Acesso Negado", "Apenas administradores podem editar cores de import√¢ncia.", parent=self)
            return
            
        selected_item = self.importance_tree.selection()
        if not selected_item:
            return
        
        importance_name = self.importance_tree.item(selected_item, "values")[0]
        current_color = self.app.settings["importance_colors"][importance_name]

        color_code = colorchooser.askcolor(title=f"Escolha a nova cor para {importance_name}", initialcolor=current_color)
        if color_code[1]:
            self.app.settings["importance_colors"][importance_name] = color_code[1]
            self._populate_importance_treeview()

    def choose_color(self, importance, color_label):
        # This method is now deprecated but kept for compatibility if needed elsewhere
        color_code = colorchooser.askcolor(title=f"Escolha a cor para {importance}")
        if color_code[1]:
            color_label.config(bg=color_code[1], text=color_code[1])

    def create_roles_tab(self):
        frame = self.roles_tab
        frame.grid_columnconfigure(0, weight=1)
        frame.grid_rowconfigure(0, weight=1)

        roles_frame = ttk.LabelFrame(frame, text="Gerenciar Cargos", padding=10)
        roles_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        roles_frame.grid_columnconfigure(0, weight=1)

        self.roles_tree = ttk.Treeview(roles_frame, columns=("Nome", "Descri√ß√£o"), show="headings")
        self.roles_tree.heading("Nome", text="Nome")
        self.roles_tree.heading("Descri√ß√£o", text="Descri√ß√£o")
        self.roles_tree.column("Nome", width=150, anchor="w")
        self.roles_tree.column("Descri√ß√£o", width=300, anchor="w")
        self.roles_tree.pack(fill="both", expand=True, pady=5)
        self.roles_tree.bind("<Double-1>", self._edit_role_level) # Double click to edit

        roles_buttons_frame = ttk.Frame(roles_frame)
        roles_buttons_frame.pack(fill="x", pady=5)

        ttk.Button(roles_buttons_frame, text="Adicionar Cargo", image=self.app.icons.get('add_icon'), compound=tk.LEFT, command=self._add_role_level).pack(side="left", padx=5)
        ttk.Button(roles_buttons_frame, text="Remover Cargo", image=self.app.icons.get('delete_icon'), compound=tk.LEFT, command=self._remove_role_level).pack(side="left", padx=5)

        self.app.load_settings() # Ensure settings are up-to-date
        self._populate_roles_treeview()

    def _populate_roles_treeview(self):
        for i in self.roles_tree.get_children():
            self.roles_tree.delete(i)
        for name, desc in self.app.settings["roles"].items():
            self.roles_tree.insert("", "end", values=(name, desc), tags=(name,))

    def _add_role_level(self):
        new_name = simpledialog.askstring("Novo Cargo", "Digite o nome para o novo cargo:", parent=self)
        if new_name:
            new_name = new_name.strip()
            if new_name in self.app.settings["roles"]:
                messagebox.showwarning("Nome Duplicado", f"O cargo '{new_name}' j√° existe.", parent=self)
                return
            new_desc = simpledialog.askstring("Descri√ß√£o do Cargo", f"Digite a descri√ß√£o para o cargo '{new_name}':", parent=self)
            if new_desc is not None:
                self.app.settings["roles"][new_name] = new_desc.strip()
                self.app.save_settings_file()
                self._populate_roles_treeview()
            else:
                messagebox.showwarning("Descri√ß√£o Necess√°ria", "A descri√ß√£o do cargo √© necess√°ria.", parent=self)

    def _edit_role_level(self, event):
        selected_item = self.roles_tree.selection()
        if not selected_item:
            return
        
        role_name = self.roles_tree.item(selected_item, "values")[0]
        current_desc = self.app.settings["roles"][role_name]

        new_desc = simpledialog.askstring("Editar Cargo", f"Editar descri√ß√£o para '{role_name}':", initialvalue=current_desc, parent=self)
        if new_desc is not None:
            self.app.settings["roles"][role_name] = new_desc.strip()
            self.app.save_settings_file()
            self._populate_roles_treeview()

    def _remove_role_level(self):
        selected_item = self.roles_tree.selection()
        if not selected_item:
            messagebox.showwarning("Nenhuma Sele√ß√£o", "Selecione um cargo para remover.", parent=self)
            return
        
        role_name = self.roles_tree.item(selected_item, "values")[0]
        
        # Prevent removal of default roles
        default_roles = self.app.get_default_settings()["roles"].keys()
        if role_name in default_roles:
            messagebox.showwarning("Cargo Padr√£o", f"O cargo '{role_name}' √© padr√£o e n√£o pode ser removido.", parent=self)
            return

        if messagebox.askyesno("Confirmar Remo√ß√£o", f"Tem certeza que deseja remover o cargo '{role_name}'?", parent=self):
            del self.app.settings["roles"][role_name]
            self.app.save_settings_file()
            self._populate_roles_treeview()

    def restore_defaults(self):
        if messagebox.askyesno("Restaurar Padr√µes", "Tem certeza que deseja restaurar todas as configura√ß√µes para os valores de f√°brica?"):
            self.app.settings = self.app.get_default_settings()
            self.app.save_settings_file()
            self.destroy()
            self.app.open_settings()

    def save_settings(self):
        try:
            # Verificar se as vari√°veis existem antes de acess√°-las
            if hasattr(self, 'pomodoro_entry'):
                pomodoro = int(self.pomodoro_entry.get())
                short_break = int(self.short_break_entry.get())
                long_break = int(self.long_break_entry.get())
                cycles = int(self.cycles_entry.get())

                if not all(x > 0 for x in [pomodoro, short_break, long_break, cycles]):
                    raise ValueError("Todos os valores devem ser maiores que zero.")

                self.app.settings['pomodoro'] = pomodoro
                self.app.settings['short_break'] = short_break
                self.app.settings['long_break'] = long_break
                self.app.settings['cycles'] = cycles

            # Configura√ß√µes gerais
            if hasattr(self, 'theme_combo'):
                self.app.settings['theme'] = self.theme_combo.get()
            if hasattr(self, 'unify_subjects_var'):
                self.app.settings['unify_subjects'] = self.unify_subjects_var.get()
            if hasattr(self, 'show_card_details_on_board_var'):
                self.app.settings['show_card_details_on_board'] = self.show_card_details_on_board_var.get()
            if hasattr(self, 'dev_mode_var'):
                self.app.settings['dev_mode'] = self.dev_mode_var.get()
            if hasattr(self, 'git_integration_enabled_var'):
                self.app.settings['git_integration_enabled'] = self.git_integration_enabled_var.get()

            # Save dashboard widget settings
            if hasattr(self, 'dashboard_widget_vars'):
                dashboard_widgets = {}
                for key, var in self.dashboard_widget_vars.items():
                    if key == 'meeting_widget':
                        # Salvar configura√ß√£o do widget de reuni√µes
                        self.app.notification_manager.notification_settings['show_widget'] = var.get()
                        self.app.notification_manager.save_notification_settings()
                    else:
                        dashboard_widgets[key] = var.get()
                
                self.app.settings['dashboard_widgets'] = dashboard_widgets

            # Save Google Calendar settings
            if hasattr(self, 'calendar_enabled_var'):
                calendar_settings = {
                    'enabled': self.calendar_enabled_var.get(),
                    'auth_type': self.auth_type_var.get() if hasattr(self, 'auth_type_var') else 'json',
                    'credentials_file': self.credentials_file_var.get() if hasattr(self, 'credentials_file_var') else '',
                    'client_id': self.client_id_var.get() if hasattr(self, 'client_id_var') else '',
                    'client_secret': self.client_secret_var.get() if hasattr(self, 'client_secret_var') else '',
                    'sync_auto': self.sync_auto_var.get() if hasattr(self, 'sync_auto_var') else True,
                    'sync_cards_deadline': self.sync_cards_deadline_var.get() if hasattr(self, 'sync_cards_deadline_var') else True,
                    'sync_calendar_events': self.sync_calendar_events_var.get() if hasattr(self, 'sync_calendar_events_var') else True
                }
                
                # Validar configura√ß√µes do Google Calendar antes de salvar
                if calendar_settings['enabled']:
                    if calendar_settings['auth_type'] == 'json':
                        if not calendar_settings['credentials_file'] or not os.path.exists(calendar_settings['credentials_file']):
                            messagebox.showerror("Erro", "‚ùå Arquivo de credenciais JSON n√£o encontrado!\n\nConfigure um arquivo v√°lido primeiro.")
                            return
                    elif calendar_settings['auth_type'] == 'key':
                        if not calendar_settings['client_id'].strip() or not calendar_settings['client_secret'].strip():
                            messagebox.showerror("Erro", "‚ùå Client ID e Client Secret s√£o obrigat√≥rios!\n\nConfigure as credenciais primeiro.")
                            return
                    else:
                        messagebox.showerror("Erro", "‚ùå Tipo de autentica√ß√£o inv√°lido!")
                        return
                
                self.app.settings['calendar_integration'] = calendar_settings

            # Save Google Calendar email settings
            if hasattr(self, 'default_emails_text'):
                # Get emails from text widget
                emails_text = self.default_emails_text.get("1.0", tk.END).strip()
                default_emails = [email.strip() for email in emails_text.split('\n') if email.strip()]
                
                # Validate email format
                import re
                email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
                valid_emails = []
                invalid_emails = []
                
                for email in default_emails:
                    if email_pattern.match(email):
                        valid_emails.append(email)
                    else:
                        invalid_emails.append(email)
                
                if invalid_emails:
                    messagebox.showwarning("Emails Inv√°lidos", 
                                         f"Os seguintes emails n√£o s√£o v√°lidos e ser√£o ignorados:\n{', '.join(invalid_emails)}")
                
                # Update calendar settings with email configuration
                calendar_settings.update({
                    'default_emails': valid_emails,
                    'include_default_emails': self.include_default_emails_var.get() if hasattr(self, 'include_default_emails_var') else True,
                    'include_card_members': self.include_card_members_var.get() if hasattr(self, 'include_card_members_var') else True
                })
                
                self.app.settings['calendar_integration'] = calendar_settings

            # Save email integration settings
            if hasattr(self, 'email_enabled_var'):
                recipients = [email.strip() for email in self.recipients_entry.get().split(',') if email.strip()]
                self.app.settings['email_integration'] = {
                                    'enabled': self.email_enabled_var.get() if hasattr(self, 'email_enabled_var') else False,
                'provider': self.email_provider_var.get() if hasattr(self, 'email_provider_var') else 'gmail',
                    'email_address': self.email_address_entry.get() if hasattr(self, 'email_address_entry') else '',
                    'email_password': self.email_password_entry.get() if hasattr(self, 'email_password_entry') else '',
                    'app_password': self.app_password_entry.get() if hasattr(self, 'app_password_entry') else '',
                    'smtp_server': self.smtp_server_entry.get() if hasattr(self, 'smtp_server_entry') else 'smtp.gmail.com',
                    'smtp_port': int(self.smtp_port_entry.get()) if hasattr(self, 'smtp_port_entry') else 587,
                                    'auto_notifications': {
                    'card_created': self.notify_card_created_var.get() if hasattr(self, 'notify_card_created_var') else True,
                    'card_modified': self.notify_card_modified_var.get() if hasattr(self, 'notify_card_modified_var') else True,
                    'card_moved': self.notify_card_moved_var.get() if hasattr(self, 'notify_card_moved_var') else True,
                    'deadline_reminder': self.notify_deadline_reminder_var.get() if hasattr(self, 'notify_deadline_reminder_var') else True,
                    'weekly_report': self.notify_weekly_report_var.get() if hasattr(self, 'notify_weekly_report_var') else True
                },
                    'notification_recipients': recipients,
                    'deadline_reminder_hours': int(self.reminder_hours_var.get()) if hasattr(self, 'reminder_hours_var') else 24,
                    'weekly_report_day': self.report_day_var.get() if hasattr(self, 'report_day_var') else 'monday',
                    'weekly_report_time': self.report_time_var.get() if hasattr(self, 'report_time_var') else '09:00'
                }

            # Roles are already updated directly by _add_role_level, _edit_role_level, _remove_role_level
            # No need to iterate self.color_labels anymore

            self.app.save_settings_file()
            
            # Apply dashboard widget settings
            self.app.apply_dashboard_widget_settings()
            self.app.change_theme(self.app.settings['theme'])
            self.app.load_aux_data()
            self.app.update_timer_display()
            
            # Preservar o estado do calend√°rio ANTES de atualizar os quadros
            calendar_state = None
            if hasattr(self.app, 'calendar_widget') and self.app.calendar_widget:
                try:
                    # Capturar estado atual do calend√°rio
                    calendar_state = {
                        'selected_date': self.app.calendar_widget.get_date(),
                        'current_month': datetime.now().strftime("%Y-%m-%d"),  # Usar data atual em vez de calevent_date
                        'events': [],
                        'calendar_width': self.app.calendar_widget.winfo_width(),
                        'calendar_height': self.app.calendar_widget.winfo_height(),
                        'calendar_geometry': self.app.calendar_widget.winfo_geometry()
                    }
                    
                    # Capturar eventos se existirem
                    if hasattr(self.app, 'events_tree') and self.app.events_tree:
                        events = []
                        for item in self.app.events_tree.get_children():
                            values = self.app.events_tree.item(item)['values']
                            events.append(values)
                        calendar_state['events'] = events
                        
                    # Capturar estado do painel de eventos
                    if hasattr(self.app, 'events_tree') and self.app.events_tree:
                        calendar_state['events_tree_width'] = self.app.events_tree.winfo_width()
                        calendar_state['events_tree_height'] = self.app.events_tree.winfo_height()
                        
                except Exception as e:
                    print(f"Erro ao capturar estado do calend√°rio: {e}")
                    calendar_state = None
            
            # Atualizar apenas os quadros sem recriar o calend√°rio
            self.app.populate_boards()
            self.app.update_legend()
            self.app.update_pomodoro_task_list()
            
            # Restaurar o estado do calend√°rio AP√ìS atualizar os quadros
            if calendar_state and hasattr(self.app, 'calendar_widget') and self.app.calendar_widget:
                try:
                    # Restaurar data selecionada
                    if calendar_state['selected_date']:
                        self.app.calendar_widget.selection_set(calendar_state['selected_date'])
                    
                    # Restaurar tamanho do calend√°rio se necess√°rio
                    if calendar_state.get('calendar_width') and calendar_state.get('calendar_height'):
                        try:
                            # For√ßar redimensionamento do calend√°rio
                            self.app.calendar_widget.configure(width=calendar_state['calendar_width'])
                            self.app.calendar_widget.update_idletasks()
                        except:
                            pass
                    
                    # Recarregar eventos do calend√°rio se necess√°rio
                    if hasattr(self.app, 'load_calendar_events'):
                        self.app.load_calendar_events()
                        
                    # For√ßar atualiza√ß√£o do layout
                    self.app.calendar_widget.update_idletasks()
                    if hasattr(self.app, 'events_tree') and self.app.events_tree:
                        self.app.events_tree.update_idletasks()
                        
                except Exception as e:
                    print(f"Erro ao restaurar estado do calend√°rio: {e}")
            
            self.destroy()
            messagebox.showinfo("Configura√ß√µes Salvas", "As configura√ß√µes foram salvas com sucesso!")

        except ValueError as e:
            messagebox.showerror("Erro", f"Por favor, insira valores num√©ricos v√°lidos e maiores que zero: {e}")

    def toggle_always_on_top(self):
        self.app.root.attributes("-topmost", self.always_on_top_var.get())

# Define CardDetailsWindow as an alias for CardWindow
CardDetailsWindow = CardWindow

class CategoriesManagerWindow:
    def __init__(self, parent, app):
        self.parent = parent
        self.app = app
        self.window = tk.Toplevel(parent)
        self.window.title("Gerenciar Categorias")
        self.window.geometry("600x500")
        self.window.transient(parent)
        self.window.grab_set()
        
        try:
            if hasattr(self, 'create_widgets'):
                self.create_widgets()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao criar widgets: {e}")
    
    def create_widgets(self):
        """Cria widgets da janela de gerenciamento de categorias"""
        # Frame principal
        main_frame = ttk.Frame(self.window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_label = ttk.Label(main_frame, text="Gerenciar Categorias", 
                               font=("Arial", 14, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Frame para lista de categorias
        list_frame = ttk.LabelFrame(main_frame, text="Categorias Cadastradas", padding="10")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Treeview para categorias
        columns = ("ID", "Nome", "Cor")
        self.categories_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=10)
        
        self.categories_tree.heading("ID", text="ID")
        self.categories_tree.heading("Nome", text="Nome")
        self.categories_tree.heading("Cor", text="Cor")
        
        self.categories_tree.column("ID", width=50, anchor="center")
        self.categories_tree.column("Nome", width=200, anchor="w")
        self.categories_tree.column("Cor", width=100, anchor="center")
        
        self.categories_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.categories_tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.categories_tree.configure(yscrollcommand=scrollbar.set)
        
        # Frame para adicionar/editar categoria
        edit_frame = ttk.LabelFrame(main_frame, text="Adicionar/Editar Categoria", padding="10")
        edit_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Grid para campos
        edit_frame.columnconfigure(1, weight=1)
        
        # Nome da categoria
        ttk.Label(edit_frame, text="Nome:").grid(row=0, column=0, sticky="w", padx=(0, 10), pady=5)
        self.name_var = tk.StringVar()
        self.name_entry = ttk.Entry(edit_frame, textvariable=self.name_var, width=30)
        self.name_entry.grid(row=0, column=1, sticky="ew", padx=(0, 10), pady=5)
        
        # Cor da categoria
        ttk.Label(edit_frame, text="Cor:").grid(row=0, column=2, sticky="w", padx=(0, 10), pady=5)
        self.color_var = tk.StringVar(value="#3498db")
        self.color_entry = ttk.Entry(edit_frame, textvariable=self.color_var, width=10)
        self.color_entry.grid(row=0, column=3, sticky="w", padx=(0, 10), pady=5)
        
        # Bot√£o para escolher cor
        self.color_button = tk.Button(edit_frame, text="Escolher", 
                                     command=self.choose_color, bg=self.color_var.get())
        self.color_button.grid(row=0, column=4, padx=(0, 10), pady=5)
        
        # Bot√µes de a√ß√£o
        button_frame = ttk.Frame(edit_frame)
        button_frame.grid(row=1, column=0, columnspan=5, pady=10)
        
        ttk.Button(button_frame, text="Adicionar", 
                  command=self.add_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Editar", 
                  command=self.edit_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Remover", 
                  command=self.remove_category).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Limpar", 
                  command=self.clear_form).pack(side=tk.LEFT, padx=5)
        
        # Bot√µes principais
        main_button_frame = ttk.Frame(main_frame)
        main_button_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(main_button_frame, text="Fechar", 
                  command=self.window.destroy).pack(side=tk.RIGHT, padx=5)
        
        # Carregar categorias
        self.load_categories()
        
        # Bind para sele√ß√£o
        self.categories_tree.bind("<<TreeviewSelect>>", self.on_category_select)
    
    def load_categories(self):
        """Carrega as categorias na treeview"""
        # Limpar treeview
        for item in self.categories_tree.get_children():
            self.categories_tree.delete(item)
        
        # Adicionar categorias
        for category in self.app.categories:
            self.categories_tree.insert("", "end", values=(
                category['id'],
                category['name'],
                category['color']
            ))
    
    def choose_color(self):
        """Abre o seletor de cores"""
        try:
            from tkinter import colorchooser
            color = colorchooser.askcolor(title="Escolher Cor da Categoria")[1]
            if color:
                self.color_var.set(color)
                self.color_button.config(bg=color)
        except ImportError:
            messagebox.showwarning("Aviso", "Seletor de cores n√£o dispon√≠vel")
    
    def add_category(self):
        """Adiciona uma nova categoria"""
        name = self.name_var.get().strip()
        color = self.color_var.get().strip()
        
        if not name:
            messagebox.showwarning("Aviso", "Nome da categoria √© obrigat√≥rio!")
            return
        
        if not color:
            messagebox.showwarning("Aviso", "Cor da categoria √© obrigat√≥ria!")
            return
        
        # Verificar se j√° existe
        for category in self.app.categories:
            if category['name'].lower() == name.lower():
                messagebox.showwarning("Aviso", f"Categoria '{name}' j√° existe!")
                return
        
        # Gerar novo ID
        new_id = max([cat['id'] for cat in self.app.categories], default=0) + 1
        
        # Adicionar categoria
        new_category = {
            'id': new_id,
            'name': name,
            'color': color
        }
        
        self.app.categories.append(new_category)
        self.app.save_categories()
        self.load_categories()
        self.clear_form()
        
        messagebox.showinfo("Sucesso", f"Categoria '{name}' adicionada com sucesso!")
    
    def edit_category(self):
        """Edita a categoria selecionada"""
        selected = self.categories_tree.selection()
        if not selected:
            messagebox.showwarning("Aviso", "Selecione uma categoria para editar!")
            return
        
        name = self.name_var.get().strip()
        color = self.color_var.get().strip()
        
        if not name:
            messagebox.showwarning("Aviso", "Nome da categoria √© obrigat√≥rio!")
            return
        
        if not color:
            messagebox.showwarning("Aviso", "Cor da categoria √© obrigat√≥ria!")
            return
        
        # Obter categoria selecionada
        item = self.categories_tree.item(selected[0])
        category_id = item['values'][0]
        
        # Verificar se nome j√° existe (exceto para a categoria atual)
        for category in self.app.categories:
            if category['id'] != category_id and category['name'].lower() == name.lower():
                messagebox.showwarning("Aviso", f"Categoria '{name}' j√° existe!")
                return
        
        # Atualizar categoria
        for category in self.app.categories:
            if category['id'] == category_id:
                category['name'] = name
                category['color'] = color
                break
        
        self.app.save_categories()
        self.load_categories()
        self.clear_form()
        
        messagebox.showinfo("Sucesso", f"Categoria '{name}' atualizada com sucesso!")
    
    def remove_category(self):
        """Remove a categoria selecionada"""
        selected = self.categories_tree.selection()
        if not selected:
            messagebox.showwarning("Aviso", "Selecione uma categoria para remover!")
            return
        
        item = self.categories_tree.item(selected[0])
        category_id = item['values'][0]
        category_name = item['values'][1]
        
        if messagebox.askyesno("Confirmar", f"Tem certeza que deseja remover a categoria '{category_name}'?"):
            # Remover categoria
            self.app.categories = [cat for cat in self.app.categories if cat['id'] != category_id]
            self.app.save_categories()
            self.load_categories()
            self.clear_form()
            
            messagebox.showinfo("Sucesso", f"Categoria '{category_name}' removida com sucesso!")
    
    def clear_form(self):
        """Limpa o formul√°rio"""
        self.name_var.set("")
        self.color_var.set("#3498db")
        self.color_button.config(bg="#3498db")
        self.categories_tree.selection_remove(*self.categories_tree.selection())
    
    def on_category_select(self, event):
        """Chamado quando uma categoria √© selecionada"""
        selected = self.categories_tree.selection()
        if selected:
            item = self.categories_tree.item(selected[0])
            values = item['values']
            
            self.name_var.set(values[1])
            self.color_var.set(values[2])
            self.color_button.config(bg=values[2])

    # ============================================================================
    # SISTEMA FINANCEIRO EMPRESARIAL
    # ============================================================================

    def create_finance_dashboard_enterprise(self, parent):
        """Cria o dashboard financeiro empresarial"""
        # Frame principal com scroll
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        canvas = tk.Canvas(main_frame)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Header
        header_frame = ttk.Frame(scrollable_frame)
        header_frame.pack(fill=tk.X, padx=20, pady=20)
        
        ttk.Label(header_frame, text="üè¢ Dashboard Financeiro Empresarial", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        ttk.Button(header_frame, text="üîÑ Atualizar", 
                  command=self.refresh_enterprise_dashboard).pack(side=tk.RIGHT)
        
        # Cards de m√©tricas principais
        metrics_frame = ttk.Frame(scrollable_frame)
        metrics_frame.pack(fill=tk.X, padx=20, pady=10)
        
        # Saldo Total
        self.create_enterprise_metric_card(metrics_frame, "üí∞ Saldo Total", "R$ 0,00", "#2ecc71", 0, 0)
        
        # Receitas do M√™s
        self.create_enterprise_metric_card(metrics_frame, "üìà Receitas/M√™s", "R$ 0,00", "#3498db", 0, 1)
        
        # Despesas do M√™s
        self.create_enterprise_metric_card(metrics_frame, "üìâ Despesas/M√™s", "R$ 0,00", "#e74c3c", 0, 2)
        
        # Lucro do M√™s
        self.create_enterprise_metric_card(metrics_frame, "üíµ Lucro/M√™s", "R$ 0,00", "#f39c12", 0, 3)
        
        # Contas a Receber
        self.create_enterprise_metric_card(metrics_frame, "üì• Contas a Receber", "R$ 0,00", "#9b59b6", 1, 0)
        
        # Contas a Pagar
        self.create_enterprise_metric_card(metrics_frame, "üì§ Contas a Pagar", "R$ 0,00", "#e67e22", 1, 1)
        
        # Clientes Ativos
        self.create_enterprise_metric_card(metrics_frame, "üë• Clientes Ativos", "0", "#1abc9c", 1, 2)
        
        # Fornecedores
        self.create_enterprise_metric_card(metrics_frame, "üè≠ Fornecedores", "0", "#34495e", 1, 3)
        
        # Se√ß√£o de gr√°ficos
        charts_frame = ttk.Frame(scrollable_frame)
        charts_frame.pack(fill=tk.X, padx=20, pady=20)
        
        ttk.Label(charts_frame, text="üìä An√°lises Financeiras", 
                 font=("Arial", 14, "bold")).pack(anchor=tk.W)
        
        charts_buttons_frame = ttk.Frame(charts_frame)
        charts_buttons_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(charts_buttons_frame, text="üìà Evolu√ß√£o Mensal", 
                  command=lambda: self.show_enterprise_chart("evolucao")).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(charts_buttons_frame, text="ü•ß Receitas por Categoria", 
                  command=lambda: self.show_enterprise_chart("receitas_categoria")).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(charts_buttons_frame, text="üìä Despesas por Departamento", 
                  command=lambda: self.show_enterprise_chart("despesas_departamento")).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(charts_buttons_frame, text="üíº Fluxo de Caixa", 
                  command=lambda: self.show_enterprise_chart("fluxo_caixa")).pack(side=tk.LEFT, padx=5)
        
        # Se√ß√£o de alertas e pend√™ncias
        alerts_frame = ttk.Frame(scrollable_frame)
        alerts_frame.pack(fill=tk.X, padx=20, pady=20)
        
        ttk.Label(alerts_frame, text="‚ö†Ô∏è Alertas e Pend√™ncias", 
                 font=("Arial", 14, "bold")).pack(anchor=tk.W)
        
        # Treeview para alertas
        self.alerts_tree = ttk.Treeview(alerts_frame, columns=("tipo", "descricao", "valor", "prazo"), 
                                       show="headings", height=6)
        self.alerts_tree.heading("tipo", text="Tipo")
        self.alerts_tree.heading("descricao", text="Descri√ß√£o")
        self.alerts_tree.heading("valor", text="Valor")
        self.alerts_tree.heading("prazo", text="Prazo")
        
        self.alerts_tree.column("tipo", width=100)
        self.alerts_tree.column("descricao", width=300)
        self.alerts_tree.column("valor", width=100)
        self.alerts_tree.column("prazo", width=100)
        
        self.alerts_tree.pack(fill=tk.X, pady=10)
        
        # Configurar scroll
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Atualizar dados
        self.refresh_enterprise_dashboard()
    
    def create_enterprise_metric_card(self, parent, title, value, color, row, col):
        """Cria um card de m√©trica empresarial"""
        card_frame = ttk.Frame(parent, relief=tk.RAISED, borderwidth=2)
        card_frame.grid(row=row, column=col, padx=10, pady=10, sticky="nsew")
        
        # Configurar grid
        parent.grid_columnconfigure(col, weight=1)
        parent.grid_rowconfigure(row, weight=1)
        
        # T√≠tulo
        ttk.Label(card_frame, text=title, font=("Arial", 10, "bold")).pack(pady=(10, 5))
        
        # Valor
        value_label = ttk.Label(card_frame, text=value, font=("Arial", 16, "bold"), foreground=color)
        value_label.pack(pady=(0, 10))
        
        # Armazenar refer√™ncia para atualiza√ß√£o
        if not hasattr(self, 'enterprise_metrics'):
            self.enterprise_metrics = {}
        self.enterprise_metrics[f"{title}_{row}_{col}"] = value_label
    
    def refresh_enterprise_dashboard(self):
        """Atualiza o dashboard empresarial"""
        try:
            # Buscar dados do banco
            departments = self.db.get_departments()
            clients = self.db.get_clients()
            suppliers = self.db.get_suppliers()
            accounts_receivable = self.db.get_accounts_receivable()
            accounts_payable = self.db.get_accounts_payable()
            
            # Calcular m√©tricas
            total_receivable = sum(float(ar['amount']) for ar in accounts_receivable if ar['status'] == 'Pendente')
            total_payable = sum(float(ap['amount']) for ap in accounts_payable if ap['status'] == 'Pendente')
            
            # Atualizar cards
            if hasattr(self, 'enterprise_metrics'):
                self.enterprise_metrics.get("üí∞ Saldo Total_0_0", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("üìà Receitas/M√™s_0_1", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("üìâ Despesas/M√™s_0_2", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("üíµ Lucro/M√™s_0_3", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("üì• Contas a Receber_1_0", ttk.Label()).configure(text=f"R$ {total_receivable:,.2f}")
                self.enterprise_metrics.get("üì§ Contas a Pagar_1_1", ttk.Label()).configure(text=f"R$ {total_payable:,.2f}")
                self.enterprise_metrics.get("üë• Clientes Ativos_1_2", ttk.Label()).configure(text=str(len(clients)))
                self.enterprise_metrics.get("üè≠ Fornecedores_1_3", ttk.Label()).configure(text=str(len(suppliers)))
            
            # Atualizar alertas
            self.update_enterprise_alerts()
            
        except Exception as e:
            print(f"Erro ao atualizar dashboard empresarial: {e}")
    
    def update_enterprise_alerts(self):
        """Atualiza a lista de alertas empresariais"""
        if not hasattr(self, 'alerts_tree'):
            return
        
        # Limpar lista
        for item in self.alerts_tree.get_children():
            self.alerts_tree.delete(item)
        
        try:
            # Buscar contas a pagar vencidas
            accounts_payable = self.db.get_accounts_payable()
            today = datetime.now().date()
            
            for ap in accounts_payable:
                if ap['status'] == 'Pendente':
                    due_date = datetime.strptime(ap['due_date'], '%Y-%m-%d').date()
                    if due_date < today:
                        self.alerts_tree.insert("", "end", values=(
                            "Conta Vencida",
                            f"Pagar: {ap['description']}",
                            f"R$ {float(ap['amount']):,.2f}",
                            ap['due_date']
                        ))
            
            # Buscar contas a receber vencidas
            accounts_receivable = self.db.get_accounts_receivable()
            
            for ar in accounts_receivable:
                if ar['status'] == 'Pendente':
                    due_date = datetime.strptime(ar['due_date'], '%Y-%m-%d').date()
                    if due_date < today:
                        self.alerts_tree.insert("", "end", values=(
                            "Recebimento Vencido",
                            f"Receber: {ar['description']}",
                            f"R$ {float(ar['amount']):,.2f}",
                            ar['due_date']
                        ))
        
        except Exception as e:
            print(f"Erro ao atualizar alertas: {e}")
    
    def show_enterprise_chart(self, chart_type):
        """Mostra gr√°ficos empresariais"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
            
            # Criar janela para o gr√°fico
            chart_window = tk.Toplevel(self.root)
            chart_window.title(f"Gr√°fico - {chart_type}")
            chart_window.geometry("800x600")
            
            fig, ax = plt.subplots(figsize=(10, 6))
            
            if chart_type == "evolucao":
                # Gr√°fico de evolu√ß√£o mensal
                months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun']
                receitas = [50000, 55000, 48000, 62000, 58000, 65000]
                despesas = [45000, 47000, 43000, 52000, 49000, 54000]
                
                ax.plot(months, receitas, 'o-', label='Receitas', color='#3498db')
                ax.plot(months, despesas, 's-', label='Despesas', color='#e74c3c')
                ax.set_title('Evolu√ß√£o Mensal - Receitas vs Despesas')
                ax.set_ylabel('Valor (R$)')
                ax.legend()
                ax.grid(True, alpha=0.3)
            
            elif chart_type == "receitas_categoria":
                # Gr√°fico de pizza - receitas por categoria
                categories = ['Vendas', 'Servi√ßos', 'Consultoria', 'Outros']
                values = [45, 30, 20, 5]
                colors = ['#3498db', '#2ecc71', '#f39c12', '#e74c3c']
                
                ax.pie(values, labels=categories, colors=colors, autopct='%1.1f%%')
                ax.set_title('Receitas por Categoria')
            
            elif chart_type == "despesas_departamento":
                # Gr√°fico de barras - despesas por departamento
                departments = ['TI', 'Marketing', 'RH', 'Financeiro', 'Opera√ß√µes']
                expenses = [25000, 18000, 15000, 12000, 22000]
                colors = ['#3498db', '#2ecc71', '#f39c12', '#e74c3c', '#9b59b6']
                
                bars = ax.bar(departments, expenses, color=colors)
                ax.set_title('Despesas por Departamento')
                ax.set_ylabel('Valor (R$)')
                
                # Adicionar valores nas barras
                for bar, value in zip(bars, expenses):
                    ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 1000,
                           f'R$ {value:,.0f}', ha='center', va='bottom')
            
            elif chart_type == "fluxo_caixa":
                # Gr√°fico de fluxo de caixa
                dates = ['01/01', '15/01', '01/02', '15/02', '01/03', '15/03']
                cash_flow = [50000, 45000, 52000, 48000, 55000, 58000]
                
                ax.plot(dates, cash_flow, 'o-', color='#2ecc71', linewidth=2)
                ax.fill_between(dates, cash_flow, alpha=0.3, color='#2ecc71')
                ax.set_title('Fluxo de Caixa - √öltimos 3 Meses')
                ax.set_ylabel('Saldo (R$)')
                ax.grid(True, alpha=0.3)
            
            # Configurar layout
            plt.tight_layout()
            
            # Criar canvas
            canvas = FigureCanvasTkAgg(fig, chart_window)
            canvas.draw()
            canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except ImportError:
            messagebox.showwarning("Aviso", "Matplotlib n√£o est√° instalado. Instale com: pip install matplotlib")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar gr√°fico: {e}")
    
    def create_clients_management_tab(self, parent):
        """Cria a aba de gest√£o de clientes"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Header
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(header_frame, text="üë• Gest√£o de Clientes", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        ttk.Button(header_frame, text="‚ûï Novo Cliente", 
                  command=self.open_new_client_window).pack(side=tk.RIGHT)
        
        # Frame para formul√°rio e lista
        content_frame = ttk.Frame(main_frame)
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        # Formul√°rio de cliente
        form_frame = ttk.LabelFrame(content_frame, text="Dados do Cliente", padding=10)
        form_frame.pack(fill=tk.X, pady=(0, 20))
        
        # Primeira linha
        row1 = ttk.Frame(form_frame)
        row1.pack(fill=tk.X, pady=5)
        
        ttk.Label(row1, text="Nome/Raz√£o Social:").pack(side=tk.LEFT)
        self.client_name_var = tk.StringVar()
        ttk.Entry(row1, textvariable=self.client_name_var, width=30).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row1, text="CNPJ/CPF:").pack(side=tk.LEFT)
        self.client_cnpj_var = tk.StringVar()
        ttk.Entry(row1, textvariable=self.client_cnpj_var, width=20).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row1, text="Segmento:").pack(side=tk.LEFT)
        self.client_segment_var = tk.StringVar()
        ttk.Combobox(row1, textvariable=self.client_segment_var, 
                    values=["Tecnologia", "Sa√∫de", "Educa√ß√£o", "Varejo", "Ind√∫stria", "Servi√ßos", "Outros"],
                    width=15).pack(side=tk.LEFT, padx=(10, 0))
        
        # Segunda linha
        row2 = ttk.Frame(form_frame)
        row2.pack(fill=tk.X, pady=5)
        
        ttk.Label(row2, text="Email:").pack(side=tk.LEFT)
        self.client_email_var = tk.StringVar()
        ttk.Entry(row2, textvariable=self.client_email_var, width=30).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row2, text="Telefone:").pack(side=tk.LEFT)
        self.client_phone_var = tk.StringVar()
        ttk.Entry(row2, textvariable=self.client_phone_var, width=15).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row2, text="Limite de Cr√©dito:").pack(side=tk.LEFT)
        self.client_credit_var = tk.StringVar()
        ttk.Entry(row2, textvariable=self.client_credit_var, width=15).pack(side=tk.LEFT, padx=(10, 0))
        
        # Terceira linha
        row3 = ttk.Frame(form_frame)
        row3.pack(fill=tk.X, pady=5)
        
        ttk.Label(row3, text="Contato:").pack(side=tk.LEFT)
        self.client_contact_var = tk.StringVar()
        ttk.Entry(row3, textvariable=self.client_contact_var, width=30).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row3, text="Endere√ßo:").pack(side=tk.LEFT)
        self.client_address_var = tk.StringVar()
        ttk.Entry(row3, textvariable=self.client_address_var, width=40).pack(side=tk.LEFT, padx=(10, 0))
        
        # Bot√µes
        buttons_frame = ttk.Frame(form_frame)
        buttons_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(buttons_frame, text="üíæ Salvar Cliente", 
                  command=self.save_client).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(buttons_frame, text="üîÑ Limpar", 
                  command=self.clear_client_form).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(buttons_frame, text="üóëÔ∏è Excluir", 
                  command=self.delete_client).pack(side=tk.LEFT)
        
        # Lista de clientes
        list_frame = ttk.LabelFrame(content_frame, text="Clientes Cadastrados", padding=10)
        list_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview
        columns = ("id", "nome", "cnpj_cpf", "email", "telefone", "segmento", "limite_credito", "status")
        self.clients_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=10)
        
        self.clients_tree.heading("id", text="ID")
        self.clients_tree.heading("nome", text="Nome/Raz√£o Social")
        self.clients_tree.heading("cnpj_cpf", text="CNPJ/CPF")
        self.clients_tree.heading("email", text="Email")
        self.clients_tree.heading("telefone", text="Telefone")
        self.clients_tree.heading("segmento", text="Segmento")
        self.clients_tree.heading("limite_credito", text="Limite de Cr√©dito")
        self.clients_tree.heading("status", text="Status")
        
        self.clients_tree.column("id", width=50)
        self.clients_tree.column("nome", width=200)
        self.clients_tree.column("cnpj_cpf", width=120)
        self.clients_tree.column("email", width=150)
        self.clients_tree.column("telefone", width=100)
        self.clients_tree.column("segmento", width=100)
        self.clients_tree.column("limite_credito", width=120)
        self.clients_tree.column("status", width=80)
        
        # Scrollbars
        tree_scroll_y = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.clients_tree.yview)
        tree_scroll_x = ttk.Scrollbar(list_frame, orient=tk.HORIZONTAL, command=self.clients_tree.xview)
        self.clients_tree.configure(yscrollcommand=tree_scroll_y.set, xscrollcommand=tree_scroll_x.set)
        
        # Pack
        self.clients_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        tree_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Bind para sele√ß√£o
        self.clients_tree.bind('<<TreeviewSelect>>', self.on_client_select)
        
        # Carregar dados
        self.load_clients()
    
    def save_client(self):
        """Salva um novo cliente"""
        try:
            # Validar campos obrigat√≥rios
            if not self.client_name_var.get().strip():
                messagebox.showerror("Erro", "Nome/Raz√£o Social √© obrigat√≥rio!")
                return
            
            if not self.client_cnpj_var.get().strip():
                messagebox.showerror("Erro", "CNPJ/CPF √© obrigat√≥rio!")
                return
            
            # Preparar dados
            client_data = {
                'name': self.client_name_var.get().strip(),
                'cnpj_cpf': self.client_cnpj_var.get().strip(),
                'email': self.client_email_var.get().strip(),
                'phone': self.client_phone_var.get().strip(),
                'address': self.client_address_var.get().strip(),
                'contact_person': self.client_contact_var.get().strip(),
                'segment': self.client_segment_var.get().strip(),
                'credit_limit': float(self.client_credit_var.get() or 0)
            }
            
            # Salvar no banco
            client_id = self.db.create_client(**client_data)
            
            if client_id:
                messagebox.showinfo("Sucesso", "Cliente salvo com sucesso!")
                self.clear_client_form()
                self.load_clients()
            else:
                messagebox.showerror("Erro", "Erro ao salvar cliente!")
        
        except ValueError:
            messagebox.showerror("Erro", "Limite de cr√©dito deve ser um n√∫mero v√°lido!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar cliente: {e}")
    
    def clear_client_form(self):
        """Limpa o formul√°rio de cliente"""
        self.client_name_var.set("")
        self.client_cnpj_var.set("")
        self.client_email_var.set("")
        self.client_phone_var.set("")
        self.client_address_var.set("")
        self.client_contact_var.set("")
        self.client_segment_var.set("")
        self.client_credit_var.set("")
    
    def load_clients(self):
        """Carrega a lista de clientes"""
        try:
            # Limpar lista
            for item in self.clients_tree.get_children():
                self.clients_tree.delete(item)
            
            # Buscar clientes
            clients = self.db.get_clients()
            
            # Adicionar √† lista
            for client in clients:
                self.clients_tree.insert("", "end", values=(
                    client['id'],
                    client['name'],
                    client['cnpj_cpf'],
                    client['email'],
                    client['phone'],
                    client['segment'],
                    f"R$ {float(client['credit_limit']):,.2f}",
                    "Ativo" if client['is_active'] else "Inativo"
                ))
        
        except Exception as e:
            print(f"Erro ao carregar clientes: {e}")
    
    def on_client_select(self, event):
        """Evento de sele√ß√£o de cliente"""
        selection = self.clients_tree.selection()
        if selection:
            item = self.clients_tree.item(selection[0])
            values = item['values']
            
            # Preencher formul√°rio
            self.client_name_var.set(values[1])
            self.client_cnpj_var.set(values[2])
            self.client_email_var.set(values[3])
            self.client_phone_var.set(values[4])
            self.client_segment_var.set(values[5])
            self.client_credit_var.set(values[6].replace("R$ ", "").replace(",", ""))
    
    def delete_client(self):
        """Exclui um cliente"""
        selection = self.clients_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione um cliente para excluir!")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir este cliente?"):
            try:
                item = self.clients_tree.item(selection[0])
                client_id = item['values'][0]
                
                # Excluir do banco (soft delete)
                # self.db.delete_client(client_id)  # Implementar m√©todo
                
                messagebox.showinfo("Sucesso", "Cliente exclu√≠do com sucesso!")
                self.load_clients()
                self.clear_client_form()
            
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao excluir cliente: {e}")
    
    def open_new_client_window(self):
        """Abre janela para novo cliente"""
        self.clear_client_form()
        # Focar no primeiro campo
        # Implementar foco autom√°tico
    
    # M√©todos placeholder para outras abas
    def create_suppliers_management_tab(self, parent):
        """Cria a aba de gest√£o de fornecedores"""
        ttk.Label(parent, text="üè≠ Gest√£o de Fornecedores - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_receivables_management_tab(self, parent):
        """Cria a aba de contas a receber"""
        ttk.Label(parent, text="üì• Contas a Receber - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_payables_management_tab(self, parent):
        """Cria a aba de contas a pagar"""
        ttk.Label(parent, text="üì§ Contas a Pagar - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_invoices_management_tab(self, parent):
        """Cria a aba de faturas"""
        ttk.Label(parent, text="üßæ Gest√£o de Faturas - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_cashflow_management_tab(self, parent):
        """Cria a aba de fluxo de caixa"""
        ttk.Label(parent, text="üíº Fluxo de Caixa - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_budgets_management_tab(self, parent):
        """Cria a aba de or√ßamentos"""
        ttk.Label(parent, text="üìä Gest√£o de Or√ßamentos - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_enterprise_reports_tab(self, parent):
        """Cria a aba de relat√≥rios empresariais"""
        ttk.Label(parent, text="üìà Relat√≥rios Empresariais - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_finance_config_tab(self, parent):
        """Cria a aba de configura√ß√µes financeiras"""
        ttk.Label(parent, text="‚öôÔ∏è Configura√ß√µes Financeiras - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)

    # ============================================================================
    # M√âTODOS AUXILIARES PARA CONTAS A PAGAR E CONTAS A RECEBER
    # ============================================================================
    
    def load_receivables(self):
        """Carrega as contas a receber"""
        try:
            # Limpar treeview
            for item in self.receivables_tree.get_children():
                self.receivables_tree.delete(item)
            
            # Carregar dados (simulado por enquanto)
            receivables = self.get_receivables_data()
            
            for receivable in receivables:
                # Determinar cor baseada no status
                tags = ()
                if receivable['status'] == 'Vencido':
                    tags = ('overdue',)
                elif receivable['status'] == 'Pago':
                    tags = ('paid',)
                
                self.receivables_tree.insert("", "end", values=(
                    receivable['id'],
                    receivable['client'],
                    receivable['description'],
                    f"R$ {receivable['amount']:,.2f}",
                    receivable['due_date'],
                    receivable['status'],
                    receivable['created_date']
                ), tags=tags)
            
            # Atualizar estat√≠sticas
            self.update_receivables_stats()
            
        except Exception as e:
            print(f"Erro ao carregar contas a receber: {e}")
    
    def get_receivables_data(self):
        """Retorna dados simulados de contas a receber"""
        return [
            {
                'id': 1,
                'client': 'Cliente A',
                'description': 'Presta√ß√£o de servi√ßos',
                'amount': 1500.00,
                'due_date': '2024-01-15',
                'status': 'Pendente',
                'created_date': '2024-01-01'
            },
            {
                'id': 2,
                'client': 'Cliente B',
                'description': 'Venda de produtos',
                'amount': 2500.00,
                'due_date': '2024-01-10',
                'status': 'Vencido',
                'created_date': '2024-01-01'
            },
            {
                'id': 3,
                'client': 'Cliente C',
                'description': 'Consultoria',
                'amount': 800.00,
                'due_date': '2024-01-20',
                'status': 'Pago',
                'created_date': '2024-01-01'
            }
        ]
    
    def update_receivables_stats(self):
        """Atualiza as estat√≠sticas de contas a receber"""
        try:
            receivables = self.get_receivables_data()
            
            total = sum(r['amount'] for r in receivables)
            pending = sum(r['amount'] for r in receivables if r['status'] == 'Pendente')
            overdue = sum(r['amount'] for r in receivables if r['status'] == 'Vencido')
            paid = sum(r['amount'] for r in receivables if r['status'] == 'Pago')
            
            self.receivable_total_label.config(text=f"Total: R$ {total:,.2f}")
            self.receivable_pending_label.config(text=f"Pendente: R$ {pending:,.2f}")
            self.receivable_overdue_label.config(text=f"Vencido: R$ {overdue:,.2f}")
            self.receivable_paid_label.config(text=f"Pago: R$ {paid:,.2f}")
            
        except Exception as e:
            print(f"Erro ao atualizar estat√≠sticas: {e}")
    
    def filter_receivables(self):
        """Filtra as contas a receber"""
        try:
            status_filter = self.receivable_status_filter.get()
            client_filter = self.receivable_client_filter.get()
            due_filter = self.receivable_due_filter.get()
            
            # Implementar l√≥gica de filtro
            self.load_receivables()  # Recarregar com filtros
            
        except Exception as e:
            print(f"Erro ao filtrar contas a receber: {e}")
    
    def on_receivable_select(self, event):
        """Evento de sele√ß√£o de conta a receber"""
        selection = self.receivables_tree.selection()
        if selection:
            item = self.receivables_tree.item(selection[0])
            values = item['values']
            
            # Abrir janela de edi√ß√£o
            self.open_edit_receivable_window(values[0])
    
    def open_new_receivable_window(self):
        """Abre janela para nova conta a receber"""
        self.open_receivable_form_window()
    
    def open_edit_receivable_window(self, receivable_id):
        """Abre janela para editar conta a receber"""
        self.open_receivable_form_window(receivable_id)
    
    def open_receivable_form_window(self, receivable_id=None):
        """Abre janela de formul√°rio para conta a receber"""
        # Criar janela
        form_window = tk.Toplevel(self.root)
        form_window.title("Nova Conta a Receber" if receivable_id is None else "Editar Conta a Receber")
        form_window.geometry("500x600")
        form_window.resizable(False, False)
        form_window.transient(self.root)
        form_window.grab_set()
        
        # Centralizar janela
        form_window.update_idletasks()
        x = (form_window.winfo_screenwidth() // 2) - (500 // 2)
        y = (form_window.winfo_screenheight() // 2) - (600 // 2)
        form_window.geometry(f"500x600+{x}+{y}")
        
        # Frame principal
        main_frame = ttk.Frame(form_window, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title = "Nova Conta a Receber" if receivable_id is None else "Editar Conta a Receber"
        ttk.Label(main_frame, text=title, font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Formul√°rio
        form_frame = ttk.Frame(main_frame)
        form_frame.pack(fill=tk.BOTH, expand=True)
        
        # Cliente
        ttk.Label(form_frame, text="Cliente:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        client_var = tk.StringVar()
        client_combo = ttk.Combobox(form_frame, textvariable=client_var, state="readonly", width=30)
        client_combo['values'] = ["Cliente A", "Cliente B", "Cliente C"]
        client_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        
        # Descri√ß√£o
        ttk.Label(form_frame, text="Descri√ß√£o:").grid(row=1, column=0, sticky="w", padx=5, pady=5)
        description_var = tk.StringVar()
        description_entry = ttk.Entry(form_frame, textvariable=description_var, width=30)
        description_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        
        # Valor
        ttk.Label(form_frame, text="Valor:").grid(row=2, column=0, sticky="w", padx=5, pady=5)
        amount_var = tk.StringVar()
        amount_entry = ttk.Entry(form_frame, textvariable=amount_var, width=30)
        amount_entry.grid(row=2, column=1, sticky="ew", padx=5, pady=5)
        
        # Data de vencimento
        ttk.Label(form_frame, text="Vencimento:").grid(row=3, column=0, sticky="w", padx=5, pady=5)
        due_date_var = tk.StringVar()
        due_date_entry = ttk.Entry(form_frame, textvariable=due_date_var, width=30)
        due_date_entry.grid(row=3, column=1, sticky="ew", padx=5, pady=5)
        
        # Status
        ttk.Label(form_frame, text="Status:").grid(row=4, column=0, sticky="w", padx=5, pady=5)
        status_var = tk.StringVar()
        status_combo = ttk.Combobox(form_frame, textvariable=status_var, 
                                  values=["Pendente", "Pago", "Vencido", "Cancelado"],
                                  state="readonly", width=30)
        status_combo.set("Pendente")
        status_combo.grid(row=4, column=1, sticky="ew", padx=5, pady=5)
        
        # Observa√ß√µes
        ttk.Label(form_frame, text="Observa√ß√µes:").grid(row=5, column=0, sticky="w", padx=5, pady=5)
        notes_text = tk.Text(form_frame, height=4, width=30)
        notes_text.grid(row=5, column=1, sticky="ew", padx=5, pady=5)
        
        # Configurar grid
        form_frame.columnconfigure(1, weight=1)
        
        # Bot√µes
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X, pady=(20, 0))
        
        ttk.Button(buttons_frame, text="Salvar", 
                  command=lambda: self.save_receivable(form_window, receivable_id)).pack(side=tk.RIGHT, padx=5)
        ttk.Button(buttons_frame, text="Cancelar", 
                  command=form_window.destroy).pack(side=tk.RIGHT, padx=5)
        
        # Focar no primeiro campo
        client_combo.focus()
    
    def save_receivable(self, window, receivable_id=None):
        """Salva a conta a receber"""
        try:
            # Implementar l√≥gica de salvamento
            messagebox.showinfo("Sucesso", "Conta a receber salva com sucesso!")
            window.destroy()
            self.load_receivables()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar conta a receber: {e}")
    
    def delete_receivable(self):
        """Exclui uma conta a receber"""
        selection = self.receivables_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma conta a receber para excluir!")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir esta conta a receber?"):
            try:
                # Implementar l√≥gica de exclus√£o
                messagebox.showinfo("Sucesso", "Conta a receber exclu√≠da com sucesso!")
                self.load_receivables()
                
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao excluir conta a receber: {e}")
    
    def load_payables(self):
        """Carrega as contas a pagar"""
        try:
            # Limpar treeview
            for item in self.payables_tree.get_children():
                self.payables_tree.delete(item)
            
            # Carregar dados (simulado por enquanto)
            payables = self.get_payables_data()
            
            for payable in payables:
                # Determinar cor baseada no status
                tags = ()
                if payable['status'] == 'Vencido':
                    tags = ('overdue',)
                elif payable['status'] == 'Pago':
                    tags = ('paid',)
                
                self.payables_tree.insert("", "end", values=(
                    payable['id'],
                    payable['supplier'],
                    payable['description'],
                    f"R$ {payable['amount']:,.2f}",
                    payable['due_date'],
                    payable['status'],
                    payable['created_date']
                ), tags=tags)
            
            # Atualizar estat√≠sticas
            self.update_payables_stats()
            
        except Exception as e:
            print(f"Erro ao carregar contas a pagar: {e}")
    
    def get_payables_data(self):
        """Retorna dados simulados de contas a pagar"""
        return [
            {
                'id': 1,
                'supplier': 'Fornecedor A',
                'description': 'Compra de materiais',
                'amount': 800.00,
                'due_date': '2024-01-20',
                'status': 'Pendente',
                'created_date': '2024-01-01'
            },
            {
                'id': 2,
                'supplier': 'Fornecedor B',
                'description': 'Servi√ßos de manuten√ß√£o',
                'amount': 1200.00,
                'due_date': '2024-01-12',
                'status': 'Vencido',
                'created_date': '2024-01-01'
            },
            {
                'id': 3,
                'supplier': 'Fornecedor C',
                'description': 'Aluguel',
                'amount': 1500.00,
                'due_date': '2024-01-05',
                'status': 'Pago',
                'created_date': '2024-01-01'
            }
        ]
    
    def update_payables_stats(self):
        """Atualiza as estat√≠sticas de contas a pagar"""
        try:
            payables = self.get_payables_data()
            
            total = sum(p['amount'] for p in payables)
            pending = sum(p['amount'] for p in payables if p['status'] == 'Pendente')
            overdue = sum(p['amount'] for p in payables if p['status'] == 'Vencido')
            paid = sum(p['amount'] for p in payables if p['status'] == 'Pago')
            
            self.payable_total_label.config(text=f"Total: R$ {total:,.2f}")
            self.payable_pending_label.config(text=f"Pendente: R$ {pending:,.2f}")
            self.payable_overdue_label.config(text=f"Vencido: R$ {overdue:,.2f}")
            self.payable_paid_label.config(text=f"Pago: R$ {paid:,.2f}")
            
        except Exception as e:
            print(f"Erro ao atualizar estat√≠sticas: {e}")
    
    def filter_payables(self):
        """Filtra as contas a pagar"""
        try:
            status_filter = self.payable_status_filter.get()
            supplier_filter = self.payable_supplier_filter.get()
            due_filter = self.payable_due_filter.get()
            
            # Implementar l√≥gica de filtro
            self.load_payables()  # Recarregar com filtros
            
        except Exception as e:
            print(f"Erro ao filtrar contas a pagar: {e}")
    
    def on_payable_select(self, event):
        """Evento de sele√ß√£o de conta a pagar"""
        selection = self.payables_tree.selection()
        if selection:
            item = self.payables_tree.item(selection[0])
            values = item['values']
            
            # Abrir janela de edi√ß√£o
            self.open_edit_payable_window(values[0])
    
    def open_new_payable_window(self):
        """Abre janela para nova conta a pagar"""
        self.open_payable_form_window()
    
    def open_edit_payable_window(self, payable_id):
        """Abre janela para editar conta a pagar"""
        self.open_payable_form_window(payable_id)
    
    def open_payable_form_window(self, payable_id=None):
        """Abre janela de formul√°rio para conta a pagar"""
        # Criar janela
        form_window = tk.Toplevel(self.root)
        form_window.title("Nova Conta a Pagar" if payable_id is None else "Editar Conta a Pagar")
        form_window.geometry("500x600")
        form_window.resizable(False, False)
        form_window.transient(self.root)
        form_window.grab_set()
        
        # Centralizar janela
        form_window.update_idletasks()
        x = (form_window.winfo_screenwidth() // 2) - (500 // 2)
        y = (form_window.winfo_screenheight() // 2) - (600 // 2)
        form_window.geometry(f"500x600+{x}+{y}")
        
        # Frame principal
        main_frame = ttk.Frame(form_window, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title = "Nova Conta a Pagar" if payable_id is None else "Editar Conta a Pagar"
        ttk.Label(main_frame, text=title, font=("Arial", 16, "bold")).pack(pady=(0, 20))
        
        # Formul√°rio
        form_frame = ttk.Frame(main_frame)
        form_frame.pack(fill=tk.BOTH, expand=True)
        
        # Fornecedor
        ttk.Label(form_frame, text="Fornecedor:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        supplier_var = tk.StringVar()
        supplier_combo = ttk.Combobox(form_frame, textvariable=supplier_var, state="readonly", width=30)
        supplier_combo['values'] = ["Fornecedor A", "Fornecedor B", "Fornecedor C"]
        supplier_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        
        # Descri√ß√£o
        ttk.Label(form_frame, text="Descri√ß√£o:").grid(row=1, column=0, sticky="w", padx=5, pady=5)
        description_var = tk.StringVar()
        description_entry = ttk.Entry(form_frame, textvariable=description_var, width=30)
        description_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        
        # Valor
        ttk.Label(form_frame, text="Valor:").grid(row=2, column=0, sticky="w", padx=5, pady=5)
        amount_var = tk.StringVar()
        amount_entry = ttk.Entry(form_frame, textvariable=amount_var, width=30)
        amount_entry.grid(row=2, column=1, sticky="ew", padx=5, pady=5)
        
        # Data de vencimento
        ttk.Label(form_frame, text="Vencimento:").grid(row=3, column=0, sticky="w", padx=5, pady=5)
        due_date_var = tk.StringVar()
        due_date_entry = ttk.Entry(form_frame, textvariable=due_date_var, width=30)
        due_date_entry.grid(row=3, column=1, sticky="ew", padx=5, pady=5)
        
        # Status
        ttk.Label(form_frame, text="Status:").grid(row=4, column=0, sticky="w", padx=5, pady=5)
        status_var = tk.StringVar()
        status_combo = ttk.Combobox(form_frame, textvariable=status_var, 
                                  values=["Pendente", "Pago", "Vencido", "Cancelado"],
                                  state="readonly", width=30)
        status_combo.set("Pendente")
        status_combo.grid(row=4, column=1, sticky="ew", padx=5, pady=5)
        
        # Observa√ß√µes
        ttk.Label(form_frame, text="Observa√ß√µes:").grid(row=5, column=0, sticky="w", padx=5, pady=5)
        notes_text = tk.Text(form_frame, height=4, width=30)
        notes_text.grid(row=5, column=1, sticky="ew", padx=5, pady=5)
        
        # Configurar grid
        form_frame.columnconfigure(1, weight=1)
        
        # Bot√µes
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X, pady=(20, 0))
        
        ttk.Button(buttons_frame, text="Salvar", 
                  command=lambda: self.save_payable(form_window, payable_id)).pack(side=tk.RIGHT, padx=5)
        ttk.Button(buttons_frame, text="Cancelar", 
                  command=form_window.destroy).pack(side=tk.RIGHT, padx=5)
        
        # Focar no primeiro campo
        supplier_combo.focus()
    
    def save_payable(self, window, payable_id=None):
        """Salva a conta a pagar"""
        try:
            # Implementar l√≥gica de salvamento
            messagebox.showinfo("Sucesso", "Conta a pagar salva com sucesso!")
            window.destroy()
            self.load_payables()
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar conta a pagar: {e}")
    
    def delete_payable(self):
        """Exclui uma conta a pagar"""
        selection = self.payables_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione uma conta a pagar para excluir!")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir esta conta a pagar?"):
            try:
                # Implementar l√≥gica de exclus√£o
                messagebox.showinfo("Sucesso", "Conta a pagar exclu√≠da com sucesso!")
                self.load_payables()
                
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao excluir conta a pagar: {e}")

if __name__ == "__main__":
    try:
        # Sistema de controle de concorr√™ncia para o banco de dados
        print("üîí Iniciando controle de concorr√™ncia do banco de dados...")
        db_control = DatabaseConcurrencyControl('boodesk_new.db')
        
        # Tentar adquirir lock do banco
        if not db_control.acquire_lock(timeout=30):
            print("‚ùå N√£o foi poss√≠vel adquirir lock do banco de dados")
            print("üí° Verifique se h√° outras inst√¢ncias do app rodando")
            messagebox.showerror("Erro", "N√£o foi poss√≠vel acessar o banco de dados.\nVerifique se h√° outras inst√¢ncias do app rodando.")
            sys.exit(1)
        
        print("‚úÖ Lock do banco adquirido com sucesso")
        
        # Determine base_dir for icons
        if getattr(sys, 'frozen', False):
            base_dir = sys._MEIPASS
        else:
            base_dir = os.path.dirname(os.path.abspath(__file__))

        root = ThemedTk(theme="aquativo")
        
        # Configure main window to start maximized
        try:
            root.state('zoomed')  # Maximize the window on Windows
        except:
            try:
                root.attributes('-zoomed', True)  # Alternative for some Linux systems
            except:
                # Fallback: maximize using geometry
                root.update_idletasks()
                screen_width = root.winfo_screenwidth()
                screen_height = root.winfo_screenheight()
                root.geometry(f"{screen_width}x{screen_height}+0+0")
        
        root.resizable(True, True)  # Permitir redimensionamento
        
        # Load icons AFTER the root window is created
        app_icons = load_app_icons(base_dir)

        # Criar aplica√ß√£o sem usu√°rio inicial
        print("DEBUG: Criando aplica√ß√£o...")
        app = BoodeskApp(root, None, app_icons)
        root.app = app
        
        # Configurar protocolo de fechamento
        def on_closing_with_lock():
            """Handler de fechamento que libera o lock do banco"""
            try:
                print("üîì Liberando lock do banco de dados (fechamento)...")
                db_control.release_lock()
            except:
                pass
            app.on_closing()
        
        root.protocol("WM_DELETE_WINDOW", on_closing_with_lock)
        
        print("DEBUG: Aplica√ß√£o criada com sucesso")
        
        # Configurar sistema de login
        root.login_successful = False
        root.current_user = None
        print("DEBUG: Sistema de login configurado")
        
        # Criar janela de login de forma mais direta
        print("DEBUG: Criando janela de login...")
        
        # Criar uma janela de login simples e robusta
        login_window = tk.Toplevel()
        login_window.title("Login - Sistema Boodesk")
        login_window.geometry("450x400")
        login_window.resizable(False, False)
        
        # Centralizar na tela
        login_window.update_idletasks()
        x = (login_window.winfo_screenwidth() - 450) // 2
        y = (login_window.winfo_screenheight() - 400) // 2
        login_window.geometry(f"450x400+{x}+{y}")
        
        # For√ßar exibi√ß√£o
        login_window.lift()
        login_window.focus_force()
        login_window.deiconify()
        login_window.update()
        
        # Ocultar janela principal ap√≥s criar a janela de login
        root.withdraw()
        print("DEBUG: Janela principal ocultada")
        
        # Criar widgets b√°sicos
        frame = ttk.Frame(login_window, padding="20")
        frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        ttk.Label(frame, text="Login - Sistema Boodesk", font=("Arial", 16, "bold")).pack(pady=20)
        
        # Campo de usu√°rio com √≠cone
        user_frame = ttk.Frame(frame)
        user_frame.pack(fill=tk.X, pady=5)
        ttk.Label(user_frame, text="üë§ Usu√°rio:", font=("Arial", 10, "bold")).pack(anchor=tk.W)
        user_entry = ttk.Entry(user_frame, width=30, font=("Arial", 11))
        user_entry.pack(fill=tk.X, pady=5)
        user_entry.insert(0, "admin")  # Preencher com admin por padr√£o
        
        # Campo de senha com √≠cone
        pass_frame = ttk.Frame(frame)
        pass_frame.pack(fill=tk.X, pady=5)
        ttk.Label(pass_frame, text="üîí Senha:", font=("Arial", 10, "bold")).pack(anchor=tk.W)
        pass_entry = ttk.Entry(pass_frame, show="*", width=30, font=("Arial", 11))
        pass_entry.pack(fill=tk.X, pady=5)
        
        # Frame dos bot√µes
        button_frame = ttk.Frame(frame)
        button_frame.pack(fill=tk.X, pady=20)
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        
        def do_login():
            username = user_entry.get().strip()
            password = pass_entry.get()
            print(f"DEBUG: Tentativa de login - Usu√°rio: '{username}', Senha: '{password}'")
            
            if username and password:
                # Verificar se o usu√°rio existe no banco de dados
                try:
                    # Usar o banco de dados em vez do arquivo XLSX
                    user_data = app.db.get_user_by_username(username)
                    print(f"DEBUG: Usu√°rio encontrado no banco: {user_data is not None}")
                    
                    if user_data and user_data['password_hash'] == password:
                        # Verificar se o usu√°rio tem membro associado
                        if 'member_id' in user_data and user_data['member_id']:
                            # Criar usu√°rio manualmente
                            user = User(
                                username=user_data['username'],
                                role=user_data['role'],
                                cargo=user_data.get('cargo', 'Usu√°rio') if hasattr(user_data, 'get') else user_data['cargo'],
                                user_id=user_data.get('id', 1) if hasattr(user_data, 'get') else user_data['id']
                            )
                            user.is_authenticated = True
                            user.login_time = pd.Timestamp.now()
                            
                            root.login_successful = True
                            root.current_user = user
                            print(f"DEBUG: Login bem-sucedido para {username}")
                            login_window.destroy()
                        else:
                            print(f"DEBUG: Usu√°rio {username} n√£o tem membro associado")
                            messagebox.showerror("Erro", "Usu√°rio n√£o tem membro associado. Contate o administrador.")
                    else:
                        print(f"DEBUG: Usu√°rio n√£o encontrado ou senha incorreta")
                        messagebox.showerror("Erro", "Usu√°rio ou senha incorretos!")
                except Exception as e:
                    print(f"DEBUG: Erro no login: {e}")
                    messagebox.showerror("Erro", f"Erro no sistema de login: {e}")
            else:
                messagebox.showerror("Erro", "Preencha todos os campos!")
        
        def cancel():
            root.login_successful = False
            login_window.destroy()
        
        # Bot√µes com √≠cones
        ttk.Button(button_frame, text="üîê Entrar", command=do_login).grid(row=0, column=0, padx=5, sticky="ew")
        ttk.Button(button_frame, text="üìù Cadastrar", command=lambda: messagebox.showinfo("Info", "Funcionalidade de cadastro ser√° implementada")).grid(row=0, column=1, padx=5, sticky="ew")
        ttk.Button(button_frame, text="üö™ Sair", command=cancel).grid(row=0, column=2, padx=5, sticky="ew")
        
        # Funcionalidade de Enter e Tab
        def on_user_enter(event):
            pass_entry.focus()
            return "break"
        
        def on_pass_enter(event):
            do_login()
            return "break"
        
        def on_user_tab(event):
            pass_entry.focus()
            return "break"
        
        def on_pass_tab(event):
            user_entry.focus()
            return "break"
        
        user_entry.bind("<Return>", on_user_enter)
        user_entry.bind("<Tab>", on_user_tab)
        pass_entry.bind("<Return>", on_pass_enter)
        pass_entry.bind("<Tab>", on_pass_tab)
        
        # Focar no campo de usu√°rio
        user_entry.focus()
        
        # For√ßar exibi√ß√£o novamente ap√≥s criar widgets
        login_window.after(100, lambda: login_window.lift())
        login_window.after(200, lambda: login_window.focus_force())
        login_window.after(300, lambda: login_window.deiconify())
        
        print("DEBUG: Aguardando fechamento da janela de login...")
        try:
            root.wait_window(login_window)
            print("DEBUG: Janela de login fechada")
        except Exception as e:
            print(f"DEBUG: Erro ao aguardar janela de login: {e}")
            root.destroy()
        
        # Verificar se o login foi bem-sucedido
        print(f"DEBUG: login_successful = {root.login_successful}")
        print(f"DEBUG: current_user = {root.current_user}")
        
        if root.login_successful and root.current_user:
            print("DEBUG: Login bem-sucedido, configurando usu√°rio...")
            # Configurar usu√°rio na aplica√ß√£o
            app.current_user = root.current_user
            app.apply_role_permissions()
            
            # Adicionar m√©todo _get_current_user_member √† inst√¢ncia
            def _get_current_user_member(self):
                """Retorna o nome do membro associado ao usuario logado"""
                try:
                    if not self.current_user:
                        return None
                    
                    username = self.current_user.username
                    
                    # Buscar o usu√°rio no PostgreSQL
                    user_data = self.db.get_user_by_username(username)
                    
                    if user_data and user_data.get('member_id'):
                        member_id = user_data['member_id']
                        # Buscar o nome do membro usando o member_id
                        members = self.db.get_all_members()
                        for member in members:
                            if member['id'] == member_id:
                                member_name = member['name']
                                print(f"DEBUG: Usuario {username} associado ao membro {member_name}")
                                return member_name
                    
                    print(f"DEBUG: Usu√°rio {username} n√£o tem membro associado")
                    return None
                    
                except Exception as e:
                    print(f"DEBUG: Erro ao buscar membro do usu√°rio: {e}")
                    return None
            
            # Adicionar o m√©todo √† inst√¢ncia
            import types
            app._get_current_user_member = types.MethodType(_get_current_user_member, app)
            
            # Inicializar displays ap√≥s todos os m√©todos serem definidos
            print("DEBUG: Chamando update_all_displays")
            app.update_all_displays()
            print("DEBUG: update_all_displays conclu√≠do")
            
            # Aplicar tema salvo nas configura√ß√µes
            # Aplicar tema salvo nas configura√ß√µes com isolamento por usu√°rio
            try:
                # Carregar tema espec√≠fico do usu√°rio do banco de dados
                user_id = app.get_current_user_id()
                saved_theme = "aquativo"  # Tema padr√£o
                
                if user_id and hasattr(app, 'db') and app.db:
                    try:
                        # Buscar tema do usu√°rio no banco
                        db_theme = app.db.get_setting('theme', user_id=user_id)
                        if db_theme:
                            saved_theme = db_theme
                            print(f"DEBUG: Tema carregado do banco para usu√°rio {user_id}: {saved_theme}")
                        else:
                            print(f"DEBUG: Nenhum tema encontrado no banco para usu√°rio {user_id}, usando padr√£o")
                    except Exception as db_error:
                        print(f"DEBUG: Erro ao carregar tema do banco: {db_error}")
                else:
                    print("DEBUG: Usando tema padr√£o (usu√°rio n√£o identificado ou banco indispon√≠vel)")
                
                # Verificar se o tema existe na lista de temas dispon√≠veis
                available_themes = app.root.get_themes()
                if saved_theme not in available_themes:
                    print(f"‚ö†Ô∏è Tema '{saved_theme}' n√£o dispon√≠vel, usando 'aquativo'")
                    saved_theme = 'aquativo'
                
                # Atualizar configura√ß√µes com o tema carregado
                app.settings['theme'] = saved_theme
                
                print(f"DEBUG: Aplicando tema: {saved_theme}")
                app.root.set_theme(saved_theme)
                
                # For√ßar atualiza√ß√£o da interface ap√≥s aplicar o tema
                app.root.update_idletasks()
                app.root.update()
                
                print("DEBUG: Tema aplicado com sucesso")
            except Exception as e:
                print(f"DEBUG: Erro ao aplicar tema: {e}")
                # Fallback para tema padr√£o
                try:
                    app.root.set_theme('aquativo')
                    print("DEBUG: Tema padr√£o aplicado como fallback")
                except:
                    print("DEBUG: Erro ao aplicar tema padr√£o")
            app.show_dashboard_for_admin()
            
            # Mostrar aplica√ß√£o principal
            print("DEBUG: Mostrando aplica√ß√£o principal...")
            root.deiconify()
            
            # Maximizar a janela principal
            try:
                root.state('zoomed')  # Windows
                print("DEBUG: Janela maximizada (Windows)")
            except:
                try:
                    root.attributes('-zoomed', True)  # Linux
                    print("DEBUG: Janela maximizada (Linux)")
                except:
                    # Fallback: maximizar usando geometry
                    root.update_idletasks()
                    screen_width = root.winfo_screenwidth()
                    screen_height = root.winfo_screenheight()
                    root.geometry(f"{screen_width}x{screen_height}+0+0")
                    print("DEBUG: Janela maximizada (Fallback)")
            
            # Mostrar notifica√ß√µes AP√ìS o login
            root.after(1000, app.show_deadline_notifications)
            
            root.mainloop()
        else:
            print("DEBUG: Login cancelado ou falhou, fechando aplica√ß√£o...")
            # Login cancelado ou falhou
            root.destroy()
        
        # Liberar lock do banco ao sair
        print("üîì Liberando lock do banco de dados...")
        db_control.release_lock()
            
    except Exception as e:
        import traceback
        error_msg = f"Ocorreu um erro inesperado: {e}\n\nDetalhes t√©cnicos:\n{traceback.format_exc()}"
        print(f"DEBUG: Erro completo: {error_msg}")
        messagebox.showerror("Erro Inesperado", f"Ocorreu um erro inesperado: {e}")
        
        # Liberar lock do banco em caso de erro
        try:
            print("üîì Liberando lock do banco de dados (erro)...")
            db_control.release_lock()
        except:
            pass
        
        # Tentar fechar a aplica√ß√£o de forma limpa
        try:
            root.destroy()
        except:
            pass

# ============================================================================
# MELHORIAS IMPLEMENTADAS - SISTEMA DE FILTRO INTELIGENTE E NOTIFICA√á√ïES
# ============================================================================

def get_boards_for_member(self, member_name):
    """Retorna apenas os quadros onde o membro participa de cards"""
    boards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards in board_data.items():
            if list_name == 'workflow':  # Ignorar metadados
                continue
            for card in cards:
                if member_name in card.get('members', []):
                    boards.append(board_name)
                    break  # Uma vez encontrado, n√£o precisa verificar mais cards
    return list(set(boards))  # Remove duplicatas

def _should_show_board_for_user_improved(self, board_name, current_user_member):
    """Vers√£o melhorada do filtro de quadros"""
    # Administradores veem todos os quadros
    if hasattr(self, 'current_user') and getattr(self.current_user, 'role', None) == 'admin':
        return True
    
    # Se n√£o h√° membro associado, mostrar apenas quadros principais
    if not current_user_member:
        return board_name in ["Quadro Principal", "Quadro Geral"]
    
    # Verificar se o membro participa de algum card no quadro
    board_data = self.boodesk_data.get("boards", {}).get(board_name, {})
    if isinstance(board_data, dict):
        for list_name, cards in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards:
                if current_user_member in card.get('members', []):
                    return True
    
    # Quadros especiais sempre vis√≠veis
    if board_name in ["Quadro Principal", "Quadro Geral"]:
        return True
    
    return False

def notify_member_added_to_card(self, card_id, member_name, added_by):
    """Notifica membro quando adicionado a um card"""
    card = self.get_card_by_id(card_id)
    if not card:
        return
    
    notification = {
        'type': 'member_added',
        'card_title': card['title'],
        'card_id': card_id,
        'member': member_name,
        'added_by': added_by,
        'board': card.get('board_name', ''),
        'list': card.get('list_name', ''),
        'timestamp': datetime.now().isoformat(),
        'read': False
    }
    
    # Salvar notifica√ß√£o no banco
    self.save_notification(notification)
    
    # Mostrar notifica√ß√£o na interface
    self.show_notification_popup(notification)

def show_notification_popup(self, notification):
    """Mostra popup de notifica√ß√£o"""
    popup = tk.Toplevel(self.root)
    popup.title("Nova Notifica√ß√£o")
    popup.geometry("400x200")
    
    message = f"Voc√™ foi adicionado ao card:\n'{notification['card_title']}'\n\nQuadro: {notification['board']}\nLista: {notification['list']}"
    
    ttk.Label(popup, text=message, wraplength=350).pack(pady=20)
    ttk.Button(popup, text="Ver Card", command=lambda: self.open_card(notification['card_id'])).pack(pady=10)
    ttk.Button(popup, text="Fechar", command=popup.destroy).pack(pady=5)

def save_notification(self, notification):
    """Salva notifica√ß√£o no banco de dados"""
    try:
        conn = supabase_config.get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO notifications (type, card_title, card_id, member, added_by, board, list_name, timestamp, read_status)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            notification['type'],
            notification['card_title'],
            notification['card_id'],
            notification['member'],
            notification['added_by'],
            notification['board'],
            notification['list'],
            notification['timestamp'],
            notification['read']
        ))
        
        conn.commit()
        conn.close()
        print(f"‚úÖ Notifica√ß√£o salva para {notification['member']}")
    except Exception as e:
        print(f"‚ùå Erro ao salvar notifica√ß√£o: {e}")

def create_member_dashboard(self, member_name):
    """Cria dashboard personalizado para o membro"""
    dashboard = {
        'my_cards': self.get_cards_by_member(member_name),
        'my_boards': self.get_boards_for_member(member_name),
        'pending_tasks': self.get_pending_tasks(member_name),
        'completed_tasks': self.get_completed_tasks(member_name),
        'recent_activities': self.get_recent_activities(member_name),
        'upcoming_deadlines': self.get_upcoming_deadlines(member_name)
    }
    return dashboard

def get_cards_by_member(self, member_name):
    """Retorna todos os cards onde o membro participa"""
    cards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards_list in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards_list:
                if member_name in card.get('members', []):
                    card['board_name'] = board_name
                    card['list_name'] = list_name
                    cards.append(card)
    return cards

def get_pending_tasks(self, member_name):
    """Retorna tarefas pendentes do membro"""
    return [card for card in self.get_cards_by_member(member_name) 
            if card.get('status') != 'done']

def get_completed_tasks(self, member_name, days=30):
    """Retorna tarefas completadas nos √∫ltimos X dias"""
    cutoff_date = datetime.now() - timedelta(days=days)
    completed = []
    for card in self.get_cards_by_member(member_name):
        if card.get('status') == 'done':
            completed_date = card.get('completed_at')
            if completed_date and completed_date > cutoff_date:
                completed.append(card)
    return completed

def get_upcoming_deadlines(self, member_name, days=7):
    """Retorna prazos pr√≥ximos do membro"""
    cutoff_date = datetime.now() + timedelta(days=days)
    upcoming = []
    for card in self.get_cards_by_member(member_name):
        deadline = card.get('deadline')
        if deadline and deadline <= cutoff_date and card.get('status') != 'done':
            upcoming.append(card)
    return upcoming

def log_activity(self, action, user, card_id=None, details=None):
    """Registra atividade no sistema"""
    activity = {
        'id': str(uuid.uuid4()),
        'action': action,
        'user': user,
        'card_id': card_id,
        'details': details,
        'timestamp': datetime.now().isoformat()
    }
    
    # Salvar no banco
    self.save_activity(activity)
    
    # Atualizar interface se necess√°rio
    self.update_activity_display()

def save_activity(self, activity):
    """Salva atividade no banco de dados"""
    try:
        conn = supabase_config.get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO activities (id, action, user, card_id, details, timestamp)
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (
            activity['id'],
            activity['action'],
            activity['user'],
            activity['card_id'],
            activity['details'],
            activity['timestamp']
        ))
        
        conn.commit()
        conn.close()
        print(f"‚úÖ Atividade registrada: {activity['action']}")
    except Exception as e:
        print(f"‚ùå Erro ao salvar atividade: {e}")

def get_recent_activities(self, member_name, limit=10):
    """Retorna atividades recentes relacionadas ao membro"""
    try:
        conn = supabase_config.get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT action, details, timestamp FROM activities 
            WHERE user = %s OR details LIKE %s
            ORDER BY timestamp DESC LIMIT %s
        """, (member_name, f"%{member_name}%", limit))
        
        activities = cursor.fetchall()
        conn.close()
        
        return [{'action': a[0], 'details': a[1], 'timestamp': a[2]} for a in activities]
    except Exception as e:
        print(f"‚ùå Erro ao buscar atividades: {e}")
        return []

def update_activity_display(self):
    """Atualiza display de atividades na interface"""
    if hasattr(self, 'activity_frame'):
        # Limpar frame atual
        for widget in self.activity_frame.winfo_children():
            widget.destroy()
        
        # Obter atividades do usu√°rio atual
        current_user_member = self._get_current_user_member()
        activities = self.get_recent_activities(current_user_member, 5)
        
        # Criar lista de atividades
        for activity in activities:
            activity_text = f"{activity['action']} - {activity['timestamp']}"
            ttk.Label(self.activity_frame, text=activity_text).pack(anchor='w')

def get_member_metrics(self, member_name, period='month'):
    """Calcula m√©tricas de produtividade do membro"""
    start_date = self.get_period_start_date(period)
    
    metrics = {
        'cards_created': len(self.get_cards_created_by(member_name, start_date)),
        'cards_completed': len(self.get_cards_completed_by(member_name, start_date)),
        'average_completion_time': self.get_avg_completion_time(member_name, start_date),
        'productivity_score': self.calculate_productivity_score(member_name, start_date),
        'on_time_completion_rate': self.get_on_time_completion_rate(member_name, start_date),
        'active_boards': len(self.get_boards_for_member(member_name))
    }
    return metrics

def get_period_start_date(self, period):
    """Retorna data de in√≠cio do per√≠odo"""
    now = datetime.now()
    if period == 'week':
        return now - timedelta(days=7)
    elif period == 'month':
        return now - timedelta(days=30)
    elif period == 'quarter':
        return now - timedelta(days=90)
    else:
        return now - timedelta(days=365)

def get_cards_created_by(self, member_name, start_date):
    """Retorna cards criados pelo membro desde uma data"""
    cards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards_list in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards_list:
                if card.get('created_by') == member_name:
                    created_date = card.get('created_at')
                    if created_date and created_date >= start_date:
                        cards.append(card)
    return cards

def get_cards_completed_by(self, member_name, start_date):
    """Retorna cards completados pelo membro desde uma data"""
    cards = []
    for board_name, board_data in self.boodesk_data['boards'].items():
        for list_name, cards_list in board_data.items():
            if list_name == 'workflow':
                continue
            for card in cards_list:
                if member_name in card.get('members', []) and card.get('status') == 'done':
                    completed_date = card.get('completed_at')
                    if completed_date and completed_date >= start_date:
                        cards.append(card)
    return cards

def get_avg_completion_time(self, member_name, start_date):
    """Calcula tempo m√©dio de conclus√£o"""
    completed_cards = self.get_cards_completed_by(member_name, start_date)
    if not completed_cards:
        return 0
    
    total_time = 0
    for card in completed_cards:
        created = card.get('created_at')
        completed = card.get('completed_at')
        if created and completed:
            try:
                created_dt = datetime.fromisoformat(created)
                completed_dt = datetime.fromisoformat(completed)
                total_time += (completed_dt - created_dt).total_seconds() / 3600  # em horas
            except:
                pass
    
    return total_time / len(completed_cards) if completed_cards else 0

def get_on_time_completion_rate(self, member_name, start_date):
    """Calcula taxa de conclus√£o no prazo"""
    completed_cards = self.get_cards_completed_by(member_name, start_date)
    if not completed_cards:
        return 0
    
    on_time_count = 0
    for card in completed_cards:
        deadline = card.get('deadline')
        completed = card.get('completed_at')
        if deadline and completed:
            try:
                deadline_dt = datetime.fromisoformat(deadline)
                completed_dt = datetime.fromisoformat(completed)
                if completed_dt <= deadline_dt:
                    on_time_count += 1
            except:
                pass
    
    return on_time_count / len(completed_cards) if completed_cards else 0

def calculate_productivity_score(self, member_name, start_date):
    """Calcula score de produtividade (0-100)"""
    completed = len(self.get_cards_completed_by(member_name, start_date))
    total_assigned = len(self.get_cards_by_member(member_name))
    
    if total_assigned == 0:
        return 0
    
    on_time_rate = self.get_on_time_completion_rate(member_name, start_date)
    completion_rate = completed / total_assigned
    
    # Score baseado em conclus√£o e pontualidade
    score = (completion_rate * 0.7 + on_time_rate * 0.3) * 100
    return min(100, max(0, score))

def generate_member_report(self, member_name, period='month'):
    """Gera relat√≥rio completo do membro"""
    metrics = self.get_member_metrics(member_name, period)
    cards = self.get_cards_by_member(member_name)
    
    report = {
        'member': member_name,
        'period': period,
        'metrics': metrics,
        'cards_summary': {
            'total': len(cards),
            'pending': len([c for c in cards if c.get('status') != 'done']),
            'completed': len([c for c in cards if c.get('status') == 'done']),
            'overdue': len([c for c in cards if self.is_card_overdue(c)])
        },
        'boards_participation': self.get_boards_for_member(member_name),
        'recent_activities': self.get_recent_activities(member_name, 10)
    }
    
    return report

def is_card_overdue(self, card):
    """Verifica se um card est√° atrasado"""
    deadline = card.get('deadline')
    if not deadline or card.get('status') == 'done':
        return False
    
    try:
        deadline_dt = datetime.fromisoformat(deadline)
        return datetime.now() > deadline_dt
    except:
        return False

def create_progress_indicators(self, board_frame, member_name):
    """Cria indicadores visuais de progresso"""
    progress_frame = ttk.LabelFrame(board_frame, text="Meu Progresso")
    progress_frame.pack(fill=tk.X, pady=5)
    
    # Cards pendentes
    pending = len(self.get_pending_tasks(member_name))
    ttk.Label(progress_frame, text=f"üìã Pendentes: {pending}").pack(side=tk.LEFT, padx=10)
    
    # Cards completados hoje
    completed_today = len(self.get_completed_tasks(member_name, 1))
    ttk.Label(progress_frame, text=f"‚úÖ Completados Hoje: {completed_today}").pack(side=tk.LEFT, padx=10)
    
    # Cards atrasados
    overdue = len([c for c in self.get_cards_by_member(member_name) if self.is_card_overdue(c)])
    ttk.Label(progress_frame, text=f"‚ö†Ô∏è Atrasados: {overdue}").pack(side=tk.LEFT, padx=10)

def create_advanced_filters(self, board_frame):
    """Cria filtros avan√ßados para cards"""
    filter_frame = ttk.LabelFrame(board_frame, text="Filtros")
    filter_frame.pack(fill=tk.X, pady=5)
    
    # Filtro por status
    status_var = tk.StringVar(value="Todos")
    ttk.Label(filter_frame, text="Status:").pack(side=tk.LEFT, padx=5)
    status_combo = ttk.Combobox(filter_frame, textvariable=status_var, 
                               values=["Todos", "Pendentes", "Em Progresso", "Conclu√≠dos"])
    status_combo.pack(side=tk.LEFT, padx=5)
    
    # Filtro por prazo
    deadline_var = tk.StringVar(value="Todos")
    ttk.Label(filter_frame, text="Prazo:").pack(side=tk.LEFT, padx=5)
    deadline_combo = ttk.Combobox(filter_frame, textvariable=deadline_var,
                                 values=["Todos", "Hoje", "Esta Semana", "Atrasados"])
    deadline_combo.pack(side=tk.LEFT, padx=5)
    
    # Bot√£o aplicar filtros
    ttk.Button(filter_frame, text="Aplicar", 
               command=lambda: self.apply_filters(status_var.get(), deadline_var.get())).pack(side=tk.LEFT, padx=10)

def apply_filters(self, status_filter, deadline_filter):
    """Aplica filtros aos cards"""
    # Implementar l√≥gica de filtros aqui
    print(f"Aplicando filtros: Status={status_filter}, Prazo={deadline_filter}")
    # Atualizar display dos cards com base nos filtros

def open_personal_dashboard(self):
    """Abre dashboard personalizado do usu√°rio"""
    current_user_member = self._get_current_user_member()
    if not current_user_member:
        messagebox.showwarning("Aviso", "Voc√™ precisa estar logado para acessar o dashboard pessoal.")
        return
    
    dashboard_data = self.create_member_dashboard(current_user_member)
    self.show_personal_dashboard_window(dashboard_data)

def create_tooltip(self, widget, text):
    """Cria um tooltip para um widget"""
    def show_tooltip(event):
        tooltip = tk.Toplevel()
        tooltip.wm_overrideredirect(True)
        tooltip.wm_geometry(f"+{event.x_root+10}+{event.y_root+10}")
        
        label = ttk.Label(tooltip, text=text, justify=tk.LEFT,
                         background="#ffffe0", relief=tk.SOLID, borderwidth=1,
                         font=("Arial", "8", "normal"))
        label.pack()
        
        def hide_tooltip(event):
            tooltip.destroy()
        
        widget.bind('<Leave>', hide_tooltip)
        tooltip.bind('<Leave>', hide_tooltip)
    
    widget.bind('<Enter>', show_tooltip)

def show_kanban_performance(self):
        """Mostra janela de performance do Kanban"""
        if not hasattr(self, 'kanban_optimizer') or not self.kanban_optimizer:
            messagebox.showwarning("Aviso", "Otimizador de performance n√£o est√° dispon√≠vel")
            return
        
        # Criar janela de performance
        performance_window = tk.Toplevel(self.root)
        performance_window.title("Performance do Kanban")
        performance_window.geometry("400x300")
        performance_window.transient(self.root)
        performance_window.grab_set()
        
        # Frame principal
        main_frame = ttk.Frame(performance_window, padding=20)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        ttk.Label(main_frame, text="Estat√≠sticas de Performance", 
                 font=("Arial", 14, "bold")).pack(pady=(0, 20))
        
        # Obter estat√≠sticas
        stats = self.kanban_optimizer.get_performance_stats()
        
        # Frame para estat√≠sticas
        stats_frame = ttk.LabelFrame(main_frame, text="Cache e Performance", padding=10)
        stats_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Exibir estat√≠sticas
        ttk.Label(stats_frame, text=f"Widgets em cache: {stats.get('cached_widgets', 0)}").pack(anchor='w')
        ttk.Label(stats_frame, text=f"Cards em cache: {stats.get('cached_cards', 0)}").pack(anchor='w')
        ttk.Label(stats_frame, text=f"Fila de atualiza√ß√µes: {stats.get('update_queue_size', 0)}").pack(anchor='w')
        
        # Frame para a√ß√µes
        actions_frame = ttk.Frame(main_frame)
        actions_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(actions_frame, text="Limpar Cache", 
                  command=self.clear_kanban_cache).pack(side=tk.LEFT, padx=(0, 10))
        
        ttk.Button(actions_frame, text="Recarregar Otimizador", 
                  command=self.reload_kanban_optimizer).pack(side=tk.LEFT)
    
    def clear_kanban_cache(self):
        """Limpa cache do Kanban"""
        if hasattr(self, 'kanban_optimizer') and self.kanban_optimizer:
            self.kanban_optimizer.clear_cache()
            messagebox.showinfo("Sucesso", "Cache do Kanban limpo com sucesso!")
    
    def reload_kanban_optimizer(self):
        """Recarrega o otimizador do Kanban"""
        if KANBAN_OPTIMIZER_AVAILABLE:
            self.kanban_optimizer = KanbanPerformanceOptimizer(self)
            messagebox.showinfo("Sucesso", "Otimizador do Kanban recarregado!")
        else:
            messagebox.showerror("Erro", "Otimizador n√£o est√° dispon√≠vel")

    def show_personal_dashboard_window(self, dashboard_data):
        """Mostra janela do dashboard pessoal"""
    dashboard_window = tk.Toplevel(self.root)
    dashboard_window.title(f"Dashboard Pessoal - {dashboard_data['my_cards'][0]['members'][0] if dashboard_data['my_cards'] else 'Usu√°rio'}")
    dashboard_window.geometry("800x600")
    
    # Criar notebook para organizar as se√ß√µes
    notebook = ttk.Notebook(dashboard_window)
    notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    # Aba de Cards
    cards_frame = ttk.Frame(notebook)
    notebook.add(cards_frame, text="Meus Cards")
    
    # Lista de cards
    cards_text = tk.Text(cards_frame, wrap=tk.WORD, height=20)
    cards_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    for card in dashboard_data['my_cards']:
        status_icon = "‚úÖ" if card.get('status') == 'done' else "üìã"
        card_text = f"{status_icon} {card['title']} - {card['board_name']} > {card['list_name']}\n"
        cards_text.insert(tk.END, card_text)
    
    # Aba de M√©tricas
    metrics_frame = ttk.Frame(notebook)
    notebook.add(metrics_frame, text="M√©tricas")
    
    metrics = self.get_member_metrics(dashboard_data['my_cards'][0]['members'][0] if dashboard_data['my_cards'] else 'Usu√°rio')
    
    metrics_text = tk.Text(metrics_frame, wrap=tk.WORD, height=20)
    metrics_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    metrics_text.insert(tk.END, f"üìä M√âTRICAS DE PRODUTIVIDADE\n\n")
    metrics_text.insert(tk.END, f"Cards Criados: {metrics['cards_created']}\n")
    metrics_text.insert(tk.END, f"Cards Completados: {metrics['cards_completed']}\n")
    metrics_text.insert(tk.END, f"Tempo M√©dio de Conclus√£o: {metrics['average_completion_time']:.1f} horas\n")
    metrics_text.insert(tk.END, f"Score de Produtividade: {metrics['productivity_score']:.1f}%\n")
    metrics_text.insert(tk.END, f"Taxa de Conclus√£o no Prazo: {metrics['on_time_completion_rate']*100:.1f}%\n")
    metrics_text.insert(tk.END, f"Quadros Ativos: {metrics['active_boards']}\n")
    
    # Aba de Atividades
    activities_frame = ttk.Frame(notebook)
    notebook.add(activities_frame, text="Atividades Recentes")
    
    activities_text = tk.Text(activities_frame, wrap=tk.WORD, height=20)
    activities_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    for activity in dashboard_data['recent_activities']:
        activity_text = f"üïí {activity['action']} - {activity['timestamp']}\n"
        activities_text.insert(tk.END, activity_text)


        """Cria o dashboard financeiro empresarial"""
        # Frame principal com scroll
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        canvas = tk.Canvas(main_frame)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Header
        header_frame = ttk.Frame(scrollable_frame)
        header_frame.pack(fill=tk.X, padx=20, pady=20)
        
        ttk.Label(header_frame, text="üè¢ Dashboard Financeiro Empresarial", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        ttk.Button(header_frame, text="üîÑ Atualizar", 
                  command=self.refresh_enterprise_dashboard).pack(side=tk.RIGHT)
        
        # Cards de m√©tricas principais
        metrics_frame = ttk.Frame(scrollable_frame)
        metrics_frame.pack(fill=tk.X, padx=20, pady=10)
        
        # Saldo Total
        self.create_enterprise_metric_card(metrics_frame, "üí∞ Saldo Total", "R$ 0,00", "#2ecc71", 0, 0)
        
        # Receitas do M√™s
        self.create_enterprise_metric_card(metrics_frame, "üìà Receitas/M√™s", "R$ 0,00", "#3498db", 0, 1)
        
        # Despesas do M√™s
        self.create_enterprise_metric_card(metrics_frame, "üìâ Despesas/M√™s", "R$ 0,00", "#e74c3c", 0, 2)
        
        # Lucro do M√™s
        self.create_enterprise_metric_card(metrics_frame, "üíµ Lucro/M√™s", "R$ 0,00", "#f39c12", 0, 3)
        
        # Contas a Receber
        self.create_enterprise_metric_card(metrics_frame, "üì• Contas a Receber", "R$ 0,00", "#9b59b6", 1, 0)
        
        # Contas a Pagar
        self.create_enterprise_metric_card(metrics_frame, "üì§ Contas a Pagar", "R$ 0,00", "#e67e22", 1, 1)
        
        # Clientes Ativos
        self.create_enterprise_metric_card(metrics_frame, "üë• Clientes Ativos", "0", "#1abc9c", 1, 2)
        
        # Fornecedores
        self.create_enterprise_metric_card(metrics_frame, "üè≠ Fornecedores", "0", "#34495e", 1, 3)
        
        # Se√ß√£o de gr√°ficos
        charts_frame = ttk.Frame(scrollable_frame)
        charts_frame.pack(fill=tk.X, padx=20, pady=20)
        
        ttk.Label(charts_frame, text="üìä An√°lises Financeiras", 
                 font=("Arial", 14, "bold")).pack(anchor=tk.W)
        
        charts_buttons_frame = ttk.Frame(charts_frame)
        charts_buttons_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(charts_buttons_frame, text="üìà Evolu√ß√£o Mensal", 
                  command=lambda: self.show_enterprise_chart("evolucao")).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(charts_buttons_frame, text="ü•ß Receitas por Categoria", 
                  command=lambda: self.show_enterprise_chart("receitas_categoria")).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(charts_buttons_frame, text="üìä Despesas por Departamento", 
                  command=lambda: self.show_enterprise_chart("despesas_departamento")).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(charts_buttons_frame, text="üíº Fluxo de Caixa", 
                  command=lambda: self.show_enterprise_chart("fluxo_caixa")).pack(side=tk.LEFT, padx=5)
        
        # Se√ß√£o de alertas e pend√™ncias
        alerts_frame = ttk.Frame(scrollable_frame)
        alerts_frame.pack(fill=tk.X, padx=20, pady=20)
        
        ttk.Label(alerts_frame, text="‚ö†Ô∏è Alertas e Pend√™ncias", 
                 font=("Arial", 14, "bold")).pack(anchor=tk.W)
        
        # Treeview para alertas
        self.alerts_tree = ttk.Treeview(alerts_frame, columns=("tipo", "descricao", "valor", "prazo"), 
                                       show="headings", height=6)
        self.alerts_tree.heading("tipo", text="Tipo")
        self.alerts_tree.heading("descricao", text="Descri√ß√£o")
        self.alerts_tree.heading("valor", text="Valor")
        self.alerts_tree.heading("prazo", text="Prazo")
        
        self.alerts_tree.column("tipo", width=100)
        self.alerts_tree.column("descricao", width=300)
        self.alerts_tree.column("valor", width=100)
        self.alerts_tree.column("prazo", width=100)
        
        self.alerts_tree.pack(fill=tk.X, pady=10)
        
        # Configurar scroll
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Atualizar dados
        self.refresh_enterprise_dashboard()
    
    def create_enterprise_metric_card(self, parent, title, value, color, row, col):
        """Cria um card de m√©trica empresarial"""
        card_frame = ttk.Frame(parent, relief=tk.RAISED, borderwidth=2)
        card_frame.grid(row=row, column=col, padx=10, pady=10, sticky="nsew")
        
        # Configurar grid
        parent.grid_columnconfigure(col, weight=1)
        parent.grid_rowconfigure(row, weight=1)
        
        # T√≠tulo
        ttk.Label(card_frame, text=title, font=("Arial", 10, "bold")).pack(pady=(10, 5))
        
        # Valor
        value_label = ttk.Label(card_frame, text=value, font=("Arial", 16, "bold"), foreground=color)
        value_label.pack(pady=(0, 10))
        
        # Armazenar refer√™ncia para atualiza√ß√£o
        if not hasattr(self, 'enterprise_metrics'):
            self.enterprise_metrics = {}
        self.enterprise_metrics[f"{title}_{row}_{col}"] = value_label
    
    def refresh_enterprise_dashboard(self):
        """Atualiza o dashboard empresarial"""
        try:
            # Buscar dados do banco
            departments = self.db.get_departments()
            clients = self.db.get_clients()
            suppliers = self.db.get_suppliers()
            accounts_receivable = self.db.get_accounts_receivable()
            accounts_payable = self.db.get_accounts_payable()
            
            # Calcular m√©tricas
            total_receivable = sum(float(ar['amount']) for ar in accounts_receivable if ar['status'] == 'Pendente')
            total_payable = sum(float(ap['amount']) for ap in accounts_payable if ap['status'] == 'Pendente')
            
            # Atualizar cards
            if hasattr(self, 'enterprise_metrics'):
                self.enterprise_metrics.get("üí∞ Saldo Total_0_0", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("üìà Receitas/M√™s_0_1", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("üìâ Despesas/M√™s_0_2", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("üíµ Lucro/M√™s_0_3", ttk.Label()).configure(text="R$ 0,00")
                self.enterprise_metrics.get("üì• Contas a Receber_1_0", ttk.Label()).configure(text=f"R$ {total_receivable:,.2f}")
                self.enterprise_metrics.get("üì§ Contas a Pagar_1_1", ttk.Label()).configure(text=f"R$ {total_payable:,.2f}")
                self.enterprise_metrics.get("üë• Clientes Ativos_1_2", ttk.Label()).configure(text=str(len(clients)))
                self.enterprise_metrics.get("üè≠ Fornecedores_1_3", ttk.Label()).configure(text=str(len(suppliers)))
            
            # Atualizar alertas
            self.update_enterprise_alerts()
            
        except Exception as e:
            print(f"Erro ao atualizar dashboard empresarial: {e}")
    
    def update_enterprise_alerts(self):
        """Atualiza a lista de alertas empresariais"""
        if not hasattr(self, 'alerts_tree'):
            return
        
        # Limpar lista
        for item in self.alerts_tree.get_children():
            self.alerts_tree.delete(item)
        
        try:
            # Buscar contas a pagar vencidas
            accounts_payable = self.db.get_accounts_payable()
            today = datetime.now().date()
            
            for ap in accounts_payable:
                if ap['status'] == 'Pendente':
                    due_date = datetime.strptime(ap['due_date'], '%Y-%m-%d').date()
                    if due_date < today:
                        self.alerts_tree.insert("", "end", values=(
                            "Conta Vencida",
                            f"Pagar: {ap['description']}",
                            f"R$ {float(ap['amount']):,.2f}",
                            ap['due_date']
                        ))
            
            # Buscar contas a receber vencidas
            accounts_receivable = self.db.get_accounts_receivable()
            
            for ar in accounts_receivable:
                if ar['status'] == 'Pendente':
                    due_date = datetime.strptime(ar['due_date'], '%Y-%m-%d').date()
                    if due_date < today:
                        self.alerts_tree.insert("", "end", values=(
                            "Recebimento Vencido",
                            f"Receber: {ar['description']}",
                            f"R$ {float(ar['amount']):,.2f}",
                            ar['due_date']
                        ))
        
        except Exception as e:
            print(f"Erro ao atualizar alertas: {e}")
    
    def show_enterprise_chart(self, chart_type):
        """Mostra gr√°ficos empresariais"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
            
            # Criar janela para o gr√°fico
            chart_window = tk.Toplevel(self.root)
            chart_window.title(f"Gr√°fico - {chart_type}")
            chart_window.geometry("800x600")
            
            fig, ax = plt.subplots(figsize=(10, 6))
            
            if chart_type == "evolucao":
                # Gr√°fico de evolu√ß√£o mensal
                months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun']
                receitas = [50000, 55000, 48000, 62000, 58000, 65000]
                despesas = [45000, 47000, 43000, 52000, 49000, 54000]
                
                ax.plot(months, receitas, 'o-', label='Receitas', color='#3498db')
                ax.plot(months, despesas, 's-', label='Despesas', color='#e74c3c')
                ax.set_title('Evolu√ß√£o Mensal - Receitas vs Despesas')
                ax.set_ylabel('Valor (R$)')
                ax.legend()
                ax.grid(True, alpha=0.3)
            
            elif chart_type == "receitas_categoria":
                # Gr√°fico de pizza - receitas por categoria
                categories = ['Vendas', 'Servi√ßos', 'Consultoria', 'Outros']
                values = [45, 30, 20, 5]
                colors = ['#3498db', '#2ecc71', '#f39c12', '#e74c3c']
                
                ax.pie(values, labels=categories, colors=colors, autopct='%1.1f%%')
                ax.set_title('Receitas por Categoria')
            
            elif chart_type == "despesas_departamento":
                # Gr√°fico de barras - despesas por departamento
                departments = ['TI', 'Marketing', 'RH', 'Financeiro', 'Opera√ß√µes']
                expenses = [25000, 18000, 15000, 12000, 22000]
                colors = ['#3498db', '#2ecc71', '#f39c12', '#e74c3c', '#9b59b6']
                
                bars = ax.bar(departments, expenses, color=colors)
                ax.set_title('Despesas por Departamento')
                ax.set_ylabel('Valor (R$)')
                
                # Adicionar valores nas barras
                for bar, value in zip(bars, expenses):
                    ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 1000,
                           f'R$ {value:,.0f}', ha='center', va='bottom')
            
            elif chart_type == "fluxo_caixa":
                # Gr√°fico de fluxo de caixa
                dates = ['01/01', '15/01', '01/02', '15/02', '01/03', '15/03']
                cash_flow = [50000, 45000, 52000, 48000, 55000, 58000]
                
                ax.plot(dates, cash_flow, 'o-', color='#2ecc71', linewidth=2)
                ax.fill_between(dates, cash_flow, alpha=0.3, color='#2ecc71')
                ax.set_title('Fluxo de Caixa - √öltimos 3 Meses')
                ax.set_ylabel('Saldo (R$)')
                ax.grid(True, alpha=0.3)
            
            # Configurar layout
            plt.tight_layout()
            
            # Criar canvas
            canvas = FigureCanvasTkAgg(fig, chart_window)
            canvas.draw()
            canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except ImportError:
            messagebox.showwarning("Aviso", "Matplotlib n√£o est√° instalado. Instale com: pip install matplotlib")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao gerar gr√°fico: {e}")
    
    def create_clients_management_tab(self, parent):
        """Cria a aba de gest√£o de clientes"""
        # Frame principal
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Header
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(header_frame, text="üë• Gest√£o de Clientes", 
                 font=("Arial", 16, "bold")).pack(side=tk.LEFT)
        
        ttk.Button(header_frame, text="‚ûï Novo Cliente", 
                  command=self.open_new_client_window).pack(side=tk.RIGHT)
        
        # Frame para formul√°rio e lista
        content_frame = ttk.Frame(main_frame)
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        # Formul√°rio de cliente
        form_frame = ttk.LabelFrame(content_frame, text="Dados do Cliente", padding=10)
        form_frame.pack(fill=tk.X, pady=(0, 20))
        
        # Primeira linha
        row1 = ttk.Frame(form_frame)
        row1.pack(fill=tk.X, pady=5)
        
        ttk.Label(row1, text="Nome/Raz√£o Social:").pack(side=tk.LEFT)
        self.client_name_var = tk.StringVar()
        ttk.Entry(row1, textvariable=self.client_name_var, width=30).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row1, text="CNPJ/CPF:").pack(side=tk.LEFT)
        self.client_cnpj_var = tk.StringVar()
        ttk.Entry(row1, textvariable=self.client_cnpj_var, width=20).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row1, text="Segmento:").pack(side=tk.LEFT)
        self.client_segment_var = tk.StringVar()
        ttk.Combobox(row1, textvariable=self.client_segment_var, 
                    values=["Tecnologia", "Sa√∫de", "Educa√ß√£o", "Varejo", "Ind√∫stria", "Servi√ßos", "Outros"],
                    width=15).pack(side=tk.LEFT, padx=(10, 0))
        
        # Segunda linha
        row2 = ttk.Frame(form_frame)
        row2.pack(fill=tk.X, pady=5)
        
        ttk.Label(row2, text="Email:").pack(side=tk.LEFT)
        self.client_email_var = tk.StringVar()
        ttk.Entry(row2, textvariable=self.client_email_var, width=30).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row2, text="Telefone:").pack(side=tk.LEFT)
        self.client_phone_var = tk.StringVar()
        ttk.Entry(row2, textvariable=self.client_phone_var, width=15).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row2, text="Limite de Cr√©dito:").pack(side=tk.LEFT)
        self.client_credit_var = tk.StringVar()
        ttk.Entry(row2, textvariable=self.client_credit_var, width=15).pack(side=tk.LEFT, padx=(10, 0))
        
        # Terceira linha
        row3 = ttk.Frame(form_frame)
        row3.pack(fill=tk.X, pady=5)
        
        ttk.Label(row3, text="Contato:").pack(side=tk.LEFT)
        self.client_contact_var = tk.StringVar()
        ttk.Entry(row3, textvariable=self.client_contact_var, width=30).pack(side=tk.LEFT, padx=(10, 20))
        
        ttk.Label(row3, text="Endere√ßo:").pack(side=tk.LEFT)
        self.client_address_var = tk.StringVar()
        ttk.Entry(row3, textvariable=self.client_address_var, width=40).pack(side=tk.LEFT, padx=(10, 0))
        
        # Bot√µes
        buttons_frame = ttk.Frame(form_frame)
        buttons_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(buttons_frame, text="üíæ Salvar Cliente", 
                  command=self.save_client).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(buttons_frame, text="üîÑ Limpar", 
                  command=self.clear_client_form).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(buttons_frame, text="üóëÔ∏è Excluir", 
                  command=self.delete_client).pack(side=tk.LEFT)
        
        # Lista de clientes
        list_frame = ttk.LabelFrame(content_frame, text="Clientes Cadastrados", padding=10)
        list_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview
        columns = ("id", "nome", "cnpj_cpf", "email", "telefone", "segmento", "limite_credito", "status")
        self.clients_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=10)
        
        self.clients_tree.heading("id", text="ID")
        self.clients_tree.heading("nome", text="Nome/Raz√£o Social")
        self.clients_tree.heading("cnpj_cpf", text="CNPJ/CPF")
        self.clients_tree.heading("email", text="Email")
        self.clients_tree.heading("telefone", text="Telefone")
        self.clients_tree.heading("segmento", text="Segmento")
        self.clients_tree.heading("limite_credito", text="Limite de Cr√©dito")
        self.clients_tree.heading("status", text="Status")
        
        self.clients_tree.column("id", width=50)
        self.clients_tree.column("nome", width=200)
        self.clients_tree.column("cnpj_cpf", width=120)
        self.clients_tree.column("email", width=150)
        self.clients_tree.column("telefone", width=100)
        self.clients_tree.column("segmento", width=100)
        self.clients_tree.column("limite_credito", width=120)
        self.clients_tree.column("status", width=80)
        
        # Scrollbars
        tree_scroll_y = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.clients_tree.yview)
        tree_scroll_x = ttk.Scrollbar(list_frame, orient=tk.HORIZONTAL, command=self.clients_tree.xview)
        self.clients_tree.configure(yscrollcommand=tree_scroll_y.set, xscrollcommand=tree_scroll_x.set)
        
        # Pack
        self.clients_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        tree_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Bind para sele√ß√£o
        self.clients_tree.bind('<<TreeviewSelect>>', self.on_client_select)
        
        # Carregar dados
        self.load_clients()
    
    def save_client(self):
        """Salva um novo cliente"""
        try:
            # Validar campos obrigat√≥rios
            if not self.client_name_var.get().strip():
                messagebox.showerror("Erro", "Nome/Raz√£o Social √© obrigat√≥rio!")
                return
            
            if not self.client_cnpj_var.get().strip():
                messagebox.showerror("Erro", "CNPJ/CPF √© obrigat√≥rio!")
                return
            
            # Preparar dados
            client_data = {
                'name': self.client_name_var.get().strip(),
                'cnpj_cpf': self.client_cnpj_var.get().strip(),
                'email': self.client_email_var.get().strip(),
                'phone': self.client_phone_var.get().strip(),
                'address': self.client_address_var.get().strip(),
                'contact_person': self.client_contact_var.get().strip(),
                'segment': self.client_segment_var.get().strip(),
                'credit_limit': float(self.client_credit_var.get() or 0)
            }
            
            # Salvar no banco
            client_id = self.db.create_client(**client_data)
            
            if client_id:
                messagebox.showinfo("Sucesso", "Cliente salvo com sucesso!")
                self.clear_client_form()
                self.load_clients()
            else:
                messagebox.showerror("Erro", "Erro ao salvar cliente!")
        
        except ValueError:
            messagebox.showerror("Erro", "Limite de cr√©dito deve ser um n√∫mero v√°lido!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar cliente: {e}")
    
    def clear_client_form(self):
        """Limpa o formul√°rio de cliente"""
        self.client_name_var.set("")
        self.client_cnpj_var.set("")
        self.client_email_var.set("")
        self.client_phone_var.set("")
        self.client_address_var.set("")
        self.client_contact_var.set("")
        self.client_segment_var.set("")
        self.client_credit_var.set("")
    
    def load_clients(self):
        """Carrega a lista de clientes"""
        try:
            # Limpar lista
            for item in self.clients_tree.get_children():
                self.clients_tree.delete(item)
            
            # Buscar clientes
            clients = self.db.get_clients()
            
            # Adicionar √† lista
            for client in clients:
                self.clients_tree.insert("", "end", values=(
                    client['id'],
                    client['name'],
                    client['cnpj_cpf'],
                    client['email'],
                    client['phone'],
                    client['segment'],
                    f"R$ {float(client['credit_limit']):,.2f}",
                    "Ativo" if client['is_active'] else "Inativo"
                ))
        
        except Exception as e:
            print(f"Erro ao carregar clientes: {e}")
    
    def on_client_select(self, event):
        """Evento de sele√ß√£o de cliente"""
        selection = self.clients_tree.selection()
        if selection:
            item = self.clients_tree.item(selection[0])
            values = item['values']
            
            # Preencher formul√°rio
            self.client_name_var.set(values[1])
            self.client_cnpj_var.set(values[2])
            self.client_email_var.set(values[3])
            self.client_phone_var.set(values[4])
            self.client_segment_var.set(values[5])
            self.client_credit_var.set(values[6].replace("R$ ", "").replace(",", ""))
    
    def delete_client(self):
        """Exclui um cliente"""
        selection = self.clients_tree.selection()
        if not selection:
            messagebox.showwarning("Aviso", "Selecione um cliente para excluir!")
            return
        
        if messagebox.askyesno("Confirmar", "Tem certeza que deseja excluir este cliente?"):
            try:
                item = self.clients_tree.item(selection[0])
                client_id = item['values'][0]
                
                # Excluir do banco (soft delete)
                # self.db.delete_client(client_id)  # Implementar m√©todo
                
                messagebox.showinfo("Sucesso", "Cliente exclu√≠do com sucesso!")
                self.load_clients()
                self.clear_client_form()
            
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao excluir cliente: {e}")
    
    def open_new_client_window(self):
        """Abre janela para novo cliente"""
        self.clear_client_form()
        # Focar no primeiro campo
        # Implementar foco autom√°tico
    
    # M√©todos placeholder para outras abas
    def create_suppliers_management_tab(self, parent):
        """Cria a aba de gest√£o de fornecedores"""
        ttk.Label(parent, text="üè≠ Gest√£o de Fornecedores - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_receivables_management_tab(self, parent):
        """Cria a aba de contas a receber"""
        ttk.Label(parent, text="üì• Contas a Receber - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_payables_management_tab(self, parent):
        """Cria a aba de contas a pagar"""
        ttk.Label(parent, text="üì§ Contas a Pagar - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_invoices_management_tab(self, parent):
        """Cria a aba de faturas"""
        ttk.Label(parent, text="üßæ Gest√£o de Faturas - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_cashflow_management_tab(self, parent):
        """Cria a aba de fluxo de caixa"""
        ttk.Label(parent, text="üíº Fluxo de Caixa - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_budgets_management_tab(self, parent):
        """Cria a aba de or√ßamentos"""
        ttk.Label(parent, text="üìä Gest√£o de Or√ßamentos - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_enterprise_reports_tab(self, parent):
        """Cria a aba de relat√≥rios empresariais"""
        ttk.Label(parent, text="üìà Relat√≥rios Empresariais - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)
    
    def create_finance_config_tab(self, parent):
        """Cria a aba de configura√ß√µes financeiras"""
        ttk.Label(parent, text="‚öôÔ∏è Configura√ß√µes Financeiras - Em desenvolvimento", 
                 font=("Arial", 16, "bold")).pack(pady=50)


# ============================================================================
# FIM DAS MELHORIAS IMPLEMENTADAS
# ============================================================================
